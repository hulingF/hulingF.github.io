<!DOCTYPE html>
<html lang=en>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5" />
    <meta name="description" content="MySQL原理之查询优化篇一、MySQL基于成本的优化我们之前老说MySQL执行一个查询可以有不同的执行方案，它会选择其中成本最低，或者说代价最低的那种方案去真正的执行查询。不过我们之前对成本的描述是非常模糊的，其实在MySQL中一条查询语句的执行成本是由下边这两个方面组成的：  I&#x2F;O成本 我们的表经常使用的MyISAM、InnoDB存储引擎都是将数据和索引都存储到磁盘上的，当我们想查询表中的记">
<meta property="og:type" content="article">
<meta property="og:title" content="MySQL原理之查询优化篇">
<meta property="og:url" content="https://hulingf.github.io/2023/12/19/MySQL%E5%8E%9F%E7%90%86%E4%B9%8B%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E7%AF%87/index.html">
<meta property="og:site_name" content="大军的秘密花园">
<meta property="og:description" content="MySQL原理之查询优化篇一、MySQL基于成本的优化我们之前老说MySQL执行一个查询可以有不同的执行方案，它会选择其中成本最低，或者说代价最低的那种方案去真正的执行查询。不过我们之前对成本的描述是非常模糊的，其实在MySQL中一条查询语句的执行成本是由下边这两个方面组成的：  I&#x2F;O成本 我们的表经常使用的MyISAM、InnoDB存储引擎都是将数据和索引都存储到磁盘上的，当我们想查询表中的记">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://hulingf.github.io/imgs/MySQL%E5%8E%9F%E7%90%86%E4%B9%8B%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E7%AF%87/16998b505d671d4etplv-t2oaga2asx-jj-mark1890000q75.webp">
<meta property="og:image" content="https://hulingf.github.io/imgs/MySQL%E5%8E%9F%E7%90%86%E4%B9%8B%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E7%AF%87/16998b505d7a278atplv-t2oaga2asx-jj-mark1890000q75.webp">
<meta property="og:image" content="https://hulingf.github.io/imgs/MySQL%E5%8E%9F%E7%90%86%E4%B9%8B%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E7%AF%87/16998b505eab86e6tplv-t2oaga2asx-jj-mark1890000q75.webp">
<meta property="og:image" content="https://hulingf.github.io/AppData/Roaming/Typora/typora-user-images/image-20231219112601615.png">
<meta property="og:image" content="https://hulingf.github.io/AppData/Roaming/Typora/typora-user-images/image-20231219114959190.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/MySQL%E5%8E%9F%E7%90%86%E4%B9%8B%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E7%AF%87/image-20231219115949876.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/MySQL%E5%8E%9F%E7%90%86%E4%B9%8B%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E7%AF%87/image-20231219115832194.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/MySQL%E5%8E%9F%E7%90%86%E4%B9%8B%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E7%AF%87/image-20231219131607845.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/MySQL%E5%8E%9F%E7%90%86%E4%B9%8B%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E7%AF%87/image-20231219131837979.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/MySQL%E5%8E%9F%E7%90%86%E4%B9%8B%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E7%AF%87/image-20231219132042472.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/MySQL%E5%8E%9F%E7%90%86%E4%B9%8B%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E7%AF%87/167e94d5b165a91ftplv-t2oaga2asx-jj-mark1890000q75.webp">
<meta property="og:image" content="https://hulingf.github.io/imgs/MySQL%E5%8E%9F%E7%90%86%E4%B9%8B%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E7%AF%87/167e94d5b1e44524tplv-t2oaga2asx-jj-mark1890000q75.webp">
<meta property="og:image" content="https://hulingf.github.io/imgs/MySQL%E5%8E%9F%E7%90%86%E4%B9%8B%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E7%AF%87/167e94d5b17c24e3tplv-t2oaga2asx-jj-mark1890000q75.webp">
<meta property="og:image" content="https://hulingf.github.io/imgs/MySQL%E5%8E%9F%E7%90%86%E4%B9%8B%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E7%AF%87/image-20231219132732638.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/MySQL%E5%8E%9F%E7%90%86%E4%B9%8B%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E7%AF%87/image-20231219132854607.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/MySQL%E5%8E%9F%E7%90%86%E4%B9%8B%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E7%AF%87/16a8dda5369e68c5tplv-t2oaga2asx-jj-mark1890000q75.webp">
<meta property="og:image" content="https://hulingf.github.io/imgs/MySQL%E5%8E%9F%E7%90%86%E4%B9%8B%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E7%AF%87/16a8dda5394d3903tplv-t2oaga2asx-jj-mark1890000q75.webp">
<meta property="og:image" content="https://hulingf.github.io/imgs/MySQL%E5%8E%9F%E7%90%86%E4%B9%8B%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E7%AF%87/16ecb503727bb15etplv-t2oaga2asx-jj-mark1890000q75.webp">
<meta property="og:image" content="https://hulingf.github.io/imgs/MySQL%E5%8E%9F%E7%90%86%E4%B9%8B%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E7%AF%87/image-20231219151453493.png">
<meta property="article:published_time" content="2023-12-19T03:57:02.125Z">
<meta property="article:modified_time" content="2023-12-19T07:45:59.042Z">
<meta property="article:author" content="hulingF">
<meta property="article:tag" content="MySQL原理">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://hulingf.github.io/imgs/MySQL%E5%8E%9F%E7%90%86%E4%B9%8B%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E7%AF%87/16998b505d671d4etplv-t2oaga2asx-jj-mark1890000q75.webp">
    
    
      
        
          <link rel="shortcut icon" href="/images/favicon.ico">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
        
      
    
    <!-- title -->
    <title>MySQL原理之查询优化篇</title>
    <!-- async scripts -->
    <!-- Google Analytics -->


    <!-- Umami Analytics -->


    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
    <!-- rss -->
    
    
	<!-- mathjax -->
	
<meta name="generator" content="Hexo 6.3.0"></head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#" aria-label="Menu"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#" aria-label="Menu"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" aria-label="Top" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa-solid fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
        <!--
       --><li><a href="/">Home</a></li><!--
     --><!--
       --><li><a href="/about/">About</a></li><!--
     --><!--
       --><li><a href="/archives/">Writing</a></li><!--
     --><!--
       --><li><a href="/tags/">Tag</a></li><!--
     --><!--
       --><li><a target="_blank" rel="noopener" href="http://github.com/hulingF">Projects</a></li><!--
     -->
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" aria-label="Previous post" href="/2023/12/19/MySQL%E5%8E%9F%E7%90%86%E4%B9%8B%E5%BD%A9%E8%9B%8B%E7%AF%87/"><i class="fa-solid fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" aria-label="Next post" href="/2023/12/18/MySQL%E5%8E%9F%E7%90%86%E4%B9%8B%E6%9F%A5%E8%AF%A2%E7%AF%87/"><i class="fa-solid fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" aria-label="Back to top" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" aria-label="Share post" href="#"><i class="fa-solid fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://hulingf.github.io/2023/12/19/MySQL%E5%8E%9F%E7%90%86%E4%B9%8B%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E7%AF%87/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://hulingf.github.io/2023/12/19/MySQL%E5%8E%9F%E7%90%86%E4%B9%8B%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E7%AF%87/&text=MySQL原理之查询优化篇"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://hulingf.github.io/2023/12/19/MySQL%E5%8E%9F%E7%90%86%E4%B9%8B%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E7%AF%87/&title=MySQL原理之查询优化篇"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://hulingf.github.io/2023/12/19/MySQL%E5%8E%9F%E7%90%86%E4%B9%8B%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E7%AF%87/&is_video=false&description=MySQL原理之查询优化篇"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=MySQL原理之查询优化篇&body=Check out this article: https://hulingf.github.io/2023/12/19/MySQL%E5%8E%9F%E7%90%86%E4%B9%8B%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E7%AF%87/"><i class="fa-solid fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://hulingf.github.io/2023/12/19/MySQL%E5%8E%9F%E7%90%86%E4%B9%8B%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E7%AF%87/&title=MySQL原理之查询优化篇"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://hulingf.github.io/2023/12/19/MySQL%E5%8E%9F%E7%90%86%E4%B9%8B%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E7%AF%87/&title=MySQL原理之查询优化篇"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://hulingf.github.io/2023/12/19/MySQL%E5%8E%9F%E7%90%86%E4%B9%8B%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E7%AF%87/&title=MySQL原理之查询优化篇"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://hulingf.github.io/2023/12/19/MySQL%E5%8E%9F%E7%90%86%E4%B9%8B%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E7%AF%87/&title=MySQL原理之查询优化篇"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://hulingf.github.io/2023/12/19/MySQL%E5%8E%9F%E7%90%86%E4%B9%8B%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E7%AF%87/&name=MySQL原理之查询优化篇&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://hulingf.github.io/2023/12/19/MySQL%E5%8E%9F%E7%90%86%E4%B9%8B%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E7%AF%87/&t=MySQL原理之查询优化篇"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    
    
      <div id="toc">
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#MySQL%E5%8E%9F%E7%90%86%E4%B9%8B%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E7%AF%87"><span class="toc-number">1.</span> <span class="toc-text">MySQL原理之查询优化篇</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81MySQL%E5%9F%BA%E4%BA%8E%E6%88%90%E6%9C%AC%E7%9A%84%E4%BC%98%E5%8C%96"><span class="toc-number">1.1.</span> <span class="toc-text">一、MySQL基于成本的优化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1%E5%8D%95%E8%A1%A8%E6%9F%A5%E8%AF%A2%E7%9A%84%E6%88%90%E6%9C%AC"><span class="toc-number">1.1.1.</span> <span class="toc-text">1.1单表查询的成本</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2%E5%9F%BA%E4%BA%8E%E6%88%90%E6%9C%AC%E7%9A%84%E4%BC%98%E5%8C%96%E6%AD%A5%E9%AA%A4"><span class="toc-number">1.1.2.</span> <span class="toc-text">1.2基于成本的优化步骤</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-1%E6%A0%B9%E6%8D%AE%E6%90%9C%E7%B4%A2%E6%9D%A1%E4%BB%B6%EF%BC%8C%E6%89%BE%E5%87%BA%E6%89%80%E6%9C%89%E5%8F%AF%E8%83%BD%E4%BD%BF%E7%94%A8%E7%9A%84%E7%B4%A2%E5%BC%95"><span class="toc-number">1.1.2.1.</span> <span class="toc-text">1.2.1根据搜索条件，找出所有可能使用的索引</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-2%E8%AE%A1%E7%AE%97%E5%85%A8%E8%A1%A8%E6%89%AB%E6%8F%8F%E7%9A%84%E4%BB%A3%E4%BB%B7"><span class="toc-number">1.1.2.2.</span> <span class="toc-text">1.2.2计算全表扫描的代价</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-3%E8%AE%A1%E7%AE%97%E4%BD%BF%E7%94%A8%E4%B8%8D%E5%90%8C%E7%B4%A2%E5%BC%95%E6%89%A7%E8%A1%8C%E6%9F%A5%E8%AF%A2%E7%9A%84%E4%BB%A3%E4%BB%B7"><span class="toc-number">1.1.2.3.</span> <span class="toc-text">1.2.3计算使用不同索引执行查询的代价</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8idx-key2%E6%89%A7%E8%A1%8C%E6%9F%A5%E8%AF%A2%E7%9A%84%E6%88%90%E6%9C%AC%E5%88%86%E6%9E%90"><span class="toc-number">1.1.2.3.1.</span> <span class="toc-text">使用idx_key2执行查询的成本分析</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8idx-key1%E6%89%A7%E8%A1%8C%E6%9F%A5%E8%AF%A2%E7%9A%84%E6%88%90%E6%9C%AC%E5%88%86%E6%9E%90"><span class="toc-number">1.1.2.3.2.</span> <span class="toc-text">使用idx_key1执行查询的成本分析</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%98%AF%E5%90%A6%E6%9C%89%E5%8F%AF%E8%83%BD%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95%E5%90%88%E5%B9%B6%EF%BC%88Index-Merge%EF%BC%89"><span class="toc-number">1.1.2.3.3.</span> <span class="toc-text">是否有可能使用索引合并（Index Merge）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-4%E5%AF%B9%E6%AF%94%E5%90%84%E7%A7%8D%E6%89%A7%E8%A1%8C%E6%96%B9%E6%A1%88%E7%9A%84%E4%BB%A3%E4%BB%B7%EF%BC%8C%E6%89%BE%E5%87%BA%E6%88%90%E6%9C%AC%E6%9C%80%E4%BD%8E%E7%9A%84%E6%96%B9%E6%A1%88"><span class="toc-number">1.1.2.4.</span> <span class="toc-text">1.2.4对比各种执行方案的代价，找出成本最低的方案</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3%E5%9F%BA%E4%BA%8E%E7%B4%A2%E5%BC%95%E7%BB%9F%E8%AE%A1%E6%95%B0%E6%8D%AE%E7%9A%84%E6%88%90%E6%9C%AC%E8%AE%A1%E7%AE%97"><span class="toc-number">1.1.3.</span> <span class="toc-text">1.3基于索引统计数据的成本计算</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2%E7%9A%84%E6%88%90%E6%9C%AC"><span class="toc-number">1.1.4.</span> <span class="toc-text">1.4连接查询的成本</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-1Condition-filtering%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.1.4.1.</span> <span class="toc-text">1.4.1Condition filtering介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-2%E4%B8%A4%E8%A1%A8%E8%BF%9E%E6%8E%A5%E7%9A%84%E6%88%90%E6%9C%AC%E5%88%86%E6%9E%90"><span class="toc-number">1.1.4.2.</span> <span class="toc-text">1.4.2两表连接的成本分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-3%E5%A4%9A%E8%A1%A8%E8%BF%9E%E6%8E%A5%E7%9A%84%E6%88%90%E6%9C%AC%E5%88%86%E6%9E%90"><span class="toc-number">1.1.4.3.</span> <span class="toc-text">1.4.3多表连接的成本分析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5%E8%B0%83%E8%8A%82%E6%88%90%E6%9C%AC%E5%B8%B8%E6%95%B0"><span class="toc-number">1.1.5.</span> <span class="toc-text">1.5调节成本常数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-5-1mysql-server-cost%E8%A1%A8"><span class="toc-number">1.1.5.1.</span> <span class="toc-text">1.5.1mysql.server_cost表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-5-2mysql-engine-cost%E8%A1%A8"><span class="toc-number">1.1.5.2.</span> <span class="toc-text">1.5.2mysql.engine_cost表</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81InnoDB%E7%9A%84%E7%BB%9F%E8%AE%A1%E6%95%B0%E6%8D%AE%E6%94%B6%E9%9B%86%E7%AD%96%E7%95%A5"><span class="toc-number">1.2.</span> <span class="toc-text">二、InnoDB的统计数据收集策略</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1%E4%B8%A4%E7%A7%8D%E4%B8%8D%E5%90%8C%E7%9A%84%E7%BB%9F%E8%AE%A1%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F"><span class="toc-number">1.2.1.</span> <span class="toc-text">2.1两种不同的统计数据存储方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2%E5%9F%BA%E4%BA%8E%E7%A3%81%E7%9B%98%E7%9A%84%E6%B0%B8%E4%B9%85%E6%80%A7%E7%BB%9F%E8%AE%A1%E6%95%B0%E6%8D%AE"><span class="toc-number">1.2.2.</span> <span class="toc-text">2.2基于磁盘的永久性统计数据</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-1innodb-table-stats"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">2.2.1innodb_table_stats</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#n-rows%E7%BB%9F%E8%AE%A1%E9%A1%B9%E7%9A%84%E6%94%B6%E9%9B%86"><span class="toc-number">1.2.2.1.1.</span> <span class="toc-text">n_rows统计项的收集</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#clustered-index-size%E7%BB%9F%E8%AE%A1%E9%A1%B9%E7%9A%84%E6%94%B6%E9%9B%86-x2F-sum-of-other-index-sizes%E7%BB%9F%E8%AE%A1%E9%A1%B9%E7%9A%84%E6%94%B6%E9%9B%86"><span class="toc-number">1.2.2.1.2.</span> <span class="toc-text">clustered_index_size统计项的收集&#x2F;sum_of_other_index_sizes统计项的收集</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-2innodb-index-stats"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">2.2.2innodb_index_stats</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-3%E5%AE%9A%E6%9C%9F%E6%9B%B4%E6%96%B0%E7%BB%9F%E8%AE%A1%E6%95%B0%E6%8D%AE"><span class="toc-number">1.2.2.3.</span> <span class="toc-text">2.2.3定期更新统计数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-4%E6%89%8B%E5%8A%A8%E6%9B%B4%E6%96%B0innodb-table-stats%E5%92%8Cinnodb-index-stats%E8%A1%A8"><span class="toc-number">1.2.2.4.</span> <span class="toc-text">2.2.4手动更新innodb_table_stats和innodb_index_stats表</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3%E5%9F%BA%E4%BA%8E%E5%86%85%E5%AD%98%E7%9A%84%E9%9D%9E%E6%B0%B8%E4%B9%85%E6%80%A7%E7%BB%9F%E8%AE%A1%E6%95%B0%E6%8D%AE"><span class="toc-number">1.2.3.</span> <span class="toc-text">2.3基于内存的非永久性统计数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4innodb-stats-method%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">1.2.4.</span> <span class="toc-text">2.4innodb_stats_method的使用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81MySQL%E5%9F%BA%E4%BA%8E%E8%A7%84%E5%88%99%E7%9A%84%E4%BC%98%E5%8C%96"><span class="toc-number">1.3.</span> <span class="toc-text">三、MySQL基于规则的优化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1%E6%9D%A1%E4%BB%B6%E5%8C%96%E7%AE%80"><span class="toc-number">1.3.1.</span> <span class="toc-text">3.1条件化简</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-1%E7%A7%BB%E9%99%A4%E4%B8%8D%E5%BF%85%E8%A6%81%E7%9A%84%E6%8B%AC%E5%8F%B7"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">3.1.1移除不必要的括号</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-2%E5%B8%B8%E9%87%8F%E4%BC%A0%E9%80%92constant-propagation"><span class="toc-number">1.3.1.2.</span> <span class="toc-text">3.1.2常量传递constant_propagation</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-3%E7%AD%89%E5%80%BC%E4%BC%A0%E9%80%92equality-propagation"><span class="toc-number">1.3.1.3.</span> <span class="toc-text">3.1.3等值传递equality_propagation</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-4%E7%A7%BB%E9%99%A4%E6%B2%A1%E7%94%A8%E7%9A%84%E6%9D%A1%E4%BB%B6trivial-condition-removal"><span class="toc-number">1.3.1.4.</span> <span class="toc-text">3.1.4移除没用的条件trivial_condition_removal</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-5%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AE%A1%E7%AE%97"><span class="toc-number">1.3.1.5.</span> <span class="toc-text">3.1.5表达式计算</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-6HAVING%E5%AD%90%E5%8F%A5%E5%92%8CWHERE%E5%AD%90%E5%8F%A5%E7%9A%84%E5%90%88%E5%B9%B6"><span class="toc-number">1.3.1.6.</span> <span class="toc-text">3.1.6HAVING子句和WHERE子句的合并</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-7%E5%B8%B8%E9%87%8F%E8%A1%A8%E6%A3%80%E6%B5%8B"><span class="toc-number">1.3.1.7.</span> <span class="toc-text">3.1.7常量表检测</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2%E5%A4%96%E8%BF%9E%E6%8E%A5%E6%B6%88%E9%99%A4"><span class="toc-number">1.3.2.</span> <span class="toc-text">3.2外连接消除</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3%E5%AD%90%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96"><span class="toc-number">1.3.3.</span> <span class="toc-text">3.3子查询优化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-1%E5%AD%90%E6%9F%A5%E8%AF%A2%E8%AF%AD%E6%B3%95"><span class="toc-number">1.3.3.1.</span> <span class="toc-text">3.3.1子查询语法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8C%89%E8%BF%94%E5%9B%9E%E7%9A%84%E7%BB%93%E6%9E%9C%E9%9B%86%E5%8C%BA%E5%88%86%E5%AD%90%E6%9F%A5%E8%AF%A2"><span class="toc-number">1.3.3.1.1.</span> <span class="toc-text">按返回的结果集区分子查询</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8C%89%E4%B8%8E%E5%A4%96%E5%B1%82%E6%9F%A5%E8%AF%A2%E5%85%B3%E7%B3%BB%E6%9D%A5%E5%8C%BA%E5%88%86%E5%AD%90%E6%9F%A5%E8%AF%A2"><span class="toc-number">1.3.3.1.2.</span> <span class="toc-text">按与外层查询关系来区分子查询</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AD%90%E6%9F%A5%E8%AF%A2%E5%9C%A8%E5%B8%83%E5%B0%94%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">1.3.3.1.3.</span> <span class="toc-text">子查询在布尔表达式中的使用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AD%90%E6%9F%A5%E8%AF%A2%E8%AF%AD%E6%B3%95%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">1.3.3.1.4.</span> <span class="toc-text">子查询语法注意事项</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-2%E5%AD%90%E6%9F%A5%E8%AF%A2%E5%9C%A8MySQL%E4%B8%AD%E6%98%AF%E6%80%8E%E4%B9%88%E6%89%A7%E8%A1%8C%E7%9A%84"><span class="toc-number">1.3.3.2.</span> <span class="toc-text">3.3.2子查询在MySQL中是怎么执行的</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B0%8F%E7%99%BD%E4%BB%AC%E7%9C%BC%E4%B8%AD%E5%AD%90%E6%9F%A5%E8%AF%A2%E7%9A%84%E6%89%A7%E8%A1%8C%E6%96%B9%E5%BC%8F"><span class="toc-number">1.3.3.2.1.</span> <span class="toc-text">小白们眼中子查询的执行方式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A0%87%E9%87%8F%E5%AD%90%E6%9F%A5%E8%AF%A2%E3%80%81%E8%A1%8C%E5%AD%90%E6%9F%A5%E8%AF%A2%E7%9A%84%E6%89%A7%E8%A1%8C%E6%96%B9%E5%BC%8F"><span class="toc-number">1.3.3.2.2.</span> <span class="toc-text">标量子查询、行子查询的执行方式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#IN%E5%AD%90%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96"><span class="toc-number">1.3.3.2.3.</span> <span class="toc-text">IN子查询优化</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%89%A9%E5%8C%96%E8%A1%A8%E8%BD%AC%E8%BF%9E%E6%8E%A5"><span class="toc-number">1.3.3.2.4.</span> <span class="toc-text">物化表转连接</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B0%86%E5%AD%90%E6%9F%A5%E8%AF%A2%E8%BD%AC%E6%8D%A2%E4%B8%BAsemi-join"><span class="toc-number">1.3.3.2.5.</span> <span class="toc-text">将子查询转换为semi-join</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#semi-join%E7%9A%84%E9%80%82%E7%94%A8%E6%9D%A1%E4%BB%B6"><span class="toc-number">1.3.3.2.6.</span> <span class="toc-text">semi-join的适用条件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%8D%E9%80%82%E7%94%A8%E4%BA%8Esemi-join%E7%9A%84%E6%83%85%E5%86%B5"><span class="toc-number">1.3.3.2.7.</span> <span class="toc-text">不适用于semi-join的情况</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#ANY-x2F-ALL%E5%AD%90%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96"><span class="toc-number">1.3.3.2.8.</span> <span class="toc-text">ANY&#x2F;ALL子查询优化</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#NOT-EXISTS%E5%AD%90%E6%9F%A5%E8%AF%A2%E7%9A%84%E6%89%A7%E8%A1%8C"><span class="toc-number">1.3.3.2.9.</span> <span class="toc-text">[NOT] EXISTS子查询的执行</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AF%B9%E4%BA%8E%E6%B4%BE%E7%94%9F%E8%A1%A8%E7%9A%84%E4%BC%98%E5%8C%96"><span class="toc-number">1.3.3.2.10.</span> <span class="toc-text">对于派生表的优化</span></a></li></ol></li></ol></li></ol></li></ol></li></ol>
      </div>
    
  </span>
</div>

    
    <div class="content index py4 ">
        
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle p-name" itemprop="name headline">
        MySQL原理之查询优化篇
    </h1>



    <div class="meta">
      <span class="author p-author h-card" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span class="p-name" itemprop="name">hulingF</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2023-12-19T03:57:02.125Z" class="dt-published" itemprop="datePublished">2023-12-19</time>
        
      
    </div>


      

      
    <div class="article-tag">
        <i class="fa-solid fa-tag"></i>
        <a class="p-category" href="/tags/MySQL%E5%8E%9F%E7%90%86/" rel="tag">MySQL原理</a>
    </div>


    </div>
  </header>
  

  <div class="content e-content" itemprop="articleBody">
    <h1 id="MySQL原理之查询优化篇"><a href="#MySQL原理之查询优化篇" class="headerlink" title="MySQL原理之查询优化篇"></a>MySQL原理之查询优化篇</h1><h2 id="一、MySQL基于成本的优化"><a href="#一、MySQL基于成本的优化" class="headerlink" title="一、MySQL基于成本的优化"></a>一、MySQL基于成本的优化</h2><p>我们之前老说<code>MySQL</code>执行一个查询可以有不同的执行方案，它会选择其中成本最低，或者说代价最低的那种方案去真正的执行查询。不过我们之前对<code>成本</code>的描述是非常模糊的，其实在<code>MySQL</code>中一条查询语句的执行成本是由下边这两个方面组成的：</p>
<ul>
<li><p><code>I/O</code>成本</p>
<p>我们的表经常使用的<code>MyISAM</code>、<code>InnoDB</code>存储引擎都是将数据和索引都存储到磁盘上的，当我们想查询表中的记录时，需要先把数据或者索引加载到内存中然后再操作。这个从磁盘到内存这个加载的过程损耗的时间称之为<code>I/O</code>成本。</p>
</li>
<li><p><code>CPU</code>成本</p>
<p>读取以及检测记录是否满足对应的搜索条件、对结果集进行排序等这些操作损耗的时间称之为<code>CPU</code>成本。</p>
</li>
</ul>
<p>对于<code>InnoDB</code>存储引擎来说，页是磁盘和内存之间交互的基本单位，设计<code>MySQL</code>的大叔规定读取一个页面花费的成本默认是<code>1.0</code>，读取以及检测一条记录是否符合搜索条件的成本默认是<code>0.2</code>。<code>1.0</code>、<code>0.2</code>这些数字称之为<code>成本常数</code>，这两个成本常数我们最常用到，其余的成本常数我们后边再说哈。</p>
<blockquote>
<p>需要注意的是，不管读取记录时需不需要检测是否满足搜索条件，其成本都算是0.2。</p>
</blockquote>
<h3 id="1-1单表查询的成本"><a href="#1-1单表查询的成本" class="headerlink" title="1.1单表查询的成本"></a>1.1单表查询的成本</h3><p>为了故事的顺利发展，我们还得把之前用到的<code>single_table</code>表搬来，怕大家忘了这个表长啥样，再给大家抄一遍：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> single_table (</span><br><span class="line">    id <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">    key1 <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    key2 <span class="type">INT</span>,</span><br><span class="line">    key3 <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    key_part1 <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    key_part2 <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    key_part3 <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    common_field <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (id),</span><br><span class="line">    KEY idx_key1 (key1),</span><br><span class="line">    <span class="keyword">UNIQUE</span> KEY idx_key2 (key2),</span><br><span class="line">    KEY idx_key3 (key3),</span><br><span class="line">    KEY idx_key_part(key_part1, key_part2, key_part3)</span><br><span class="line">) Engine<span class="operator">=</span>InnoDB CHARSET<span class="operator">=</span>utf8;</span><br></pre></td></tr></table></figure>

<p>还是假设这个表里边儿有10000条记录，除<code>id</code>列外其余的列都插入随机值。下边正式开始我们的表演。</p>
<h3 id="1-2基于成本的优化步骤"><a href="#1-2基于成本的优化步骤" class="headerlink" title="1.2基于成本的优化步骤"></a>1.2基于成本的优化步骤</h3><p>在一条单表查询语句真正执行之前，<code>MySQL</code>的查询优化器会找出执行该语句所有可能使用的方案，对比之后找出成本最低的方案，这个成本最低的方案就是所谓的<code>执行计划</code>，之后才会调用存储引擎提供的接口真正的执行查询，这个过程总结一下就是这样：</p>
<ol>
<li>根据搜索条件，找出所有可能使用的索引</li>
<li>计算全表扫描的代价</li>
<li>计算使用不同索引执行查询的代价</li>
<li>对比各种执行方案的代价，找出成本最低的那一个</li>
</ol>
<p>下边我们就以一个实例来分析一下这些步骤，单表查询语句如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> single_table <span class="keyword">WHERE</span> </span><br><span class="line">    key1 <span class="keyword">IN</span> (<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>) <span class="keyword">AND</span> </span><br><span class="line">    key2 <span class="operator">&gt;</span> <span class="number">10</span> <span class="keyword">AND</span> key2 <span class="operator">&lt;</span> <span class="number">1000</span> <span class="keyword">AND</span> </span><br><span class="line">    key3 <span class="operator">&gt;</span> key2 <span class="keyword">AND</span> </span><br><span class="line">    key_part1 <span class="keyword">LIKE</span> <span class="string">&#x27;%hello%&#x27;</span> <span class="keyword">AND</span></span><br><span class="line">    common_field <span class="operator">=</span> <span class="string">&#x27;123&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>乍看上去有点儿复杂哦，我们一步一步分析一下。</p>
<h4 id="1-2-1根据搜索条件，找出所有可能使用的索引"><a href="#1-2-1根据搜索条件，找出所有可能使用的索引" class="headerlink" title="1.2.1根据搜索条件，找出所有可能使用的索引"></a>1.2.1根据搜索条件，找出所有可能使用的索引</h4><p>我们前边说过，对于<code>B+</code>树索引来说，只要索引列和常数使用<code>=</code>、<code>&lt;=&gt;</code>、<code>IN</code>、<code>NOT IN</code>、<code>IS NULL</code>、<code>IS NOT NULL</code>、<code>&gt;</code>、<code>&lt;</code>、<code>&gt;=</code>、<code>&lt;=</code>、<code>BETWEEN</code>、<code>!=</code>（不等于也可以写成<code>&lt;&gt;</code>）或者<code>LIKE</code>操作符连接起来，就可以产生一个所谓的<code>范围区间</code>（<code>LIKE</code>匹配字符串前缀也行），也就是说这些搜索条件都可能使用到索引，设计<code>MySQL</code>的大叔把一个查询中可能使用到的索引称之为<code>possible keys</code>。</p>
<p>我们分析一下上边查询中涉及到的几个搜索条件：</p>
<ul>
<li><code>key1 IN (&#39;a&#39;, &#39;b&#39;, &#39;c&#39;)</code>，这个搜索条件可以使用二级索引<code>idx_key1</code>。</li>
<li><code>key2 &gt; 10 AND key2 &lt; 1000</code>，这个搜索条件可以使用二级索引<code>idx_key2</code>。</li>
<li><code>key3 &gt; key2</code>，这个搜索条件的索引列由于没有和常数比较，所以并不能使用到索引。</li>
<li><code>key_part1 LIKE &#39;%hello%&#39;</code>，<code>key_part1</code>通过<code>LIKE</code>操作符和以通配符开头的字符串做比较，不可以适用索引。</li>
<li><code>common_field = &#39;123&#39;</code>，由于该列上压根儿没有索引，所以不会用到索引。</li>
</ul>
<p>综上所述，上边的查询语句可能用到的索引，也就是<code>possible keys</code>只有<code>idx_key1</code>和<code>idx_key2</code>。</p>
<h4 id="1-2-2计算全表扫描的代价"><a href="#1-2-2计算全表扫描的代价" class="headerlink" title="1.2.2计算全表扫描的代价"></a>1.2.2计算全表扫描的代价</h4><p>对于<code>InnoDB</code>存储引擎来说，全表扫描的意思就是把聚簇索引中的记录都依次和给定的搜索条件做一下比较，把符合搜索条件的记录加入到结果集，所以需要将聚簇索引对应的页面加载到内存中，然后再检测记录是否符合搜索条件。由于查询成本&#x3D;<code>I/O</code>成本+<code>CPU</code>成本，所以计算全表扫描的代价需要两个信息：</p>
<ul>
<li>聚簇索引占用的页面数</li>
<li>该表中的记录数</li>
</ul>
<p>这两个信息从哪来呢？设计<code>MySQL</code>的大叔为每个表维护了一系列的<code>统计信息</code>，关于这些统计信息是如何收集起来的我们放在本章后边详细唠叨，现在看看怎么查看这些统计信息哈。设计<code>MySQL</code>的大叔给我们提供了<code>SHOW TABLE STATUS</code>语句来查看表的统计信息，如果要看指定的某个表的统计信息，在该语句后加对应的<code>LIKE</code>语句就好了，比方说我们要查看<code>single_table</code>这个表的统计信息可以这么写：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SHOW</span> <span class="keyword">TABLE</span> STATUS <span class="keyword">LIKE</span> <span class="string">&#x27;single_table&#x27;</span>\G</span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">1.</span> <span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">           Name: single_table</span><br><span class="line">         Engine: InnoDB</span><br><span class="line">        Version: <span class="number">10</span></span><br><span class="line">     Row_format: <span class="keyword">Dynamic</span></span><br><span class="line">           <span class="keyword">Rows</span>: <span class="number">9693</span></span><br><span class="line"> Avg_row_length: <span class="number">163</span></span><br><span class="line">    Data_length: <span class="number">1589248</span></span><br><span class="line">Max_data_length: <span class="number">0</span></span><br><span class="line">   Index_length: <span class="number">2752512</span></span><br><span class="line">      Data_free: <span class="number">4194304</span></span><br><span class="line"> Auto_increment: <span class="number">10001</span></span><br><span class="line">    Create_time: <span class="number">2018</span><span class="number">-12</span><span class="number">-10</span> <span class="number">13</span>:<span class="number">37</span>:<span class="number">23</span></span><br><span class="line">    Update_time: <span class="number">2018</span><span class="number">-12</span><span class="number">-10</span> <span class="number">13</span>:<span class="number">38</span>:<span class="number">03</span></span><br><span class="line">     Check_time: <span class="keyword">NULL</span></span><br><span class="line">      <span class="keyword">Collation</span>: utf8_general_ci</span><br><span class="line">       Checksum: <span class="keyword">NULL</span></span><br><span class="line"> Create_options:</span><br><span class="line">        Comment:</span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure>

<p>然出现了很多统计选项，但我们目前只关心两个：</p>
<ul>
<li><p><code>Rows</code></p>
<p>本选项表示表中的记录条数。对于使用<code>MyISAM</code>存储引擎的表来说，该值是准确的，对于使用<code>InnoDB</code>存储引擎的表来说，该值是一个估计值。从查询结果我们也可以看出来，由于我们的<code>single_table</code>表是使用<code>InnoDB</code>存储引擎的，所以虽然实际上表中有10000条记录，但是<code>SHOW TABLE STATUS</code>显示的<code>Rows</code>值只有9693条记录。</p>
</li>
<li><p><code>Data_length</code></p>
<p>本选项表示表占用的存储空间字节数。使用<code>MyISAM</code>存储引擎的表来说，该值就是数据文件的大小，对于使用<code>InnoDB</code>存储引擎的表来说，该值就相当于聚簇索引占用的存储空间大小，也就是说可以这样计算该值的大小：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Data_length <span class="operator">=</span> 聚簇索引的页面数量 x 每个页面的大小</span><br></pre></td></tr></table></figure>

<p>我们的<code>single_table</code>使用默认<code>16KB</code>的页面大小，而上边查询结果显示<code>Data_length</code>的值是<code>1589248</code>，所以我们可以反向来推导出<code>聚簇索引的页面数量</code>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">聚簇索引的页面数量 <span class="operator">=</span> <span class="number">1589248</span> ÷ <span class="number">16</span> ÷ <span class="number">1024</span> <span class="operator">=</span> <span class="number">97</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>我们现在已经得到了聚簇索引占用的页面数量以及该表记录数的估计值，所以就可以计算全表扫描成本了，但是设计<code>MySQL</code>的大叔在真实计算成本时会进行一些<code>微调</code>，这些微调的值是直接硬编码到代码里的，由于没有注释，我也不知道这些微调值是个啥子意思，但是由于这些微调的值十分的小，并不影响我们分析，所以我们也没有必要在这些微调值上纠结了。现在可以看一下全表扫描成本的计算过程：</p>
<ul>
<li><p><code>I/O</code>成本</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">97</span> x <span class="number">1.0</span> <span class="operator">+</span> <span class="number">1.1</span> <span class="operator">=</span> <span class="number">98.1</span></span><br></pre></td></tr></table></figure>

<p><code>97</code>指的是聚簇索引占用的页面数，<code>1.0</code>指的是加载一个页面的成本常数，后边的<code>1.1</code>是一个微调值，我们不用在意。</p>
</li>
<li><p><code>CPU</code>成本：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">9693</span> x <span class="number">0.2</span> <span class="operator">+</span> <span class="number">1.0</span> <span class="operator">=</span> <span class="number">1939.6</span></span><br></pre></td></tr></table></figure>

<p><code>9693</code>指的是统计数据中表的记录数，对于<code>InnoDB</code>存储引擎来说是一个估计值，<code>0.2</code>指的是访问一条记录所需的成本常数，后边的<code>1.0</code>是一个微调值，我们不用在意。</p>
</li>
<li><p>总成本：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">98.1</span> <span class="operator">+</span> <span class="number">1939.6</span> <span class="operator">=</span> <span class="number">2037.7</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>综上所述，对于<code>single_table</code>的全表扫描所需的总成本就是<code>2037.7</code>。</p>
<blockquote>
<p>我们前边说过表中的记录其实都存储在聚簇索引对应B+树的叶子节点中，所以只要我们通过根节点获得了最左边的叶子节点，就可以沿着叶子节点组成的双向链表把所有记录都查看一遍。也就是说全表扫描这个过程其实有的B+树内节点是不需要访问的，但是设计MySQL的大叔们在计算全表扫描成本时直接使用聚簇索引占用的页面数作为计算I&#x2F;O成本的依据，是不区分内节点和叶子节点的，有点儿简单暴力，大家注意一下就好了。</p>
</blockquote>
<h4 id="1-2-3计算使用不同索引执行查询的代价"><a href="#1-2-3计算使用不同索引执行查询的代价" class="headerlink" title="1.2.3计算使用不同索引执行查询的代价"></a>1.2.3计算使用不同索引执行查询的代价</h4><p>从第1步分析我们得到，上述查询可能使用到<code>idx_key1</code>和<code>idx_key2</code>这两个索引，我们需要分别分析单独使用这些索引执行查询的成本，最后还要分析是否可能使用到索引合并。这里需要提一点的是，<code>MySQL</code>查询优化器先分析使用唯一二级索引的成本，再分析使用普通索引的成本，所以我们也先分析<code>idx_key2</code>的成本，然后再看使用<code>idx_key1</code>的成本。</p>
<h5 id="使用idx-key2执行查询的成本分析"><a href="#使用idx-key2执行查询的成本分析" class="headerlink" title="使用idx_key2执行查询的成本分析"></a>使用idx_key2执行查询的成本分析</h5><p><code>idx_key2</code>对应的搜索条件是：<code>key2 &gt; 10 AND key2 &lt; 1000</code>，也就是说对应的范围区间就是：<code>(10, 1000)</code>，使用<code>idx_key2</code>搜索的示意图就是这样子：</p>
<img src="/../../../../../../imgs/MySQL原理之查询优化篇/16998b505d671d4etplv-t2oaga2asx-jj-mark1890000q75.webp" alt="image_1d6cb8nolj1714dimrf1iu64l99.png-124.3kB" style="zoom:80%;" /> 

<p>对于使用<code>二级索引 + 回表</code>方式的查询，设计<code>MySQL</code>的大叔计算这种查询的成本依赖两个方面的数据：</p>
<ul>
<li><p>范围区间数量</p>
<p>不论某个范围区间的二级索引到底占用了多少页面，查询优化器粗暴的认为读取索引的一个范围区间的<code>I/O</code>成本和读取一个页面是相同的。本例中使用<code>idx_key2</code>的范围区间只有一个：<code>(10, 1000)</code>，所以相当于访问这个范围区间的二级索引付出的<code>I/O</code>成本就是：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> x <span class="number">1.0</span> <span class="operator">=</span> <span class="number">1.0</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>步骤1：先根据<code>key2 &gt; 10</code>这个条件访问一下<code>idx_key2</code>对应的<code>B+</code>树索引，找到满足<code>key2 &gt; 10</code>这个条件的第一条记录，我们把这条记录称之为<code>区间最左记录</code>。我们前头说过在<code>B+</code>数树中定位一条记录的过程是贼快的，是常数级别的，所以这个过程的性能消耗是可以忽略不计的。</p>
</li>
<li><p>步骤2：然后再根据<code>key2 &lt; 1000</code>这个条件继续从<code>idx_key2</code>对应的<code>B+</code>树索引中找出最后一条满足这个条件的记录，我们把这条记录称之为<code>区间最右记录</code>，这个过程的性能消耗也可以忽略不计的。</p>
</li>
<li><p>步骤3：如果<code>区间最左记录</code>和<code>区间最右记录</code>相隔不太远（在<code>MySQL 5.7.21</code>这个版本里，只要相隔不大于10个页面即可），那就可以精确统计出满足<code>key2 &gt; 10 AND key2 &lt; 1000</code>条件的二级索引记录条数。否则只沿着<code>区间最左记录</code>向右读10个页面，计算平均每个页面中包含多少记录，然后用这个平均值乘以<code>区间最左记录</code>和<code>区间最右记录</code>之间的页面数量就可以了。那么问题又来了，怎么估计<code>区间最左记录</code>和<code>区间最右记录</code>之间有多少个页面呢？解决这个问题还得回到<code>B+</code>树索引的结构中来：</p>
<p><img src="/../../../../../../imgs/MySQL%E5%8E%9F%E7%90%86%E4%B9%8B%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E7%AF%87/16998b505d7a278atplv-t2oaga2asx-jj-mark1890000q75.webp" alt="image_1cubndfil1i02ddfas1j3brq9m.png-85.3kB"> </p>
<p>如图，我们假设<code>区间最左记录</code>在<code>页b</code>中，<code>区间最右记录</code>在<code>页c</code>中，那么我们想计算<code>区间最左记录</code>和<code>区间最右记录</code>之间的页面数量就相当于计算<code>页b</code>和<code>页c</code>之间有多少页面，而每一条<code>目录项记录</code>都对应一个数据页，所以计算<code>页b</code>和<code>页c</code>之间有多少页面就相当于计算它们父节点（也就是页a）中对应的目录项记录之间隔着几条记录。在一个页面中统计两条记录之间有几条记录的成本就贼小了。</p>
<p>不过还有问题，如果<code>页b</code>和<code>页c</code>之间的页面实在太多，以至于<code>页b</code>和<code>页c</code>对应的目录项记录都不在一个页面中该咋办？继续递归啊，也就是再统计<code>页b</code>和<code>页c</code>对应的目录项记录所在页之间有多少个页面。之前我们说过一个<code>B+</code>树有4层高已经很了不得了，所以这个统计过程也不是很耗费性能。</p>
</li>
</ul>
<p>知道了如何统计二级索引某个范围区间的记录数之后，就需要回到现实问题中来，根据上述算法测得<code>idx_key2</code>在区间<code>(10, 1000)</code>之间大约有<code>95</code>条记录。读取这<code>95</code>条二级索引记录需要付出的<code>CPU</code>成本就是：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">95</span> x <span class="number">0.2</span> <span class="operator">+</span> <span class="number">0.01</span> <span class="operator">=</span> <span class="number">19.01</span></span><br></pre></td></tr></table></figure>

<p>其中<code>95</code>是需要读取的二级索引记录条数，<code>0.2</code>是读取一条记录成本常数，<code>0.01</code>是微调。</p>
<p>在通过二级索引获取到记录之后，还需要干两件事儿：</p>
<ul>
<li><p>根据这些记录里的主键值到聚簇索引中做回表操作</p>
<p>这里需要大家使劲儿睁大自己滴溜溜的大眼睛仔细瞧，设计<code>MySQL</code>的大叔评估回表操作的<code>I/O</code>成本依旧很豪放，他们认为每次回表操作都相当于访问一个页面，也就是说二级索引范围区间有多少记录，就需要进行多少次回表操作，也就是需要进行多少次页面<code>I/O</code>。我们上边统计了使用<code>idx_key2</code>二级索引执行查询时，预计有<code>95</code>条二级索引记录需要进行回表操作，所以回表操作带来的<code>I/O</code>成本就是：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">95</span> x <span class="number">1.0</span> <span class="operator">=</span> <span class="number">95.0</span></span><br></pre></td></tr></table></figure>

<p>其中<code>95</code>是预计的二级索引记录数，<code>1.0</code>是一个页面的<code>I/O</code>成本常数。</p>
</li>
<li><p>回表操作后得到的完整用户记录，然后再检测其他搜索条件是否成立</p>
<p>回表操作的本质就是通过二级索引记录的主键值到聚簇索引中找到完整的用户记录，然后再检测除<code>key2 &gt; 10 AND key2 &lt; 1000</code>这个搜索条件以外的搜索条件是否成立。因为我们通过范围区间获取到二级索引记录共<code>95</code>条，也就对应着聚簇索引中<code>95</code>条完整的用户记录，读取并检测这些完整的用户记录是否符合其余的搜索条件的<code>CPU</code>成本如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">95</span> x <span class="number">0.2</span> <span class="operator">=</span> <span class="number">19.0</span></span><br></pre></td></tr></table></figure>

<p>其中<code>95</code>是待检测记录的条数，<code>0.2</code>是检测一条记录是否符合给定的搜索条件的成本常数。</p>
</li>
</ul>
</li>
</ul>
<p>所以本例中使用<code>idx_key2</code>执行查询的成本就如下所示：</p>
<ul>
<li><p><code>I/O</code>成本：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.0</span> <span class="operator">+</span> <span class="number">95</span> x <span class="number">1.0</span> <span class="operator">=</span> <span class="number">96.0</span> (范围区间的数量 <span class="operator">+</span> 预估的二级索引记录条数)</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>CPU</code>成本：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">95</span> x <span class="number">0.2</span> <span class="operator">+</span> <span class="number">0.01</span> <span class="operator">+</span> <span class="number">95</span> x <span class="number">0.2</span> <span class="operator">=</span> <span class="number">38.01</span> （读取二级索引记录的成本 <span class="operator">+</span> 读取并检测回表后聚簇索引记录的成本）</span><br></pre></td></tr></table></figure></li>
</ul>
<p>综上所述，使用<code>idx_key2</code>执行查询的总成本就是：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">96.0</span> <span class="operator">+</span> <span class="number">38.01</span> <span class="operator">=</span> <span class="number">134.01</span></span><br></pre></td></tr></table></figure>

<h5 id="使用idx-key1执行查询的成本分析"><a href="#使用idx-key1执行查询的成本分析" class="headerlink" title="使用idx_key1执行查询的成本分析"></a>使用idx_key1执行查询的成本分析</h5><p><code>idx_key1</code>对应的搜索条件是：<code>key1 IN (&#39;a&#39;, &#39;b&#39;, &#39;c&#39;)</code>，也就是说相当于3个单点区间：</p>
<ul>
<li><code>[&#39;a&#39;, &#39;a&#39;]</code></li>
<li><code>[&#39;b&#39;, &#39;b&#39;]</code></li>
<li><code>[&#39;c&#39;, &#39;c&#39;]</code></li>
</ul>
<p>使用<code>idx_key1</code>搜索的示意图就是这样子：</p>
<p><img src="/../../../../../../imgs/MySQL%E5%8E%9F%E7%90%86%E4%B9%8B%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E7%AF%87/16998b505eab86e6tplv-t2oaga2asx-jj-mark1890000q75.webp" alt="image_1cubvsars1i0rvdc11b3118th9830.png-124.1kB"> </p>
<p>与使用<code>idx_key2</code>的情况类似，我们也需要计算使用<code>idx_key1</code>时需要访问的范围区间数量以及需要回表的记录数：</p>
<ul>
<li><p>范围区间数量</p>
<p>使用<code>idx_key1</code>执行查询时很显然有3个单点区间，所以访问这3个范围区间的二级索引付出的I&#x2F;O成本就是：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span> x <span class="number">1.0</span> <span class="operator">=</span> <span class="number">3.0</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>需要回表的记录数</p>
<p>由于使用<code>idx_key1</code>时有3个单点区间，所以每个单点区间都需要查找一遍对应的二级索引记录数：</p>
<ul>
<li><p>查找单点区间<code>[&#39;a&#39;, &#39;a&#39;]</code>对应的二级索引记录数</p>
<p>计算单点区间对应的二级索引记录数和计算连续范围区间对应的二级索引记录数是一样的，都是先计算<code>区间最左记录</code>和<code>区间最右记录</code>，然后再计算它们之间的记录数，具体算法上边都唠叨过了，就不赘述了。最后计算得到单点区间<code>[&#39;a&#39;, &#39;a&#39;]</code>对应的二级索引记录数是：<code>35</code>。</p>
</li>
<li><p>查找单点区间<code>[&#39;b&#39;, &#39;b&#39;]</code>对应的二级索引记录数</p>
<p>与上同理，计算得到本单点区间对应的记录数是：<code>44</code>。</p>
</li>
<li><p>查找单点区间<code>[&#39;c&#39;, &#39;c&#39;]</code>对应的二级索引记录数</p>
<p>与上同理，计算得到本单点区间对应的记录数是：<code>39</code>。</p>
</li>
</ul>
<p>所以，这三个单点区间总共需要回表的记录数就是：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">35</span> <span class="operator">+</span> <span class="number">44</span> <span class="operator">+</span> <span class="number">39</span> <span class="operator">=</span> <span class="number">118</span></span><br></pre></td></tr></table></figure>

<p>读取这些二级索引记录的<code>CPU</code>成本就是：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">118</span> x <span class="number">0.2</span> <span class="operator">+</span> <span class="number">0.01</span> <span class="operator">=</span> <span class="number">23.61</span></span><br></pre></td></tr></table></figure>

<p>得到总共需要回表的记录数之后，就要考虑：</p>
<ul>
<li><p>根据这些记录里的主键值到聚簇索引中做回表操作</p>
<p>所需的<code>I/O</code>成本就是：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">118</span> x <span class="number">1.0</span> <span class="operator">=</span> <span class="number">118.0</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>回表操作后得到的完整用户记录，然后再比较其他搜索条件是否成立</p>
<p>此步骤对应的<code>CPU</code>成本就是：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">118</span> x <span class="number">0.2</span> <span class="operator">=</span> <span class="number">23.6</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<p>所以本例中使用<code>idx_key1</code>执行查询的成本就如下所示：</p>
<ul>
<li><p><code>I/O</code>成本：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3.0</span> <span class="operator">+</span> <span class="number">118</span> x <span class="number">1.0</span> <span class="operator">=</span> <span class="number">121.0</span> (范围区间的数量 <span class="operator">+</span> 预估的二级索引记录条数)</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>CPU</code>成本：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">118</span> x <span class="number">0.2</span> <span class="operator">+</span> <span class="number">0.01</span> <span class="operator">+</span> <span class="number">118</span> x <span class="number">0.2</span> <span class="operator">=</span> <span class="number">47.21</span> （读取二级索引记录的成本 <span class="operator">+</span> 读取并检测回表后聚簇索引记录的成本）</span><br></pre></td></tr></table></figure></li>
</ul>
<p>综上所述，使用<code>idx_key1</code>执行查询的总成本就是：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">121.0</span> <span class="operator">+</span> <span class="number">47.21</span> <span class="operator">=</span> <span class="number">168.21</span></span><br></pre></td></tr></table></figure>

<h5 id="是否有可能使用索引合并（Index-Merge）"><a href="#是否有可能使用索引合并（Index-Merge）" class="headerlink" title="是否有可能使用索引合并（Index Merge）"></a>是否有可能使用索引合并（Index Merge）</h5><p>本例中有关<code>key1</code>和<code>key2</code>的搜索条件是使用<code>AND</code>连接起来的，而对于<code>idx_key1</code>和<code>idx_key2</code>都是范围查询，也就是说查找到的二级索引记录并不是按照主键值进行排序的，并不满足使用<code>Intersection</code>索引合并的条件，所以并不会使用索引合并。</p>
<blockquote>
<p>MySQL查询优化器计算索引合并成本的算法也比较麻烦，所以我们这也就不展开唠叨了。</p>
</blockquote>
<h4 id="1-2-4对比各种执行方案的代价，找出成本最低的方案"><a href="#1-2-4对比各种执行方案的代价，找出成本最低的方案" class="headerlink" title="1.2.4对比各种执行方案的代价，找出成本最低的方案"></a>1.2.4对比各种执行方案的代价，找出成本最低的方案</h4><p>下边把执行本例中的查询的各种可执行方案以及它们对应的成本列出来：</p>
<ul>
<li>全表扫描的成本：<code>2037.7</code></li>
<li>使用<code>idx_key2</code>的成本：<code>134.01</code></li>
<li>使用<code>idx_key1</code>的成本：<code>168.21</code></li>
</ul>
<p>很显然，使用<code>idx_key2</code>的成本最低，所以当然选择<code>idx_key2</code>来执行查询喽。</p>
<h3 id="1-3基于索引统计数据的成本计算"><a href="#1-3基于索引统计数据的成本计算" class="headerlink" title="1.3基于索引统计数据的成本计算"></a>1.3基于索引统计数据的成本计算</h3><p>有时候使用索引执行查询时会有许多单点区间，比如使用<code>IN</code>语句就很容易产生非常多的单点区间，比如下边这个查询（下边查询语句中的<code>...</code>表示还有很多参数）：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> single_table <span class="keyword">WHERE</span> key1 <span class="keyword">IN</span> (<span class="string">&#x27;aa1&#x27;</span>, <span class="string">&#x27;aa2&#x27;</span>, <span class="string">&#x27;aa3&#x27;</span>, ... , <span class="string">&#x27;zzz&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>很显然，这个查询可能使用到的索引就是<code>idx_key1</code>，由于这个索引并不是唯一二级索引，所以并不能确定一个单点区间对应的二级索引记录的条数有多少，需要我们去计算。计算方式我们上边已经介绍过了，就是先获取索引对应的<code>B+</code>树的<code>区间最左记录</code>和<code>区间最右记录</code>，然后再计算这两条记录之间有多少记录（记录条数少的时候可以做到精确计算，多的时候只能估算）。设计<code>MySQL</code>的大叔把这种通过直接访问索引对应的<code>B+</code>树来计算某个范围区间对应的索引记录条数的方式称之为<code>index dive</code>。</p>
<p>有零星几个单点区间的话，使用<code>index dive</code>的方式去计算这些单点区间对应的记录数也不是什么问题，可是你架不住有的孩子憋足了劲往<code>IN</code>语句里塞东西呀，我就见过有的同学写的<code>IN</code>语句里有20000个参数的🤣🤣，这就意味着<code>MySQL</code>的查询优化器为了计算这些单点区间对应的索引记录条数，要进行20000次<code>index dive</code>操作，这性能损耗可就大了，搞不好计算这些单点区间对应的索引记录条数的成本比直接全表扫描的成本都大了。设计<code>MySQL</code>的大叔们多聪明啊，他们当然考虑到了这种情况，所以提供了一个系统变量<code>eq_range_index_dive_limit</code>，我们看一下在<code>MySQL 5.7.21</code>中这个系统变量的默认值：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;%dive%&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------------+-------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name             <span class="operator">|</span> <span class="keyword">Value</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------------+-------+</span></span><br><span class="line"><span class="operator">|</span> eq_range_index_dive_limit <span class="operator">|</span> <span class="number">200</span>   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------------+-------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.08</span> sec)</span><br></pre></td></tr></table></figure>

<p>也就是说如果我们的<code>IN</code>语句中的参数个数小于200个的话，将使用<code>index dive</code>的方式计算各个单点区间对应的记录条数，如果大于或等于200个的话，可就不能使用<code>index dive</code>了，要使用所谓的索引统计数据来进行估算。怎么个估算法？继续往下看。</p>
<p>像会为每个表维护一份统计数据一样，<code>MySQL</code>也会为表中的每一个索引维护一份统计数据，查看某个表中索引的统计数据可以使用<code>SHOW INDEX FROM 表名</code>的语法，比如我们查看一下<code>single_table</code>的各个索引的统计数据可以这么写：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SHOW</span> INDEX <span class="keyword">FROM</span> single_table;</span><br><span class="line"><span class="operator">+</span><span class="comment">--------------+------------+--------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">Table</span>        <span class="operator">|</span> Non_unique <span class="operator">|</span> Key_name     <span class="operator">|</span> Seq_in_index <span class="operator">|</span> Column_name <span class="operator">|</span> <span class="keyword">Collation</span> <span class="operator">|</span> <span class="keyword">Cardinality</span> <span class="operator">|</span> Sub_part <span class="operator">|</span> Packed <span class="operator">|</span> <span class="keyword">Null</span> <span class="operator">|</span> Index_type <span class="operator">|</span> Comment <span class="operator">|</span> Index_comment <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------+------------+--------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+</span></span><br><span class="line"><span class="operator">|</span> single_table <span class="operator">|</span>          <span class="number">0</span> <span class="operator">|</span> <span class="keyword">PRIMARY</span>      <span class="operator">|</span>            <span class="number">1</span> <span class="operator">|</span> id          <span class="operator">|</span> A         <span class="operator">|</span>       <span class="number">9693</span>  <span class="operator">|</span>     <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>   <span class="operator">|</span>      <span class="operator">|</span> BTREE      <span class="operator">|</span>         <span class="operator">|</span>               <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> single_table <span class="operator">|</span>          <span class="number">0</span> <span class="operator">|</span> idx_key2     <span class="operator">|</span>            <span class="number">1</span> <span class="operator">|</span> key2        <span class="operator">|</span> A         <span class="operator">|</span>       <span class="number">9693</span>  <span class="operator">|</span>     <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>   <span class="operator">|</span> YES  <span class="operator">|</span> BTREE      <span class="operator">|</span>         <span class="operator">|</span>               <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> single_table <span class="operator">|</span>          <span class="number">1</span> <span class="operator">|</span> idx_key1     <span class="operator">|</span>            <span class="number">1</span> <span class="operator">|</span> key1        <span class="operator">|</span> A         <span class="operator">|</span>        <span class="number">968</span> <span class="operator">|</span>     <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>   <span class="operator">|</span> YES  <span class="operator">|</span> BTREE      <span class="operator">|</span>         <span class="operator">|</span>               <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> single_table <span class="operator">|</span>          <span class="number">1</span> <span class="operator">|</span> idx_key3     <span class="operator">|</span>            <span class="number">1</span> <span class="operator">|</span> key3        <span class="operator">|</span> A         <span class="operator">|</span>        <span class="number">799</span> <span class="operator">|</span>     <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>   <span class="operator">|</span> YES  <span class="operator">|</span> BTREE      <span class="operator">|</span>         <span class="operator">|</span>               <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> single_table <span class="operator">|</span>          <span class="number">1</span> <span class="operator">|</span> idx_key_part <span class="operator">|</span>            <span class="number">1</span> <span class="operator">|</span> key_part1   <span class="operator">|</span> A         <span class="operator">|</span>        <span class="number">9673</span> <span class="operator">|</span>     <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>   <span class="operator">|</span> YES  <span class="operator">|</span> BTREE      <span class="operator">|</span>         <span class="operator">|</span>               <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> single_table <span class="operator">|</span>          <span class="number">1</span> <span class="operator">|</span> idx_key_part <span class="operator">|</span>            <span class="number">2</span> <span class="operator">|</span> key_part2   <span class="operator">|</span> A         <span class="operator">|</span>        <span class="number">9999</span> <span class="operator">|</span>     <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>   <span class="operator">|</span> YES  <span class="operator">|</span> BTREE      <span class="operator">|</span>         <span class="operator">|</span>               <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> single_table <span class="operator">|</span>          <span class="number">1</span> <span class="operator">|</span> idx_key_part <span class="operator">|</span>            <span class="number">3</span> <span class="operator">|</span> key_part3   <span class="operator">|</span> A         <span class="operator">|</span>       <span class="number">10000</span> <span class="operator">|</span>     <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>   <span class="operator">|</span> YES  <span class="operator">|</span> BTREE      <span class="operator">|</span>         <span class="operator">|</span>               <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------+------------+--------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+</span></span><br><span class="line"><span class="number">7</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure>

<p>哇唔，竟然有这么多属性，不过好在这些属性都不难理解，我们就都介绍一遍吧：</p>
<img src="/../../AppData/Roaming/Typora/typora-user-images/image-20231219112601615.png" alt="image-20231219112601615" style="zoom:67%;" /> 

<p>其实我们现在最在意的是<code>Cardinality</code>属性，<code>Cardinality</code>直译过来就是<code>基数</code>的意思，表示索引列中不重复值的个数。比如对于一个一万行记录的表来说，某个索引列的<code>Cardinality</code>属性是<code>10000</code>，那意味着该列中没有重复的值，如果<code>Cardinality</code>属性是<code>1</code>的话，就意味着该列的值全部是重复的。不过需要注意的是，对于InnoDB存储引擎来说，使用SHOW INDEX语句展示出来的某个索引列的Cardinality属性是一个估计值，并不是精确的。关于这个<code>Cardinality</code>属性的值是如何被计算出来的我们后边再说，先看看它有什么用途。</p>
<p>前边说道，当<code>IN</code>语句中的参数个数大于或等于系统变量<code>eq_range_index_dive_limit</code>的值的话，就不会使用<code>index dive</code>的方式计算各个单点区间对应的索引记录条数，而是使用索引统计数据，这里所指的<code>索引统计数据</code>指的是这两个值：</p>
<ul>
<li><p>使用<code>SHOW TABLE STATUS</code>展示出的<code>Rows</code>值，也就是一个表中有多少条记录。</p>
<p>这个统计数据我们在前边唠叨全表扫描成本的时候说过很多遍了，就不赘述了。</p>
</li>
<li><p>使用<code>SHOW INDEX</code>语句展示出的<code>Cardinality</code>属性。</p>
<p>结合上一个<code>Rows</code>统计数据，我们可以针对索引列，计算出平均一个值重复多少次。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一个值的重复次数 ≈ <span class="keyword">Rows</span> ÷ <span class="keyword">Cardinality</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>以<code>single_table</code>表的<code>idx_key1</code>索引为例，它的<code>Rows</code>值是<code>9693</code>，它对应索引列<code>key1</code>的<code>Cardinality</code>值是<code>968</code>，所以我们可以计算<code>key1</code>列平均单个值的重复次数就是：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">9693</span> ÷ <span class="number">968</span> ≈ <span class="number">10</span>（条）</span><br></pre></td></tr></table></figure>

<p>此时再看上边那条查询语句：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> single_table <span class="keyword">WHERE</span> key1 <span class="keyword">IN</span> (<span class="string">&#x27;aa1&#x27;</span>, <span class="string">&#x27;aa2&#x27;</span>, <span class="string">&#x27;aa3&#x27;</span>, ... , <span class="string">&#x27;zzz&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>假设<code>IN</code>语句中有20000个参数的话，就直接使用统计数据来估算这些参数需要单点区间对应的记录条数了，每个参数大约对应<code>10</code>条记录，所以总共需要回表的记录数就是：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">20000</span> x <span class="number">10</span> <span class="operator">=</span> <span class="number">200000</span></span><br></pre></td></tr></table></figure>

<p>使用统计数据来计算单点区间对应的索引记录条数可比<code>index dive</code>的方式简单多了，但是它的致命弱点就是：不精确！。使用统计数据算出来的查询成本与实际所需的成本可能相差非常大。</p>
<blockquote>
<p>大家需要注意一下，在MySQL 5.7.3以及之前的版本中，eq_range_index_dive_limit的默认值为10，之后的版本默认值为200。所以如果大家采用的是5.7.3以及之前的版本的话，很容易采用索引统计数据而不是index dive的方式来计算查询成本。当你的查询中使用到了IN查询，但是却实际没有用到索引，就应该考虑一下是不是由于 eq_range_index_dive_limit 值太小导致的。</p>
</blockquote>
<h3 id="1-4连接查询的成本"><a href="#1-4连接查询的成本" class="headerlink" title="1.4连接查询的成本"></a>1.4连接查询的成本</h3><p>连接查询至少是要有两个表的，只有一个<code>single_table</code>表是不够的，所以为了故事的顺利发展，我们直接构造一个和<code>single_table</code>表一模一样的<code>single_table2</code>表。为了简便起见，我们把<code>single_table</code>表称为<code>s1</code>表，把<code>single_table2</code>表称为<code>s2</code>表。</p>
<h4 id="1-4-1Condition-filtering介绍"><a href="#1-4-1Condition-filtering介绍" class="headerlink" title="1.4.1Condition filtering介绍"></a>1.4.1Condition filtering介绍</h4><p>我们前边说过，<code>MySQL</code>中连接查询采用的是嵌套循环连接算法，驱动表会被访问一次，被驱动表可能会被访问多次，所以对于两表连接查询来说，它的查询成本由下边两个部分构成：</p>
<ul>
<li>单次查询驱动表的成本</li>
<li>多次查询被驱动表的成本（具体查询多少次取决于对驱动表查询的结果集中有多少条记录）</li>
</ul>
<p>我们把对驱动表进行查询后得到的记录条数称之为驱动表的<code>扇出</code>（英文名：<code>fanout</code>）。很显然驱动表的扇出值越小，对被驱动表的查询次数也就越少，连接查询的总成本也就越低。当查询优化器想计算整个连接查询所使用的成本时，就需要计算出驱动表的扇出值，有的时候扇出值的计算是很容易的，比如下边这两个查询：</p>
<ul>
<li><p>查询一：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> single_table <span class="keyword">AS</span> s1 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> single_table2 <span class="keyword">AS</span> s2;</span><br></pre></td></tr></table></figure>

<p>假设使用<code>s1</code>表作为驱动表，很显然对驱动表的单表查询只能使用全表扫描的方式执行，驱动表的扇出值也很明确，那就是驱动表中有多少记录，扇出值就是多少。我们前边说过，统计数据中<code>s1</code>表的记录行数是<code>9693</code>，也就是说优化器就直接会把<code>9693</code>当作在<code>s1</code>表的扇出值。</p>
</li>
<li><p>查询二：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> single_table <span class="keyword">AS</span> s1 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> single_table2 <span class="keyword">AS</span> s2 </span><br><span class="line"><span class="keyword">WHERE</span> s1.key2 <span class="operator">&gt;</span><span class="number">10</span> <span class="keyword">AND</span> s1.key2 <span class="operator">&lt;</span> <span class="number">1000</span>;</span><br></pre></td></tr></table></figure>

<p>仍然假设<code>s1</code>表是驱动表的话，很显然对驱动表的单表查询可以使用<code>idx_key2</code>索引执行查询。此时<code>idx_key2</code>的范围区间<code>(10, 1000)</code>中有多少条记录，那么扇出值就是多少。我们前边计算过，满足<code>idx_key2</code>的范围区间<code>(10, 1000)</code>的记录数是95条，也就是说本查询中优化器会把<code>95</code>当作驱动表<code>s1</code>的扇出值。</p>
</li>
</ul>
<p>事情当然不会总是一帆风顺的，要不然剧情就太平淡了。有的时候扇出值的计算就变得很棘手，比方说下边几个查询：</p>
<ul>
<li><p>查询三：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> single_table <span class="keyword">AS</span> s1 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> single_table2 <span class="keyword">AS</span> s2 </span><br><span class="line">    <span class="keyword">WHERE</span> s1.common_field <span class="operator">&gt;</span> <span class="string">&#x27;xyz&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>本查询和<code>查询一</code>类似，只不过对于驱动表<code>s1</code>多了一个<code>common_field &gt; &#39;xyz&#39;</code>的搜索条件。查询优化器又不会真正的去执行查询，所以它只能<code>猜</code>这<code>9693</code>记录里有多少条记录满足<code>common_field &gt; &#39;xyz&#39;</code>条件。</p>
</li>
<li><p>查询四：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> single_table <span class="keyword">AS</span> s1 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> single_table2 <span class="keyword">AS</span> s2 </span><br><span class="line">    <span class="keyword">WHERE</span> s1.key2 <span class="operator">&gt;</span> <span class="number">10</span> <span class="keyword">AND</span> s1.key2 <span class="operator">&lt;</span> <span class="number">1000</span> <span class="keyword">AND</span></span><br><span class="line">          s1.common_field <span class="operator">&gt;</span> <span class="string">&#x27;xyz&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>本查询和<code>查询二</code>类似，只不过对于驱动表<code>s1</code>也多了一个<code>common_field &gt; &#39;xyz&#39;</code>的搜索条件。不过因为本查询可以使用<code>idx_key2</code>索引，所以只需要从符合二级索引范围区间的记录中猜有多少条记录符合<code>common_field &gt; &#39;xyz&#39;</code>条件，也就是只需要猜在<code>95</code>条记录中有多少符合<code>common_field &gt; &#39;xyz&#39;</code>条件。</p>
</li>
<li><p>查询五：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> single_table <span class="keyword">AS</span> s1 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> single_table2 <span class="keyword">AS</span> s2 </span><br><span class="line">    <span class="keyword">WHERE</span> s1.key2 <span class="operator">&gt;</span> <span class="number">10</span> <span class="keyword">AND</span> s1.key2 <span class="operator">&lt;</span> <span class="number">1000</span> <span class="keyword">AND</span></span><br><span class="line">          s1.key1 <span class="keyword">IN</span> (<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>) <span class="keyword">AND</span></span><br><span class="line">          s1.common_field <span class="operator">&gt;</span> <span class="string">&#x27;xyz&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>本查询和<code>查询二</code>类似，不过在驱动表<code>s1</code>选取<code>idx_key2</code>索引执行查询后，优化器需要从符合二级索引范围区间的记录中猜有多少条记录符合下边两个条件：</p>
<ul>
<li><code>key1 IN (&#39;a&#39;, &#39;b&#39;, &#39;c&#39;)</code></li>
<li><code>common_field &gt; &#39;xyz&#39;</code></li>
</ul>
<p>也就是优化器需要猜在<code>95</code>条记录中有多少符合上述两个条件的。</p>
</li>
</ul>
<p>说了这么多，其实就是想表达在这两种情况下计算驱动表扇出值时需要靠<code>猜</code>：</p>
<ul>
<li>如果使用的是全表扫描的方式执行的单表查询，那么计算驱动表扇出时需要猜满足搜索条件的记录到底有多少条。</li>
<li>如果使用的是索引执行的单表扫描，那么计算驱动表扇出的时候需要猜满足除使用到对应索引的搜索条件外的其他搜索条件的记录有多少条。</li>
</ul>
<p>设计<code>MySQL</code>的大叔把这个<code>猜</code>的过程称之为<code>condition filtering</code>。当然，这个过程可能会使用到索引，也可能使用到统计数据，也可能就是设计<code>MySQL</code>的大叔单纯的瞎猜，整个评估过程挺复杂的，再仔细的唠叨一遍可能引起大家的生理不适，所以我们就跳过了哈。</p>
<blockquote>
<p>在MySQL 5.7之前的版本中，查询优化器在计算驱动表扇出时，如果是使用全表扫描的话，就直接使用表中记录的数量作为扇出值，如果使用索引的话，就直接使用满足范围条件的索引记录条数作为扇出值。在MySQL 5.7中，设计MySQL的大叔引入了这个condition filtering的功能，就是还要猜一猜剩余的那些搜索条件能把驱动表中的记录再过滤多少条，其实本质上就是为了让成本估算更精确。<br>我们所说的纯粹瞎猜其实是很不严谨的，设计MySQL的大叔们称之为启发式规则（heuristic），大家有兴趣的可以再深入了解一下哈。</p>
</blockquote>
<h4 id="1-4-2两表连接的成本分析"><a href="#1-4-2两表连接的成本分析" class="headerlink" title="1.4.2两表连接的成本分析"></a>1.4.2两表连接的成本分析</h4><p>连接查询的成本计算公式是这样的：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">连接查询总成本 <span class="operator">=</span> 单次访问驱动表的成本 <span class="operator">+</span> 驱动表扇出数 x 单次访问被驱动表的成本</span><br></pre></td></tr></table></figure>

<p>对于左（外）连接和右（外）连接查询来说，它们的驱动表是固定的，所以想要得到最优的查询方案只需要：</p>
<ul>
<li>分别为驱动表和被驱动表选择成本最低的访问方法。</li>
</ul>
<p>可是对于内连接来说，驱动表和被驱动表的位置是可以互换的，所以需要考虑两个方面的问题：</p>
<ul>
<li>不同的表作为驱动表最终的查询成本可能是不同的，也就是需要考虑最优的表连接顺序。</li>
<li>然后分别为驱动表和被驱动表选择成本最低的访问方法。</li>
</ul>
<p>很显然，计算内连接查询成本的方式更麻烦一些，下边我们就以内连接为例来看看如何计算出最优的连接查询方案。</p>
<blockquote>
<p>左（外）连接和右（外）连接查询在某些特殊情况下可以被优化为内连接查询，例如查询语句中的Where条件中出现 &#x3D;&#x3D;被驱动表的列IS NOT NULL&#x3D;&#x3D;。</p>
</blockquote>
<p>比如对于下边这个查询来说：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> single_table <span class="keyword">AS</span> s1 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> single_table2 <span class="keyword">AS</span> s2 </span><br><span class="line">    <span class="keyword">ON</span> s1.key1 <span class="operator">=</span> s2.common_field </span><br><span class="line">    <span class="keyword">WHERE</span> s1.key2 <span class="operator">&gt;</span> <span class="number">10</span> <span class="keyword">AND</span> s1.key2 <span class="operator">&lt;</span> <span class="number">1000</span> <span class="keyword">AND</span> </span><br><span class="line">          s2.key2 <span class="operator">&gt;</span> <span class="number">1000</span> <span class="keyword">AND</span> s2.key2 <span class="operator">&lt;</span> <span class="number">2000</span>;</span><br></pre></td></tr></table></figure>

<p>可以选择的连接顺序有两种：</p>
<ul>
<li><code>s1</code>连接<code>s2</code>，也就是<code>s1</code>作为驱动表，<code>s2</code>作为被驱动表。</li>
<li><code>s2</code>连接<code>s1</code>，也就是<code>s2</code>作为驱动表，<code>s1</code>作为被驱动表。</li>
</ul>
<p>查询优化器需要分别考虑这两种情况下的最优查询成本，然后选取那个成本更低的连接顺序以及该连接顺序下各个表的最优访问方法作为最终的查询计划。我们分别来看一下（定性的分析一下，不像分析单表查询那样定量的分析了）：</p>
<ul>
<li><p>使用<code>s1</code>作为驱动表的情况</p>
<ul>
<li><p>分析对于驱动表的成本最低的执行方案</p>
<p>首先看一下涉及<code>s1</code>表单表的搜索条件有哪些：</p>
<ul>
<li><code>s1.key2 &gt; 10 AND s1.key2 &lt; 1000</code></li>
</ul>
<p>所以这个查询可能使用到<code>idx_key2</code>索引，从全表扫描和使用<code>idx_key2</code>这两个方案中选出成本最低的那个，这个过程我们上边都唠叨过了，很显然使用<code>idx_key2</code>执行查询的成本更低些。</p>
</li>
<li><p>然后分析对于被驱动表的成本最低的执行方案</p>
<p>此时涉及被驱动表<code>s2</code>的搜索条件就是：</p>
<ul>
<li><code>s2.common_field = 常数</code>（这是因为对驱动表<code>s1</code>结果集中的每一条记录，都需要进行一次被驱动表<code>s2</code>的访问，此时那些涉及两表的条件现在相当于只涉及被驱动表<code>s2</code>了。）</li>
<li><code>s2.key2 &gt; 1000 AND s2.key2 &lt; 2000</code></li>
</ul>
<p>很显然，第一个条件由于<code>common_field</code>没有用到索引，所以并没有什么卵用，此时访问<code>s2</code>表时可用的方案也是全表扫描和使用<code>idx_key2</code>两种，假设使用<code>idx_key2</code>的成本更小。</p>
</li>
</ul>
<p>所以此时使用<code>s1</code>作为驱动表时的总成本就是（暂时不考虑使用<code>join buffer</code>对成本的影响）：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用idx_key2访问s1的成本 <span class="operator">+</span> s1的扇出 × 使用idx_key2访问s2的成本</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用<code>s2</code>作为驱动表的情况</p>
<ul>
<li><p>分析对于驱动表的成本最低的执行方案</p>
<p>首先看一下涉及<code>s2</code>表单表的搜索条件有哪些：</p>
<ul>
<li><code>s2.key2 &gt; 1000 AND s2.key2 &lt; 2000</code></li>
</ul>
<p>所以这个查询可能使用到<code>idx_key2</code>索引，从全表扫描和使用<code>idx_key2</code>这两个方案中选出成本最低的那个，假设使用<code>idx_key2</code>执行查询的成本更低些。</p>
</li>
<li><p>然后分析对于被驱动表的成本最低的执行方案</p>
<p>此时涉及被驱动表<code>s1</code>的搜索条件就是：</p>
<ul>
<li><code>s1.key1 = 常数</code></li>
<li><code>s1.key2 &gt; 10 AND s1.key2 &lt; 2000</code></li>
</ul>
<p>这时就很有趣了，使用<code>idx_key1</code>可以进行<code>ref</code>方式的访问，使用<code>idx_key2</code>可以使用<code>range</code>方式的访问。这是优化器需要从全表扫描、使用<code>idx_key1</code>、使用<code>idx_key2</code>这几个方案里选出一个成本最低的方案。这里有个问题啊，因为<code>idx_key2</code>的范围区间是确定的：<code>(10, 1000)</code>，怎么计算使用<code>idx_key2</code>的成本我们上边已经说过了，可是在没有真正执行查询前，<code>s1.key1 = 常数</code>中的<code>常数</code>值我们是不知道的，怎么衡量使用<code>idx_key1</code>执行查询的成本呢？其实很简单，直接使用索引统计数据就好了（就是索引列平均一个值重复多少次）。一般情况下，<code>ref</code>的访问方式要比<code>range</code>成本更低，这里假设使用<code>idx_key1</code>进行对<code>s1</code>的访问。</p>
</li>
</ul>
<p>所以此时使用<code>s2</code>作为驱动表时的总成本就是：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用idx_key2访问s2的成本 <span class="operator">+</span> s2的扇出 × 使用idx_key1访问s1的成本</span><br></pre></td></tr></table></figure></li>
</ul>
<p>最后优化器会比较这两种方式的最优访问成本，选取那个成本更低的连接顺序去真正的执行查询。从上边的计算过程也可以看出来，连接查询成本占大头的其实是<code>驱动表扇出数 x 单次访问被驱动表的成本</code>，所以我们的优化重点其实是下边这两个部分：</p>
<ul>
<li><p>尽量减少驱动表的扇出</p>
</li>
<li><p>对被驱动表的访问成本尽量低</p>
<p>这一点对于我们实际书写连接查询语句时十分有用，我们需要尽量在被驱动表的连接列上建立索引，这样就可以使用<code>ref</code>访问方法来降低访问被驱动表的成本了。如果可以，被驱动表的连接列最好是该表的主键或者唯一二级索引列，这样就可以把访问被驱动表的成本降到更低了。</p>
</li>
</ul>
<h4 id="1-4-3多表连接的成本分析"><a href="#1-4-3多表连接的成本分析" class="headerlink" title="1.4.3多表连接的成本分析"></a>1.4.3多表连接的成本分析</h4><p>首先要考虑一下多表连接时可能产生出多少种连接顺序：</p>
<ul>
<li><p>对于两表连接，比如表A和表B连接</p>
<p>只有 AB、BA这两种连接顺序。其实相当于<code>2 × 1 = 2</code>种连接顺序。</p>
</li>
<li><p>对于三表连接，比如表A、表B、表C进行连接</p>
<p>有ABC、ACB、BAC、BCA、CAB、CBA这么6种连接顺序。其实相当于<code>3 × 2 × 1 = 6</code>种连接顺序。</p>
</li>
<li><p>对于四表连接的话，则会有<code>4 × 3 × 2 × 1 = 24</code>种连接顺序。</p>
</li>
<li><p>对于<code>n</code>表连接的话，则有 <code>n × (n-1) × (n-2) × ··· × 1</code>种连接顺序，就是n的阶乘种连接顺序，也就是<code>n!</code>。</p>
</li>
</ul>
<p>有<code>n</code>个表进行连接，<code>MySQL</code>查询优化器要每一种连接顺序的成本都计算一遍么？那可是<code>n!</code>种连接顺序呀。其实真的是要都算一遍，不过设计<code>MySQL</code>的大叔们想了很多办法减少计算非常多种连接顺序的成本的方法：</p>
<ul>
<li><p>提前结束某种顺序的成本评估</p>
<p><code>MySQL</code>在计算各种连接顺序的成本之前，会维护一个全局的变量，这个变量表示当前最小的连接查询成本。如果在分析某个连接顺序的成本时，该成本已经超过当前最小的连接查询成本，那就压根儿不对该连接顺序继续往下分析了。比方说A、B、C三个表进行连接，已经得到连接顺序<code>ABC</code>是当前的最小连接成本，比方说<code>10.0</code>，在计算连接顺序<code>BCA</code>时，发现<code>B</code>和<code>C</code>的连接成本就已经大于<code>10.0</code>时，就不再继续往后分析<code>BCA</code>这个连接顺序的成本了。</p>
</li>
<li><p>系统变量<code>optimizer_search_depth</code></p>
<p>为了防止无穷无尽的分析各种连接顺序的成本，设计<code>MySQL</code>的大叔们提出了<code>optimizer_search_depth</code>系统变量，如果连接表的个数小于该值，那么就继续穷举分析每一种连接顺序的成本，否则只对与<code>optimizer_search_depth</code>值相同数量的表进行穷举分析。很显然，该值越大，成本分析的越精确，越容易得到好的执行计划，但是消耗的时间也就越长，否则得到不是很好的执行计划，但可以省掉很多分析连接成本的时间。</p>
</li>
<li><p>根据某些规则压根儿就不考虑某些连接顺序</p>
<p>即使是有上边两条规则的限制，但是分析多个表不同连接顺序成本花费的时间还是会很长，所以设计<code>MySQL</code>的大叔干脆提出了一些所谓的<code>启发式规则</code>（就是根据以往经验指定的一些规则），凡是不满足这些规则的连接顺序压根儿就不分析，这样可以极大的减少需要分析的连接顺序的数量，但是也可能造成错失最优的执行计划。他们提供了一个系统变量<code>optimizer_prune_level</code>来控制到底是不是用这些启发式规则。</p>
</li>
</ul>
<h3 id="1-5调节成本常数"><a href="#1-5调节成本常数" class="headerlink" title="1.5调节成本常数"></a>1.5调节成本常数</h3><p>我们前边已经介绍了两个<code>成本常数</code>：</p>
<ul>
<li>读取一个页面花费的成本默认是<code>1.0</code></li>
<li>检测一条记录是否符合搜索条件的成本默认是<code>0.2</code></li>
</ul>
<p>其实除了这两个成本常数，<code>MySQL</code>还支持好多呢，它们被存储到了<code>mysql</code>数据库（这是一个系统数据库，我们之前介绍过）的两个表中：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SHOW</span> TABLES <span class="keyword">FROM</span> mysql <span class="keyword">LIKE</span> <span class="string">&#x27;%cost%&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------------+</span></span><br><span class="line"><span class="operator">|</span> Tables_in_mysql (<span class="operator">%</span>cost<span class="operator">%</span>) <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------------+</span></span><br><span class="line"><span class="operator">|</span> engine_cost              <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> server_cost              <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------------+</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

<p>我们在第一章中就说过，一条语句的执行其实是分为两层的：</p>
<ul>
<li><code>server</code>层</li>
<li>存储引擎层</li>
</ul>
<p>在<code>server</code>层进行连接管理、查询缓存、语法解析、查询优化等操作，在存储引擎层执行具体的数据存取操作。也就是说一条语句在<code>server</code>层中执行的成本是和它操作的表使用的存储引擎是没关系的，所以关于这些操作对应的<code>成本常数</code>就存储在了<code>server_cost</code>表中，而依赖于存储引擎的一些操作对应的<code>成本常数</code>就存储在了<code>engine_cost</code>表中。</p>
<h4 id="1-5-1mysql-server-cost表"><a href="#1-5-1mysql-server-cost表" class="headerlink" title="1.5.1mysql.server_cost表"></a>1.5.1mysql.server_cost表</h4><p><code>server_cost</code>表中在<code>server</code>层进行的一些操作对应的<code>成本常数</code>，具体内容如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> mysql.server_cost;</span><br><span class="line"><span class="operator">+</span><span class="comment">------------------------------+------------+---------------------+---------+</span></span><br><span class="line"><span class="operator">|</span> cost_name                    <span class="operator">|</span> cost_value <span class="operator">|</span> last_update         <span class="operator">|</span> comment <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------------------------+------------+---------------------+---------+</span></span><br><span class="line"><span class="operator">|</span> disk_temptable_create_cost   <span class="operator">|</span>       <span class="keyword">NULL</span> <span class="operator">|</span> <span class="number">2018</span><span class="number">-01</span><span class="number">-20</span> <span class="number">12</span>:<span class="number">03</span>:<span class="number">21</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> disk_temptable_row_cost      <span class="operator">|</span>       <span class="keyword">NULL</span> <span class="operator">|</span> <span class="number">2018</span><span class="number">-01</span><span class="number">-20</span> <span class="number">12</span>:<span class="number">03</span>:<span class="number">21</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> key_compare_cost             <span class="operator">|</span>       <span class="keyword">NULL</span> <span class="operator">|</span> <span class="number">2018</span><span class="number">-01</span><span class="number">-20</span> <span class="number">12</span>:<span class="number">03</span>:<span class="number">21</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> memory_temptable_create_cost <span class="operator">|</span>       <span class="keyword">NULL</span> <span class="operator">|</span> <span class="number">2018</span><span class="number">-01</span><span class="number">-20</span> <span class="number">12</span>:<span class="number">03</span>:<span class="number">21</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> memory_temptable_row_cost    <span class="operator">|</span>       <span class="keyword">NULL</span> <span class="operator">|</span> <span class="number">2018</span><span class="number">-01</span><span class="number">-20</span> <span class="number">12</span>:<span class="number">03</span>:<span class="number">21</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> row_evaluate_cost            <span class="operator">|</span>       <span class="keyword">NULL</span> <span class="operator">|</span> <span class="number">2018</span><span class="number">-01</span><span class="number">-20</span> <span class="number">12</span>:<span class="number">03</span>:<span class="number">21</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------------------------+------------+---------------------+---------+</span></span><br><span class="line"><span class="number">6</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.05</span> sec)</span><br></pre></td></tr></table></figure>

<p><img src="/../../AppData/Roaming/Typora/typora-user-images/image-20231219114959190.png" alt="image-20231219114959190"> </p>
<blockquote>
<p>MySQL在执行诸如DISTINCT查询、分组查询、Union查询以及某些特殊条件下的排序查询都可能在内部先创建一个临时表，使用这个临时表来辅助完成查询（比如对于DISTINCT查询可以建一个带有UNIQUE索引的临时表，直接把需要去重的记录插入到这个临时表中，插入完成之后的记录就是结果集了）。在数据量大的情况下可能创建基于磁盘的临时表，也就是为该临时表使用MyISAM、InnoDB等存储引擎，在数据量不大时可能创建基于内存的临时表，也就是使用Memory存储引擎。关于更多临时表的细节我们并不打算展开唠叨，因为展开可能又需要好几万字了，大家知道创建临时表和对这个临时表进行写入和读取的操作代价还是很高的就行了。</p>
</blockquote>
<p>这些成本常数在<code>server_cost</code>中的初始值都是<code>NULL</code>，意味着优化器会使用它们的默认值来计算某个操作的成本，如果我们想修改某个成本常数的值的话，需要做两个步骤：</p>
<ul>
<li><p>对我们感兴趣的成本常数做更新操作</p>
<p>比方说我们想把检测一条记录是否符合搜索条件的成本增大到<code>0.4</code>，那么就可以这样写更新语句：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> mysql.server_cost </span><br><span class="line">    <span class="keyword">SET</span> cost_value <span class="operator">=</span> <span class="number">0.4</span></span><br><span class="line">    <span class="keyword">WHERE</span> cost_name <span class="operator">=</span> <span class="string">&#x27;row_evaluate_cost&#x27;</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>让系统重新加载这个表的值。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FLUSH OPTIMIZER_COSTS;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>当然，在你修改完某个成本常数后想把它们再改回默认值的话，可以直接把<code>cost_value</code>的值设置为<code>NULL</code>，再使用<code>FLUSH OPTIMIZER_COSTS</code>语句让系统重新加载它就好了。</p>
<h4 id="1-5-2mysql-engine-cost表"><a href="#1-5-2mysql-engine-cost表" class="headerlink" title="1.5.2mysql.engine_cost表"></a>1.5.2mysql.engine_cost表</h4><p><code>engine_cost表</code>表中在存储引擎层进行的一些操作对应的<code>成本常数</code>，具体内容如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> mysql.engine_cost;</span><br><span class="line"><span class="operator">+</span><span class="comment">-------------+-------------+------------------------+------------+---------------------+---------+</span></span><br><span class="line"><span class="operator">|</span> engine_name <span class="operator">|</span> device_type <span class="operator">|</span> cost_name              <span class="operator">|</span> cost_value <span class="operator">|</span> last_update         <span class="operator">|</span> comment <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------+-------------+------------------------+------------+---------------------+---------+</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">default</span>     <span class="operator">|</span>           <span class="number">0</span> <span class="operator">|</span> io_block_read_cost     <span class="operator">|</span>       <span class="keyword">NULL</span> <span class="operator">|</span> <span class="number">2018</span><span class="number">-01</span><span class="number">-20</span> <span class="number">12</span>:<span class="number">03</span>:<span class="number">21</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">default</span>     <span class="operator">|</span>           <span class="number">0</span> <span class="operator">|</span> memory_block_read_cost <span class="operator">|</span>       <span class="keyword">NULL</span> <span class="operator">|</span> <span class="number">2018</span><span class="number">-01</span><span class="number">-20</span> <span class="number">12</span>:<span class="number">03</span>:<span class="number">21</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------+-------------+------------------------+------------+---------------------+---------+</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.05</span> sec)</span><br></pre></td></tr></table></figure>

<p>与<code>server_cost</code>相比，<code>engine_cost</code>多了两个列：</p>
<ul>
<li><p><code>engine_name</code>列</p>
<p>指成本常数适用的存储引擎名称。如果该值为<code>default</code>，意味着对应的成本常数适用于所有的存储引擎。</p>
</li>
<li><p><code>device_type</code>列</p>
<p>指存储引擎使用的设备类型，这主要是为了区分常规的机械硬盘和固态硬盘，不过在<code>MySQL 5.7.21</code>这个版本中并没有对机械硬盘的成本和固态硬盘的成本作区分，所以该值默认是<code>0</code>。</p>
</li>
</ul>
<p>我们从<code>engine_cost</code>表中的内容可以看出来，目前支持的存储引擎成本常数只有两个：</p>
<p><img src="/../../../../../../imgs/MySQL%E5%8E%9F%E7%90%86%E4%B9%8B%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E7%AF%87/image-20231219115949876.png" alt="image-20231219115949876"> </p>
<p>大家看完这两个成本常数的默认值是不是有些疑惑，怎么从内存中和从磁盘上读取一个块的默认成本是一样的，脑子瓦特了？这主要是因为在<code>MySQL</code>目前的实现中，并不能准确预测某个查询需要访问的块中有哪些块已经加载到内存中，有哪些块还停留在磁盘上，所以设计<code>MySQL</code>的大叔们很粗暴的认为不管这个块有没有加载到内存中，使用的成本都是<code>1.0</code>，不过随着<code>MySQL</code>的发展，等到可以准确预测哪些块在磁盘上，那些块在内存中的那一天，这两个成本常数的默认值可能会改一改吧。</p>
<blockquote>
<p>在MySQL8中，io_block_read_cost的值和memory_block_read_cost的值已经不同了。</p>
</blockquote>
<p><img src="/../../../../../../imgs/MySQL%E5%8E%9F%E7%90%86%E4%B9%8B%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E7%AF%87/image-20231219115832194.png" alt="image-20231219115832194"></p>
<p>与更新<code>server_cost</code>表中的记录一样，我们也可以通过更新<code>engine_cost</code>表中的记录来更改关于存储引擎的成本常数，我们也可以通过为<code>engine_cost</code>表插入新记录的方式来添加只针对某种存储引擎的成本常数：</p>
<ul>
<li><p>插入针对某个存储引擎的成本常数</p>
<p>比如我们想增大<code>InnoDB</code>存储引擎页面<code>I/O</code>的成本，书写正常的插入语句即可：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> mysql.engine_cost</span><br><span class="line">    <span class="keyword">VALUES</span> (<span class="string">&#x27;InnoDB&#x27;</span>, <span class="number">0</span>, <span class="string">&#x27;io_block_read_cost&#x27;</span>, <span class="number">2.0</span>,</span><br><span class="line">    <span class="built_in">CURRENT_TIMESTAMP</span>, <span class="string">&#x27;increase Innodb I/O cost&#x27;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>让系统重新加载这个表的值。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FLUSH OPTIMIZER_COSTS;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="二、InnoDB的统计数据收集策略"><a href="#二、InnoDB的统计数据收集策略" class="headerlink" title="二、InnoDB的统计数据收集策略"></a>二、InnoDB的统计数据收集策略</h2><p>我们前边唠叨查询成本的时候经常用到一些统计数据，比如通过<code>SHOW TABLE STATUS</code>可以看到关于表的统计数据，通过<code>SHOW INDEX</code>可以看到关于索引的统计数据，那么这些统计数据是怎么来的呢？它们是以什么方式收集的呢？本章将聚焦于<code>InnoDB</code>存储引擎的统计数据收集策略，看完本章大家就会明白为啥前边老说<code>InnoDB</code>的统计信息是不精确的估计值了。</p>
<h3 id="2-1两种不同的统计数据存储方式"><a href="#2-1两种不同的统计数据存储方式" class="headerlink" title="2.1两种不同的统计数据存储方式"></a>2.1两种不同的统计数据存储方式</h3><p><code>InnoDB</code>提供了两种存储统计数据的方式：</p>
<ul>
<li><p>永久性的统计数据</p>
<p>这种统计数据存储在磁盘上，也就是服务器重启之后这些统计数据还在。</p>
</li>
<li><p>非永久性的统计数据</p>
<p>这种统计数据存储在内存中，当服务器关闭时这些这些统计数据就都被清除掉了，等到服务器重启之后，在某些适当的场景下才会重新收集这些统计数据。</p>
</li>
</ul>
<p>设计<code>MySQL</code>的大叔们给我们提供了系统变量<code>innodb_stats_persistent</code>来控制到底采用哪种方式去存储统计数据。在<code>MySQL 5.6.6</code>之前，<code>innodb_stats_persistent</code>的值默认是<code>OFF</code>，也就是说<code>InnoDB</code>的统计数据默认是存储到内存的，之后的版本中<code>innodb_stats_persistent</code>的值默认是<code>ON</code>，也就是统计数据默认被存储到磁盘中。</p>
<p>不过<code>InnoDB</code>默认是以表为单位来收集和存储统计数据的，也就是说我们可以把某些表的统计数据（以及该表的索引统计数据）存储在磁盘上，把另一些表的统计数据存储在内存中。怎么做到的呢？我们可以在创建和修改表的时候通过指定<code>STATS_PERSISTENT</code>属性来指明该表的统计数据存储方式：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 表名 (...) Engine<span class="operator">=</span>InnoDB, STATS_PERSISTENT <span class="operator">=</span> (<span class="number">1</span><span class="operator">|</span><span class="number">0</span>);</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 Engine<span class="operator">=</span>InnoDB, STATS_PERSISTENT <span class="operator">=</span> (<span class="number">1</span><span class="operator">|</span><span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>当<code>STATS_PERSISTENT=1</code>时，表明我们想把该表的统计数据永久的存储到磁盘上，当<code>STATS_PERSISTENT=0</code>时，表明我们想把该表的统计数据临时的存储到内存中。如果我们在创建表时未指定<code>STATS_PERSISTENT</code>属性，那默认采用系统变量<code>innodb_stats_persistent</code>的值作为该属性的值。</p>
<h3 id="2-2基于磁盘的永久性统计数据"><a href="#2-2基于磁盘的永久性统计数据" class="headerlink" title="2.2基于磁盘的永久性统计数据"></a>2.2基于磁盘的永久性统计数据</h3><p>当我们选择把某个表以及该表索引的统计数据存放到磁盘上时，实际上是把这些统计数据存储到了两个表里：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SHOW</span> TABLES <span class="keyword">FROM</span> mysql <span class="keyword">LIKE</span> <span class="string">&#x27;innodb%&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------------+</span></span><br><span class="line"><span class="operator">|</span> Tables_in_mysql (innodb<span class="operator">%</span>) <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------------+</span></span><br><span class="line"><span class="operator">|</span> innodb_index_stats        <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> innodb_table_stats        <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------------+</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure>

<p>可以看到，这两个表都位于<code>mysql</code>系统数据库下边，其中：</p>
<ul>
<li><code>innodb_table_stats</code>存储了关于表的统计数据，每一条记录对应着一个表的统计数据。</li>
<li><code>innodb_index_stats</code>存储了关于索引的统计数据，每一条记录对应着一个索引的一个统计项的统计数据。</li>
</ul>
<p>我们下边的任务就是看一下这两个表里边都有什么以及表里的数据是如何生成的。</p>
<h4 id="2-2-1innodb-table-stats"><a href="#2-2-1innodb-table-stats" class="headerlink" title="2.2.1innodb_table_stats"></a>2.2.1innodb_table_stats</h4><p>直接看一下这个<code>innodb_table_stats</code>表中的各个列都是干嘛的：</p>
<p><img src="/../../../../../../imgs/MySQL%E5%8E%9F%E7%90%86%E4%B9%8B%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E7%AF%87/image-20231219131607845.png" alt="image-20231219131607845"> </p>
<p>注意这个表的主键是<code>(database_name,table_name)</code>，也就是innodb_table_stats表的每条记录代表着一个表的统计信息。我们直接看一下这个表里的内容：</p>
<p><img src="/../../../../../../imgs/MySQL%E5%8E%9F%E7%90%86%E4%B9%8B%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E7%AF%87/image-20231219131837979.png" alt="image-20231219131837979"></p>
<p>可以看到我们熟悉的<code>single_table</code>表的统计信息就对应着<code>mysql.innodb_table_stats</code>的第三条记录。几个重要统计信息项的值如下：</p>
<ul>
<li><code>n_rows</code>的值是<code>9693</code>，表明<code>single_table</code>表中大约有<code>9693</code>条记录，注意这个数据是估计值。</li>
<li><code>clustered_index_size</code>的值是<code>97</code>，表明<code>single_table</code>表的聚簇索引占用97个页面，这个值是也是一个估计值。</li>
<li><code>sum_of_other_index_sizes</code>的值是<code>175</code>，表明<code>single_table</code>表的其他索引一共占用175个页面，这个值是也是一个估计值。</li>
</ul>
<h5 id="n-rows统计项的收集"><a href="#n-rows统计项的收集" class="headerlink" title="n_rows统计项的收集"></a>n_rows统计项的收集</h5><p>为啥老强调<code>n_rows</code>这个统计项的值是估计值呢？现在就来揭晓答案。<code>InnoDB</code>统计一个表中有多少行记录的套路是这样的：</p>
<ul>
<li><p>按照一定算法（并不是纯粹随机的）选取几个叶子节点页面，计算每个页面中主键值记录数量，然后计算平均一个页面中主键值的记录数量乘以全部叶子节点的数量就算是该表的<code>n_rows</code>值。</p>
<p>可以看出来这个<code>n_rows</code>值精确与否取决于统计时采样的页面数量，设计<code>MySQL</code>的大叔很贴心的为我们准备了一个名为<code>innodb_stats_persistent_sample_pages</code>的系统变量来控制使用永久性的统计数据时，计算统计数据时采样的页面数量。该值设置的越大，统计出的<code>n_rows</code>值越精确，但是统计耗时也就最久；该值设置的越小，统计出的<code>n_rows</code>值越不精确，但是统计耗时特别少。所以在实际使用是需要我们去权衡利弊，该系统变量的默认值是<code>20</code>。</p>
<p><img src="/../../../../../../imgs/MySQL%E5%8E%9F%E7%90%86%E4%B9%8B%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E7%AF%87/image-20231219132042472.png" alt="image-20231219132042472"> </p>
<p>我们前边说过，不过<code>InnoDB</code>默认是以表为单位来收集和存储统计数据的，我们也可以单独设置某个表的采样页面的数量，设置方式就是在创建或修改表的时候通过指定<code>STATS_SAMPLE_PAGES</code>属性来指明该表的统计数据存储方式：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 表名 (...) Engine<span class="operator">=</span>InnoDB, STATS_SAMPLE_PAGES <span class="operator">=</span> 具体的采样页面数量;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 Engine<span class="operator">=</span>InnoDB, STATS_SAMPLE_PAGES <span class="operator">=</span> 具体的采样页面数量;</span><br></pre></td></tr></table></figure>

<p>如果我们在创建表的语句中并没有指定<code>STATS_SAMPLE_PAGES</code>属性的话，将默认使用系统变量<code>innodb_stats_persistent_sample_pages</code>的值作为该属性的值。</p>
</li>
</ul>
<h5 id="clustered-index-size统计项的收集-x2F-sum-of-other-index-sizes统计项的收集"><a href="#clustered-index-size统计项的收集-x2F-sum-of-other-index-sizes统计项的收集" class="headerlink" title="clustered_index_size统计项的收集&#x2F;sum_of_other_index_sizes统计项的收集"></a>clustered_index_size统计项的收集&#x2F;sum_of_other_index_sizes统计项的收集</h5><p>这两个统计项的收集过程如下：</p>
<ul>
<li><p>从数据字典里找到表的各个索引对应的根页面位置。</p>
<p>系统表<code>SYS_INDEXES</code>里存储了各个索引对应的根页面信息。</p>
</li>
<li><p>从根页面的<code>Page Header</code>里找到叶子节点段和非叶子节点段对应的<code>Segment Header</code>。</p>
<p>在每个索引的根页面的<code>Page Header</code>部分都有两个字段：</p>
<ul>
<li><code>PAGE_BTR_SEG_LEAF</code>：表示B+树叶子段的<code>Segment Header</code>信息。</li>
<li><code>PAGE_BTR_SEG_TOP</code>：表示B+树非叶子段的<code>Segment Header</code>信息。</li>
</ul>
</li>
<li><p>从叶子节点段和非叶子节点段的<code>Segment Header</code>中找到这两个段对应的<code>INODE Entry</code>结构。</p>
<p>这个是<code>Segment Header</code>结构：</p>
<p><img src="/../../../../../../imgs/MySQL%E5%8E%9F%E7%90%86%E4%B9%8B%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E7%AF%87/167e94d5b165a91ftplv-t2oaga2asx-jj-mark1890000q75.webp" alt="image_1cum7dbc812843ac192pfik1raep.png-107.3kB"> </p>
</li>
<li><p>从对应的<code>INODE Entry</code>结构中可以找到该段对应所有零散的页面地址以及<code>FREE</code>、<code>NOT_FULL</code>、<code>FULL</code>链表的基节点。</p>
<p>这个是<code>INODE Entry</code>结构：</p>
<p><img src="/../../../../../../imgs/MySQL%E5%8E%9F%E7%90%86%E4%B9%8B%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E7%AF%87/167e94d5b1e44524tplv-t2oaga2asx-jj-mark1890000q75.webp" alt="image_1cum7f49h1beg5uccbq197n1g1b16.png-173.9kB"> </p>
</li>
<li><p>直接统计零散的页面有多少个，然后从那三个链表的<code>List Length</code>字段中读出该段占用的区的大小，每个区占用<code>64</code>个页，所以就可以统计出整个段占用的页面。</p>
<p>这个是链表基节点的示意图：</p>
<p><img src="/../../../../../../imgs/MySQL%E5%8E%9F%E7%90%86%E4%B9%8B%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E7%AF%87/167e94d5b17c24e3tplv-t2oaga2asx-jj-mark1890000q75.webp" alt="image_1cum7hkiihikm4b88j10461plc1j.png-129.9kB"> </p>
</li>
<li><p>分别计算聚簇索引的叶子结点段和非叶子节点段占用的页面数，它们的和就是<code>clustered_index_size</code>的值，按照同样的套路把其余索引占用的页面数都算出来，加起来之后就是<code>sum_of_other_index_sizes</code>的值。</p>
</li>
</ul>
<p>这里需要大家注意一个问题，我们说一个段的数据在非常多时（超过32个页面），会以<code>区</code>为单位来申请空间，这里头的问题是以区为单位申请空间中有一些页可能并没有使用，但是在统计<code>clustered_index_size</code>和<code>sum_of_other_index_sizes</code>时都把它们算进去了，所以说聚簇索引和其他的索引占用的页面数可能比这两个值要小一些。</p>
<h4 id="2-2-2innodb-index-stats"><a href="#2-2-2innodb-index-stats" class="headerlink" title="2.2.2innodb_index_stats"></a>2.2.2innodb_index_stats</h4><p>直接看一下这个<code>innodb_index_stats</code>表中的各个列都是干嘛的：</p>
<img src="/../../../../../../imgs/MySQL原理之查询优化篇/image-20231219132732638.png" alt="image-20231219132732638" style="zoom:80%;" /> 

<p>注意这个表的主键是<code>(database_name,table_name,index_name,stat_name)</code>，其中的<code>stat_name</code>是指统计项的名称，也就是说innodb_index_stats表的每条记录代表着一个索引的一个统计项。可能这会大家有些懵逼这个统计项到底指什么，别着急，我们直接看一下关于<code>single_table</code>表的索引统计数据都有些什么：</p>
<p><img src="/../../../../../../imgs/MySQL%E5%8E%9F%E7%90%86%E4%B9%8B%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E7%AF%87/image-20231219132854607.png" alt="image-20231219132854607"> </p>
<p>这个结果有点儿多，正确查看这个结果的方式是这样的：</p>
<ul>
<li><p>先查看<code>index_name</code>列，这个列说明该记录是哪个索引的统计信息，从结果中我们可以看出来，<code>PRIMARY</code>索引（也就是主键）占了3条记录，<code>idx_key_part</code>索引占了6条记录。</p>
</li>
<li><p>针对<code>index_name</code>列相同的记录，<code>stat_name</code>表示针对该索引的统计项名称，<code>stat_value</code>展示的是该索引在该统计项上的值，<code>stat_description</code>指的是来描述该统计项的含义的。我们来具体看一下一个索引都有哪些统计项：</p>
<ul>
<li><p><code>n_leaf_pages</code>：表示该索引的叶子节点占用多少页面。</p>
</li>
<li><p><code>size</code>：表示该索引共占用多少页面。</p>
</li>
<li><p><code>n_diff_pfxNN</code>：表示对应的索引列不重复的值有多少。其中的<code>NN</code>长得有点儿怪呀，啥意思呢？</p>
<p>其实<code>NN</code>可以被替换为<code>01</code>、<code>02</code>、<code>03</code>… 这样的数字。比如对于<code>idx_key_part</code>来说：</p>
<ul>
<li><code>n_diff_pfx01</code>表示的是统计<code>key_part1</code>这单单一个列不重复的值有多少。</li>
<li><code>n_diff_pfx02</code>表示的是统计<code>key_part1、key_part2</code>这两个列组合起来不重复的值有多少。</li>
<li><code>n_diff_pfx03</code>表示的是统计<code>key_part1、key_part2、key_part3</code>这三个列组合起来不重复的值有多少。</li>
<li><code>n_diff_pfx04</code>表示的是统计<code>key_part1、key_part2、key_part3、id</code>这四个列组合起来不重复的值有多少。</li>
</ul>
<blockquote>
<p>这里需要注意的是，对于普通的二级索引，并不能保证它的索引列值是唯一的，比如对于idx_key1来说，key1列就可能有很多值重复的记录。此时只有在索引列上加上主键值才可以区分两条索引列值都一样的二级索引记录。对于主键和唯一二级索引则没有这个问题，它们本身就可以保证索引列值的不重复，所以也不需要再统计一遍在索引列后加上主键值的不重复值有多少。比如上边的idx_key1有n_diff_pfx01、n_diff_pfx02两个统计项，而idx_key2却只有n_diff_pfx01一个统计项。</p>
</blockquote>
</li>
</ul>
</li>
<li><p>在计算某些索引列中包含多少不重复值时，需要对一些叶子节点页面进行采样，<code>sample_size</code>列就表明了采样的页面数量是多少。</p>
<blockquote>
<p>对于有多个列的联合索引来说，采样的页面数量是：innodb_stats_persistent_sample_pages × 索引列的个数。当需要采样的页面数量大于该索引的叶子节点数量的话，就直接采用全表扫描来统计索引列的不重复值数量了。所以大家可以在查询结果中看到不同索引对应的size列的值可能是不同的。</p>
</blockquote>
<ul>
<li><p>本案例中主键id列采样的页面数量是20*1&#x3D;20&lt;聚簇索引的叶子节点数量91，因此sample_size&#x3D;20，选取20个叶子节点采样页面</p>
</li>
<li><p>本案例中key1列（普通二级索引）采样的页面数量是20*2&#x3D;40&gt;二级索引的叶子节点数量28，因此sample_size&#x3D;28，直接采用全表扫描</p>
</li>
<li><p>本案例中key2列（唯一二级索引）采样的页面数量是20*1&#x3D;20&gt;二级索引的叶子节点数量16，因此sample_size&#x3D;16，直接采用全表扫描</p>
</li>
<li><p>本案例中key3列（普通二级索引）采样的页面数量是20*2&#x3D;40&gt;二级索引的叶子节点数量31，因此sample_size&#x3D;31，直接采用全表扫描</p>
</li>
<li><p>本案例中key_part1、key_part2、keypart3列（联合索引）采样的页面数量是20*4&#x3D;80&gt;二级索引的叶子节点数量64，因此sample_size&#x3D;64，直接采用全表扫描</p>
</li>
</ul>
</li>
</ul>
<h4 id="2-2-3定期更新统计数据"><a href="#2-2-3定期更新统计数据" class="headerlink" title="2.2.3定期更新统计数据"></a>2.2.3定期更新统计数据</h4><p>随着我们不断的对表进行增删改操作，表中的数据也一直在变化，<code>innodb_table_stats</code>和<code>innodb_index_stats</code>表里的统计数据是不是也应该跟着变一变了？当然要变了，不变的话<code>MySQL</code>查询优化器计算的成本可就差老鼻子远了。设计<code>MySQL</code>的大叔提供了如下两种更新统计数据的方式：</p>
<ul>
<li><p>开启<code>innodb_stats_auto_recalc</code>。</p>
<p>系统变量<code>innodb_stats_auto_recalc</code>决定着服务器是否自动重新计算统计数据，它的默认值是<code>ON</code>，也就是该功能默认是开启的。每个表都维护了一个变量，该变量记录着对该表进行增删改的记录条数，如果发生变动的记录数量超过了表大小的<code>10%</code>，并且自动重新计算统计数据的功能是打开的，那么服务器会重新进行一次统计数据的计算，并且更新<code>innodb_table_stats</code>和<code>innodb_index_stats</code>表。不过自动重新计算统计数据的过程是异步发生的，也就是即使表中变动的记录数超过了<code>10%</code>，自动重新计算统计数据也不会立即发生，可能会延迟几秒才会进行计算。</p>
<p>再一次强调，<code>InnoDB</code>默认是以表为单位来收集和存储统计数据的，我们也可以单独为某个表设置是否自动重新计算统计数的属性，设置方式就是在创建或修改表的时候通过指定<code>STATS_AUTO_RECALC</code>属性来指明该表的统计数据存储方式：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 表名 (...) Engine<span class="operator">=</span>InnoDB, STATS_AUTO_RECALC <span class="operator">=</span> (<span class="number">1</span><span class="operator">|</span><span class="number">0</span>);</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 Engine<span class="operator">=</span>InnoDB, STATS_AUTO_RECALC <span class="operator">=</span> (<span class="number">1</span><span class="operator">|</span><span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>当<code>STATS_AUTO_RECALC=1</code>时，表明我们想让该表自动重新计算统计数据，当<code>STATS_AUTO_RECALC=0</code>时，表明不想让该表自动重新计算统计数据。如果我们在创建表时未指定<code>STATS_AUTO_RECALC</code>属性，那默认采用系统变量<code>innodb_stats_auto_recalc</code>的值作为该属性的值。</p>
</li>
<li><p>手动调用<code>ANALYZE TABLE</code>语句来更新统计信息</p>
<p>如果<code>innodb_stats_auto_recalc</code>系统变量的值为<code>OFF</code>的话，我们也可以手动调用<code>ANALYZE TABLE</code>语句来重新计算统计数据，比如我们可以这样更新关于<code>single_table</code>表的统计数据：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> ANALYZE <span class="keyword">TABLE</span> single_table;</span><br><span class="line"><span class="operator">+</span><span class="comment">------------------------+---------+----------+----------+</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">Table</span>                  <span class="operator">|</span> Op      <span class="operator">|</span> Msg_type <span class="operator">|</span> Msg_text <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------------------+---------+----------+----------+</span></span><br><span class="line"><span class="operator">|</span> xiaohaizi.single_table <span class="operator">|</span> analyze <span class="operator">|</span> status   <span class="operator">|</span> OK       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------------------+---------+----------+----------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.08</span> sec)</span><br></pre></td></tr></table></figure>

<p>需要注意的是，ANALYZE TABLE语句会立即重新计算统计数据，也就是这个过程是同步的，在表中索引多或者采样页面特别多时这个过程可能会特别慢，请不要没事儿就运行一下<code>ANALYZE TABLE</code>语句，最好在业务不是很繁忙的时候再运行。</p>
</li>
</ul>
<h4 id="2-2-4手动更新innodb-table-stats和innodb-index-stats表"><a href="#2-2-4手动更新innodb-table-stats和innodb-index-stats表" class="headerlink" title="2.2.4手动更新innodb_table_stats和innodb_index_stats表"></a>2.2.4手动更新innodb_table_stats和innodb_index_stats表</h4><p>其实<code>innodb_table_stats</code>和<code>innodb_index_stats</code>表就相当于一个普通的表一样，我们能对它们做增删改查操作。这也就意味着我们可以手动更新某个表或者索引的统计数据。比如说我们想把<code>single_table</code>表关于行数的统计数据更改一下可以这么做：</p>
<ul>
<li><p>步骤一：更新<code>innodb_table_stats</code>表。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> innodb_table_stats </span><br><span class="line">    <span class="keyword">SET</span> n_rows <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">WHERE</span> table_name <span class="operator">=</span> <span class="string">&#x27;single_table&#x27;</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>步骤二：让<code>MySQL</code>查询优化器重新加载我们更改过的数据。</p>
<p>更新完<code>innodb_table_stats</code>只是单纯的修改了一个表的数据，需要让<code>MySQL</code>查询优化器重新加载我们更改过的数据，运行下边的命令就可以了：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FLUSH <span class="keyword">TABLE</span> single_table;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>之后我们使用<code>SHOW TABLE STATUS</code>语句查看表的统计数据时就看到<code>Rows</code>行变为了<code>1</code>。</p>
<h3 id="2-3基于内存的非永久性统计数据"><a href="#2-3基于内存的非永久性统计数据" class="headerlink" title="2.3基于内存的非永久性统计数据"></a>2.3基于内存的非永久性统计数据</h3><p>当我们把系统变量<code>innodb_stats_persistent</code>的值设置为<code>OFF</code>时，之后创建的表的统计数据默认就都是非永久性的了，或者我们直接在创建表或修改表时设置<code>STATS_PERSISTENT</code>属性的值为<code>0</code>，那么该表的统计数据就是非永久性的了。</p>
<p>与永久性的统计数据不同，非永久性的统计数据采样的页面数量是由<code>innodb_stats_transient_sample_pages</code>控制的，这个系统变量的默认值是<code>8</code>。</p>
<p>另外，由于非永久性的统计数据经常更新，所以导致<code>MySQL</code>查询优化器计算查询成本的时候依赖的是经常变化的统计数据，也就会生成经常变化的执行计划，这个可能让大家有些懵逼。不过最近的<code>MySQL</code>版本都不咋用这种基于内存的非永久性统计数据了，所以我们也就不深入唠叨它了。</p>
<h3 id="2-4innodb-stats-method的使用"><a href="#2-4innodb-stats-method的使用" class="headerlink" title="2.4innodb_stats_method的使用"></a>2.4innodb_stats_method的使用</h3><p>我们知道<code>索引列不重复的值的数量</code>这个统计数据对于<code>MySQL</code>查询优化器十分重要，因为通过它可以计算出在索引列中平均一个值重复多少行，它的应用场景主要有两个：</p>
<ul>
<li><p>单表查询中单点区间太多，比方说这样：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> tbl_name <span class="keyword">WHERE</span> key <span class="keyword">IN</span> (<span class="string">&#x27;xx1&#x27;</span>, <span class="string">&#x27;xx2&#x27;</span>, ..., <span class="string">&#x27;xxn&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>当<code>IN</code>里的参数数量过多时，采用<code>index dive</code>的方式直接访问<code>B+</code>树索引去统计每个单点区间对应的记录的数量就太耗费性能了，所以直接依赖统计数据中的平均一个值重复多少行来计算单点区间对应的记录数量。</p>
</li>
<li><p>连接查询时，如果有涉及两个表的等值匹配连接条件，该连接条件对应的被驱动表中的列又拥有索引时，则可以使用<code>ref</code>访问方法来对被驱动表进行查询，比方说这样：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t1 <span class="keyword">JOIN</span> t2 <span class="keyword">ON</span> t1.column <span class="operator">=</span> t2.key <span class="keyword">WHERE</span> ...;</span><br></pre></td></tr></table></figure>

<p>在真正执行对<code>t2</code>表的查询前，<code>t1.comumn</code>的值是不确定的，所以我们也不能通过<code>index dive</code>的方式直接访问<code>B+</code>树索引去统计每个单点区间对应的记录的数量，所以也只能依赖统计数据中的平均一个值重复多少行来计算单点区间对应的记录数量。</p>
</li>
</ul>
<p>在统计索引列不重复的值的数量时，有一个比较烦的问题就是索引列中出现<code>NULL</code>值怎么办，比方说某个索引列的内容是这样：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">+</span><span class="comment">------+</span></span><br><span class="line"><span class="operator">|</span> col  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">2</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+</span></span><br></pre></td></tr></table></figure>

<p>此时计算这个<code>col</code>列中不重复的值的数量就有下边的分歧：</p>
<ul>
<li><p>有的人认为<code>NULL</code>值代表一个未确定的值，所以设计<code>MySQL</code>的大叔才认为任何和<code>NULL</code>值做比较的表达式的值都为<code>NULL</code>，就是这样：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="number">1</span> <span class="operator">=</span> <span class="keyword">NULL</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">1</span> <span class="operator">=</span> <span class="keyword">NULL</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------+</span></span><br><span class="line"><span class="operator">|</span>     <span class="keyword">NULL</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="number">1</span> <span class="operator">!=</span> <span class="keyword">NULL</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">-----------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">1</span> <span class="operator">!=</span> <span class="keyword">NULL</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------+</span></span><br><span class="line"><span class="operator">|</span>      <span class="keyword">NULL</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="keyword">NULL</span> <span class="operator">=</span> <span class="keyword">NULL</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">-------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">=</span> <span class="keyword">NULL</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------+</span></span><br><span class="line"><span class="operator">|</span>        <span class="keyword">NULL</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="keyword">NULL</span> <span class="operator">!=</span> <span class="keyword">NULL</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">--------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">!=</span> <span class="keyword">NULL</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------+</span></span><br><span class="line"><span class="operator">|</span>         <span class="keyword">NULL</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

<p>所以每一个<code>NULL</code>值都是独一无二的，也就是说统计索引列不重复的值的数量时，应该把<code>NULL</code>值当作一个独立的值，所以<code>col</code>列的不重复的值的数量就是：<code>4</code>（分别是1、2、NULL、NULL这四个值）。</p>
</li>
<li><p>有的人认为其实<code>NULL</code>值在业务上就是代表没有，所有的<code>NULL</code>值代表的意义是一样的，所以<code>col</code>列不重复的值的数量就是：<code>3</code>（分别是1、2、NULL这三个值）。</p>
</li>
<li><p>有的人认为这<code>NULL</code>完全没有意义嘛，所以在统计索引列不重复的值的数量时压根儿不能把它们算进来，所以<code>col</code>列不重复的值的数量就是：<code>2</code>（分别是1、2这两个值）。</p>
</li>
</ul>
<p>设计<code>MySQL</code>的大叔蛮贴心的，他们提供了一个名为<code>innodb_stats_method</code>的系统变量，相当于在计算某个索引列不重复值的数量时如何对待<code>NULL</code>值这个锅甩给了用户，这个系统变量有三个候选值：</p>
<ul>
<li><p><code>nulls_equal</code>：认为所有<code>NULL</code>值都是相等的。这个值也是<code>innodb_stats_method</code>的默认值。</p>
<p>如果某个索引列中<code>NULL</code>值特别多的话，这种统计方式会让优化器认为某个列中平均一个值重复次数特别多，所以倾向于不使用索引进行访问。</p>
</li>
<li><p><code>nulls_unequal</code>：认为所有<code>NULL</code>值都是不相等的。</p>
<p>如果某个索引列中<code>NULL</code>值特别多的话，这种统计方式会让优化器认为某个列中平均一个值重复次数特别少，所以倾向于使用索引进行访问。</p>
</li>
<li><p><code>nulls_ignored</code>：直接把<code>NULL</code>值忽略掉。</p>
</li>
</ul>
<p>反正这个锅是甩给用户了，当你选定了<code>innodb_stats_method</code>值之后，优化器即使选择了不是最优的执行计划，那也跟设计<code>MySQL</code>的大叔们没关系了哈～ 当然对于用户的我们来说，最好不在索引列中存放NULL值才是正解。</p>
<h2 id="三、MySQL基于规则的优化"><a href="#三、MySQL基于规则的优化" class="headerlink" title="三、MySQL基于规则的优化"></a>三、MySQL基于规则的优化</h2><p>家别忘了<code>MySQL</code>本质上是一个软件，设计<code>MySQL</code>的大叔并不能要求使用这个软件的人个个都是数据库高高手，就像我写这本书的时候并不能要求各位在学之前就会了里边儿的知识。</p>
<p>也就是说我们无法避免某些同学写一些执行起来十分耗费性能的语句。即使是这样，设计<code>MySQL</code>的大叔还是依据一些规则，竭尽全力的把这个很糟糕的语句转换成某种可以比较高效执行的形式，这个过程也可以被称作<code>查询重写</code>（就是人家觉得你写的语句不好，自己再重写一遍）。下面详细唠叨一下一些比较重要的重写规则。</p>
<h3 id="3-1条件化简"><a href="#3-1条件化简" class="headerlink" title="3.1条件化简"></a>3.1条件化简</h3><p>我们编写的查询语句的搜索条件本质上是一个表达式，这些表达式可能比较繁杂，或者不能高效的执行，<code>MySQL</code>的查询优化器会为我们简化这些表达式。为了方便大家理解，我们后边举例子的时候都使用诸如<code>a</code>、<code>b</code>、<code>c</code>之类的简单字母代表某个表的列名。</p>
<h4 id="3-1-1移除不必要的括号"><a href="#3-1-1移除不必要的括号" class="headerlink" title="3.1.1移除不必要的括号"></a>3.1.1移除不必要的括号</h4><p>有时候表达式里有许多无用的括号，比如这样：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">((a <span class="operator">=</span> <span class="number">5</span> <span class="keyword">AND</span> b <span class="operator">=</span> c) <span class="keyword">OR</span> ((a <span class="operator">&gt;</span> c) <span class="keyword">AND</span> (c <span class="operator">&lt;</span> <span class="number">5</span>)))</span><br></pre></td></tr></table></figure>

<p>看着就很烦，优化器会把那些用不到的括号给干掉，就是这样：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(a <span class="operator">=</span> <span class="number">5</span> <span class="keyword">and</span> b <span class="operator">=</span> c) <span class="keyword">OR</span> (a <span class="operator">&gt;</span> c <span class="keyword">AND</span> c <span class="operator">&lt;</span> <span class="number">5</span>)</span><br></pre></td></tr></table></figure>

<h4 id="3-1-2常量传递constant-propagation"><a href="#3-1-2常量传递constant-propagation" class="headerlink" title="3.1.2常量传递constant_propagation"></a>3.1.2常量传递constant_propagation</h4><p>有时候某个表达式是某个列和某个常量做等值匹配，比如这样：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a <span class="operator">=</span> <span class="number">5</span></span><br></pre></td></tr></table></figure>

<p>当这个表达式和其他涉及列<code>a</code>的表达式使用<code>AND</code>连接起来时，可以将其他表达式中的<code>a</code>的值替换为<code>5</code>，比如这样：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a <span class="operator">=</span> <span class="number">5</span> <span class="keyword">AND</span> b <span class="operator">&gt;</span> a</span><br></pre></td></tr></table></figure>

<p>就可以被转换为：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a <span class="operator">=</span> <span class="number">5</span> <span class="keyword">AND</span> b <span class="operator">&gt;</span> <span class="number">5</span></span><br></pre></td></tr></table></figure>

<h4 id="3-1-3等值传递equality-propagation"><a href="#3-1-3等值传递equality-propagation" class="headerlink" title="3.1.3等值传递equality_propagation"></a>3.1.3等值传递equality_propagation</h4><p>有时候多个列之间存在等值匹配的关系，比如这样：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a <span class="operator">=</span> b <span class="keyword">and</span> b <span class="operator">=</span> c <span class="keyword">and</span> c <span class="operator">=</span> <span class="number">5</span></span><br></pre></td></tr></table></figure>

<p>这个表达式可以被简化为：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a <span class="operator">=</span> <span class="number">5</span> <span class="keyword">and</span> b <span class="operator">=</span> <span class="number">5</span> <span class="keyword">and</span> c <span class="operator">=</span> <span class="number">5</span></span><br></pre></td></tr></table></figure>

<h4 id="3-1-4移除没用的条件trivial-condition-removal"><a href="#3-1-4移除没用的条件trivial-condition-removal" class="headerlink" title="3.1.4移除没用的条件trivial_condition_removal"></a>3.1.4移除没用的条件trivial_condition_removal</h4><p>对于一些明显永远为<code>TRUE</code>或者<code>FALSE</code>的表达式，优化器会移除掉它们，比如这个表达式：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(a <span class="operator">&lt;</span> <span class="number">1</span> <span class="keyword">and</span> b <span class="operator">=</span> b) <span class="keyword">OR</span> (a <span class="operator">=</span> <span class="number">6</span> <span class="keyword">OR</span> <span class="number">5</span> <span class="operator">!=</span> <span class="number">5</span>)</span><br></pre></td></tr></table></figure>

<p>很明显，<code>b = b</code>这个表达式永远为<code>TRUE</code>，<code>5 != 5</code>这个表达式永远为<code>FALSE</code>，所以简化后的表达式就是这样的：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(a <span class="operator">&lt;</span> <span class="number">1</span> <span class="keyword">and</span> <span class="literal">TRUE</span>) <span class="keyword">OR</span> (a <span class="operator">=</span> <span class="number">6</span> <span class="keyword">OR</span> <span class="literal">FALSE</span>)</span><br></pre></td></tr></table></figure>

<p>可以继续被简化为</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a <span class="operator">&lt;</span> <span class="number">1</span> <span class="keyword">OR</span> a <span class="operator">=</span> <span class="number">6</span></span><br></pre></td></tr></table></figure>

<h4 id="3-1-5表达式计算"><a href="#3-1-5表达式计算" class="headerlink" title="3.1.5表达式计算"></a>3.1.5表达式计算</h4><p>在查询开始执行之前，如果表达式中只包含常量的话，它的值会被先计算出来，比如这个：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a <span class="operator">=</span> <span class="number">5</span> <span class="operator">+</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>因为<code>5 + 1</code>这个表达式只包含常量，所以就会被化简成：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a <span class="operator">=</span> <span class="number">6</span></span><br></pre></td></tr></table></figure>

<p>但是这里需要注意的是，如果某个列并不是以单独的形式作为表达式的操作数时，比如出现在函数中，出现在某个更复杂表达式中，就像这样：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ABS</span>(a) <span class="operator">&gt;</span> <span class="number">5</span></span><br></pre></td></tr></table></figure>

<p>优化器是不会尝试对这些表达式进行化简的。我们前边说过只有搜索条件中索引列和常数使用某些运算符连接起来才可能使用到索引，所以如果可以的话，最好让索引列以单独的形式出现在表达式中。</p>
<h4 id="3-1-6HAVING子句和WHERE子句的合并"><a href="#3-1-6HAVING子句和WHERE子句的合并" class="headerlink" title="3.1.6HAVING子句和WHERE子句的合并"></a>3.1.6HAVING子句和WHERE子句的合并</h4><p>如果查询语句中没有出现诸如<code>SUM</code>、<code>MAX</code>等等的聚集函数以及<code>GROUP BY</code>子句，优化器就把<code>HAVING</code>子句和<code>WHERE</code>子句合并起来。</p>
<h4 id="3-1-7常量表检测"><a href="#3-1-7常量表检测" class="headerlink" title="3.1.7常量表检测"></a>3.1.7常量表检测</h4><p>设计<code>MySQL</code>的大叔觉得下边这两种查询运行的特别快：</p>
<ul>
<li><p>查询的表中一条记录没有，或者只有一条记录。</p>
<blockquote>
<p>大家有没有觉得这一条有点儿不对劲，我还没开始查表呢咋就知道这表里边有几条记录呢？哈哈，这个其实依靠的是统计数据。不过我们说过InnoDB的统计数据数据不准确，所以这一条不能用于使用InnoDB作为存储引擎的表，只能适用于使用Memory或者MyISAM存储引擎的表。</p>
</blockquote>
</li>
<li><p>使用主键等值匹配或者唯一二级索引列等值匹配作为搜索条件来查询某个表。</p>
</li>
</ul>
<p>设计<code>MySQL</code>的大叔觉得这两种查询花费的时间特别少，少到可以忽略，所以也把通过这两种方式查询的表称之为<code>常量表</code>（英文名：<code>constant tables</code>）。优化器在分析一个查询语句时，先首先执行常量表查询，然后把查询中涉及到该表的条件全部替换成常数，最后再分析其余表的查询成本，比方说这个查询语句：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> table1 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> table2</span><br><span class="line">    <span class="keyword">ON</span> table1.column1 <span class="operator">=</span> table2.column2 </span><br><span class="line">    <span class="keyword">WHERE</span> table1.primary_key <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>很明显，这个查询可以使用主键和常量值的等值匹配来查询<code>table1</code>表，也就是在这个查询中<code>table1</code>表相当于<code>常量表</code>，在分析对<code>table2</code>表的查询成本之前，就会执行对<code>table1</code>表的查询，并把查询中涉及<code>table1</code>表的条件都替换掉，也就是上边的语句会被转换成这样：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> table1表记录的各个字段的常量值, table2.<span class="operator">*</span> <span class="keyword">FROM</span> table1 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> table2 </span><br><span class="line">    <span class="keyword">ON</span> table1表column1列的常量值 <span class="operator">=</span> table2.column2;</span><br></pre></td></tr></table></figure>

<h3 id="3-2外连接消除"><a href="#3-2外连接消除" class="headerlink" title="3.2外连接消除"></a>3.2外连接消除</h3><p>我们前边说过，<code>内连接</code>的驱动表和被驱动表的位置可以相互转换，而<code>左（外）连接</code>和<code>右（外）连接</code>的驱动表和被驱动表是固定的。这就导致<code>内连接</code>可能通过优化表的连接顺序来降低整体的查询成本，而<code>外连接</code>却无法优化表的连接顺序。为了故事的顺利发展，我们还是把之前介绍连接原理时用过的<code>t1</code>和<code>t2</code>表请出来，为了防止大家早就忘掉了，我们再看一下这两个表的结构：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t1 (</span><br><span class="line">    m1 <span class="type">int</span>, </span><br><span class="line">    n1 <span class="type">char</span>(<span class="number">1</span>)</span><br><span class="line">) Engine<span class="operator">=</span>InnoDB, CHARSET<span class="operator">=</span>utf8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t2 (</span><br><span class="line">    m2 <span class="type">int</span>, </span><br><span class="line">    n2 <span class="type">char</span>(<span class="number">1</span>)</span><br><span class="line">) Engine<span class="operator">=</span>InnoDB, CHARSET<span class="operator">=</span>utf8;</span><br></pre></td></tr></table></figure>

<p>为了唤醒大家的记忆，我们再把这两个表中的数据给展示一下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t1;</span><br><span class="line"><span class="operator">+</span><span class="comment">------+------+</span></span><br><span class="line"><span class="operator">|</span> m1   <span class="operator">|</span> n1   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+------+</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span> a    <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">2</span> <span class="operator">|</span> b    <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">3</span> <span class="operator">|</span> c    <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+------+</span></span><br><span class="line"><span class="number">3</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t2;</span><br><span class="line"><span class="operator">+</span><span class="comment">------+------+</span></span><br><span class="line"><span class="operator">|</span> m2   <span class="operator">|</span> n2   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+------+</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">2</span> <span class="operator">|</span> b    <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">3</span> <span class="operator">|</span> c    <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">4</span> <span class="operator">|</span> d    <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+------+</span></span><br><span class="line"><span class="number">3</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

<p>我们之前说过，外连接和内连接的本质区别就是：对于外连接的驱动表的记录来说，如果无法在被驱动表中找到匹配ON子句中的过滤条件的记录，那么该记录仍然会被加入到结果集中，对应的被驱动表记录的各个字段使用NULL值填充；而内连接的驱动表的记录如果无法在被驱动表中找到匹配ON子句中的过滤条件的记录，那么该记录会被舍弃。查询效果就是这样：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t1 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> t2 <span class="keyword">ON</span> t1.m1 <span class="operator">=</span> t2.m2;</span><br><span class="line"><span class="operator">+</span><span class="comment">------+------+------+------+</span></span><br><span class="line"><span class="operator">|</span> m1   <span class="operator">|</span> n1   <span class="operator">|</span> m2   <span class="operator">|</span> n2   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+------+------+------+</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">2</span> <span class="operator">|</span> b    <span class="operator">|</span>    <span class="number">2</span> <span class="operator">|</span> b    <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">3</span> <span class="operator">|</span> c    <span class="operator">|</span>    <span class="number">3</span> <span class="operator">|</span> c    <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+------+------+------+</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t1 <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> t2 <span class="keyword">ON</span> t1.m1 <span class="operator">=</span> t2.m2;</span><br><span class="line"><span class="operator">+</span><span class="comment">------+------+------+------+</span></span><br><span class="line"><span class="operator">|</span> m1   <span class="operator">|</span> n1   <span class="operator">|</span> m2   <span class="operator">|</span> n2   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+------+------+------+</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">2</span> <span class="operator">|</span> b    <span class="operator">|</span>    <span class="number">2</span> <span class="operator">|</span> b    <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">3</span> <span class="operator">|</span> c    <span class="operator">|</span>    <span class="number">3</span> <span class="operator">|</span> c    <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span> a    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+------+------+------+</span></span><br><span class="line"><span class="number">3</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

<p>对于上边例子中的（左）外连接来说，由于驱动表<code>t1</code>中<code>m1=1, n1=&#39;a&#39;</code>的记录无法在被驱动表<code>t2</code>中找到符合<code>ON</code>子句条件<code>t1.m1 = t2.m2</code>的记录，所以就直接把这条记录加入到结果集，对应的<code>t2</code>表的<code>m2</code>和<code>n2</code>列的值都设置为<code>NULL</code>。</p>
<blockquote>
<p>右（外）连接和左（外）连接其实只在驱动表的选取方式上是不同的，其余方面都是一样的，所以优化器会首先把右（外）连接查询转换成左（外）连接查询。我们后边就不再唠叨右（外）连接了。</p>
</blockquote>
<p>我们知道<code>WHERE</code>子句的杀伤力比较大，凡是不符合WHERE子句中条件的记录都不会参与连接。只要我们在搜索条件中指定关于被驱动表相关列的值不为<code>NULL</code>，那么外连接中在被驱动表中找不到符合<code>ON</code>子句条件的驱动表记录也就被排除出最后的结果集了，也就是说：在这种情况下：外连接和内连接也就没有什么区别了！比方说这个查询：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t1 <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> t2 <span class="keyword">ON</span> t1.m1 <span class="operator">=</span> t2.m2 <span class="keyword">WHERE</span> t2.n2 <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">------+------+------+------+</span></span><br><span class="line"><span class="operator">|</span> m1   <span class="operator">|</span> n1   <span class="operator">|</span> m2   <span class="operator">|</span> n2   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+------+------+------+</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">2</span> <span class="operator">|</span> b    <span class="operator">|</span>    <span class="number">2</span> <span class="operator">|</span> b    <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">3</span> <span class="operator">|</span> c    <span class="operator">|</span>    <span class="number">3</span> <span class="operator">|</span> c    <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+------+------+------+</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure>

<p>由于指定了被驱动表<code>t2</code>的<code>n2</code>列不允许为<code>NULL</code>，所以上边的<code>t1</code>和<code>t2</code>表的左（外）连接查询和内连接查询是一样一样的。当然，我们也可以不用显式的指定被驱动表的某个列<code>IS NOT NULL</code>，只要隐含的有这个意思就行了，比方说这样：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t1 <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> t2 <span class="keyword">ON</span> t1.m1 <span class="operator">=</span> t2.m2 <span class="keyword">WHERE</span> t2.m2 <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">------+------+------+------+</span></span><br><span class="line"><span class="operator">|</span> m1   <span class="operator">|</span> n1   <span class="operator">|</span> m2   <span class="operator">|</span> n2   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+------+------+------+</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">2</span> <span class="operator">|</span> b    <span class="operator">|</span>    <span class="number">2</span> <span class="operator">|</span> b    <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+------+------+------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

<p>在这个例子中，我们在<code>WHERE</code>子句中指定了被驱动表<code>t2</code>的<code>m2</code>列等于<code>2</code>，也就相当于间接的指定了<code>m2</code>列不为<code>NULL</code>值，所以上边的这个左（外）连接查询其实和下边这个内连接查询是等价的：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t1 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> t2 <span class="keyword">ON</span> t1.m1 <span class="operator">=</span> t2.m2 <span class="keyword">WHERE</span> t2.m2 <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">------+------+------+------+</span></span><br><span class="line"><span class="operator">|</span> m1   <span class="operator">|</span> n1   <span class="operator">|</span> m2   <span class="operator">|</span> n2   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+------+------+------+</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">2</span> <span class="operator">|</span> b    <span class="operator">|</span>    <span class="number">2</span> <span class="operator">|</span> b    <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+------+------+------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

<p>我们把这种在外连接查询中，指定的<code>WHERE</code>子句中包含被驱动表中的列不为<code>NULL</code>值的条件称之为<code>空值拒绝</code>（英文名：<code>reject-NULL</code>）。在被驱动表的WHERE子句符合空值拒绝的条件后，外连接和内连接可以相互转换。这种转换带来的好处就是查询优化器可以通过评估表的不同连接顺序的成本，选出成本最低的那种连接顺序来执行查询。</p>
<h3 id="3-3子查询优化"><a href="#3-3子查询优化" class="headerlink" title="3.3子查询优化"></a>3.3子查询优化</h3><h4 id="3-3-1子查询语法"><a href="#3-3-1子查询语法" class="headerlink" title="3.3.1子查询语法"></a>3.3.1子查询语法</h4><p>想必大家都是妈妈生下来的吧，连孙猴子都有妈妈——石头人。怀孕妈妈肚子里的那个东东就是她的孩子，类似的，在一个查询语句里的某个位置也可以有另一个查询语句，这个出现在某个查询语句的某个位置中的查询就被称为<code>子查询</code>（我们也可以称它为宝宝查询哈哈），那个充当“妈妈”角色的查询也被称之为<code>外层查询</code>。不像人们怀孕时宝宝们都只在肚子里，子查询可以在一个外层查询的各种位置出现，比如：</p>
<ul>
<li><p><code>SELECT</code>子句中</p>
<p>也就是我们平时说的查询列表中，比如这样：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> (<span class="keyword">SELECT</span> m1 <span class="keyword">FROM</span> t1 LIMIT <span class="number">1</span>);</span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------------------+</span></span><br><span class="line"><span class="operator">|</span> (<span class="keyword">SELECT</span> m1 <span class="keyword">FROM</span> t1 LIMIT <span class="number">1</span>) <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------------------+</span></span><br><span class="line"><span class="operator">|</span>                           <span class="number">1</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

<p>其中的<code>(SELECT m1 FROM t1 LIMIT 1)</code>就是我们唠叨的所谓的<code>子查询</code>。</p>
</li>
<li><p><code>FROM</code>子句中</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> m, n <span class="keyword">FROM</span> (<span class="keyword">SELECT</span> m2 <span class="operator">+</span> <span class="number">1</span> <span class="keyword">AS</span> m, n2 <span class="keyword">AS</span> n <span class="keyword">FROM</span> t2 <span class="keyword">WHERE</span> m2 <span class="operator">&gt;</span> <span class="number">2</span>) <span class="keyword">AS</span> t;</span><br><span class="line"><span class="operator">+</span><span class="comment">------+------+</span></span><br><span class="line"><span class="operator">|</span> m    <span class="operator">|</span> n    <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+------+</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">4</span> <span class="operator">|</span> c    <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">5</span> <span class="operator">|</span> d    <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+------+</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

<p>这个例子中的子查询是：<code>(SELECT m2 + 1 AS m, n2 AS n FROM t2 WHERE m2 &gt; 2)</code>，很特别的地方是它出现在了<code>FROM</code>子句中。<code>FROM</code>子句里边儿不是存放我们要查询的表的名称么，这里放进来一个子查询是个什么鬼？其实这里我们可以把子查询的查询结果当作是一个表，子查询后边的<code>AS t</code>表明这个子查询的结果就相当于一个名称为<code>t</code>的表，这个名叫<code>t</code>的表的列就是子查询结果中的列，比如例子中表<code>t</code>就有两个列：<code>m</code>列和<code>n</code>列。这个放在<code>FROM</code>子句中的子查询本质上相当于一个<code>表</code>，但又和我们平常使用的表有点儿不一样，设计<code>MySQL</code>的大叔把这种由子查询结果集组成的表称之为<code>派生表</code>。</p>
</li>
<li><p><code>WHERE</code>或<code>ON</code>子句中</p>
<p>把子查询放在外层查询的<code>WHERE</code>子句或者<code>ON</code>子句中可能是我们最常用的一种使用子查询的方式了，比如这样：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t1 <span class="keyword">WHERE</span> m1 <span class="keyword">IN</span> (<span class="keyword">SELECT</span> m2 <span class="keyword">FROM</span> t2);</span><br><span class="line"><span class="operator">+</span><span class="comment">------+------+</span></span><br><span class="line"><span class="operator">|</span> m1   <span class="operator">|</span> n1   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+------+</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">2</span> <span class="operator">|</span> b    <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">3</span> <span class="operator">|</span> c    <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+------+</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

<p>这个查询表明我们想要将<code>(SELECT m2 FROM t2)</code>这个子查询的结果作为外层查询的<code>IN</code>语句参数，整个查询语句的意思就是我们想找<code>t1</code>表中的某些记录，这些记录的<code>m1</code>列的值能在<code>t2</code>表的<code>m2</code>列找到匹配的值。</p>
</li>
<li><p><code>ORDER BY</code>子句中</p>
<p>虽然语法支持，但没啥子意义，不唠叨这种情况了。</p>
</li>
<li><p><code>GROUP BY</code>子句中</p>
<p>同上～</p>
</li>
</ul>
<h5 id="按返回的结果集区分子查询"><a href="#按返回的结果集区分子查询" class="headerlink" title="按返回的结果集区分子查询"></a>按返回的结果集区分子查询</h5><p>因为子查询本身也算是一个查询，所以可以按照它们返回的不同结果集类型而把这些子查询分为不同的类型：</p>
<ul>
<li><p>标量子查询</p>
<p>那些只返回一个单一值的子查询称之为<code>标量子查询</code>，比如这样：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> (<span class="keyword">SELECT</span> m1 <span class="keyword">FROM</span> t1 LIMIT <span class="number">1</span>);</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t1 <span class="keyword">WHERE</span> m1 <span class="operator">=</span> (<span class="keyword">SELECT</span> <span class="built_in">MIN</span>(m2) <span class="keyword">FROM</span> t2);</span><br></pre></td></tr></table></figure>

<p>这两个查询语句中的子查询都返回一个单一的值，也就是一个<code>标量</code>。这些标量子查询可以作为一个单一值或者表达式的一部分出现在查询语句的各个地方。</p>
</li>
<li><p>行子查询</p>
<p>顾名思义，就是返回一条记录的子查询，不过这条记录需要包含多个列（只包含一个列就成了标量子查询了）。比如这样：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t1 <span class="keyword">WHERE</span> (m1, n1) <span class="operator">=</span> (<span class="keyword">SELECT</span> m2, n2 <span class="keyword">FROM</span> t2 LIMIT <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>其中的<code>(SELECT m2, n2 FROM t2 LIMIT 1)</code>就是一个行子查询，整条语句的含义就是要从<code>t1</code>表中找一些记录，这些记录的<code>m1</code>和<code>n1</code>列分别等于子查询结果中的<code>m2</code>和<code>n2</code>列。</p>
</li>
<li><p>列子查询</p>
<p>列子查询自然就是查询出一个列的数据喽，不过这个列的数据需要包含多条记录（只包含一条记录就成了标量子查询了）。比如这样：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t1 <span class="keyword">WHERE</span> m1 <span class="keyword">IN</span> (<span class="keyword">SELECT</span> m2 <span class="keyword">FROM</span> t2);</span><br></pre></td></tr></table></figure>

<p>其中的<code>(SELECT m2 FROM t2)</code>就是一个列子查询，表明查询出<code>t2</code>表的<code>m2</code>列的值作为外层查询<code>IN</code>语句的参数。</p>
</li>
<li><p>表子查询</p>
<p>顾名思义，就是子查询的结果既包含很多条记录，又包含很多个列，比如这样：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t1 <span class="keyword">WHERE</span> (m1, n1) <span class="keyword">IN</span> (<span class="keyword">SELECT</span> m2, n2 <span class="keyword">FROM</span> t2);</span><br></pre></td></tr></table></figure>

<p>其中的<code>(SELECT m2, n2 FROM t2)</code>就是一个表子查询，这里需要和行子查询对比一下，行子查询中我们用了<code>LIMIT 1</code>来保证子查询的结果只有一条记录，表子查询中不需要这个限制。</p>
</li>
</ul>
<h5 id="按与外层查询关系来区分子查询"><a href="#按与外层查询关系来区分子查询" class="headerlink" title="按与外层查询关系来区分子查询"></a>按与外层查询关系来区分子查询</h5><ul>
<li><p>不相关子查询</p>
<p>如果子查询可以单独运行出结果，而不依赖于外层查询的值，我们就可以把这个子查询称之为<code>不相关子查询</code>。我们前边介绍的那些子查询全部都可以看作不相关子查询，所以也就不举例子了哈。</p>
</li>
<li><p>相关子查询</p>
<p>如果子查询的执行需要依赖于外层查询的值，我们就可以把这个子查询称之为<code>相关子查询</code>。比如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t1 <span class="keyword">WHERE</span> m1 <span class="keyword">IN</span> (<span class="keyword">SELECT</span> m2 <span class="keyword">FROM</span> t2 <span class="keyword">WHERE</span> n1 <span class="operator">=</span> n2);</span><br></pre></td></tr></table></figure>

<p>例子中的子查询是<code>(SELECT m2 FROM t2 WHERE n1 = n2)</code>，可是这个查询中有一个搜索条件是<code>n1 = n2</code>，别忘了<code>n1</code>是表<code>t1</code>的列，也就是外层查询的列，也就是说子查询的执行需要依赖于外层查询的值，所以这个子查询就是一个<code>相关子查询</code>。</p>
</li>
</ul>
<h5 id="子查询在布尔表达式中的使用"><a href="#子查询在布尔表达式中的使用" class="headerlink" title="子查询在布尔表达式中的使用"></a>子查询在布尔表达式中的使用</h5><p>我们平时用子查询最多的地方就是把它作为布尔表达式的一部分来作为搜索条件用在<code>WHERE</code>子句或者<code>ON</code>子句里。所以我们这里来总结一下子查询在布尔表达式中的使用场景。</p>
<ul>
<li><p>使用<code>=</code>、<code>&gt;</code>、<code>&lt;</code>、<code>&gt;=</code>、<code>&lt;=</code>、<code>&lt;&gt;</code>、<code>!=</code>、<code>&lt;=&gt;</code>作为布尔表达式的操作符</p>
<p>我们就把这些操作符称为<code>comparison_operator</code>吧，所以子查询组成的布尔表达式就长这样：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">操作数 comparison_operator (子查询)</span><br></pre></td></tr></table></figure>

<p>这里的<code>操作数</code>可以是某个列名，或者是一个常量，或者是一个更复杂的表达式，甚至可以是另一个子查询。但是需要注意的是，这里的子查询只能是标量子查询或者行子查询，也就是子查询的结果只能返回一个单一的值或者只能是一条记录。比如这样：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t1 <span class="keyword">WHERE</span> m1 <span class="operator">&lt;</span> (<span class="keyword">SELECT</span> <span class="built_in">MIN</span>(m2) <span class="keyword">FROM</span> t2);</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t1 <span class="keyword">WHERE</span> (m1, n1) <span class="operator">=</span> (<span class="keyword">SELECT</span> m2, n2 <span class="keyword">FROM</span> t2 LIMIT <span class="number">1</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>[NOT] IN&#x2F;ANY&#x2F;SOME&#x2F;ALL子查询</p>
<p>对于列子查询和表子查询来说，它们的结果集中包含很多条记录，这些记录相当于是一个集合，所以就不能单纯的和另外一个操作数使用<code>comparison_operator</code>来组成布尔表达式了，<code>MySQL</code>通过下面的语法来支持某个操作数和一个集合组成一个布尔表达式：</p>
<ul>
<li><p><code>IN</code>或者<code>NOT IN</code></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">操作数 [<span class="keyword">NOT</span>] <span class="keyword">IN</span> (子查询)</span><br></pre></td></tr></table></figure>

<p>这个布尔表达式的意思是用来判断某个操作数在不在由子查询结果集组成的集合中，比如下边的查询的意思是找出<code>t1</code>表中的某些记录，这些记录存在于子查询的结果集中：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t1 <span class="keyword">WHERE</span> (m1, n1) <span class="keyword">IN</span> (<span class="keyword">SELECT</span> m2, n2 <span class="keyword">FROM</span> t2);</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>ANY/SOME</code>（<code>ANY</code>和<code>SOME</code>是同义词）</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">操作数 comparison_operator <span class="keyword">ANY</span><span class="operator">/</span><span class="keyword">SOME</span>(子查询)</span><br></pre></td></tr></table></figure>

<p>这个布尔表达式的意思是只要子查询结果集中存在某个值和给定的操作数做<code>comparison_operator</code>比较结果为<code>TRUE</code>，那么整个表达式的结果就为<code>TRUE</code>，否则整个表达式的结果就为<code>FALSE</code>。比方说下边这个查询：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t1 <span class="keyword">WHERE</span> m1 <span class="operator">&gt;</span> <span class="keyword">ANY</span>(<span class="keyword">SELECT</span> m2 <span class="keyword">FROM</span> t2);</span><br></pre></td></tr></table></figure>

<p>这个查询的意思就是对于<code>t1</code>表的某条记录的<code>m1</code>列的值来说，如果子查询<code>(SELECT m2 FROM t2)</code>的结果集中存在一个小于<code>m1</code>列的值，那么整个布尔表达式的值就是<code>TRUE</code>，否则为<code>FALSE</code>，也就是说只要<code>m1</code>列的值大于子查询结果集中最小的值，整个表达式的结果就是<code>TRUE</code>，所以上边的查询本质上等价于这个查询：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t1 <span class="keyword">WHERE</span> m1 <span class="operator">&gt;</span> (<span class="keyword">SELECT</span> <span class="built_in">MIN</span>(m2) <span class="keyword">FROM</span> t2);</span><br></pre></td></tr></table></figure>

<p>另外，&#x3D;ANY相当于判断子查询结果集中是否存在某个值和给定的操作数相等，它的含义和IN是相同的。</p>
</li>
<li><p><code>ALL</code></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">操作数 comparison_operator <span class="keyword">ALL</span>(子查询)</span><br></pre></td></tr></table></figure>

<p>这个布尔表达式的意思是子查询结果集中所有的值和给定的操作数做<code>comparison_operator</code>比较结果为<code>TRUE</code>，那么整个表达式的结果就为<code>TRUE</code>，否则整个表达式的结果就为<code>FALSE</code>。比方说下边这个查询：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t1 <span class="keyword">WHERE</span> m1 <span class="operator">&gt;</span> <span class="keyword">ALL</span>(<span class="keyword">SELECT</span> m2 <span class="keyword">FROM</span> t2);</span><br></pre></td></tr></table></figure>

<p>这个查询的意思就是对于<code>t1</code>表的某条记录的<code>m1</code>列的值来说，如果子查询<code>(SELECT m2 FROM t2)</code>的结果集中的所有值都小于<code>m1</code>列的值，那么整个布尔表达式的值就是<code>TRUE</code>，否则为<code>FALSE</code>，也就是说只要<code>m1</code>列的值大于子查询结果集中最大的值，整个表达式的结果就是<code>TRUE</code>，所以上边的查询本质上等价于这个查询：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t1 <span class="keyword">WHERE</span> m1 <span class="operator">&gt;</span> (<span class="keyword">SELECT</span> <span class="built_in">MAX</span>(m2) <span class="keyword">FROM</span> t2);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>EXISTS子查询</p>
<p>有的时候我们仅仅需要判断子查询的结果集中是否有记录，而不在乎它的记录具体是个啥，可以使用把<code>EXISTS</code>或者<code>NOT EXISTS</code>放在子查询语句前边，就像这样：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">NOT</span>] <span class="keyword">EXISTS</span> (子查询)</span><br></pre></td></tr></table></figure>

<p>我们举一个例子啊：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t1 <span class="keyword">WHERE</span> <span class="keyword">EXISTS</span> (<span class="keyword">SELECT</span> <span class="number">1</span> <span class="keyword">FROM</span> t2);</span><br></pre></td></tr></table></figure>

<p>对于子查询<code>(SELECT 1 FROM t2)</code>来说，我们并不关心这个子查询最后到底查询出的结果是什么，所以查询列表里填<code>*</code>、某个列名，或者其他啥东西都无所谓，我们真正关心的是子查询的结果集中是否存在记录。也就是说只要<code>(SELECT 1 FROM t2)</code>这个查询中有记录，那么整个<code>EXISTS</code>表达式的结果就为<code>TRUE</code>。</p>
</li>
</ul>
<h5 id="子查询语法注意事项"><a href="#子查询语法注意事项" class="headerlink" title="子查询语法注意事项"></a>子查询语法注意事项</h5><ul>
<li><p>子查询必须用小括号扩起来。</p>
<p>不扩起来的子查询是非法的，比如这样：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="keyword">SELECT</span> m1 <span class="keyword">FROM</span> t1;</span><br><span class="line"></span><br><span class="line">ERROR <span class="number">1064</span> (<span class="number">42000</span>): You have an error <span class="keyword">in</span> your <span class="keyword">SQL</span> syntax; <span class="keyword">check</span> the manual that corresponds <span class="keyword">to</span> your MySQL server version <span class="keyword">for</span> the <span class="keyword">right</span> syntax <span class="keyword">to</span> use near <span class="string">&#x27;SELECT m1 FROM t1&#x27;</span> <span class="keyword">at</span> line <span class="number">1</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在<code>SELECT</code>子句中的子查询必须是标量子查询。</p>
<p>如果子查询结果集中有多个列或者多个行，都不允许放在<code>SELECT</code>子句中，也就是查询列表中，比如这样就是非法的：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> (<span class="keyword">SELECT</span> m1, n1 <span class="keyword">FROM</span> t1);</span><br><span class="line"></span><br><span class="line">ERROR <span class="number">1241</span> (<span class="number">21000</span>): Operand should contain <span class="number">1</span> <span class="keyword">column</span>(s)</span><br></pre></td></tr></table></figure>
</li>
<li><p>在想要得到标量子查询或者行子查询，但又不能保证子查询的结果集只有一条记录时，应该使用<code>LIMIT 1</code>语句来限制记录数量。</p>
</li>
<li><p>对于<code>[NOT] IN/ANY/SOME/ALL</code>子查询来说，子查询中不允许有<code>LIMIT</code>语句。</p>
<p>比如这样是非法的：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t1 <span class="keyword">WHERE</span> m1 <span class="keyword">IN</span> (<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t2 LIMIT <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">ERROR <span class="number">1235</span> (<span class="number">42000</span>): This version <span class="keyword">of</span> MySQL doesn<span class="string">&#x27;t yet support &#x27;</span>LIMIT <span class="operator">&amp;</span> <span class="keyword">IN</span><span class="operator">/</span><span class="keyword">ALL</span><span class="operator">/</span><span class="keyword">ANY</span><span class="operator">/</span><span class="keyword">SOME</span> subquery<span class="string">&#x27;</span></span><br></pre></td></tr></table></figure>

<p>为啥不合法？人家就这么规定的，不解释～ 可能以后的版本会支持吧。</p>
</li>
<li><p><code>ORDER BY</code>子句</p>
<p>子查询的结果其实就相当于一个集合，集合里的值排不排序一点儿都不重要，比如下边这个语句中的<code>ORDER BY</code>子句简直就是画蛇添足：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t1 <span class="keyword">WHERE</span> m1 <span class="keyword">IN</span> (<span class="keyword">SELECT</span> m2 <span class="keyword">FROM</span> t2 <span class="keyword">ORDER</span> <span class="keyword">BY</span> m2);</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>DISTINCT</code>语句</p>
<p>集合里的值去不去重也没啥意义，比如这样：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t1 <span class="keyword">WHERE</span> m1 <span class="keyword">IN</span> (<span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> m2 <span class="keyword">FROM</span> t2);</span><br></pre></td></tr></table></figure>
</li>
<li><p>没有聚集函数以及<code>HAVING</code>子句的<code>GROUP BY</code>子句。</p>
<p>在没有聚集函数以及<code>HAVING</code>子句时，<code>GROUP BY</code>子句就是个摆设，比如这样：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t1 <span class="keyword">WHERE</span> m1 <span class="keyword">IN</span> (<span class="keyword">SELECT</span> m2 <span class="keyword">FROM</span> t2 <span class="keyword">GROUP</span> <span class="keyword">BY</span> m2);</span><br></pre></td></tr></table></figure>

<p>对于这些冗余的语句，查询优化器在一开始就把它们给干掉了。</p>
</li>
<li><p>不允许在一条语句中增删改某个表的记录时同时还对该表进行子查询。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">DELETE</span> <span class="keyword">FROM</span> t1 <span class="keyword">WHERE</span> m1 <span class="operator">&lt;</span> (<span class="keyword">SELECT</span> <span class="built_in">MAX</span>(m1) <span class="keyword">FROM</span> t1);</span><br><span class="line"></span><br><span class="line">ERROR <span class="number">1093</span> (HY000): You can<span class="string">&#x27;t specify target table &#x27;</span>t1<span class="string">&#x27; for update in FROM clause</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="3-3-2子查询在MySQL中是怎么执行的"><a href="#3-3-2子查询在MySQL中是怎么执行的" class="headerlink" title="3.3.2子查询在MySQL中是怎么执行的"></a>3.3.2子查询在MySQL中是怎么执行的</h4><p>好了，关于子查询的基础语法我们用最快的速度温习了一遍，如果想了解更多语法细节，大家可以去查看一下<code>MySQL</code>的文档哈，现在我们就假设各位都懂了啥是个子查询了喔，接下来就要唠叨具体某种类型的子查询在<code>MySQL</code>中是怎么执行的了，想想就有点儿小激动呢～ 当然，为了故事的顺利发展，我们的例子也需要跟随形势鸟枪换炮，还是要祭出我们用了n遍的<code>single_table</code>表：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> single_table (</span><br><span class="line">    id <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">    key1 <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    key2 <span class="type">INT</span>,</span><br><span class="line">    key3 <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    key_part1 <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    key_part2 <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    key_part3 <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    common_field <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (id),</span><br><span class="line">    KEY idx_key1 (key1),</span><br><span class="line">    <span class="keyword">UNIQUE</span> KEY idx_key2 (key2),</span><br><span class="line">    KEY idx_key3 (key3),</span><br><span class="line">    KEY idx_key_part(key_part1, key_part2, key_part3)</span><br><span class="line">) Engine<span class="operator">=</span>InnoDB CHARSET<span class="operator">=</span>utf8;</span><br></pre></td></tr></table></figure>

<p>为了方便，我们假设有两个表<code>s1</code>、<code>s2</code>与这个<code>single_table</code>表的构造是相同的，而且这两个表里边儿有10000条记录，除id列外其余的列都插入随机值。下边正式开始我们的表演。</p>
<h5 id="小白们眼中子查询的执行方式"><a href="#小白们眼中子查询的执行方式" class="headerlink" title="小白们眼中子查询的执行方式"></a>小白们眼中子查询的执行方式</h5><p>在我还是一个单纯无知的少年时，觉得子查询的执行方式是这样的：</p>
<ul>
<li><p>如果该子查询是不相关子查询，比如下边这个查询：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 </span><br><span class="line">    <span class="keyword">WHERE</span> key1 <span class="keyword">IN</span> (<span class="keyword">SELECT</span> common_field <span class="keyword">FROM</span> s2);</span><br></pre></td></tr></table></figure>

<p>我年少时觉得这个查询是的执行方式是这样的：</p>
<ul>
<li>先单独执行<code>(SELECT common_field FROM s2)</code>这个子查询。</li>
<li>然后在将上一步子查询得到的结果当作外层查询的参数再执行外层查询<code>SELECT * FROM s1 WHERE key1 IN (...)</code>。</li>
</ul>
</li>
<li><p>如果该子查询是相关子查询，比如下边这个查询：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 </span><br><span class="line">    <span class="keyword">WHERE</span> key1 <span class="keyword">IN</span> (<span class="keyword">SELECT</span> common_field <span class="keyword">FROM</span> s2 <span class="keyword">WHERE</span> s1.key2 <span class="operator">=</span> s2.key2);</span><br></pre></td></tr></table></figure>

<p>这个查询中的子查询中出现了<code>s1.key2 = s2.key2</code>这样的条件，意味着该子查询的执行依赖着外层查询的值，所以我年少时觉得这个查询的执行方式是这样的：</p>
<ul>
<li>先从外层查询中获取一条记录，本例中也就是先从<code>s1</code>表中获取一条记录。</li>
<li>然后从上一步骤中获取的那条记录中找出子查询中涉及到的值，本例中就是从<code>s1</code>表中获取的那条记录中找出<code>s1.key2</code>列的值，然后执行子查询。</li>
<li>最后根据子查询的查询结果来检测外层查询<code>WHERE</code>子句的条件是否成立，如果成立，就把外层查询的那条记录加入到结果集，否则就丢弃。</li>
<li>再次执行第一步，获取第二条外层查询中的记录，依次类推～</li>
</ul>
</li>
</ul>
<p>其实设计<code>MySQL</code>的大叔想了一系列的办法来优化子查询的执行，大部分情况下这些优化措施其实挺有效的，但是保不齐有的时候马失前蹄，下边我们详细唠叨各种不同类型的子查询具体是怎么执行的。</p>
<blockquote>
<p>我们下边即将唠叨的关于MySQL优化子查询的执行方式的事儿都是基于MySQL5.7这个版本的，以后版本可能有更新的优化策略！</p>
</blockquote>
<h5 id="标量子查询、行子查询的执行方式"><a href="#标量子查询、行子查询的执行方式" class="headerlink" title="标量子查询、行子查询的执行方式"></a>标量子查询、行子查询的执行方式</h5><p>我们经常在下边两个场景中使用到标量子查询或者行子查询：</p>
<ul>
<li><code>SELECT</code>子句中，我们前边说过的在查询列表中的子查询必须是标量子查询。</li>
<li>子查询使用<code>=</code>、<code>&gt;</code>、<code>&lt;</code>、<code>&gt;=</code>、<code>&lt;=</code>、<code>&lt;&gt;</code>、<code>!=</code>、<code>&lt;=&gt;</code>等操作符和某个操作数组成一个布尔表达式，这样的子查询必须是标量子查询或者行子查询。</li>
</ul>
<p>对于上述两种场景中的不相关标量子查询或者行子查询来说，它们的执行方式是简单的，比方说下边这个查询语句：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 </span><br><span class="line">    <span class="keyword">WHERE</span> key1 <span class="operator">=</span> (<span class="keyword">SELECT</span> common_field <span class="keyword">FROM</span> s2 <span class="keyword">WHERE</span> key3 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span> LIMIT <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>它的执行方式和年少的我想的一样：</p>
<ul>
<li>先单独执行<code>(SELECT common_field FROM s2 WHERE key3 = &#39;a&#39; LIMIT 1)</code>这个子查询。</li>
<li>然后在将上一步子查询得到的结果当作外层查询的参数再执行外层查询<code>SELECT * FROM s1 WHERE key1 = ...</code>。</li>
</ul>
<p>也就是说，对于包含不相关的标量子查询或者行子查询的查询语句来说，MySQL会分别独立的执行外层查询和子查询，就当作两个单表查询就好了。</p>
<p>对于相关的标量子查询或者行子查询来说，比如下边这个查询：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> </span><br><span class="line">    key1 <span class="operator">=</span> (<span class="keyword">SELECT</span> common_field <span class="keyword">FROM</span> s2 <span class="keyword">WHERE</span> s1.key3 <span class="operator">=</span> s2.key3 LIMIT <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>事情也和年少的我想的一样，它的执行方式就是这样的：</p>
<ul>
<li>先从外层查询中获取一条记录，本例中也就是先从<code>s1</code>表中获取一条记录。</li>
<li>然后从上一步骤中获取的那条记录中找出子查询中涉及到的值，本例中就是从<code>s1</code>表中获取的那条记录中找出<code>s1.key3</code>列的值，然后执行子查询。</li>
<li>最后根据子查询的查询结果来检测外层查询<code>WHERE</code>子句的条件是否成立，如果成立，就把外层查询的那条记录加入到结果集，否则就丢弃。</li>
<li>再次执行第一步，获取第二条外层查询中的记录，依次类推～</li>
</ul>
<p>也就是说对于一开始唠叨的两种使用标量子查询以及行子查询的场景中，<code>MySQL</code>优化器的执行方式并没有什么新鲜的。</p>
<h5 id="IN子查询优化"><a href="#IN子查询优化" class="headerlink" title="IN子查询优化"></a>IN子查询优化</h5><p>对于不相关的<code>IN</code>子查询，比如这样：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 </span><br><span class="line">    <span class="keyword">WHERE</span> key1 <span class="keyword">IN</span> (<span class="keyword">SELECT</span> common_field <span class="keyword">FROM</span> s2 <span class="keyword">WHERE</span> key3 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>我们最开始的感觉就是这种不相关的<code>IN</code>子查询和不相关的标量子查询或者行子查询是一样一样的，都是把外层查询和子查询当作两个独立的单表查询来对待，可是很遗憾的是设计<code>MySQL</code>的大叔为了优化<code>IN</code>子查询倾注了太多心血（毕竟<code>IN</code>子查询是我们日常生活中最常用的子查询类型），所以整个执行过程并不像我们想象的那么简单(&gt;_&lt;)。</p>
<p>其实说句老实话，对于不相关的<code>IN</code>子查询来说，如果子查询的结果集中的记录条数很少，那么把子查询和外层查询分别看成两个单独的单表查询效率还是蛮高的，但是如果单独执行子查询后的结果集太多的话，就会导致这些问题：</p>
<ul>
<li><p>结果集太多，可能内存中都放不下～</p>
</li>
<li><p>对于外层查询来说，如果子查询的结果集太多，那就意味着<code>IN</code>子句中的参数特别多，这就导致：</p>
<ul>
<li><p>无法有效的使用索引，只能对外层查询进行全表扫描。</p>
</li>
<li><p>在对外层查询执行全表扫描时，由于<code>IN</code>子句中的参数太多，这会导致检测一条记录是否符合和<code>IN</code>子句中的参数匹配花费的时间太长。</p>
<p>比如说<code>IN</code>子句中的参数只有两个：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> tbl_name <span class="keyword">WHERE</span> <span class="keyword">column</span> <span class="keyword">IN</span> (a, b);</span><br></pre></td></tr></table></figure>

<p>这样相当于需要对<code>tbl_name</code>表中的每条记录判断一下它的<code>column</code>列是否符合<code>column = a OR column = b</code>。在<code>IN</code>子句中的参数比较少时这并不是什么问题，如果<code>IN</code>子句中的参数比较多时，比如这样：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> tbl_name <span class="keyword">WHERE</span> <span class="keyword">column</span> <span class="keyword">IN</span> (a, b, c ..., ...);</span><br></pre></td></tr></table></figure>

<p>那么这样每条记录需要判断一下它的<code>column</code>列是否符合<code>column = a OR column = b OR column = c OR ...</code>，这样性能耗费可就多了。</p>
</li>
</ul>
</li>
</ul>
<p>于是乎设计<code>MySQL</code>的大叔想了一个招：不直接将不相关子查询的结果集当作外层查询的参数，而是将该结果集写入一个临时表里。写入临时表的过程是这样的：</p>
<ul>
<li>该临时表的列就是子查询结果集中的列。</li>
<li>写入临时表的记录会被去重。</li>
</ul>
<p>我们说<code>IN</code>语句是判断某个操作数在不在某个集合中，集合中的值重不重复对整个<code>IN</code>语句的结果并没有啥子关系，所以我们在将结果集写入临时表时对记录进行去重可以让临时表变得更小，更省地方～</p>
<blockquote>
<p>临时表如何对记录进行去重？这不是小意思嘛，临时表也是个表，只要为表中记录的所有列建立主键或者唯一索引就好了嘛～</p>
</blockquote>
<ul>
<li><p>一般情况下子查询结果集不会大的离谱，所以会为它建立基于内存的使用<code>Memory</code>存储引擎的临时表，而且会为该表建立哈希索引。</p>
<blockquote>
<p>IN语句的本质就是判断某个操作数在不在某个集合里，如果集合中的数据建立了哈希索引，那么这个匹配的过程就是超级快的。</p>
</blockquote>
<p>如果子查询的结果集非常大，超过了系统变量<code>tmp_table_size</code>或者<code>max_heap_table_size</code>，临时表会转而使用基于磁盘的存储引擎来保存结果集中的记录，索引类型也对应转变为<code>B+</code>树索引。</p>
</li>
</ul>
<p>设计<code>MySQL</code>的大叔把这个将子查询结果集中的记录保存到临时表的过程称之为<code>物化</code>（英文名：<code>Materialize</code>）。为了方便起见，我们就把那个存储子查询结果集的临时表称之为<code>物化表</code>。正因为物化表中的记录都建立了索引（基于内存的物化表有哈希索引，基于磁盘的有B+树索引），通过索引执行<code>IN</code>语句判断某个操作数在不在子查询结果集中变得非常快，从而提升了子查询语句的性能。</p>
<h5 id="物化表转连接"><a href="#物化表转连接" class="headerlink" title="物化表转连接"></a>物化表转连接</h5><p>事情到这就完了？我们还得重新审视一下最开始的那个查询语句：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 </span><br><span class="line">    <span class="keyword">WHERE</span> key1 <span class="keyword">IN</span> (<span class="keyword">SELECT</span> common_field <span class="keyword">FROM</span> s2 <span class="keyword">WHERE</span> key3 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>当我们把子查询进行物化之后，假设子查询物化表的名称为<code>materialized_table</code>，该物化表存储的子查询结果集的列为<code>m_val</code>，那么这个查询其实可以从下边两种角度来看待：</p>
<ul>
<li><p>从表<code>s1</code>的角度来看待，整个查询的意思其实是：对于<code>s1</code>表中的每条记录来说，如果该记录的<code>key1</code>列的值在子查询对应的物化表中，则该记录会被加入最终的结果集。画个图表示一下就是这样：</p>
<p><img src="/../../../../../../imgs/MySQL%E5%8E%9F%E7%90%86%E4%B9%8B%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E7%AF%87/16a8dda5369e68c5tplv-t2oaga2asx-jj-mark1890000q75.webp" alt="image_1cvfj9up26i518t91li5ooq1r0u2d.png-84.9kB"> </p>
</li>
<li><p>从子查询物化表的角度来看待，整个查询的意思其实是：对于子查询物化表的每个值来说，如果能在<code>s1</code>表中找到对应的<code>key1</code>列的值与该值相等的记录，那么就把这些记录加入到最终的结果集。画个图表示一下就是这样：</p>
<p><img src="/../../../../../../imgs/MySQL%E5%8E%9F%E7%90%86%E4%B9%8B%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E7%AF%87/16a8dda5394d3903tplv-t2oaga2asx-jj-mark1890000q75.webp" alt="image_1cvfjg3os1oh1e3o5c11dhd1odd2q.png-67.4kB"> </p>
<p>也就是说其实上边的查询就相当于表<code>s1</code>和子查询物化表<code>materialized_table</code>进行内连接：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> s1.<span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> materialized_table <span class="keyword">ON</span> key1 <span class="operator">=</span> m_val;</span><br></pre></td></tr></table></figure>

<p>转化成内连接之后就有意思了，查询优化器可以评估不同连接顺序需要的成本是多少，选取成本最低的那种查询方式执行查询。我们分析一下上述查询中使用外层查询的表<code>s1</code>和物化表<code>materialized_table</code>进行内连接的成本都是由哪几部分组成的：</p>
<ul>
<li>如果使用<code>s1</code>表作为驱动表的话，总查询成本由下边几个部分组成：<ul>
<li>物化子查询时需要的成本</li>
<li>扫描<code>s1</code>表时的成本</li>
<li>s1表中的记录数量 × 通过<code>m_val = xxx</code>对<code>materialized_table</code>表进行单表访问的成本（我们前边说过物化表中的记录是不重复的，并且为物化表中的列建立了索引，所以这个步骤显然是非常快的）。</li>
</ul>
</li>
<li>如果使用<code>materialized_table</code>表作为驱动表的话，总查询成本由下边几个部分组成：<ul>
<li>物化子查询时需要的成本</li>
<li>扫描物化表时的成本</li>
<li>物化表中的记录数量 × 通过<code>key1 = xxx</code>对<code>s1</code>表进行单表访问的成本（非常庆幸<code>key1</code>列上建立了索引，所以这个步骤是非常快的）。</li>
</ul>
</li>
</ul>
<p><code>MySQL</code>查询优化器会通过运算来选择上述成本更低的方案来执行查询。</p>
</li>
</ul>
<h5 id="将子查询转换为semi-join"><a href="#将子查询转换为semi-join" class="headerlink" title="将子查询转换为semi-join"></a>将子查询转换为semi-join</h5><p>虽然将子查询进行物化之后再执行查询都会有建立临时表的成本，但是不管怎么说，我们见识到了将子查询转换为连接的强大作用，设计<code>MySQL</code>的大叔继续开脑洞：能不能不进行物化操作直接把子查询转换为连接呢？让我们重新审视一下上边的查询语句：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 </span><br><span class="line">    <span class="keyword">WHERE</span> key1 <span class="keyword">IN</span> (<span class="keyword">SELECT</span> common_field <span class="keyword">FROM</span> s2 <span class="keyword">WHERE</span> key3 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>我们可以把这个查询理解成：对于<code>s1</code>表中的某条记录，如果我们能在<code>s2</code>表（准确的说是执行完<code>WHERE s2.key3 = &#39;a&#39;</code>之后的结果集）中找到一条或多条记录，这些记录的<code>common_field</code>的值等于<code>s1</code>表记录的<code>key1</code>列的值，那么该条<code>s1</code>表的记录就会被加入到最终的结果集。这个过程其实和把<code>s1</code>和<code>s2</code>两个表连接起来的效果很像：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> s1.<span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> s2 </span><br><span class="line">    <span class="keyword">ON</span> s1.key1 <span class="operator">=</span> s2.common_field </span><br><span class="line">    <span class="keyword">WHERE</span> s2.key3 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>只不过我们不能保证对于<code>s1</code>表的某条记录来说，在<code>s2</code>表（准确的说是执行完<code>WHERE s2.key3 = &#39;a&#39;</code>之后的结果集）中有多少条记录满足<code>s1.key1 = s2.common_field</code>这个条件，不过我们可以分三种情况讨论：</p>
<ul>
<li>情况一：对于<code>s1</code>表的某条记录来说，<code>s2</code>表中没有任何记录满足<code>s1.key1 = s2.common_field</code>这个条件，那么该记录自然也不会加入到最后的结果集。</li>
<li>情况二：对于<code>s1</code>表的某条记录来说，<code>s2</code>表中有且只有1条记录满足<code>s1.key1 = s2.common_field</code>这个条件，那么该记录会被加入最终的结果集。</li>
<li>情况三：对于<code>s1</code>表的某条记录来说，<code>s2</code>表中至少有2条记录满足<code>s1.key1 = s2.common_field</code>这个条件，那么该记录会被多次加入最终的结果集。</li>
</ul>
<p>对于<code>s1</code>表的某条记录来说，由于我们只关心<code>s2</code>表中是否存在记录满足<code>s1.key1 = s2.common_field</code>这个条件，而不关心具体有多少条记录与之匹配，又因为有<code>情况三</code>的存在，我们上边所说的<code>IN</code>子查询和两表连接之间并不完全等价。但是将子查询转换为连接又真的可以充分发挥优化器的作用，所以设计<code>MySQL</code>的大叔在这里提出了一个新概念 — <code>半连接</code>（英文名：<code>semi-join</code>）。将<code>s1</code>表和<code>s2</code>表进行半连接的意思就是：对于<code>s1</code>表的某条记录来说，我们只关心在<code>s2</code>表中是否存在与之匹配的记录，而不关心具体有多少条记录与之匹配，最终的结果集中只保留<code>s1</code>表的记录。为了让大家有更直观的感受，我们假设MySQL内部是这么改写上边的子查询的：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> s1.<span class="operator">*</span> <span class="keyword">FROM</span> s1 SEMI <span class="keyword">JOIN</span> s2</span><br><span class="line">    <span class="keyword">ON</span> s1.key1 <span class="operator">=</span> s2.common_field</span><br><span class="line">    <span class="keyword">WHERE</span> key3 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>semi-join只是在MySQL内部采用的一种执行子查询的方式，MySQL并没有提供面向用户的semi-join语法，所以我们不需要，也不能尝试把上边这个语句放到黑框框里运行，我只是想说明一下上边的子查询在MySQL内部会被转换为类似上边语句的半连接～</p>
</blockquote>
<p>概念是有了，怎么实现这种所谓的<code>半连接</code>呢？设计<code>MySQL</code>的大叔准备了好几种办法。</p>
<ul>
<li><p>Table pullout （子查询中的表上拉）</p>
<p>当子查询的查询列表处只有主键或者唯一索引列时，可以直接把子查询中的表<code>上拉</code>到外层查询的<code>FROM</code>子句中，并把子查询中的搜索条件合并到外层查询的搜索条件中，比如这个</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 </span><br><span class="line">    <span class="keyword">WHERE</span> key2 <span class="keyword">IN</span> (<span class="keyword">SELECT</span> key2 <span class="keyword">FROM</span> s2 <span class="keyword">WHERE</span> key3 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>由于<code>key2</code>列是<code>s2</code>表的唯一二级索引列，所以我们可以直接把<code>s2</code>表上拉到外层查询的<code>FROM</code>子句中，并且把子查询中的搜索条件合并到外层查询的搜索条件中，上拉之后的查询就是这样的：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> s1.<span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> s2 </span><br><span class="line">    <span class="keyword">ON</span> s1.key2 <span class="operator">=</span> s2.key2 </span><br><span class="line">    <span class="keyword">WHERE</span> s2.key3 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>为啥当子查询的查询列表处只有主键或者唯一索引列时，就可以直接将子查询转换为连接查询呢？哎呀，主键或者唯一索引列中的数据本身就是不重复的嘛！所以对于同一条<code>s1</code>表中的记录，你不可能找到两条以上的符合<code>s1.key2 = s2.key2</code>的记录呀～</p>
</li>
<li><p>DuplicateWeedout execution strategy （重复值消除）</p>
<p>对于这个查询来说：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 </span><br><span class="line">    <span class="keyword">WHERE</span> key1 <span class="keyword">IN</span> (<span class="keyword">SELECT</span> common_field <span class="keyword">FROM</span> s2 <span class="keyword">WHERE</span> key3 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>转换为半连接查询后，<code>s1</code>表中的某条记录可能在<code>s2</code>表中有多条匹配的记录，所以该条记录可能多次被添加到最后的结果集中，为了消除重复，我们可以建立一个临时表，比方说这个临时表长这样：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> tmp (</span><br><span class="line">    id <span class="keyword">PRIMARY</span> KEY</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>这样在执行连接查询的过程中，每当某条<code>s1</code>表中的记录要加入结果集时，就首先把这条记录的<code>id</code>值加入到这个临时表里，如果添加成功，说明之前这条<code>s1</code>表中的记录并没有加入最终的结果集，现在把该记录添加到最终的结果集；如果添加失败，说明之前这条<code>s1</code>表中的记录已经加入过最终的结果集，这里直接把它丢弃就好了，这种使用临时表消除<code>semi-join</code>结果集中的重复值的方式称之为<code>DuplicateWeedout</code>。</p>
</li>
<li><p>LooseScan execution strategy （松散扫描）</p>
<p>大家看这个查询：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 </span><br><span class="line">    <span class="keyword">WHERE</span> key3 <span class="keyword">IN</span> (<span class="keyword">SELECT</span> key1 <span class="keyword">FROM</span> s2 <span class="keyword">WHERE</span> key1 <span class="operator">&gt;</span> <span class="string">&#x27;a&#x27;</span> <span class="keyword">AND</span> key1 <span class="operator">&lt;</span> <span class="string">&#x27;b&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>在子查询中，对于<code>s2</code>表的访问可以使用到<code>key1</code>列的索引，而恰好子查询的查询列表处就是<code>key1</code>列，这样在将该查询转换为半连接查询后，如果将<code>s2</code>作为驱动表执行查询的话，那么执行过程就是这样：</p>
<p><img src="/../../../../../../imgs/MySQL%E5%8E%9F%E7%90%86%E4%B9%8B%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E7%AF%87/16ecb503727bb15etplv-t2oaga2asx-jj-mark1890000q75.webp" alt="img"> </p>
<p>如图所示，在<code>s2</code>表的<code>idx_key1</code>索引中，值为<code>&#39;aa&#39;</code>的二级索引记录一共有3条，那么只需要取第一条的值到<code>s1</code>表中查找<code>s1.key3 = &#39;aa&#39;</code>的记录，如果能在<code>s1</code>表中找到对应的记录，那么就把对应的记录加入到结果集。依此类推，其他值相同的二级索引记录，也只需要取第一条记录的值到<code>s1</code>表中找匹配的记录，这种虽然是扫描索引，但只取值相同的记录的第一条去做匹配操作的方式称之为<code>松散扫描</code>。</p>
</li>
<li><p>Semi-join Materialization execution strategy</p>
<p>我们之前介绍的先把外层查询的<code>IN</code>子句中的不相关子查询进行物化，然后再进行外层查询的表和物化表的连接本质上也算是一种<code>semi-join</code>，只不过由于物化表中没有重复的记录，所以可以直接将子查询转为连接查询。</p>
</li>
<li><p>FirstMatch execution strategy （首次匹配）</p>
<p><code>FirstMatch</code>是一种最原始的半连接执行方式，跟我们年少时认为的相关子查询的执行方式是一样一样的，就是说先取一条外层查询的中的记录，然后到子查询的表中寻找符合匹配条件的记录，如果能找到一条，则将该外层查询的记录放入最终的结果集并且停止查找更多匹配的记录，如果找不到则把该外层查询的记录丢弃掉；然后再开始取下一条外层查询中的记录，重复上边这个过程。</p>
</li>
</ul>
<p>对于某些使用<code>IN</code>语句的相关子查询，比方这个查询：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 </span><br><span class="line">    <span class="keyword">WHERE</span> key1 <span class="keyword">IN</span> (<span class="keyword">SELECT</span> common_field <span class="keyword">FROM</span> s2 <span class="keyword">WHERE</span> s1.key3 <span class="operator">=</span> s2.key3);</span><br></pre></td></tr></table></figure>

<p>它也可以很方便的转为半连接，转换后的语句类似这样：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> s1.<span class="operator">*</span> <span class="keyword">FROM</span> s1 SEMI <span class="keyword">JOIN</span> s2 </span><br><span class="line">    <span class="keyword">ON</span> s1.key1 <span class="operator">=</span> s2.common_field <span class="keyword">AND</span> s1.key3 <span class="operator">=</span> s2.key3;</span><br></pre></td></tr></table></figure>

<p>然后就可以使用我们上边介绍过的<code>DuplicateWeedout</code>、<code>LooseScan</code>、<code>FirstMatch</code>等半连接执行策略来执行查询，当然，如果子查询的查询列表处只有主键或者唯一二级索引列，还可以直接使用<code>table pullout</code>的策略来执行查询，但是需要大家注意的是，由于相关子查询并不是一个独立的查询，所以不能转换为物化表来执行查询。</p>
<h5 id="semi-join的适用条件"><a href="#semi-join的适用条件" class="headerlink" title="semi-join的适用条件"></a>semi-join的适用条件</h5><p>当然，并不是所有包含<code>IN</code>子查询的查询语句都可以转换为<code>semi-join</code>，只有形如这样的查询才可以被转换为<code>semi-join</code>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ... <span class="keyword">FROM</span> outer_tables </span><br><span class="line">    <span class="keyword">WHERE</span> expr <span class="keyword">IN</span> (<span class="keyword">SELECT</span> ... <span class="keyword">FROM</span> inner_tables ...) <span class="keyword">AND</span> ..</span><br></pre></td></tr></table></figure>

<p>用文字总结一下，只有符合下边这些条件的子查询才可以被转换为<code>semi-join</code>：</p>
<ul>
<li>该子查询必须是和<code>IN</code>语句组成的布尔表达式，并且在外层查询的<code>WHERE</code>或者<code>ON</code>子句中出现。</li>
<li>外层查询也可以有其他的搜索条件，只不过和<code>IN</code>子查询的搜索条件必须使用<code>AND</code>连接起来。</li>
<li>该子查询必须是一个单一的查询，不能是由若干查询由<code>UNION</code>连接起来的形式。</li>
<li>该子查询不能包含<code>GROUP BY</code>或者<code>HAVING</code>语句或者聚集函数。</li>
<li>… 还有一些条件比较少见，就不唠叨啦～</li>
</ul>
<h5 id="不适用于semi-join的情况"><a href="#不适用于semi-join的情况" class="headerlink" title="不适用于semi-join的情况"></a>不适用于semi-join的情况</h5><p>对于一些不能将子查询转位<code>semi-join</code>的情况，典型的比如下边这几种：</p>
<ul>
<li><p>外层查询的WHERE条件中有其他搜索条件与IN子查询组成的布尔表达式使用<code>OR</code>连接起来</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 </span><br><span class="line">    <span class="keyword">WHERE</span> key1 <span class="keyword">IN</span> (<span class="keyword">SELECT</span> common_field <span class="keyword">FROM</span> s2 <span class="keyword">WHERE</span> key3 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">        <span class="keyword">OR</span> key2 <span class="operator">&gt;</span> <span class="number">100</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用<code>NOT IN</code>而不是<code>IN</code>的情况</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 </span><br><span class="line">    <span class="keyword">WHERE</span> key1 <span class="keyword">NOT</span> <span class="keyword">IN</span> (<span class="keyword">SELECT</span> common_field <span class="keyword">FROM</span> s2 <span class="keyword">WHERE</span> key3 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>在<code>SELECT</code>子句中的IN子查询的情况</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> key1 <span class="keyword">IN</span> (<span class="keyword">SELECT</span> common_field <span class="keyword">FROM</span> s2 <span class="keyword">WHERE</span> key3 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>) <span class="keyword">FROM</span> s1 ;</span><br></pre></td></tr></table></figure>
</li>
<li><p>子查询中包含<code>GROUP BY</code>、<code>HAVING</code>或者聚集函数的情况</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 </span><br><span class="line">    <span class="keyword">WHERE</span> key2 <span class="keyword">IN</span> (<span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> s2 <span class="keyword">GROUP</span> <span class="keyword">BY</span> key1);</span><br></pre></td></tr></table></figure>
</li>
<li><p>子查询中包含<code>UNION</code>的情况</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key1 <span class="keyword">IN</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> common_field <span class="keyword">FROM</span> s2 <span class="keyword">WHERE</span> key3 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span> </span><br><span class="line">    <span class="keyword">UNION</span></span><br><span class="line">    <span class="keyword">SELECT</span> common_field <span class="keyword">FROM</span> s2 <span class="keyword">WHERE</span> key3 <span class="operator">=</span> <span class="string">&#x27;b&#x27;</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure></li>
</ul>
<p><code>MySQL</code>仍然留了两手绝活来优化不能转为<code>semi-join</code>查询的子查询，那就是：</p>
<ul>
<li><p>对于不相关子查询来说，可以尝试把它们物化之后再参与查询</p>
<p>比如我们上边提到的这个查询：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 </span><br><span class="line">    <span class="keyword">WHERE</span> key1 <span class="keyword">NOT</span> <span class="keyword">IN</span> (<span class="keyword">SELECT</span> common_field <span class="keyword">FROM</span> s2 <span class="keyword">WHERE</span> key3 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>先将子查询物化，然后再判断<code>key1</code>是否在物化表的结果集中可以加快查询执行的速度。</p>
<blockquote>
<p>请注意这里将子查询物化之后不能转为和外层查询的表的连接，只能是先扫描s1表，然后对s1表的某条记录来说，判断该记录的key1值在不在物化表中。</p>
</blockquote>
</li>
<li><p>不管子查询是相关的还是不相关的，都可以把<code>IN</code>子查询尝试转为<code>EXISTS</code>子查询</p>
<p>其实对于任意一个IN子查询来说，都可以被转为<code>EXISTS</code>子查询，通用的例子如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">outer_expr <span class="keyword">IN</span> (<span class="keyword">SELECT</span> inner_expr <span class="keyword">FROM</span> ... <span class="keyword">WHERE</span> subquery_where)</span><br></pre></td></tr></table></figure>

<p>可以被转换为：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXISTS</span> (<span class="keyword">SELECT</span> inner_expr <span class="keyword">FROM</span> ... <span class="keyword">WHERE</span> subquery_where <span class="keyword">AND</span> outer_expr<span class="operator">=</span>inner_expr)</span><br></pre></td></tr></table></figure>

<p>当然这个过程中有一些特殊情况，比如在<code>outer_expr</code>或者<code>inner_expr</code>值为<code>NULL</code>的情况下就比较特殊。但是幸运的是，我们大部分使用<code>IN</code>子查询的场景是把它放在<code>WHERE</code>或者<code>ON</code>子句中，而<code>WHERE</code>或者<code>ON</code>子句是不区分<code>NULL</code>和<code>FALSE</code>的，比方说：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="number">1</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> <span class="keyword">NULL</span>;</span><br><span class="line"><span class="keyword">Empty</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="number">1</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> <span class="literal">FALSE</span>;</span><br><span class="line"><span class="keyword">Empty</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

<p>所以只要我们的<code>IN</code>子查询是放在<code>WHERE</code>或者<code>ON</code>子句中的，那么<code>IN -&gt; EXISTS</code>的转换就是没问题的。说了这么多，为啥要转换呢？这是因为不转换的话可能用不到索引，比方说下边这个查询：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1</span><br><span class="line">    <span class="keyword">WHERE</span> key1 <span class="keyword">IN</span> (<span class="keyword">SELECT</span> key3 <span class="keyword">FROM</span> s2 <span class="keyword">where</span> s1.common_field <span class="operator">=</span> s2.common_field) </span><br><span class="line">        <span class="keyword">OR</span> key2 <span class="operator">&gt;</span> <span class="number">1000</span>;</span><br></pre></td></tr></table></figure>

<p>这个查询中的子查询是一个相关子查询，而且子查询执行的时候不能使用到索引，但是将它转为<code>EXISTS</code>子查询后却可以使用到索引：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1</span><br><span class="line">    <span class="keyword">WHERE</span> <span class="keyword">EXISTS</span> (<span class="keyword">SELECT</span> <span class="number">1</span> <span class="keyword">FROM</span> s2 <span class="keyword">where</span> s1.common_field <span class="operator">=</span> s2.common_field <span class="keyword">AND</span> s2.key3 <span class="operator">=</span> s1.key1) </span><br><span class="line">        <span class="keyword">OR</span> key2 <span class="operator">&gt;</span> <span class="number">1000</span>;</span><br></pre></td></tr></table></figure>

<p>转为<code>EXISTS</code>子查询时便可以使用到<code>s2</code>表的<code>idx_key3</code>索引了。</p>
<p>需要注意的是，如果<code>IN</code>子查询不满足转换为<code>semi-join</code>的条件，又不能转换为物化表或者转换为物化表的成本太大，那么它就会被转换为<code>EXISTS</code>查询。</p>
<blockquote>
<p>在MySQL5.5以及之前的版本没有引进semi-join和物化的方式优化子查询时，优化器都会把IN子查询转换为EXISTS子查询，好多同学就惊呼我明明写的是一个不相关子查询，为啥要按照执行相关子查询的方式来执行呢？所以当时好多声音都是建议大家把子查询转为连接，不过随着MySQL的发展，最近的版本中引入了非常多的子查询优化策略，大家可以稍微放心的使用子查询了，内部的转换工作优化器会为大家自动实现。</p>
</blockquote>
</li>
</ul>
<h5 id="ANY-x2F-ALL子查询优化"><a href="#ANY-x2F-ALL子查询优化" class="headerlink" title="ANY&#x2F;ALL子查询优化"></a>ANY&#x2F;ALL子查询优化</h5><p>如果ANY&#x2F;ALL子查询是不相关子查询的话，它们在很多场合都能转换成我们熟悉的方式去执行，比方说：</p>
<p><img src="/../../../../../../imgs/MySQL%E5%8E%9F%E7%90%86%E4%B9%8B%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E7%AF%87/image-20231219151453493.png" alt="image-20231219151453493"> </p>
<h5 id="NOT-EXISTS子查询的执行"><a href="#NOT-EXISTS子查询的执行" class="headerlink" title="[NOT] EXISTS子查询的执行"></a>[NOT] EXISTS子查询的执行</h5><p>如果<code>[NOT] EXISTS</code>子查询是不相关子查询，可以先执行子查询，得出该<code>[NOT] EXISTS</code>子查询的结果是<code>TRUE</code>还是<code>FALSE</code>，并重写原先的查询语句，比如对这个查询来说：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 </span><br><span class="line">    <span class="keyword">WHERE</span> <span class="keyword">EXISTS</span> (<span class="keyword">SELECT</span> <span class="number">1</span> <span class="keyword">FROM</span> s2 <span class="keyword">WHERE</span> key1 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>) </span><br><span class="line">        <span class="keyword">OR</span> key2 <span class="operator">&gt;</span> <span class="number">100</span>;</span><br></pre></td></tr></table></figure>

<p>因为这个语句里的子查询是不相关子查询，所以优化器会首先执行该子查询，假设该EXISTS子查询的结果为<code>TRUE</code>，那么接着优化器会重写查询为：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 </span><br><span class="line">    <span class="keyword">WHERE</span> <span class="literal">TRUE</span> <span class="keyword">OR</span> key2 <span class="operator">&gt;</span> <span class="number">100</span>;</span><br></pre></td></tr></table></figure>

<p>进一步简化后就变成了：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 </span><br><span class="line">    <span class="keyword">WHERE</span> <span class="literal">TRUE</span>;</span><br></pre></td></tr></table></figure>

<p>对于相关的<code>[NOT] EXISTS</code>子查询来说，比如这个查询：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 </span><br><span class="line">    <span class="keyword">WHERE</span> <span class="keyword">EXISTS</span> (<span class="keyword">SELECT</span> <span class="number">1</span> <span class="keyword">FROM</span> s2 <span class="keyword">WHERE</span> s1.common_field <span class="operator">=</span> s2.common_field);</span><br></pre></td></tr></table></figure>

<p>很不幸，这个查询只能按照我们年少时的那种执行相关子查询的方式来执行。不过如果<code>[NOT] EXISTS</code>子查询中如果可以使用索引的话，那查询速度也会加快不少，比如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 </span><br><span class="line">    <span class="keyword">WHERE</span> <span class="keyword">EXISTS</span> (<span class="keyword">SELECT</span> <span class="number">1</span> <span class="keyword">FROM</span> s2 <span class="keyword">WHERE</span> s1.common_field <span class="operator">=</span> s2.key1);</span><br></pre></td></tr></table></figure>

<p>上边这个<code>EXISTS</code>子查询中可以使用<code>idx_key1</code>来加快查询速度。</p>
<h5 id="对于派生表的优化"><a href="#对于派生表的优化" class="headerlink" title="对于派生表的优化"></a>对于派生表的优化</h5><p>我们前边说过把子查询放在外层查询的<code>FROM</code>子句后，那么这个子查询的结果相当于一个<code>派生表</code>，比如下边这个查询：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span>  (</span><br><span class="line">        <span class="keyword">SELECT</span> id <span class="keyword">AS</span> d_id, key3 <span class="keyword">AS</span> d_key3 <span class="keyword">FROM</span> s2 <span class="keyword">WHERE</span> key1 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span></span><br><span class="line">    ) <span class="keyword">AS</span> derived_s1 <span class="keyword">WHERE</span> d_key3 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>子查询<code>( SELECT id AS d_id, key3 AS d_key3 FROM s2 WHERE key1 = &#39;a&#39;)</code>的结果就相当于一个派生表，这个表的名称是<code>derived_s1</code>，该表有两个列，分别是<code>d_id</code>和<code>d_key3</code>。</p>
<p>对于含有<code>派生表</code>的查询，<code>MySQL</code>提供了两种执行策略：</p>
<ul>
<li><p>最容易想到的就是把派生表物化。</p>
<p>我们可以将派生表的结果集写到一个内部的临时表中，然后就把这个物化表当作普通表一样参与查询。当然，在对派生表进行物化时，设计<code>MySQL</code>的大叔使用了一种称为<code>延迟物化</code>的策略，也就是在查询中真正使用到派生表时才回去尝试物化派生表，而不是还没开始执行查询呢就把派生表物化掉。比方说对于下边这个含有派生表的查询来说：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> (</span><br><span class="line">        <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key1 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span></span><br><span class="line">    ) <span class="keyword">AS</span> derived_s1 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> s2</span><br><span class="line">    <span class="keyword">ON</span> derived_s1.key1 <span class="operator">=</span> s2.key1</span><br><span class="line">    <span class="keyword">WHERE</span> s2.key2 <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>如果采用物化派生表的方式来执行这个查询的话，那么执行时首先会到<code>s2</code>表中找出满足<code>s2.key2 = 1</code>的记录，如果压根儿找不到，说明参与连接的<code>s2</code>表记录就是空的，所以整个查询的结果集就是空的，所以也就没有必要去物化查询中的派生表了。</p>
</li>
<li><p>将派生表和外层的表合并，也就是将查询重写为没有派生表的形式</p>
<p>我们来看这个贼简单的包含派生表的查询：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> (<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key1 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>) <span class="keyword">AS</span> derived_s1;</span><br></pre></td></tr></table></figure>

<p>这个查询本质上就是想查看<code>s1</code>表中满足<code>key1 = &#39;a&#39;</code>条件的的全部记录，所以和下边这个语句是等价的：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key1 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>对于一些稍微复杂的包含派生表的语句，比如我们上边提到的那个：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> (</span><br><span class="line">        <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key1 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span></span><br><span class="line">    ) <span class="keyword">AS</span> derived_s1 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> s2</span><br><span class="line">    <span class="keyword">ON</span> derived_s1.key1 <span class="operator">=</span> s2.key1</span><br><span class="line">    <span class="keyword">WHERE</span> s2.key2 <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>我们可以将派生表与外层查询的表合并，然后将派生表中的搜索条件放到外层查询的搜索条件中，就像这样：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> s2 </span><br><span class="line">    <span class="keyword">ON</span> s1.key1 <span class="operator">=</span> s2.key1</span><br><span class="line">    <span class="keyword">WHERE</span> s1.key1 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span> <span class="keyword">AND</span> s2.key2 <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>这样通过将外层查询和派生表合并的方式成功的消除了派生表，也就意味着我们没必要再付出创建和访问临时表的成本了。可是并不是所有带有派生表的查询都能被成功的和外层查询合并，当派生表中有这些语句就不可以和外层查询合并：</p>
<ul>
<li>聚集函数，比如MAX()、MIN()、SUM()啥的</li>
<li>DISTINCT</li>
<li>GROUP BY</li>
<li>HAVING</li>
<li>LIMIT</li>
<li>UNION 或者 UNION ALL</li>
<li>派生表对应的子查询的<code>SELECT</code>子句中含有另一个子查询</li>
<li>… 还有些不常用的情况就不多说了哈～</li>
</ul>
</li>
</ul>
<p>所以<code>MySQL</code>在执行带有派生表的时候，优先尝试把派生表和外层查询合并掉，如果不行的话，再把派生表物化掉执行查询。</p>

  </div>
</article>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
        
          <li><a href="/">Home</a></li>
        
          <li><a href="/about/">About</a></li>
        
          <li><a href="/archives/">Writing</a></li>
        
          <li><a href="/tags/">Tag</a></li>
        
          <li><a target="_blank" rel="noopener" href="http://github.com/hulingF">Projects</a></li>
        
      </ul>
    </div>

    
    
      <div id="toc-footer" style="display: none">
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#MySQL%E5%8E%9F%E7%90%86%E4%B9%8B%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E7%AF%87"><span class="toc-number">1.</span> <span class="toc-text">MySQL原理之查询优化篇</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81MySQL%E5%9F%BA%E4%BA%8E%E6%88%90%E6%9C%AC%E7%9A%84%E4%BC%98%E5%8C%96"><span class="toc-number">1.1.</span> <span class="toc-text">一、MySQL基于成本的优化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1%E5%8D%95%E8%A1%A8%E6%9F%A5%E8%AF%A2%E7%9A%84%E6%88%90%E6%9C%AC"><span class="toc-number">1.1.1.</span> <span class="toc-text">1.1单表查询的成本</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2%E5%9F%BA%E4%BA%8E%E6%88%90%E6%9C%AC%E7%9A%84%E4%BC%98%E5%8C%96%E6%AD%A5%E9%AA%A4"><span class="toc-number">1.1.2.</span> <span class="toc-text">1.2基于成本的优化步骤</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-1%E6%A0%B9%E6%8D%AE%E6%90%9C%E7%B4%A2%E6%9D%A1%E4%BB%B6%EF%BC%8C%E6%89%BE%E5%87%BA%E6%89%80%E6%9C%89%E5%8F%AF%E8%83%BD%E4%BD%BF%E7%94%A8%E7%9A%84%E7%B4%A2%E5%BC%95"><span class="toc-number">1.1.2.1.</span> <span class="toc-text">1.2.1根据搜索条件，找出所有可能使用的索引</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-2%E8%AE%A1%E7%AE%97%E5%85%A8%E8%A1%A8%E6%89%AB%E6%8F%8F%E7%9A%84%E4%BB%A3%E4%BB%B7"><span class="toc-number">1.1.2.2.</span> <span class="toc-text">1.2.2计算全表扫描的代价</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-3%E8%AE%A1%E7%AE%97%E4%BD%BF%E7%94%A8%E4%B8%8D%E5%90%8C%E7%B4%A2%E5%BC%95%E6%89%A7%E8%A1%8C%E6%9F%A5%E8%AF%A2%E7%9A%84%E4%BB%A3%E4%BB%B7"><span class="toc-number">1.1.2.3.</span> <span class="toc-text">1.2.3计算使用不同索引执行查询的代价</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8idx-key2%E6%89%A7%E8%A1%8C%E6%9F%A5%E8%AF%A2%E7%9A%84%E6%88%90%E6%9C%AC%E5%88%86%E6%9E%90"><span class="toc-number">1.1.2.3.1.</span> <span class="toc-text">使用idx_key2执行查询的成本分析</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8idx-key1%E6%89%A7%E8%A1%8C%E6%9F%A5%E8%AF%A2%E7%9A%84%E6%88%90%E6%9C%AC%E5%88%86%E6%9E%90"><span class="toc-number">1.1.2.3.2.</span> <span class="toc-text">使用idx_key1执行查询的成本分析</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%98%AF%E5%90%A6%E6%9C%89%E5%8F%AF%E8%83%BD%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95%E5%90%88%E5%B9%B6%EF%BC%88Index-Merge%EF%BC%89"><span class="toc-number">1.1.2.3.3.</span> <span class="toc-text">是否有可能使用索引合并（Index Merge）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-4%E5%AF%B9%E6%AF%94%E5%90%84%E7%A7%8D%E6%89%A7%E8%A1%8C%E6%96%B9%E6%A1%88%E7%9A%84%E4%BB%A3%E4%BB%B7%EF%BC%8C%E6%89%BE%E5%87%BA%E6%88%90%E6%9C%AC%E6%9C%80%E4%BD%8E%E7%9A%84%E6%96%B9%E6%A1%88"><span class="toc-number">1.1.2.4.</span> <span class="toc-text">1.2.4对比各种执行方案的代价，找出成本最低的方案</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3%E5%9F%BA%E4%BA%8E%E7%B4%A2%E5%BC%95%E7%BB%9F%E8%AE%A1%E6%95%B0%E6%8D%AE%E7%9A%84%E6%88%90%E6%9C%AC%E8%AE%A1%E7%AE%97"><span class="toc-number">1.1.3.</span> <span class="toc-text">1.3基于索引统计数据的成本计算</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2%E7%9A%84%E6%88%90%E6%9C%AC"><span class="toc-number">1.1.4.</span> <span class="toc-text">1.4连接查询的成本</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-1Condition-filtering%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.1.4.1.</span> <span class="toc-text">1.4.1Condition filtering介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-2%E4%B8%A4%E8%A1%A8%E8%BF%9E%E6%8E%A5%E7%9A%84%E6%88%90%E6%9C%AC%E5%88%86%E6%9E%90"><span class="toc-number">1.1.4.2.</span> <span class="toc-text">1.4.2两表连接的成本分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-3%E5%A4%9A%E8%A1%A8%E8%BF%9E%E6%8E%A5%E7%9A%84%E6%88%90%E6%9C%AC%E5%88%86%E6%9E%90"><span class="toc-number">1.1.4.3.</span> <span class="toc-text">1.4.3多表连接的成本分析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5%E8%B0%83%E8%8A%82%E6%88%90%E6%9C%AC%E5%B8%B8%E6%95%B0"><span class="toc-number">1.1.5.</span> <span class="toc-text">1.5调节成本常数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-5-1mysql-server-cost%E8%A1%A8"><span class="toc-number">1.1.5.1.</span> <span class="toc-text">1.5.1mysql.server_cost表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-5-2mysql-engine-cost%E8%A1%A8"><span class="toc-number">1.1.5.2.</span> <span class="toc-text">1.5.2mysql.engine_cost表</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81InnoDB%E7%9A%84%E7%BB%9F%E8%AE%A1%E6%95%B0%E6%8D%AE%E6%94%B6%E9%9B%86%E7%AD%96%E7%95%A5"><span class="toc-number">1.2.</span> <span class="toc-text">二、InnoDB的统计数据收集策略</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1%E4%B8%A4%E7%A7%8D%E4%B8%8D%E5%90%8C%E7%9A%84%E7%BB%9F%E8%AE%A1%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F"><span class="toc-number">1.2.1.</span> <span class="toc-text">2.1两种不同的统计数据存储方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2%E5%9F%BA%E4%BA%8E%E7%A3%81%E7%9B%98%E7%9A%84%E6%B0%B8%E4%B9%85%E6%80%A7%E7%BB%9F%E8%AE%A1%E6%95%B0%E6%8D%AE"><span class="toc-number">1.2.2.</span> <span class="toc-text">2.2基于磁盘的永久性统计数据</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-1innodb-table-stats"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">2.2.1innodb_table_stats</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#n-rows%E7%BB%9F%E8%AE%A1%E9%A1%B9%E7%9A%84%E6%94%B6%E9%9B%86"><span class="toc-number">1.2.2.1.1.</span> <span class="toc-text">n_rows统计项的收集</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#clustered-index-size%E7%BB%9F%E8%AE%A1%E9%A1%B9%E7%9A%84%E6%94%B6%E9%9B%86-x2F-sum-of-other-index-sizes%E7%BB%9F%E8%AE%A1%E9%A1%B9%E7%9A%84%E6%94%B6%E9%9B%86"><span class="toc-number">1.2.2.1.2.</span> <span class="toc-text">clustered_index_size统计项的收集&#x2F;sum_of_other_index_sizes统计项的收集</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-2innodb-index-stats"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">2.2.2innodb_index_stats</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-3%E5%AE%9A%E6%9C%9F%E6%9B%B4%E6%96%B0%E7%BB%9F%E8%AE%A1%E6%95%B0%E6%8D%AE"><span class="toc-number">1.2.2.3.</span> <span class="toc-text">2.2.3定期更新统计数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-4%E6%89%8B%E5%8A%A8%E6%9B%B4%E6%96%B0innodb-table-stats%E5%92%8Cinnodb-index-stats%E8%A1%A8"><span class="toc-number">1.2.2.4.</span> <span class="toc-text">2.2.4手动更新innodb_table_stats和innodb_index_stats表</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3%E5%9F%BA%E4%BA%8E%E5%86%85%E5%AD%98%E7%9A%84%E9%9D%9E%E6%B0%B8%E4%B9%85%E6%80%A7%E7%BB%9F%E8%AE%A1%E6%95%B0%E6%8D%AE"><span class="toc-number">1.2.3.</span> <span class="toc-text">2.3基于内存的非永久性统计数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4innodb-stats-method%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">1.2.4.</span> <span class="toc-text">2.4innodb_stats_method的使用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81MySQL%E5%9F%BA%E4%BA%8E%E8%A7%84%E5%88%99%E7%9A%84%E4%BC%98%E5%8C%96"><span class="toc-number">1.3.</span> <span class="toc-text">三、MySQL基于规则的优化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1%E6%9D%A1%E4%BB%B6%E5%8C%96%E7%AE%80"><span class="toc-number">1.3.1.</span> <span class="toc-text">3.1条件化简</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-1%E7%A7%BB%E9%99%A4%E4%B8%8D%E5%BF%85%E8%A6%81%E7%9A%84%E6%8B%AC%E5%8F%B7"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">3.1.1移除不必要的括号</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-2%E5%B8%B8%E9%87%8F%E4%BC%A0%E9%80%92constant-propagation"><span class="toc-number">1.3.1.2.</span> <span class="toc-text">3.1.2常量传递constant_propagation</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-3%E7%AD%89%E5%80%BC%E4%BC%A0%E9%80%92equality-propagation"><span class="toc-number">1.3.1.3.</span> <span class="toc-text">3.1.3等值传递equality_propagation</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-4%E7%A7%BB%E9%99%A4%E6%B2%A1%E7%94%A8%E7%9A%84%E6%9D%A1%E4%BB%B6trivial-condition-removal"><span class="toc-number">1.3.1.4.</span> <span class="toc-text">3.1.4移除没用的条件trivial_condition_removal</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-5%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AE%A1%E7%AE%97"><span class="toc-number">1.3.1.5.</span> <span class="toc-text">3.1.5表达式计算</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-6HAVING%E5%AD%90%E5%8F%A5%E5%92%8CWHERE%E5%AD%90%E5%8F%A5%E7%9A%84%E5%90%88%E5%B9%B6"><span class="toc-number">1.3.1.6.</span> <span class="toc-text">3.1.6HAVING子句和WHERE子句的合并</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-7%E5%B8%B8%E9%87%8F%E8%A1%A8%E6%A3%80%E6%B5%8B"><span class="toc-number">1.3.1.7.</span> <span class="toc-text">3.1.7常量表检测</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2%E5%A4%96%E8%BF%9E%E6%8E%A5%E6%B6%88%E9%99%A4"><span class="toc-number">1.3.2.</span> <span class="toc-text">3.2外连接消除</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3%E5%AD%90%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96"><span class="toc-number">1.3.3.</span> <span class="toc-text">3.3子查询优化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-1%E5%AD%90%E6%9F%A5%E8%AF%A2%E8%AF%AD%E6%B3%95"><span class="toc-number">1.3.3.1.</span> <span class="toc-text">3.3.1子查询语法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8C%89%E8%BF%94%E5%9B%9E%E7%9A%84%E7%BB%93%E6%9E%9C%E9%9B%86%E5%8C%BA%E5%88%86%E5%AD%90%E6%9F%A5%E8%AF%A2"><span class="toc-number">1.3.3.1.1.</span> <span class="toc-text">按返回的结果集区分子查询</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8C%89%E4%B8%8E%E5%A4%96%E5%B1%82%E6%9F%A5%E8%AF%A2%E5%85%B3%E7%B3%BB%E6%9D%A5%E5%8C%BA%E5%88%86%E5%AD%90%E6%9F%A5%E8%AF%A2"><span class="toc-number">1.3.3.1.2.</span> <span class="toc-text">按与外层查询关系来区分子查询</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AD%90%E6%9F%A5%E8%AF%A2%E5%9C%A8%E5%B8%83%E5%B0%94%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">1.3.3.1.3.</span> <span class="toc-text">子查询在布尔表达式中的使用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AD%90%E6%9F%A5%E8%AF%A2%E8%AF%AD%E6%B3%95%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">1.3.3.1.4.</span> <span class="toc-text">子查询语法注意事项</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-2%E5%AD%90%E6%9F%A5%E8%AF%A2%E5%9C%A8MySQL%E4%B8%AD%E6%98%AF%E6%80%8E%E4%B9%88%E6%89%A7%E8%A1%8C%E7%9A%84"><span class="toc-number">1.3.3.2.</span> <span class="toc-text">3.3.2子查询在MySQL中是怎么执行的</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B0%8F%E7%99%BD%E4%BB%AC%E7%9C%BC%E4%B8%AD%E5%AD%90%E6%9F%A5%E8%AF%A2%E7%9A%84%E6%89%A7%E8%A1%8C%E6%96%B9%E5%BC%8F"><span class="toc-number">1.3.3.2.1.</span> <span class="toc-text">小白们眼中子查询的执行方式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A0%87%E9%87%8F%E5%AD%90%E6%9F%A5%E8%AF%A2%E3%80%81%E8%A1%8C%E5%AD%90%E6%9F%A5%E8%AF%A2%E7%9A%84%E6%89%A7%E8%A1%8C%E6%96%B9%E5%BC%8F"><span class="toc-number">1.3.3.2.2.</span> <span class="toc-text">标量子查询、行子查询的执行方式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#IN%E5%AD%90%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96"><span class="toc-number">1.3.3.2.3.</span> <span class="toc-text">IN子查询优化</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%89%A9%E5%8C%96%E8%A1%A8%E8%BD%AC%E8%BF%9E%E6%8E%A5"><span class="toc-number">1.3.3.2.4.</span> <span class="toc-text">物化表转连接</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B0%86%E5%AD%90%E6%9F%A5%E8%AF%A2%E8%BD%AC%E6%8D%A2%E4%B8%BAsemi-join"><span class="toc-number">1.3.3.2.5.</span> <span class="toc-text">将子查询转换为semi-join</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#semi-join%E7%9A%84%E9%80%82%E7%94%A8%E6%9D%A1%E4%BB%B6"><span class="toc-number">1.3.3.2.6.</span> <span class="toc-text">semi-join的适用条件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%8D%E9%80%82%E7%94%A8%E4%BA%8Esemi-join%E7%9A%84%E6%83%85%E5%86%B5"><span class="toc-number">1.3.3.2.7.</span> <span class="toc-text">不适用于semi-join的情况</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#ANY-x2F-ALL%E5%AD%90%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96"><span class="toc-number">1.3.3.2.8.</span> <span class="toc-text">ANY&#x2F;ALL子查询优化</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#NOT-EXISTS%E5%AD%90%E6%9F%A5%E8%AF%A2%E7%9A%84%E6%89%A7%E8%A1%8C"><span class="toc-number">1.3.3.2.9.</span> <span class="toc-text">[NOT] EXISTS子查询的执行</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AF%B9%E4%BA%8E%E6%B4%BE%E7%94%9F%E8%A1%A8%E7%9A%84%E4%BC%98%E5%8C%96"><span class="toc-number">1.3.3.2.10.</span> <span class="toc-text">对于派生表的优化</span></a></li></ol></li></ol></li></ol></li></ol></li></ol>
      </div>
    

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://hulingf.github.io/2023/12/19/MySQL%E5%8E%9F%E7%90%86%E4%B9%8B%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E7%AF%87/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://hulingf.github.io/2023/12/19/MySQL%E5%8E%9F%E7%90%86%E4%B9%8B%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E7%AF%87/&text=MySQL原理之查询优化篇"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://hulingf.github.io/2023/12/19/MySQL%E5%8E%9F%E7%90%86%E4%B9%8B%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E7%AF%87/&title=MySQL原理之查询优化篇"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://hulingf.github.io/2023/12/19/MySQL%E5%8E%9F%E7%90%86%E4%B9%8B%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E7%AF%87/&is_video=false&description=MySQL原理之查询优化篇"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=MySQL原理之查询优化篇&body=Check out this article: https://hulingf.github.io/2023/12/19/MySQL%E5%8E%9F%E7%90%86%E4%B9%8B%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E7%AF%87/"><i class="fa-solid fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://hulingf.github.io/2023/12/19/MySQL%E5%8E%9F%E7%90%86%E4%B9%8B%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E7%AF%87/&title=MySQL原理之查询优化篇"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://hulingf.github.io/2023/12/19/MySQL%E5%8E%9F%E7%90%86%E4%B9%8B%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E7%AF%87/&title=MySQL原理之查询优化篇"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://hulingf.github.io/2023/12/19/MySQL%E5%8E%9F%E7%90%86%E4%B9%8B%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E7%AF%87/&title=MySQL原理之查询优化篇"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://hulingf.github.io/2023/12/19/MySQL%E5%8E%9F%E7%90%86%E4%B9%8B%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E7%AF%87/&title=MySQL原理之查询优化篇"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://hulingf.github.io/2023/12/19/MySQL%E5%8E%9F%E7%90%86%E4%B9%8B%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E7%AF%87/&name=MySQL原理之查询优化篇&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://hulingf.github.io/2023/12/19/MySQL%E5%8E%9F%E7%90%86%E4%B9%8B%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E7%AF%87/&t=MySQL原理之查询优化篇"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fa-solid fa-bars fa-lg" aria-hidden="true"></i> Menu</a>
        
          <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fa-solid fa-list fa-lg" aria-hidden="true"></i> TOC</a>
        
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fa-solid fa-share-alt fa-lg" aria-hidden="true"></i> Share</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2023
    hulingF
  </div>
  <div class="footer-right">
    <nav>
      <ul>
        <!--
       --><li><a href="/">Home</a></li><!--
     --><!--
       --><li><a href="/about/">About</a></li><!--
     --><!--
       --><li><a href="/archives/">Writing</a></li><!--
     --><!--
       --><li><a href="/tags/">Tag</a></li><!--
     --><!--
       --><li><a target="_blank" rel="noopener" href="http://github.com/hulingF">Projects</a></li><!--
     -->
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->



  <link rel="preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" crossorigin="anonymous" onload="this.onload=null;this.rel='stylesheet'"/>


    <!-- jquery -->

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" crossorigin="anonymous"></script>




<!-- clipboard -->

  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.7/clipboard.min.js" crossorigin="anonymous"></script>
  
  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"Copy to clipboard!\">";
    btn += '<i class="fa-regular fa-clone"></i>';
    btn += '</span>';
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "Copied!");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Disqus Comments -->

<!-- utterances Comments -->

</body>
</html>
