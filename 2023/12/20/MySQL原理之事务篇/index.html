<!DOCTYPE html>
<html lang=en>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5" />
    <meta name="description" content="MySQL原理之事务篇一、事务的简介1.1事务的起源对于大部分程序员来说，他们的任务就是把现实世界的业务场景映射到数据库世界。比如银行为了存储人们的账户信息会建立一个account表： 123456CREATE TABLE account (    id INT NOT NULL AUTO_INCREMENT COMMENT &amp;#x27;自增id&amp;#x27;,    name VARCHAR(10">
<meta property="og:type" content="article">
<meta property="og:title" content="MySQL原理之事务篇">
<meta property="og:url" content="https://hulingf.github.io/2023/12/20/MySQL%E5%8E%9F%E7%90%86%E4%B9%8B%E4%BA%8B%E5%8A%A1%E7%AF%87/index.html">
<meta property="og:site_name" content="大军的秘密花园">
<meta property="og:description" content="MySQL原理之事务篇一、事务的简介1.1事务的起源对于大部分程序员来说，他们的任务就是把现实世界的业务场景映射到数据库世界。比如银行为了存储人们的账户信息会建立一个account表： 123456CREATE TABLE account (    id INT NOT NULL AUTO_INCREMENT COMMENT &amp;#x27;自增id&amp;#x27;,    name VARCHAR(10">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://hulingf.github.io/imgs/MySQL%E5%8E%9F%E7%90%86%E4%B9%8B%E4%BA%8B%E5%8A%A1%E7%AF%87/169d7fd5bcbcc82ftplv-t2oaga2asx-jj-mark1890000q75.webp">
<meta property="og:image" content="https://hulingf.github.io/imgs/MySQL%E5%8E%9F%E7%90%86%E4%B9%8B%E4%BA%8B%E5%8A%A1%E7%AF%87/169d7fd5bd2cf68btplv-t2oaga2asx-jj-mark1890000q75.webp">
<meta property="og:image" content="https://hulingf.github.io/imgs/MySQL%E5%8E%9F%E7%90%86%E4%B9%8B%E4%BA%8B%E5%8A%A1%E7%AF%87/1694892fdec61898tplv-t2oaga2asx-jj-mark1890000q75.webp">
<meta property="og:image" content="https://hulingf.github.io/imgs/MySQL%E5%8E%9F%E7%90%86%E4%B9%8B%E4%BA%8B%E5%8A%A1%E7%AF%87/1694892fdf053082tplv-t2oaga2asx-jj-mark1890000q75.webp">
<meta property="og:image" content="https://hulingf.github.io/imgs/MySQL%E5%8E%9F%E7%90%86%E4%B9%8B%E4%BA%8B%E5%8A%A1%E7%AF%87/1694892fdf3da823tplv-t2oaga2asx-jj-mark1890000q75.webp">
<meta property="og:image" content="https://hulingf.github.io/imgs/MySQL%E5%8E%9F%E7%90%86%E4%B9%8B%E4%BA%8B%E5%8A%A1%E7%AF%87/1694892fdfa7d8cetplv-t2oaga2asx-jj-mark1890000q75.webp">
<meta property="og:image" content="https://hulingf.github.io/imgs/MySQL%E5%8E%9F%E7%90%86%E4%B9%8B%E4%BA%8B%E5%8A%A1%E7%AF%87/1694892fe02553d0tplv-t2oaga2asx-jj-mark1890000q75.webp">
<meta property="og:image" content="https://hulingf.github.io/imgs/MySQL%E5%8E%9F%E7%90%86%E4%B9%8B%E4%BA%8B%E5%8A%A1%E7%AF%87/1694892fe05a2603tplv-t2oaga2asx-jj-mark1890000q75.webp">
<meta property="og:image" content="https://hulingf.github.io/imgs/MySQL%E5%8E%9F%E7%90%86%E4%B9%8B%E4%BA%8B%E5%8A%A1%E7%AF%87/16948930120794a0tplv-t2oaga2asx-jj-mark1890000q75.webp">
<meta property="og:image" content="https://hulingf.github.io/imgs/MySQL%E5%8E%9F%E7%90%86%E4%B9%8B%E4%BA%8B%E5%8A%A1%E7%AF%87/1694893011fc216etplv-t2oaga2asx-jj-mark1890000q75.webp">
<meta property="og:image" content="https://hulingf.github.io/imgs/MySQL%E5%8E%9F%E7%90%86%E4%B9%8B%E4%BA%8B%E5%8A%A1%E7%AF%87/16948930147d598etplv-t2oaga2asx-jj-mark1890000q75.webp">
<meta property="og:image" content="https://hulingf.github.io/imgs/MySQL%E5%8E%9F%E7%90%86%E4%B9%8B%E4%BA%8B%E5%8A%A1%E7%AF%87/16948930162d677ftplv-t2oaga2asx-jj-mark1890000q75.webp">
<meta property="og:image" content="https://hulingf.github.io/imgs/MySQL%E5%8E%9F%E7%90%86%E4%B9%8B%E4%BA%8B%E5%8A%A1%E7%AF%87/16948930164d64a0tplv-t2oaga2asx-jj-mark1890000q75.webp">
<meta property="og:image" content="https://hulingf.github.io/imgs/MySQL%E5%8E%9F%E7%90%86%E4%B9%8B%E4%BA%8B%E5%8A%A1%E7%AF%87/169489301685dcb4tplv-t2oaga2asx-jj-mark1890000q75.webp">
<meta property="og:image" content="https://hulingf.github.io/imgs/MySQL%E5%8E%9F%E7%90%86%E4%B9%8B%E4%BA%8B%E5%8A%A1%E7%AF%87/169489303b9e5c9ftplv-t2oaga2asx-jj-mark1890000q75.webp">
<meta property="og:image" content="https://hulingf.github.io/imgs/MySQL%E5%8E%9F%E7%90%86%E4%B9%8B%E4%BA%8B%E5%8A%A1%E7%AF%87/169489303bff8e20tplv-t2oaga2asx-jj-mark1890000q75.webp">
<meta property="og:image" content="https://hulingf.github.io/imgs/MySQL%E5%8E%9F%E7%90%86%E4%B9%8B%E4%BA%8B%E5%8A%A1%E7%AF%87/169489303c1fb389tplv-t2oaga2asx-jj-mark1890000q75.webp">
<meta property="og:image" content="https://hulingf.github.io/imgs/MySQL%E5%8E%9F%E7%90%86%E4%B9%8B%E4%BA%8B%E5%8A%A1%E7%AF%87/169489303ceeb982tplv-t2oaga2asx-jj-mark1890000q75.webp">
<meta property="og:image" content="https://hulingf.github.io/imgs/MySQL%E5%8E%9F%E7%90%86%E4%B9%8B%E4%BA%8B%E5%8A%A1%E7%AF%87/1694893043dc7344tplv-t2oaga2asx-jj-mark1890000q75.webp">
<meta property="og:image" content="https://hulingf.github.io/imgs/MySQL%E5%8E%9F%E7%90%86%E4%B9%8B%E4%BA%8B%E5%8A%A1%E7%AF%87/1692548dcc3fe243tplv-t2oaga2asx-jj-mark1890000q75.webp">
<meta property="og:image" content="https://hulingf.github.io/imgs/MySQL%E5%8E%9F%E7%90%86%E4%B9%8B%E4%BA%8B%E5%8A%A1%E7%AF%87/169489304969c9d7tplv-t2oaga2asx-jj-mark1890000q75.webp">
<meta property="og:image" content="https://hulingf.github.io/imgs/MySQL%E5%8E%9F%E7%90%86%E4%B9%8B%E4%BA%8B%E5%8A%A1%E7%AF%87/169b899033f3b35dtplv-t2oaga2asx-jj-mark1890000q75.webp">
<meta property="og:image" content="https://hulingf.github.io/imgs/MySQL%E5%8E%9F%E7%90%86%E4%B9%8B%E4%BA%8B%E5%8A%A1%E7%AF%87/169b899033d57b7atplv-t2oaga2asx-jj-mark1890000q75.webp">
<meta property="og:image" content="https://hulingf.github.io/imgs/MySQL%E5%8E%9F%E7%90%86%E4%B9%8B%E4%BA%8B%E5%8A%A1%E7%AF%87/169b899033e1cb89tplv-t2oaga2asx-jj-mark1890000q75.webp">
<meta property="og:image" content="https://hulingf.github.io/imgs/MySQL%E5%8E%9F%E7%90%86%E4%B9%8B%E4%BA%8B%E5%8A%A1%E7%AF%87/169b899065200011tplv-t2oaga2asx-jj-mark1890000q75.webp">
<meta property="og:image" content="https://hulingf.github.io/imgs/MySQL%E5%8E%9F%E7%90%86%E4%B9%8B%E4%BA%8B%E5%8A%A1%E7%AF%87/image-20231220164259616.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/MySQL%E5%8E%9F%E7%90%86%E4%B9%8B%E4%BA%8B%E5%8A%A1%E7%AF%87/169b899037defb21tplv-t2oaga2asx-jj-mark1890000q75.webp">
<meta property="og:image" content="https://hulingf.github.io/imgs/MySQL%E5%8E%9F%E7%90%86%E4%B9%8B%E4%BA%8B%E5%8A%A1%E7%AF%87/image-20231220164407649.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/MySQL%E5%8E%9F%E7%90%86%E4%B9%8B%E4%BA%8B%E5%8A%A1%E7%AF%87/169b899065393c60tplv-t2oaga2asx-jj-mark1890000q75.webp">
<meta property="og:image" content="https://hulingf.github.io/imgs/MySQL%E5%8E%9F%E7%90%86%E4%B9%8B%E4%BA%8B%E5%8A%A1%E7%AF%87/169b899036dc68a0tplv-t2oaga2asx-jj-mark1890000q75.webp">
<meta property="og:image" content="https://hulingf.github.io/imgs/MySQL%E5%8E%9F%E7%90%86%E4%B9%8B%E4%BA%8B%E5%8A%A1%E7%AF%87/169b899037f19b86tplv-t2oaga2asx-jj-mark1890000q75.webp">
<meta property="og:image" content="https://hulingf.github.io/imgs/MySQL%E5%8E%9F%E7%90%86%E4%B9%8B%E4%BA%8B%E5%8A%A1%E7%AF%87/169b899065cd1697tplv-t2oaga2asx-jj-mark1890000q75.webp">
<meta property="og:image" content="https://hulingf.github.io/imgs/MySQL%E5%8E%9F%E7%90%86%E4%B9%8B%E4%BA%8B%E5%8A%A1%E7%AF%87/169b899065f16c34tplv-t2oaga2asx-jj-mark1890000q75.webp">
<meta property="og:image" content="https://hulingf.github.io/imgs/MySQL%E5%8E%9F%E7%90%86%E4%B9%8B%E4%BA%8B%E5%8A%A1%E7%AF%87/169b899065ece690tplv-t2oaga2asx-jj-mark1890000q75.webp">
<meta property="og:image" content="https://hulingf.github.io/imgs/MySQL%E5%8E%9F%E7%90%86%E4%B9%8B%E4%BA%8B%E5%8A%A1%E7%AF%87/169b8990864b2982tplv-t2oaga2asx-jj-mark1890000q75.webp">
<meta property="og:image" content="https://hulingf.github.io/imgs/MySQL%E5%8E%9F%E7%90%86%E4%B9%8B%E4%BA%8B%E5%8A%A1%E7%AF%87/169b899094bcc632tplv-t2oaga2asx-jj-mark1890000q75.webp">
<meta property="og:image" content="https://hulingf.github.io/imgs/MySQL%E5%8E%9F%E7%90%86%E4%B9%8B%E4%BA%8B%E5%8A%A1%E7%AF%87/169b899088d4f875tplv-t2oaga2asx-jj-mark1890000q75.webp">
<meta property="og:image" content="https://hulingf.github.io/imgs/MySQL%E5%8E%9F%E7%90%86%E4%B9%8B%E4%BA%8B%E5%8A%A1%E7%AF%87/169b899094ab6caftplv-t2oaga2asx-jj-mark1890000q75.webp">
<meta property="og:image" content="https://hulingf.github.io/imgs/MySQL%E5%8E%9F%E7%90%86%E4%B9%8B%E4%BA%8B%E5%8A%A1%E7%AF%87/169b89909693bfe9tplv-t2oaga2asx-jj-mark1890000q75.webp">
<meta property="og:image" content="https://hulingf.github.io/imgs/MySQL%E5%8E%9F%E7%90%86%E4%B9%8B%E4%BA%8B%E5%8A%A1%E7%AF%87/169b8990a1ec0f87tplv-t2oaga2asx-jj-mark1890000q75.webp">
<meta property="og:image" content="https://hulingf.github.io/imgs/MySQL%E5%8E%9F%E7%90%86%E4%B9%8B%E4%BA%8B%E5%8A%A1%E7%AF%87/169b8990ad89ad77tplv-t2oaga2asx-jj-mark1890000q75.webp">
<meta property="og:image" content="https://hulingf.github.io/imgs/MySQL%E5%8E%9F%E7%90%86%E4%B9%8B%E4%BA%8B%E5%8A%A1%E7%AF%87/169b8990aeb41002tplv-t2oaga2asx-jj-mark1890000q75.webp">
<meta property="og:image" content="https://hulingf.github.io/imgs/MySQL%E5%8E%9F%E7%90%86%E4%B9%8B%E4%BA%8B%E5%8A%A1%E7%AF%87/169b8990b6d085cdtplv-t2oaga2asx-jj-mark1890000q75.webp">
<meta property="og:image" content="https://hulingf.github.io/imgs/MySQL%E5%8E%9F%E7%90%86%E4%B9%8B%E4%BA%8B%E5%8A%A1%E7%AF%87/169b8990b9780dc2tplv-t2oaga2asx-jj-mark1890000q75.webp">
<meta property="og:image" content="https://hulingf.github.io/imgs/MySQL%E5%8E%9F%E7%90%86%E4%B9%8B%E4%BA%8B%E5%8A%A1%E7%AF%87/169b8990d0161bfctplv-t2oaga2asx-jj-mark1890000q75.webp">
<meta property="og:image" content="https://hulingf.github.io/imgs/MySQL%E5%8E%9F%E7%90%86%E4%B9%8B%E4%BA%8B%E5%8A%A1%E7%AF%87/9dbb2113ed2744b99f599b5fc1b2bb32tplv-k3u1fbpfcp-jj-mark1890000q75.webp">
<meta property="og:image" content="https://hulingf.github.io/imgs/MySQL%E5%8E%9F%E7%90%86%E4%B9%8B%E4%BA%8B%E5%8A%A1%E7%AF%87/0e14e4fe30664ae398a29fba855afda8tplv-k3u1fbpfcp-jj-mark1890000q75.webp">
<meta property="og:image" content="https://hulingf.github.io/imgs/MySQL%E5%8E%9F%E7%90%86%E4%B9%8B%E4%BA%8B%E5%8A%A1%E7%AF%87/2be4b2847fe64c4cb0d5db1a5505bd2atplv-k3u1fbpfcp-jj-mark1890000q75.webp">
<meta property="og:image" content="https://hulingf.github.io/imgs/MySQL%E5%8E%9F%E7%90%86%E4%B9%8B%E4%BA%8B%E5%8A%A1%E7%AF%87/8c5bef4507364a04854a088f68ba6c90tplv-k3u1fbpfcp-jj-mark1890000q75.webp">
<meta property="og:image" content="https://hulingf.github.io/imgs/MySQL%E5%8E%9F%E7%90%86%E4%B9%8B%E4%BA%8B%E5%8A%A1%E7%AF%87/image-20231220211709566.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/MySQL%E5%8E%9F%E7%90%86%E4%B9%8B%E4%BA%8B%E5%8A%A1%E7%AF%87/b6c72ab37d5a42b9a431d737f3c3b5eetplv-k3u1fbpfcp-jj-mark1890000q75.webp">
<meta property="og:image" content="https://hulingf.github.io/imgs/MySQL%E5%8E%9F%E7%90%86%E4%B9%8B%E4%BA%8B%E5%8A%A1%E7%AF%87/7bc75c7f1def4be49e6bdc451e5af1adtplv-k3u1fbpfcp-jj-mark1890000q75.webp">
<meta property="og:image" content="https://hulingf.github.io/imgs/MySQL%E5%8E%9F%E7%90%86%E4%B9%8B%E4%BA%8B%E5%8A%A1%E7%AF%87/16a33e277a98dbectplv-t2oaga2asx-jj-mark1890000q75.webp">
<meta property="og:image" content="https://hulingf.github.io/imgs/MySQL%E5%8E%9F%E7%90%86%E4%B9%8B%E4%BA%8B%E5%8A%A1%E7%AF%87/ae389880792944b0b88ff81c9b86d7cctplv-k3u1fbpfcp-jj-mark1890000q75.webp">
<meta property="og:image" content="https://hulingf.github.io/imgs/MySQL%E5%8E%9F%E7%90%86%E4%B9%8B%E4%BA%8B%E5%8A%A1%E7%AF%87/7fe2571121ec47948a52e0c233cda87atplv-k3u1fbpfcp-jj-mark1890000q75.webp">
<meta property="og:image" content="https://hulingf.github.io/imgs/MySQL%E5%8E%9F%E7%90%86%E4%B9%8B%E4%BA%8B%E5%8A%A1%E7%AF%87/2bf361978769480eae58f2ed37f44f79tplv-k3u1fbpfcp-jj-mark1890000q75.webp">
<meta property="og:image" content="https://hulingf.github.io/imgs/MySQL%E5%8E%9F%E7%90%86%E4%B9%8B%E4%BA%8B%E5%8A%A1%E7%AF%87/75fc78c0a6b34a0095fe019f35ac4698tplv-k3u1fbpfcp-jj-mark1890000q75.webp">
<meta property="article:published_time" content="2023-12-20T08:00:20.730Z">
<meta property="article:modified_time" content="2023-12-20T13:39:02.260Z">
<meta property="article:author" content="hulingF">
<meta property="article:tag" content="MySQL原理">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://hulingf.github.io/imgs/MySQL%E5%8E%9F%E7%90%86%E4%B9%8B%E4%BA%8B%E5%8A%A1%E7%AF%87/169d7fd5bcbcc82ftplv-t2oaga2asx-jj-mark1890000q75.webp">
    
    
      
        
          <link rel="shortcut icon" href="/images/favicon.ico">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
        
      
    
    <!-- title -->
    <title>MySQL原理之事务篇</title>
    <!-- async scripts -->
    <!-- Google Analytics -->


    <!-- Umami Analytics -->


    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
    <!-- rss -->
    
    
	<!-- mathjax -->
	
<meta name="generator" content="Hexo 6.3.0"></head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#" aria-label="Menu"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#" aria-label="Menu"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" aria-label="Top" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa-solid fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
        <!--
       --><li><a href="/">Home</a></li><!--
     --><!--
       --><li><a href="/about/">About</a></li><!--
     --><!--
       --><li><a href="/archives/">Writing</a></li><!--
     --><!--
       --><li><a href="/tags/">Tag</a></li><!--
     --><!--
       --><li><a target="_blank" rel="noopener" href="http://github.com/hulingF">Projects</a></li><!--
     -->
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        
        <li><a class="icon" aria-label="Next post" href="/2023/12/19/MySQL%E5%8E%9F%E7%90%86%E4%B9%8B%E7%BC%93%E5%AD%98%E7%AF%87/"><i class="fa-solid fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" aria-label="Back to top" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" aria-label="Share post" href="#"><i class="fa-solid fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://hulingf.github.io/2023/12/20/MySQL%E5%8E%9F%E7%90%86%E4%B9%8B%E4%BA%8B%E5%8A%A1%E7%AF%87/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://hulingf.github.io/2023/12/20/MySQL%E5%8E%9F%E7%90%86%E4%B9%8B%E4%BA%8B%E5%8A%A1%E7%AF%87/&text=MySQL原理之事务篇"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://hulingf.github.io/2023/12/20/MySQL%E5%8E%9F%E7%90%86%E4%B9%8B%E4%BA%8B%E5%8A%A1%E7%AF%87/&title=MySQL原理之事务篇"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://hulingf.github.io/2023/12/20/MySQL%E5%8E%9F%E7%90%86%E4%B9%8B%E4%BA%8B%E5%8A%A1%E7%AF%87/&is_video=false&description=MySQL原理之事务篇"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=MySQL原理之事务篇&body=Check out this article: https://hulingf.github.io/2023/12/20/MySQL%E5%8E%9F%E7%90%86%E4%B9%8B%E4%BA%8B%E5%8A%A1%E7%AF%87/"><i class="fa-solid fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://hulingf.github.io/2023/12/20/MySQL%E5%8E%9F%E7%90%86%E4%B9%8B%E4%BA%8B%E5%8A%A1%E7%AF%87/&title=MySQL原理之事务篇"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://hulingf.github.io/2023/12/20/MySQL%E5%8E%9F%E7%90%86%E4%B9%8B%E4%BA%8B%E5%8A%A1%E7%AF%87/&title=MySQL原理之事务篇"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://hulingf.github.io/2023/12/20/MySQL%E5%8E%9F%E7%90%86%E4%B9%8B%E4%BA%8B%E5%8A%A1%E7%AF%87/&title=MySQL原理之事务篇"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://hulingf.github.io/2023/12/20/MySQL%E5%8E%9F%E7%90%86%E4%B9%8B%E4%BA%8B%E5%8A%A1%E7%AF%87/&title=MySQL原理之事务篇"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://hulingf.github.io/2023/12/20/MySQL%E5%8E%9F%E7%90%86%E4%B9%8B%E4%BA%8B%E5%8A%A1%E7%AF%87/&name=MySQL原理之事务篇&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://hulingf.github.io/2023/12/20/MySQL%E5%8E%9F%E7%90%86%E4%B9%8B%E4%BA%8B%E5%8A%A1%E7%AF%87/&t=MySQL原理之事务篇"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    
    
      <div id="toc">
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#MySQL%E5%8E%9F%E7%90%86%E4%B9%8B%E4%BA%8B%E5%8A%A1%E7%AF%87"><span class="toc-number">1.</span> <span class="toc-text">MySQL原理之事务篇</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E4%BA%8B%E5%8A%A1%E7%9A%84%E7%AE%80%E4%BB%8B"><span class="toc-number">1.1.</span> <span class="toc-text">一、事务的简介</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1%E4%BA%8B%E5%8A%A1%E7%9A%84%E8%B5%B7%E6%BA%90"><span class="toc-number">1.1.1.</span> <span class="toc-text">1.1事务的起源</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-1%E5%8E%9F%E5%AD%90%E6%80%A7%EF%BC%88Atomicity%EF%BC%89"><span class="toc-number">1.1.1.1.</span> <span class="toc-text">1.1.1原子性（Atomicity）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-2%E9%9A%94%E7%A6%BB%E6%80%A7%EF%BC%88Isolation%EF%BC%89"><span class="toc-number">1.1.1.2.</span> <span class="toc-text">1.1.2隔离性（Isolation）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-3%E4%B8%80%E8%87%B4%E6%80%A7%EF%BC%88Consistency%EF%BC%89"><span class="toc-number">1.1.1.3.</span> <span class="toc-text">1.1.3一致性（Consistency）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-4%E6%8C%81%E4%B9%85%E6%80%A7%EF%BC%88Durability%EF%BC%89"><span class="toc-number">1.1.1.4.</span> <span class="toc-text">1.1.4持久性（Durability）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2MySQL%E4%B8%AD%E4%BA%8B%E5%8A%A1%E7%9A%84%E8%AF%AD%E6%B3%95"><span class="toc-number">1.1.2.</span> <span class="toc-text">1.2MySQL中事务的语法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-1%E5%BC%80%E5%90%AF%E4%BA%8B%E5%8A%A1"><span class="toc-number">1.1.2.1.</span> <span class="toc-text">1.2.1开启事务</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-2%E6%8F%90%E4%BA%A4%E4%BA%8B%E5%8A%A1"><span class="toc-number">1.1.2.2.</span> <span class="toc-text">1.2.2提交事务</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-3%E6%89%8B%E5%8A%A8%E4%B8%AD%E6%AD%A2%E4%BA%8B%E5%8A%A1"><span class="toc-number">1.1.2.3.</span> <span class="toc-text">1.2.3手动中止事务</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-4%E8%87%AA%E5%8A%A8%E6%8F%90%E4%BA%A4"><span class="toc-number">1.1.2.4.</span> <span class="toc-text">1.2.4自动提交</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-5%E9%9A%90%E5%BC%8F%E6%8F%90%E4%BA%A4"><span class="toc-number">1.1.2.5.</span> <span class="toc-text">1.2.5隐式提交</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-6%E4%BF%9D%E5%AD%98%E7%82%B9"><span class="toc-number">1.1.2.6.</span> <span class="toc-text">1.2.6保存点</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81Redo%E6%97%A5%E5%BF%97"><span class="toc-number">1.2.</span> <span class="toc-text">二、Redo日志</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1redo%E6%97%A5%E5%BF%97%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.2.1.</span> <span class="toc-text">2.1redo日志介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2redo%E6%97%A5%E5%BF%97%E6%A0%BC%E5%BC%8F"><span class="toc-number">1.2.2.</span> <span class="toc-text">2.2redo日志格式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-1%E7%AE%80%E5%8D%95%E7%9A%84redo%E6%97%A5%E5%BF%97%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">2.2.1简单的redo日志类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-2%E5%A4%8D%E6%9D%82%E7%9A%84redo%E6%97%A5%E5%BF%97%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">2.2.2复杂的redo日志类型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3Mini-Transaction"><span class="toc-number">1.2.3.</span> <span class="toc-text">2.3Mini-Transaction</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-1%E4%BB%A5%E7%BB%84%E7%9A%84%E5%BD%A2%E5%BC%8F%E5%86%99%E5%85%A5redo%E6%97%A5%E5%BF%97"><span class="toc-number">1.2.3.1.</span> <span class="toc-text">2.3.1以组的形式写入redo日志</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-2Mini-Transaction%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">1.2.3.2.</span> <span class="toc-text">2.3.2Mini-Transaction的概念</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4redo%E6%97%A5%E5%BF%97%E7%9A%84%E5%86%99%E5%85%A5%E8%BF%87%E7%A8%8B"><span class="toc-number">1.2.4.</span> <span class="toc-text">2.4redo日志的写入过程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-1redo-log-block"><span class="toc-number">1.2.4.1.</span> <span class="toc-text">2.4.1redo log block</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-2redo%E6%97%A5%E5%BF%97%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="toc-number">1.2.4.2.</span> <span class="toc-text">2.4.2redo日志缓冲区</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-3redo%E6%97%A5%E5%BF%97%E5%86%99%E5%85%A5log-buffer"><span class="toc-number">1.2.4.3.</span> <span class="toc-text">2.4.3redo日志写入log buffer</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5redo%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6"><span class="toc-number">1.2.5.</span> <span class="toc-text">2.5redo日志文件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5-1redo%E6%97%A5%E5%BF%97%E5%88%B7%E7%9B%98%E6%97%B6%E6%9C%BA"><span class="toc-number">1.2.5.1.</span> <span class="toc-text">2.5.1redo日志刷盘时机</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5-2redo%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6%E7%BB%84"><span class="toc-number">1.2.5.2.</span> <span class="toc-text">2.5.2redo日志文件组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5-3redo%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F"><span class="toc-number">1.2.5.3.</span> <span class="toc-text">2.5.3redo日志文件格式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6Log-Sequence-Number"><span class="toc-number">1.2.6.</span> <span class="toc-text">2.6Log Sequence Number</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-6-1flushed-to-disk-lsn"><span class="toc-number">1.2.6.1.</span> <span class="toc-text">2.6.1flushed_to_disk_lsn</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-6-2lsn%E5%80%BC%E5%92%8Credo%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6%E5%81%8F%E7%A7%BB%E9%87%8F%E7%9A%84%E5%AF%B9%E5%BA%94%E5%85%B3%E7%B3%BB"><span class="toc-number">1.2.6.2.</span> <span class="toc-text">2.6.2lsn值和redo日志文件偏移量的对应关系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-6-3flush%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84LSN"><span class="toc-number">1.2.6.3.</span> <span class="toc-text">2.6.3flush链表中的LSN</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-7checkpoint"><span class="toc-number">1.2.7.</span> <span class="toc-text">2.7checkpoint</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-7-1%E6%89%B9%E9%87%8F%E4%BB%8Eflush%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%88%B7%E5%87%BA%E8%84%8F%E9%A1%B5"><span class="toc-number">1.2.7.1.</span> <span class="toc-text">2.7.1批量从flush链表中刷出脏页</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-7-2%E6%9F%A5%E7%9C%8B%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8DLSN%E5%80%BC"><span class="toc-number">1.2.7.2.</span> <span class="toc-text">2.7.2查看系统中的各种LSN值</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-8%E5%B4%A9%E6%BA%83%E6%81%A2%E5%A4%8D"><span class="toc-number">1.2.8.</span> <span class="toc-text">2.8崩溃恢复</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-8-1%E7%A1%AE%E5%AE%9A%E6%81%A2%E5%A4%8D%E7%9A%84%E8%B5%B7%E7%82%B9"><span class="toc-number">1.2.8.1.</span> <span class="toc-text">2.8.1确定恢复的起点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-8-2%E7%A1%AE%E5%AE%9A%E6%81%A2%E5%A4%8D%E7%9A%84%E7%BB%88%E7%82%B9"><span class="toc-number">1.2.8.2.</span> <span class="toc-text">2.8.2确定恢复的终点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-8-3%E6%80%8E%E4%B9%88%E6%81%A2%E5%A4%8D"><span class="toc-number">1.2.8.3.</span> <span class="toc-text">2.8.3怎么恢复</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81Undo%E6%97%A5%E5%BF%97"><span class="toc-number">1.3.</span> <span class="toc-text">三、Undo日志</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81MVCC%E4%B8%8E%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="toc-number">1.4.</span> <span class="toc-text">四、MVCC与隔离级别</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="toc-number">1.4.1.</span> <span class="toc-text">4.1事务隔离级别</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-1%E4%BA%8B%E5%8A%A1%E5%B9%B6%E5%8F%91%E6%89%A7%E8%A1%8C%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">1.4.1.1.</span> <span class="toc-text">4.1.1事务并发执行遇到的问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-2SQL%E6%A0%87%E5%87%86%E4%B8%AD%E7%9A%84%E5%9B%9B%E7%A7%8D%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="toc-number">1.4.1.2.</span> <span class="toc-text">4.1.2SQL标准中的四种隔离级别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-3MySQL%E4%B8%AD%E6%94%AF%E6%8C%81%E7%9A%84%E5%9B%9B%E7%A7%8D%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="toc-number">1.4.1.3.</span> <span class="toc-text">4.1.3MySQL中支持的四种隔离级别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2MVCC%E5%8E%9F%E7%90%86"><span class="toc-number">1.4.2.</span> <span class="toc-text">4.2MVCC原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-1%E7%89%88%E6%9C%AC%E9%93%BE"><span class="toc-number">1.4.2.1.</span> <span class="toc-text">4.2.1版本链</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-2ReadView"><span class="toc-number">1.4.2.2.</span> <span class="toc-text">4.2.2ReadView</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-3MVCC%E5%B0%8F%E7%BB%93"><span class="toc-number">1.4.2.3.</span> <span class="toc-text">4.2.3MVCC小结</span></a></li></ol></li></ol></li></ol></li></ol>
      </div>
    
  </span>
</div>

    
    <div class="content index py4 ">
        
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle p-name" itemprop="name headline">
        MySQL原理之事务篇
    </h1>



    <div class="meta">
      <span class="author p-author h-card" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span class="p-name" itemprop="name">hulingF</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2023-12-20T08:00:20.730Z" class="dt-published" itemprop="datePublished">2023-12-20</time>
        
      
    </div>


      

      
    <div class="article-tag">
        <i class="fa-solid fa-tag"></i>
        <a class="p-category" href="/tags/MySQL%E5%8E%9F%E7%90%86/" rel="tag">MySQL原理</a>
    </div>


    </div>
  </header>
  

  <div class="content e-content" itemprop="articleBody">
    <h1 id="MySQL原理之事务篇"><a href="#MySQL原理之事务篇" class="headerlink" title="MySQL原理之事务篇"></a>MySQL原理之事务篇</h1><h2 id="一、事务的简介"><a href="#一、事务的简介" class="headerlink" title="一、事务的简介"></a>一、事务的简介</h2><h3 id="1-1事务的起源"><a href="#1-1事务的起源" class="headerlink" title="1.1事务的起源"></a>1.1事务的起源</h3><p>对于大部分程序员来说，他们的任务就是把现实世界的业务场景映射到数据库世界。比如银行为了存储人们的账户信息会建立一个<code>account</code>表：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> account (</span><br><span class="line">    id <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;自增id&#x27;</span>,</span><br><span class="line">    name <span class="type">VARCHAR</span>(<span class="number">100</span>) COMMENT <span class="string">&#x27;客户名称&#x27;</span>,</span><br><span class="line">    balance <span class="type">INT</span> COMMENT <span class="string">&#x27;余额&#x27;</span>,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (id)</span><br><span class="line">) Engine<span class="operator">=</span>InnoDB CHARSET<span class="operator">=</span>utf8;</span><br></pre></td></tr></table></figure>

<p>狗哥和猫爷是一对好基友，他们都到银行开一个账户，他们在现实世界中拥有的资产就会体现在数据库世界的<code>account</code>表中。比如现在狗哥有<code>11</code>元，猫爷只有<code>2</code>元，那么现实中的这个情况映射到数据库的<code>account</code>表就是这样：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">+</span><span class="comment">----+--------+---------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> name   <span class="operator">|</span> balance <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------+---------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> 狗哥   <span class="operator">|</span>      <span class="number">11</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">2</span> <span class="operator">|</span> 猫爷   <span class="operator">|</span>       <span class="number">2</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------+---------+</span></span><br></pre></td></tr></table></figure>

<p>在某个特定的时刻，狗哥猫爷这些家伙在银行所拥有的资产是一个特定的值，这些特定的值也可以被描述为账户在这个特定的时刻现实世界的一个状态。随着时间的流逝，狗哥和猫爷可能陆续进行向账户中存钱、取钱或者向别人转账等操作，这样他们账户中的余额就可能发生变动，每一个操作都相当于现实世界中账户的一次状态转换。数据库世界作为现实世界的一个映射，自然也要进行相应的变动。不变不知道，一变吓一跳，现实世界中一些看似很简单的状态转换，映射到数据库世界却不是那么容易的。比方说有一次猫爷在赌场赌博输了钱，急忙打电话给狗哥要借10块钱，不然那些看场子的就会把自己剁了。现实世界中的狗哥走向了ATM机，输入了猫爷的账号以及10元的转账金额，然后按下确认，狗哥就拔卡走人了。对于数据库世界来说，相当于执行了下边这两条语句：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> account <span class="keyword">SET</span> balance <span class="operator">=</span> balance <span class="operator">-</span> <span class="number">10</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> account <span class="keyword">SET</span> balance <span class="operator">=</span> balance <span class="operator">+</span> <span class="number">10</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p>但是这里头有个问题，上述两条语句只执行了一条时忽然服务器断电了咋办？把狗哥的钱扣了，但是没给猫爷转过去，那猫爷还是逃脱不了被砍死的噩运～ 即使对于单独的一条语句，我们前边唠叨<code>Buffer Pool</code>时也说过，在对某个页面进行读写访问时，都会先把这个页面加载到<code>Buffer Pool</code>中，之后如果修改了某个页面，也不会立即把修改同步到磁盘，而只是把这个修改了的页面加到<code>Buffer Pool</code>的<code>flush链表</code>中，在之后的某个时间点才会刷新到磁盘。如果在将修改过的页刷新到磁盘之前系统崩溃了那岂不是猫爷还是要被砍死？或者在刷新磁盘的过程中（只刷新部分数据到磁盘上）系统奔溃了猫爷也会被砍死？</p>
<p>怎么才能保证让可怜的猫爷不被砍死呢？其实再仔细想想，我们只是想让某些数据库操作符合现实世界中状态转换的规则而已，设计数据库的大叔们仔细盘算了盘算，现实世界中状态转换的规则有好几条，待我们慢慢道来。</p>
<h4 id="1-1-1原子性（Atomicity）"><a href="#1-1-1原子性（Atomicity）" class="headerlink" title="1.1.1原子性（Atomicity）"></a>1.1.1原子性（Atomicity）</h4><p>现实世界中转账操作是一个不可分割的操作，也就是说要么压根儿就没转，要么转账成功，不能存在中间的状态，也就是转了一半的这种情况。设计数据库的大叔们把这种要么全做，要么全不做的规则称之为<code>原子性</code>。但是在现实世界中的一个不可分割的操作却可能对应着数据库世界若干条不同的操作，数据库中的一条操作也可能被分解成若干个步骤（比如先修改缓存页，之后再刷新到磁盘等），最要命的是在任何一个可能的时间都可能发生意想不到的错误（可能是数据库本身的错误，或者是操作系统错误，甚至是直接断电之类的）而使操作执行不下去，所以猫爷可能会被砍死。为了保证在数据库世界中某些操作的原子性，设计数据库的大叔需要费一些心机来保证如果在执行操作的过程中发生了错误，把已经做了的操作恢复成没执行之前的样子，这也是我们后边章节要仔细唠叨的内容。</p>
<h4 id="1-1-2隔离性（Isolation）"><a href="#1-1-2隔离性（Isolation）" class="headerlink" title="1.1.2隔离性（Isolation）"></a>1.1.2隔离性（Isolation）</h4><p>现实世界中的两次状态转换应该是互不影响的，比如说狗哥向猫爷同时进行的两次金额为5元的转账（假设可以在两个ATM机上同时操作）。那么最后狗哥的账户里肯定会少10元，猫爷的账户里肯定多了10元。但是到对应的数据库世界中，事情又变的复杂了一些。为了简化问题，我们粗略的假设狗哥向猫爷转账5元的过程是由下边几个步骤组成的：</p>
<ul>
<li>步骤一：读取狗哥账户的余额到变量A中，这一步骤简写为<code>read(A)</code>。</li>
<li>步骤二：将狗哥账户的余额减去转账金额，这一步骤简写为<code>A = A - 5</code>。</li>
<li>步骤三：将狗哥账户修改过的余额写到磁盘里，这一步骤简写为<code>write(A)</code>。</li>
<li>步骤四：读取猫爷账户的余额到变量B，这一步骤简写为<code>read(B)</code>。</li>
<li>步骤五：将猫爷账户的余额加上转账金额，这一步骤简写为<code>B = B + 5</code>。</li>
<li>步骤六：将猫爷账户修改过的余额写到磁盘里，这一步骤简写为<code>write(B)</code>。</li>
</ul>
<p>我们将狗哥向猫爷同时进行的两次转账操作分别称为<code>T1</code>和<code>T2</code>，在现实世界中<code>T1</code>和<code>T2</code>是应该没有关系的，可以先执行完<code>T1</code>，再执行<code>T2</code>，或者先执行完<code>T2</code>，再执行<code>T1</code>，对应的数据库操作就像这样：</p>
<p><img src="/../../../../../../imgs/MySQL%E5%8E%9F%E7%90%86%E4%B9%8B%E4%BA%8B%E5%8A%A1%E7%AF%87/169d7fd5bcbcc82ftplv-t2oaga2asx-jj-mark1890000q75.webp" alt="image_1d1stskva1vp4a7f5kjdi7pf19.png-74.2kB"> </p>
<p>但是很不幸，真实的数据库中<code>T1</code>和<code>T2</code>的操作可能交替执行，比如这样：</p>
<p><img src="/../../../../../../imgs/MySQL%E5%8E%9F%E7%90%86%E4%B9%8B%E4%BA%8B%E5%8A%A1%E7%AF%87/169d7fd5bd2cf68btplv-t2oaga2asx-jj-mark1890000q75.webp" alt="image_1d1sut47o5tk13ul4gb1qibuct2j.png-67.9kB"> </p>
<p>如果按照上图中的执行顺序来进行两次转账的话，最终狗哥的账户里还剩<code>6</code>元钱，相当于只扣了5元钱，但是猫爷的账户里却成了<code>12</code>元钱，相当于多了10元钱，这银行岂不是要亏死了？</p>
<p>所以对于现实世界中状态转换对应的某些数据库操作来说，不仅要保证这些操作以<code>原子性</code>的方式执行完成，而且要保证其它的状态转换不会影响到本次状态转换，这个规则被称之为<code>隔离性</code>。这时设计数据库的大叔们就需要采取一些措施来让访问相同数据（上例中的A账户和B账户）的不同状态转换（上例中的<code>T1</code>和<code>T2</code>）对应的数据库操作的执行顺序有一定规律，这也是我们后边章节要仔细唠叨的内容。</p>
<h4 id="1-1-3一致性（Consistency）"><a href="#1-1-3一致性（Consistency）" class="headerlink" title="1.1.3一致性（Consistency）"></a>1.1.3一致性（Consistency）</h4><p>我们生活的这个世界存在着形形色色的约束，比如身份证号不能重复，性别只能是男或者女，高考的分数只能在0～750之间，人民币面值最大只能是100（现在是2019年），红绿灯只有3种颜色，房价不能为负的，学生要听老师话，吧啦吧啦有点儿扯远了～ 只有符合这些约束的数据才是有效的，比如有个小孩儿跟你说他高考考了1000分，你一听就知道他胡扯呢。数据库世界只是现实世界的一个映射，现实世界中存在的约束当然也要在数据库世界中有所体现。如果数据库中的数据全部符合现实世界中的约束（all defined rules），我们说这些数据就是一致的，或者说符合<code>一致性</code>的。</p>
<p>如何保证数据库中数据的一致性（就是符合所有现实世界的约束）呢？这其实靠两方面的努力：</p>
<ul>
<li><p>数据库本身能为我们保证一部分一致性需求（就是数据库自身可以保证一部分现实世界的约束永远有效）。</p>
<p>我们知道<code>MySQL</code>数据库可以为表建立主键、唯一索引、外键、声明某个列为<code>NOT NULL</code>来拒绝<code>NULL</code>值的插入。比如说当我们对某个列建立唯一索引时，如果插入某条记录时该列的值重复了，那么<code>MySQL</code>就会报错并且拒绝插入。除了这些我们已经非常熟悉的保证一致性的功能，<code>MySQL</code>还支持<code>CHECK</code>语法来自定义约束，比如这样：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> account (</span><br><span class="line">    id <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;自增id&#x27;</span>,</span><br><span class="line">    name <span class="type">VARCHAR</span>(<span class="number">100</span>) COMMENT <span class="string">&#x27;客户名称&#x27;</span>,</span><br><span class="line">    balance <span class="type">INT</span> COMMENT <span class="string">&#x27;余额&#x27;</span>,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (id),</span><br><span class="line">    <span class="keyword">CHECK</span> (balance <span class="operator">&gt;=</span> <span class="number">0</span>) </span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>上述例子中的<code>CHECK</code>语句本意是想规定<code>balance</code>列不能存储小于0的数字，对应的现实世界的意思就是银行账户余额不能小于0。但是很遗憾，MySQL仅仅支持CHECK语法，但实际上并没有一点卵用，也就是说即使我们使用上述带有<code>CHECK</code>子句的建表语句来创建<code>account</code>表，那么在后续插入或更新记录时，<code>MySQL</code>并不会去检查<code>CHECK</code>子句中的约束是否成立。</p>
<blockquote>
<p>其它的一些数据库，比如SQL Server或者Oracle支持的CHECK语法是有实实在在的作用的，每次进行插入或更新记录之前都会检查一下数据是否符合CHECK子句中指定的约束条件是否成立，如果不成立的话就会拒绝插入或更新。</p>
</blockquote>
<p>虽然<code>CHECK</code>子句对一致性检查没什么卵用，但是我们还是可以通过定义触发器的方式来自定义一些约束条件以保证数据库中数据的一致性。</p>
</li>
<li><p>更多的一致性需求需要靠写业务代码的程序员自己保证。</p>
<p>为建立现实世界和数据库世界的对应关系，理论上应该把现实世界中的所有约束都反应到数据库世界中，但是很不幸，在更改数据库数据时进行一致性检查是一个耗费性能的工作，比方说我们为<code>account</code>表建立了一个触发器，每当插入或者更新记录时都会校验一下<code>balance</code>列的值是不是大于0，这就会影响到插入或更新的速度。仅仅是校验一行记录符不符合一致性需求倒也不是什么大问题，有的一致性需求简直变态，比方说银行会建立一张代表账单的表，里边儿记录了每个账户的每笔交易，每一笔交易完成后，都需要保证整个系统的余额等于所有账户的收入减去所有账户的支出。如果在数据库层面实现这个一致性需求的话，每次发生交易时，都需要将所有的收入加起来减去所有的支出，再将所有的账户余额加起来，看看两个值相不相等。这不是搞笑呢么，如果账单表里有几亿条记录，光是这个校验的过程可能就要跑好几个小时，也就是说你在煎饼摊买个煎饼，使用银行卡付款之后要等好几个小时才能提示付款成功，这样的性能代价是完全承受不起的。</p>
<p>现实生活中复杂的一致性需求比比皆是，而由于性能问题把一致性需求交给数据库去解决这是不现实的，所以这个锅就甩给了业务端程序员。比方说我们的<code>account</code>表，我们也可以不建立触发器，只要编写业务的程序员在自己的业务代码里判断一下，当某个操作会将<code>balance</code>列的值更新为小于0的值时，就不执行该操作就好了嘛！</p>
</li>
</ul>
<p>我们前边唠叨的<code>原子性</code>和<code>隔离性</code>都会对<code>一致性</code>产生影响，比如我们现实世界中转账操作完成后，有一个<code>一致性</code>需求就是参与转账的账户的总的余额是不变的。如果数据库不遵循<code>原子性</code>要求，也就是转了一半就不转了，也就是说给狗哥扣了钱而没给猫爷转过去，那最后就是不符合一致性需求的；类似的，如果数据库不遵循<code>隔离性</code>要求，就像我们前边唠叨<code>隔离性</code>时举的例子中所说的，最终狗哥账户中扣的钱和猫爷账户中涨的钱可能就不一样了，也就是说不符合<code>一致性</code>需求了。所以说，数据库某些操作的原子性和隔离性都是保证一致性的一种手段，在操作执行完成后保证符合所有既定的约束则是一种结果。那满足<code>原子性</code>和<code>隔离性</code>的操作一定就满足<code>一致性</code>么？那倒也不一定，比如说狗哥要转账20元给猫爷，虽然在满足<code>原子性</code>和<code>隔离性</code>，但转账完成了之后狗哥的账户的余额就成负的了，这显然是不满足<code>一致性</code>的。那不满足<code>原子性</code>和<code>隔离性</code>的操作就一定不满足<code>一致性</code>么？这也不一定，只要最后的结果符合所有现实世界中的约束，那么就是符合<code>一致性</code>的。</p>
<h4 id="1-1-4持久性（Durability）"><a href="#1-1-4持久性（Durability）" class="headerlink" title="1.1.4持久性（Durability）"></a>1.1.4持久性（Durability）</h4><p>当现实世界的一个状态转换完成后，这个转换的结果将永久的保留，这个规则被设计数据库的大叔们称为<code>持久性</code>。比方说狗哥向猫爷转账，当ATM机提示转账成功了，就意味着这次账户的状态转换完成了，狗哥就可以拔卡走人了。如果当狗哥走掉之后，银行又把这次转账操作给撤销掉，恢复到没转账之前的样子，那猫爷不就惨了，又得被砍死了，所以这个<code>持久性</code>是非常重要的。</p>
<p>当把现实世界的状态转换映射到数据库世界时，<code>持久性</code>意味着该转换对应的数据库操作所修改的数据都应该在磁盘上保留下来，不论之后发生了什么事故，本次转换造成的影响都不应该被丢失掉（要不然猫爷还是会被砍死）。</p>
<h3 id="1-2MySQL中事务的语法"><a href="#1-2MySQL中事务的语法" class="headerlink" title="1.2MySQL中事务的语法"></a>1.2MySQL中事务的语法</h3><p>我们说<code>事务</code>的本质其实只是一系列数据库操作，只不过这些数据库操作符合<code>ACID</code>特性而已，那么<code>MySQL</code>中如何将某些操作放到一个事务里去执行的呢？我们下边就来重点唠叨唠叨。</p>
<h4 id="1-2-1开启事务"><a href="#1-2-1开启事务" class="headerlink" title="1.2.1开启事务"></a>1.2.1开启事务</h4><p>我们可以使用下边两种语句之一来开启一个事务：</p>
<ul>
<li><p><code>BEGIN [WORK];</code></p>
<p><code>BEGIN</code>语句代表开启一个事务，后边的单词<code>WORK</code>可有可无。开启事务后，就可以继续写若干条语句，这些语句都属于刚刚开启的这个事务。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">BEGIN</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> 加入事务的语句...</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>START TRANSACTION;</code></p>
<p><code>START TRANSACTION</code>语句和<code>BEGIN</code>语句有着相同的功效，都标志着开启一个事务，比如这样：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">START</span> TRANSACTION;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> 加入事务的语句...</span><br></pre></td></tr></table></figure>

<p>不过比<code>BEGIN</code>语句牛逼一点儿的是，可以在<code>START TRANSACTION</code>语句后边跟随几个<code>修饰符</code>，就是它们几个：</p>
<ul>
<li><p><code>READ ONLY</code>：标识当前事务是一个只读事务，也就是属于该事务的数据库操作只能读取数据，而不能修改数据。</p>
<blockquote>
<p>其实只读事务中只是不允许修改那些其他事务也能访问到的表中的数据，对于临时表来说（我们使用CREATE TMEPORARY TABLE创建的表），由于它们只能在当前会话中可见，所以只读事务其实也是可以对临时表进行增、删、改操作的。</p>
</blockquote>
</li>
<li><p><code>READ WRITE</code>：标识当前事务是一个读写事务，也就是属于该事务的数据库操作既可以读取数据，也可以修改数据。</p>
</li>
<li><p><code>WITH CONSISTENT SNAPSHOT</code>：启动一致性读（先不用关心啥是个一致性读，后边的章节才会唠叨）。</p>
</li>
</ul>
<p>比如我们想开启一个只读事务的话，直接把<code>READ ONLY</code>这个修饰符加在<code>START TRANSACTION</code>语句后边就好，比如这样：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">START</span> TRANSACTION READ <span class="keyword">ONLY</span>;</span><br></pre></td></tr></table></figure>

<p>如果我们想在<code>START TRANSACTION</code>后边跟随多个<code>修饰符</code>的话，可以使用逗号将<code>修饰符</code>分开，比如开启一个只读事务和一致性读，就可以这样写：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">START</span> TRANSACTION READ <span class="keyword">ONLY</span>, <span class="keyword">WITH</span> CONSISTENT SNAPSHOT;</span><br></pre></td></tr></table></figure>

<p>不过这里需要大家注意的一点是，<code>READ ONLY</code>和<code>READ WRITE</code>是用来设置所谓的事务<code>访问模式</code>的，就是以只读还是读写的方式来访问数据库中的数据，一个事务的访问模式不能同时既设置为<code>只读</code>的也设置为<code>读写</code>的，所以我们不能同时把<code>READ ONLY</code>和<code>READ WRITE</code>放到<code>START TRANSACTION</code>语句后边。另外，如果我们不显式指定事务的访问模式，那么该事务的访问模式就是<code>读写</code>模式。</p>
</li>
</ul>
<h4 id="1-2-2提交事务"><a href="#1-2-2提交事务" class="headerlink" title="1.2.2提交事务"></a>1.2.2提交事务</h4><p>开启事务之后就可以继续写需要放到该事务中的语句了，当最后一条语句写完了之后，我们就可以提交该事务了，提交的语句也很简单：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">COMMIT</span> [WORK]</span><br></pre></td></tr></table></figure>

<p><code>COMMIT</code>语句就代表提交一个事务，后边的<code>WORK</code>可有可无。比如我们上边说狗哥给猫爷转10元钱其实对应<code>MySQL</code>中的两条语句，我们就可以把这两条语句放到一个事务中，完整的过程就是这样：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">BEGIN</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">UPDATE</span> account <span class="keyword">SET</span> balance <span class="operator">=</span> balance <span class="operator">-</span> <span class="number">10</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected (<span class="number">0.02</span> sec)</span><br><span class="line"><span class="keyword">Rows</span> matched: <span class="number">1</span>  Changed: <span class="number">1</span>  Warnings: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">UPDATE</span> account <span class="keyword">SET</span> balance <span class="operator">=</span> balance <span class="operator">+</span> <span class="number">10</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"><span class="keyword">Rows</span> matched: <span class="number">1</span>  Changed: <span class="number">1</span>  Warnings: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">COMMIT</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

<h4 id="1-2-3手动中止事务"><a href="#1-2-3手动中止事务" class="headerlink" title="1.2.3手动中止事务"></a>1.2.3手动中止事务</h4><p>如果我们写了几条语句之后发现上边的某条语句写错了，我们可以手动的使用下边这个语句来将数据库恢复到事务执行之前的样子：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ROLLBACK</span> [WORK]</span><br></pre></td></tr></table></figure>

<p><code>ROLLBACK</code>语句就代表中止并回滚一个事务，后边的<code>WORK</code>可有可无类似的。比如我们在写狗哥给猫爷转账10元钱对应的<code>MySQL</code>语句时，先给狗哥扣了10元，然后一时大意只给猫爷账户上增加了1元，此时就可以使用<code>ROLLBACK</code>语句进行回滚，完整的过程就是这样：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">BEGIN</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">UPDATE</span> account <span class="keyword">SET</span> balance <span class="operator">=</span> balance <span class="operator">-</span> <span class="number">10</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"><span class="keyword">Rows</span> matched: <span class="number">1</span>  Changed: <span class="number">1</span>  Warnings: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">UPDATE</span> account <span class="keyword">SET</span> balance <span class="operator">=</span> balance <span class="operator">+</span> <span class="number">1</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"><span class="keyword">Rows</span> matched: <span class="number">1</span>  Changed: <span class="number">1</span>  Warnings: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">ROLLBACK</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

<p>这里需要强调一下，<code>ROLLBACK</code>语句是我们程序员手动的去回滚事务时才去使用的，如果事务在执行过程中遇到了某些错误而无法继续执行的话，事务自身会自动的回滚。</p>
<blockquote>
<p>我们这里所说的开启、提交、中止事务的语法只是针对使用黑框框时通过mysql客户端程序与服务器进行交互时控制事务的语法，如果大家使用的是别的客户端程序，比如JDBC之类的，那需要参考相应的文档来看看如何控制事务。</p>
</blockquote>
<h4 id="1-2-4自动提交"><a href="#1-2-4自动提交" class="headerlink" title="1.2.4自动提交"></a>1.2.4自动提交</h4><p><code>MySQL</code>中有一个系统变量<code>autocommit</code>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;autocommit&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">---------------+-------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name <span class="operator">|</span> <span class="keyword">Value</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------+-------+</span></span><br><span class="line"><span class="operator">|</span> autocommit    <span class="operator">|</span> <span class="keyword">ON</span>    <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------+-------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure>

<p>可以看到它的默认值为<code>ON</code>，也就是说默认情况下，如果我们不显式的使用<code>START TRANSACTION</code>或者<code>BEGIN</code>语句开启一个事务，那么每一条语句都算是一个独立的事务，这种特性称之为事务的<code>自动提交</code>。假如我们在狗哥向猫爷转账10元时不以<code>START TRANSACTION</code>或者<code>BEGIN</code>语句显式的开启一个事务，那么下边这两条语句就相当于放到两个独立的事务中去执行：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> account <span class="keyword">SET</span> balance <span class="operator">=</span> balance <span class="operator">-</span> <span class="number">10</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> account <span class="keyword">SET</span> balance <span class="operator">=</span> balance <span class="operator">+</span> <span class="number">10</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p>当然，如果我们想关闭这种<code>自动提交</code>的功能，可以使用下边两种方法之一：</p>
<ul>
<li><p>显式的的使用<code>START TRANSACTION</code>或者<code>BEGIN</code>语句开启一个事务。</p>
<p>这样在本次事务提交或者回滚前会暂时关闭掉自动提交的功能。</p>
</li>
<li><p>把系统变量<code>autocommit</code>的值设置为<code>OFF</code>，就像这样：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> autocommit <span class="operator">=</span> OFF;</span><br></pre></td></tr></table></figure>

<p>这样的话，我们写入的多条语句就算是属于同一个事务了，直到我们显式的写出<code>COMMIT</code>语句来把这个事务提交掉，或者显式的写出<code>ROLLBACK</code>语句来把这个事务回滚掉。</p>
</li>
</ul>
<h4 id="1-2-5隐式提交"><a href="#1-2-5隐式提交" class="headerlink" title="1.2.5隐式提交"></a>1.2.5隐式提交</h4><p>当我们使用<code>START TRANSACTION</code>或者<code>BEGIN</code>语句开启了一个事务，或者把系统变量<code>autocommit</code>的值设置为<code>OFF</code>时，事务就不会进行<code>自动提交</code>，但是如果我们输入了某些语句之后就会<code>悄悄的</code>提交掉，就像我们输入了<code>COMMIT</code>语句了一样，这种因为某些特殊的语句而导致事务提交的情况称为<code>隐式提交</code>，这些会导致事务隐式提交的语句包括：</p>
<ul>
<li><p>定义或修改数据库对象的数据定义语言（Data definition language，缩写为：<code>DDL</code>）。</p>
<p>所谓的数据库对象，指的就是<code>数据库</code>、<code>表</code>、<code>视图</code>、<code>存储过程</code>等等这些东西。当我们使用<code>CREATE</code>、<code>ALTER</code>、<code>DROP</code>等语句去修改这些所谓的数据库对象时，就会隐式的提交前边语句所属于的事务，就像这样：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> ... # 事务中的一条语句</span><br><span class="line"><span class="keyword">UPDATE</span> ... # 事务中的一条语句</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> ... # 此语句会隐式的提交前边语句所属于的事务</span><br></pre></td></tr></table></figure>
</li>
<li><p>隐式使用或修改<code>mysql</code>数据库中的表</p>
<p>当我们使用<code>ALTER USER</code>、<code>CREATE USER</code>、<code>DROP USER</code>、<code>GRANT</code>、<code>RENAME USER</code>、<code>REVOKE</code>、<code>SET PASSWORD</code>等语句时也会隐式的提交前边语句所属于的事务。</p>
</li>
<li><p>事务控制或关于锁定的语句</p>
<p>当我们在一个事务还没提交或者回滚时就又使用<code>START TRANSACTION</code>或者<code>BEGIN</code>语句开启了另一个事务时，会隐式的提交上一个事务，比如这样：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> ... # 事务中的一条语句</span><br><span class="line"><span class="keyword">UPDATE</span> ... # 事务中的一条语句</span><br><span class="line"></span><br><span class="line"><span class="keyword">BEGIN</span>; # 此语句会隐式的提交前边语句所属于的事务</span><br></pre></td></tr></table></figure>

<p>或者当前的<code>autocommit</code>系统变量的值为<code>OFF</code>，我们手动把它调为<code>ON</code>时，也会隐式的提交前边语句所属的事务。</p>
<p>或者使用<code>LOCK TABLES</code>、<code>UNLOCK TABLES</code>等关于锁定的语句也会隐式的提交前边语句所属的事务。</p>
</li>
<li><p>加载数据的语句</p>
<p>比如我们使用<code>LOAD DATA</code>语句来批量往数据库中导入数据时，也会隐式的提交前边语句所属的事务。</p>
</li>
<li><p>关于<code>MySQL</code>复制的一些语句</p>
<p>使用<code>START SLAVE</code>、<code>STOP SLAVE</code>、<code>RESET SLAVE</code>、<code>CHANGE MASTER TO</code>等语句时也会隐式的提交前边语句所属的事务。</p>
</li>
<li><p>其它的一些语句</p>
<p>使用<code>ANALYZE TABLE</code>、<code>CACHE INDEX</code>、<code>CHECK TABLE</code>、<code>FLUSH</code>、 <code>LOAD INDEX INTO CACHE</code>、<code>OPTIMIZE TABLE</code>、<code>REPAIR TABLE</code>、<code>RESET</code>等语句也会隐式的提交前边语句所属的事务。</p>
</li>
</ul>
<h4 id="1-2-6保存点"><a href="#1-2-6保存点" class="headerlink" title="1.2.6保存点"></a>1.2.6保存点</h4><p>如果你开启了一个事务，并且已经敲了很多语句，忽然发现上一条语句有点问题，你只好使用<code>ROLLBACK</code>语句来让数据库状态恢复到事务执行之前的样子，然后一切从头再来，总有一种一夜回到解放前的感觉。所以设计数据库的大叔们提出了一个<code>保存点</code>（英文：<code>savepoint</code>）的概念，就是在事务对应的数据库语句中打几个点，我们在调用<code>ROLLBACK</code>语句时可以指定会滚到哪个点，而不是回到最初的原点。定义保存点的语法如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SAVEPOINT</span> 保存点名称;</span><br></pre></td></tr></table></figure>

<p>当我们想回滚到某个保存点时，可以使用下边这个语句（下边语句中的单词<code>WORK</code>和<code>SAVEPOINT</code>是可有可无的）：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ROLLBACK</span> [WORK] <span class="keyword">TO</span> [<span class="keyword">SAVEPOINT</span>] 保存点名称;</span><br></pre></td></tr></table></figure>

<p>不过如果<code>ROLLBACK</code>语句后边不跟随保存点名称的话，会直接回滚到事务执行之前的状态。</p>
<p>如果我们想删除某个保存点，可以使用这个语句：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">RELEASE</span> <span class="keyword">SAVEPOINT</span> 保存点名称;</span><br></pre></td></tr></table></figure>

<p>下边还是以狗哥向猫爷转账10元的例子展示一下<code>保存点</code>的用法，在执行完扣除狗哥账户的钱<code>10</code>元的语句之后打一个<code>保存点</code>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> account;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------+---------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> name   <span class="operator">|</span> balance <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------+---------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> 狗哥   <span class="operator">|</span>      <span class="number">11</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">2</span> <span class="operator">|</span> 猫爷   <span class="operator">|</span>       <span class="number">2</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------+---------+</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">BEGIN</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">UPDATE</span> account <span class="keyword">SET</span> balance <span class="operator">=</span> balance <span class="operator">-</span> <span class="number">10</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected (<span class="number">0.01</span> sec)</span><br><span class="line"><span class="keyword">Rows</span> matched: <span class="number">1</span>  Changed: <span class="number">1</span>  Warnings: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SAVEPOINT</span> s1;    # 一个保存点</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> account;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------+---------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> name   <span class="operator">|</span> balance <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------+---------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> 狗哥   <span class="operator">|</span>       <span class="number">1</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">2</span> <span class="operator">|</span> 猫爷   <span class="operator">|</span>       <span class="number">2</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------+---------+</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">UPDATE</span> account <span class="keyword">SET</span> balance <span class="operator">=</span> balance <span class="operator">+</span> <span class="number">1</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">2</span>; # 更新错了</span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"><span class="keyword">Rows</span> matched: <span class="number">1</span>  Changed: <span class="number">1</span>  Warnings: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">ROLLBACK</span> <span class="keyword">TO</span> s1;  # 回滚到保存点s1处</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> account;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------+---------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> name   <span class="operator">|</span> balance <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------+---------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> 狗哥   <span class="operator">|</span>       <span class="number">1</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">2</span> <span class="operator">|</span> 猫爷   <span class="operator">|</span>       <span class="number">2</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------+---------+</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

<h2 id="二、Redo日志"><a href="#二、Redo日志" class="headerlink" title="二、Redo日志"></a>二、Redo日志</h2><h3 id="2-1redo日志介绍"><a href="#2-1redo日志介绍" class="headerlink" title="2.1redo日志介绍"></a>2.1redo日志介绍</h3><p>我们知道<code>InnoDB</code>存储引擎是以页为单位来管理存储空间的，我们进行的增删改查操作其实本质上都是在访问页面（包括读页面、写页面、创建新页面等操作）。我们前边唠叨<code>Buffer Pool</code>的时候说过，在真正访问页面之前，需要把在磁盘上的页缓存到内存中的<code>Buffer Pool</code>之后才可以访问。但是在唠叨事务的时候又强调过一个称之为<code>持久性</code>的特性，就是说对于一个已经提交的事务，在事务提交后即使系统发生了崩溃，这个事务对数据库中所做的更改也不能丢失。但是如果我们只在内存的<code>Buffer Pool</code>中修改了页面，假设在事务提交后突然发生了某个故障，导致内存中的数据都失效了，那么这个已经提交了的事务对数据库中所做的更改也就跟着丢失了，这是我们所不能忍受的（想想ATM机已经提示狗哥转账成功，但之后由于服务器出现故障，重启之后猫爷发现自己没收到钱，猫爷就被砍死了）。那么如何保证这个<code>持久性</code>呢？一个很简单的做法就是在事务提交完成之前把该事务所修改的所有页面都刷新到磁盘，但是这个简单粗暴的做法有些问题：</p>
<ul>
<li><p>刷新一个完整的数据页太浪费了</p>
<p>有时候我们仅仅修改了某个页面中的一个字节，但是我们知道在<code>InnoDB</code>中是以页为单位来进行磁盘IO的，也就是说我们在该事务提交时不得不将一个完整的页面从内存中刷新到磁盘，我们又知道一个页面默认是16KB大小，只修改一个字节就要刷新16KB的数据到磁盘上显然是太浪费了。</p>
</li>
<li><p>随机IO刷起来比较慢</p>
<p>一个事务可能包含很多语句，即使是一条语句也可能修改许多页面，倒霉催的是该事务修改的这些页面可能并不相邻，这就意味着在将某个事务修改的<code>Buffer Pool</code>中的页面刷新到磁盘时，需要进行很多的随机IO，随机IO比顺序IO要慢，尤其对于传统的机械硬盘来说。</p>
</li>
</ul>
<p>咋办呢？再次回到我们的初心：我们只是想让已经提交了的事务对数据库中数据所做的修改永久生效，即使后来系统崩溃，在重启后也能把这种修改恢复出来。所以我们其实没有必要在每次事务提交时就把该事务在内存中修改过的全部页面刷新到磁盘，只需要把修改了哪些东西记录一下就好，比方说某个事务将系统表空间中的第100号页面中偏移量为1000处的那个字节的值<code>1</code>改成<code>2</code>我们只需要记录一下：</p>
<blockquote>
<p>将第0号表空间的100号页面的偏移量为1000处的值更新为<code>2</code>。</p>
</blockquote>
<p>这样我们在事务提交时，把上述内容刷新到磁盘中，即使之后系统崩溃了，重启之后只要按照上述内容所记录的步骤重新更新一下数据页，那么该事务对数据库中所做的修改又可以被恢复出来，也就意味着满足<code>持久性</code>的要求。因为在系统崩溃重启时需要按照上述内容所记录的步骤重新更新数据页，所以上述内容也被称之为<code>重做日志</code>，英文名为<code>redo log</code>，我们也可以土洋结合，称之为<code>redo日志</code>。与在事务提交时将所有修改过的内存中的页面刷新到磁盘中相比，只将该事务执行过程中产生的<code>redo</code>日志刷新到磁盘的好处如下：</p>
<ul>
<li><p><code>redo</code>日志占用的空间非常小</p>
<p>存储表空间ID、页号、偏移量以及需要更新的值所需的存储空间是很小的，关于<code>redo</code>日志的格式我们稍后会详细唠叨，现在只要知道一条<code>redo</code>日志占用的空间不是很大就好了。</p>
</li>
<li><p><code>redo</code>日志是顺序写入磁盘的</p>
<p>在执行事务的过程中，每执行一条语句，就可能产生若干条<code>redo</code>日志，这些日志是按照产生的顺序写入磁盘的，也就是使用顺序IO。</p>
</li>
</ul>
<h3 id="2-2redo日志格式"><a href="#2-2redo日志格式" class="headerlink" title="2.2redo日志格式"></a>2.2redo日志格式</h3><p>通过上边的内容我们知道，<code>redo</code>日志本质上只是记录了一下事务对数据库做了哪些修改。 设计<code>InnoDB</code>的大叔们针对事务对数据库的不同修改场景定义了多种类型的<code>redo</code>日志，但是绝大部分类型的<code>redo</code>日志都有下边这种通用的结构：</p>
<p><img src="/../../../../../../imgs/MySQL%E5%8E%9F%E7%90%86%E4%B9%8B%E4%BA%8B%E5%8A%A1%E7%AF%87/1694892fdec61898tplv-t2oaga2asx-jj-mark1890000q75.webp" alt="image_1d36k7d3412oo1c0qcuuben12l79.png-31.3kB"> </p>
<p>各个部分的详细释义如下：</p>
<ul>
<li><p><code>type</code>：该条<code>redo</code>日志的类型。</p>
<p>在<code>MySQL 5.7.21</code>这个版本中，设计<code>InnoDB</code>的大叔一共为<code>redo</code>日志设计了53种不同的类型，稍后会详细介绍不同类型的<code>redo</code>日志。</p>
</li>
<li><p><code>space ID</code>：表空间ID。</p>
</li>
<li><p><code>page number</code>：页号。</p>
</li>
<li><p><code>data</code>：该条<code>redo</code>日志的具体内容。</p>
</li>
</ul>
<h4 id="2-2-1简单的redo日志类型"><a href="#2-2-1简单的redo日志类型" class="headerlink" title="2.2.1简单的redo日志类型"></a>2.2.1简单的redo日志类型</h4><p>我们前边介绍<code>InnoDB</code>的记录行格式的时候说过，如果我们没有为某个表显式的定义主键，并且表中也没有定义<code>Unique</code>键，那么<code>InnoDB</code>会自动的为表添加一个称之为<code>row_id</code>的隐藏列作为主键。为这个<code>row_id</code>隐藏列赋值的方式如下：</p>
<ul>
<li>服务器会在内存中维护一个全局变量，每当向某个包含隐藏的<code>row_id</code>列的表中插入一条记录时，就会把该变量的值当作新记录的<code>row_id</code>列的值，并且把该变量自增1。</li>
<li>每当这个变量的值为256的倍数时，就会将该变量的值刷新到系统表空间的页号为<code>7</code>的页面中一个称之为<code>Max Row ID</code>的属性处（我们前边介绍表空间结构时详细说过）。</li>
<li>当系统启动时，会将上边提到的<code>Max Row ID</code>属性加载到内存中，将该值加上256之后赋值给我们前边提到的全局变量（因为在上次关机时该全局变量的值可能大于<code>Max Row ID</code>属性值）。</li>
</ul>
<p>这个<code>Max Row ID</code>属性占用的存储空间是8个字节，当某个事务向某个包含<code>row_id</code>隐藏列的表插入一条记录，并且为该记录分配的<code>row_id</code>值为256的倍数时，就会向系统表空间页号为7的页面的相应偏移量处写入8个字节的值。但是我们要知道，这个写入实际上是在<code>Buffer Pool</code>中完成的，我们需要为这个页面的修改记录一条<code>redo</code>日志，以便在系统崩溃后能将已经提交的该事务对该页面所做的修改恢复出来。这种情况下对页面的修改是极其简单的，<code>redo</code>日志中只需要记录一下在某个页面的某个偏移量处修改了几个字节的值，具体被修改的内容是啥就好了，设计<code>InnoDB</code>的大叔把这种极其简单的<code>redo</code>日志称之为<code>物理日志</code>，并且根据在页面中写入数据的多少划分了几种不同的<code>redo</code>日志类型：</p>
<ul>
<li><code>MLOG_1BYTE</code>（<code>type</code>字段对应的十进制数字为<code>1</code>）：表示在页面的某个偏移量处写入1个字节的<code>redo</code>日志类型。</li>
<li><code>MLOG_2BYTE</code>（<code>type</code>字段对应的十进制数字为<code>2</code>）：表示在页面的某个偏移量处写入2个字节的<code>redo</code>日志类型。</li>
<li><code>MLOG_4BYTE</code>（<code>type</code>字段对应的十进制数字为<code>4</code>）：表示在页面的某个偏移量处写入4个字节的<code>redo</code>日志类型。</li>
<li><code>MLOG_8BYTE</code>（<code>type</code>字段对应的十进制数字为<code>8</code>）：表示在页面的某个偏移量处写入8个字节的<code>redo</code>日志类型。</li>
<li><code>MLOG_WRITE_STRING</code>（<code>type</code>字段对应的十进制数字为<code>30</code>）：表示在页面的某个偏移量处写入一串数据。</li>
</ul>
<p>我们上边提到的<code>Max Row ID</code>属性实际占用8个字节的存储空间，所以在修改页面中的该属性时，会记录一条类型为<code>MLOG_8BYTE</code>的<code>redo</code>日志，<code>MLOG_8BYTE</code>的<code>redo</code>日志结构如下所示：</p>
<p><img src="/../../../../../../imgs/MySQL%E5%8E%9F%E7%90%86%E4%B9%8B%E4%BA%8B%E5%8A%A1%E7%AF%87/1694892fdf053082tplv-t2oaga2asx-jj-mark1890000q75.webp" alt="image_1d3fv01mv3jd7m719rpmn2jcsp.png-42.6kB"> </p>
<p>其余<code>MLOG_1BYTE</code>、<code>MLOG_2BYTE</code>、<code>MLOG_4BYTE</code>类型的<code>redo</code>日志结构和<code>MLOG_8BYTE</code>的类似，只不过具体数据中包含对应个字节的数据罢了。<code>MLOG_WRITE_STRING</code>类型的<code>redo</code>日志表示写入一串数据，但是因为不能确定写入的具体数据占用多少字节，所以需要在日志结构中添加一个<code>len</code>字段：</p>
<p><img src="/../../../../../../imgs/MySQL%E5%8E%9F%E7%90%86%E4%B9%8B%E4%BA%8B%E5%8A%A1%E7%AF%87/1694892fdf3da823tplv-t2oaga2asx-jj-mark1890000q75.webp" alt="image_1d3fv8at819jh1m7m1sfb1donvmu16.png-47.2kB"> </p>
<blockquote>
<p>只要将MLOG_WRITE_STRING类型的redo日志的len字段填充上1、2、4、8这些数字，就可以分别替代MLOG_1BYTE、MLOG_2BYTE、MLOG_4BYTE、MLOG_8BYTE这些类型的redo日志，为啥还要多此一举设计这么多类型呢？还不是因为省空间啊，能不写len字段就不写len字段，省一个字节算一个字节。</p>
</blockquote>
<h4 id="2-2-2复杂的redo日志类型"><a href="#2-2-2复杂的redo日志类型" class="headerlink" title="2.2.2复杂的redo日志类型"></a>2.2.2复杂的redo日志类型</h4><p>有时候执行一条语句会修改非常多的页面，包括系统数据页面和用户数据页面（用户数据指的就是聚簇索引和二级索引对应的<code>B+</code>树）。以一条<code>INSERT</code>语句为例，它除了要向<code>B+</code>树的页面中插入数据，也可能更新系统数据<code>Max Row ID</code>的值，不过对于我们用户来说，平时更关心的是语句对<code>B+</code>树所做更新：</p>
<ul>
<li>表中包含多少个索引，一条<code>INSERT</code>语句就可能更新多少棵<code>B+</code>树。</li>
<li>针对某一棵<code>B+</code>树来说，既可能更新叶子节点页面，也可能更新内节点页面，也可能创建新的页面（在该记录插入的叶子节点的剩余空间比较少，不足以存放该记录时，会进行页面的分裂，在内节点页面中添加<code>目录项记录</code>）。</li>
</ul>
<p>在语句执行过程中，<code>INSERT</code>语句对所有页面的修改都得保存到<code>redo</code>日志中去。这句话说的比较轻巧，做起来可就比较麻烦了，比方说将记录插入到聚簇索引中时，如果定位到的叶子节点的剩余空间足够存储该记录时，那么只更新该叶子节点页面就好，那么只记录一条<code>MLOG_WRITE_STRING</code>类型的<code>redo</code>日志，表明在页面的某个偏移量处增加了哪些数据就好了么？那就too young too naive了～ 别忘了一个数据页中除了存储实际的记录之后，还有什么<code>File Header</code>、<code>Page Header</code>、<code>Page Directory</code>等等部分（在唠叨数据页的章节有详细讲解），所以每往叶子节点代表的数据页里插入一条记录时，还有其他很多地方会跟着更新，比如说：</p>
<ul>
<li>可能更新<code>Page Directory</code>中的槽信息。</li>
<li><code>Page Header</code>中的各种页面统计信息，比如<code>PAGE_N_DIR_SLOTS</code>表示的槽数量可能会更改，<code>PAGE_HEAP_TOP</code>代表的还未使用的空间最小地址可能会更改，<code>PAGE_N_HEAP</code>代表的本页面中的记录数量可能会更改，吧啦吧啦，各种信息都可能会被修改。</li>
<li>我们知道在数据页里的记录是按照索引列从小到大的顺序组成一个单向链表的，每插入一条记录，还需要更新上一条记录的记录头信息中的<code>next_record</code>属性来维护这个单向链表。</li>
<li>还有别的吧啦吧啦的更新的地方，就不一一唠叨了…</li>
</ul>
<p>画一个简易的示意图就像是这样：</p>
<p><img src="/../../../../../../imgs/MySQL%E5%8E%9F%E7%90%86%E4%B9%8B%E4%BA%8B%E5%8A%A1%E7%AF%87/1694892fdfa7d8cetplv-t2oaga2asx-jj-mark1890000q75.webp" alt="image_1d3gv4i7vtsirf81ikl1q2140n2g.png-67.2kB"> </p>
<p>说了这么多，就是想表达：把一条记录插入到一个页面时需要更改的地方非常多。这时我们如果使用上边介绍的简单的物理<code>redo</code>日志来记录这些修改时，可以有两种解决方案：</p>
<ul>
<li><p>方案一：在每个修改的地方都记录一条<code>redo</code>日志。</p>
<p>也就是如上图所示，有多少个加粗的块，就写多少条物理<code>redo</code>日志。这样子记录<code>redo</code>日志的缺点是显而易见的，因为被修改的地方是在太多了，可能记录的<code>redo</code>日志占用的空间都比整个页面占用的空间都多了～</p>
</li>
<li><p>方案二：将整个页面的<code>第一个被修改的字节</code>到<code>最后一个修改的字节</code>之间所有的数据当成是一条物理<code>redo</code>日志中的具体数据。</p>
<p>从图中也可以看出来，<code>第一个被修改的字节</code>到<code>最后一个修改的字节</code>之间仍然有许多没有修改过的数据，我们把这些没有修改的数据也加入到<code>redo</code>日志中去岂不是太浪费了～</p>
</li>
</ul>
<p>正因为上述两种使用物理<code>redo</code>日志的方式来记录某个页面中做了哪些修改比较浪费，设计<code>InnoDB</code>的大叔本着勤俭节约的初心，提出了一些新的<code>redo</code>日志类型，比如：</p>
<ul>
<li><code>MLOG_REC_INSERT</code>（对应的十进制数字为<code>9</code>）：表示插入一条使用非紧凑行格式的记录时的<code>redo</code>日志类型。</li>
</ul>
<blockquote>
<p>Redundant是一种比较原始的行格式，它就是非紧凑的。而Compact、Dynamic以及Compressed行格式是较新的行格式，它们是紧凑的（占用更小的存储空间）。</p>
</blockquote>
<ul>
<li><code>MLOG_COMP_REC_INSERT</code>（对应的十进制数字为<code>38</code>）：表示插入一条使用紧凑行格式的记录时的<code>redo</code>日志类型。</li>
<li><code>MLOG_COMP_PAGE_CREATE</code>（<code>type</code>字段对应的十进制数字为<code>58</code>）：表示创建一个存储紧凑行格式记录的页面的<code>redo</code>日志类型。</li>
<li><code>MLOG_COMP_REC_DELETE</code>（<code>type</code>字段对应的十进制数字为<code>42</code>）：表示删除一条使用紧凑行格式记录的<code>redo</code>日志类型。</li>
<li><code>MLOG_COMP_LIST_START_DELETE</code>（<code>type</code>字段对应的十进制数字为<code>44</code>）：表示从某条给定记录开始删除页面中的一系列使用紧凑行格式记录的<code>redo</code>日志类型。</li>
<li><code>MLOG_COMP_LIST_END_DELETE</code>（<code>type</code>字段对应的十进制数字为<code>43</code>）：与<code>MLOG_COMP_LIST_START_DELETE</code>类型的<code>redo</code>日志呼应，表示删除一系列记录直到<code>MLOG_COMP_LIST_END_DELETE</code>类型的<code>redo</code>日志对应的记录为止。</li>
</ul>
<blockquote>
<p>我们前边唠叨InnoDB数据页格式的时候重点强调过，数据页中的记录是按照索引列大小的顺序组成单向链表的。有时候我们会有删除索引列的值在某个区间范围内的所有记录的需求，这时候如果我们每删除一条记录就写一条redo日志的话，效率可能有点低，所以提出MLOG_COMP_LIST_START_DELETE和MLOG_COMP_LIST_END_DELETE类型的redo日志，可以很大程度上减少redo日志的条数。</p>
</blockquote>
<p>这些类型的<code>redo</code>日志既包含<code>物理</code>层面的意思，也包含<code>逻辑</code>层面的意思，具体指：</p>
<ul>
<li>物理层面看，这些日志都指明了对哪个表空间的哪个页进行了修改。</li>
<li>逻辑层面看，在系统崩溃重启时，并不能直接根据这些日志里的记载，将页面内的某个偏移量处恢复成某个数据，而是需要调用一些事先准备好的函数，执行完这些函数后才可以将页面恢复成系统崩溃前的样子。</li>
</ul>
<p>大家看到这可能有些懵逼，我们还是以类型为<code>MLOG_COMP_REC_INSERT</code>这个代表插入一条使用紧凑行格式的记录时的<code>redo</code>日志为例来理解一下我们上边所说的<code>物理</code>层面和<code>逻辑</code>层面到底是个啥意思。废话少说，直接看一下这个类型为<code>MLOG_COMP_REC_INSERT</code>的<code>redo</code>日志的结构（由于字段太多了，我们把它们竖着看效果好些）：</p>
<p><img src="/../../../../../../imgs/MySQL%E5%8E%9F%E7%90%86%E4%B9%8B%E4%BA%8B%E5%8A%A1%E7%AF%87/1694892fe02553d0tplv-t2oaga2asx-jj-mark1890000q75.webp" alt="image_1d3bn8tsq1ssp1nmdks8kdr17e31t.png-85.7kB"> </p>
<p>这个类型为<code>MLOG_COMP_REC_INSERT</code>的<code>redo</code>日志结构有几个地方需要大家注意：</p>
<ul>
<li>我们前边在唠叨索引的时候说过，在一个数据页里，不论是叶子节点还是非叶子节点，记录都是按照索引列从小到大的顺序排序的。对于二级索引来说，当索引列的值相同时，记录还需要按照主键值进行排序。图中<code>n_uniques</code>的值的含义是在一条记录中，需要几个字段的值才能确保记录的唯一性，这样当插入一条记录时就可以按照记录的前<code>n_uniques</code>个字段进行排序。对于聚簇索引来说，<code>n_uniques</code>的值为主键的列数，对于其他二级索引来说，该值为索引列数+主键列数。这里需要注意的是，唯一二级索引的值可能为<code>NULL</code>，所以该值仍然为索引列数+主键列数。</li>
<li><code>field1_len ~ fieldn_len</code>代表着该记录若干个字段占用存储空间的大小，需要注意的是，这里不管该字段的类型是固定长度大小的（比如<code>INT</code>），还是可变长度大小（比如<code>VARCHAR(M)</code>）的，该字段占用的大小始终要写入<code>redo</code>日志中。</li>
<li><code>offset</code>代表的是该记录的前一条记录在页面中的地址。为啥要记录前一条记录的地址呢？这是因为每向数据页插入一条记录，都需要修改该页面中维护的记录链表，每条记录的<code>记录头信息</code>中都包含一个称为<code>next_record</code>的属性，所以在插入新记录时，需要修改前一条记录的<code>next_record</code>属性。</li>
<li>我们知道一条记录其实由<code>额外信息</code>和<code>真实数据</code>这两部分组成，这两个部分的总大小就是一条记录占用存储空间的总大小。通过<code>end_seg_len</code>的值可以间接的计算出一条记录占用存储空间的总大小，为啥不直接存储一条记录占用存储空间的总大小呢？这是因为写<code>redo</code>日志是一个非常频繁的操作，设计<code>InnoDB</code>的大叔想方设法想减小<code>redo</code>日志本身占用的存储空间大小，所以想了一些弯弯绕的算法来实现这个目标，<code>end_seg_len</code>这个字段就是为了节省<code>redo</code>日志存储空间而提出来的。至于具体设计<code>InnoDB</code>的大叔到底是用了什么神奇魔法减小<code>redo</code>日志大小的，我们这就不多唠叨了，因为的确有那么一丢丢小复杂，说清楚还是有一点点麻烦的，而且说明白了也没啥用。</li>
<li><code>mismatch_index</code>的值也是为了节省<code>redo</code>日志的大小而设立的，大家可以忽略。</li>
</ul>
<p>很显然这个类型为<code>MLOG_COMP_REC_INSERT</code>的<code>redo</code>日志并没有记录<code>PAGE_N_DIR_SLOTS</code>的值修改为了啥，<code>PAGE_HEAP_TOP</code>的值修改为了啥，<code>PAGE_N_HEAP</code>的值修改为了啥等等这些信息，而只是把在本页面中插入一条记录所有必备的要素记了下来，之后系统崩溃重启时，服务器会调用相关向某个页面插入一条记录的那个函数，而<code>redo</code>日志中的那些数据就可以被当成是调用这个函数所需的参数，在调用完该函数后，页面中的<code>PAGE_N_DIR_SLOTS</code>、<code>PAGE_HEAP_TOP</code>、<code>PAGE_N_HEAP</code>等等的值也就都被恢复到系统崩溃前的样子了。这就是所谓的<code>逻辑</code>日志的意思。</p>
<blockquote>
<p>为了节省redo日志占用的存储空间大小，设计InnoDB的大叔对redo日志中的某些数据还可能进行压缩处理，比方说space ID和page number一般占用4个字节来存储，但是经过压缩后，可能使用更小的空间来存储。具体压缩算法就不唠叨了。</p>
</blockquote>
<h3 id="2-3Mini-Transaction"><a href="#2-3Mini-Transaction" class="headerlink" title="2.3Mini-Transaction"></a>2.3Mini-Transaction</h3><h4 id="2-3-1以组的形式写入redo日志"><a href="#2-3-1以组的形式写入redo日志" class="headerlink" title="2.3.1以组的形式写入redo日志"></a>2.3.1以组的形式写入redo日志</h4><p>语句在执行过程中可能修改若干个页面。比如我们前边说的一条<code>INSERT</code>语句可能修改系统表空间页号为<code>7</code>的页面的<code>Max Row ID</code>属性（当然也可能更新别的系统页面，只不过我们没有都列举出来而已），还会更新聚簇索引和二级索引对应<code>B+</code>树中的页面。由于对这些页面的更改都发生在<code>Buffer Pool</code>中，所以在修改完页面之后，需要记录一下相应的<code>redo</code>日志。在执行语句的过程中产生的<code>redo</code>日志被设计<code>InnoDB</code>的大叔人为的划分成了若干个不可分割的组，比如：</p>
<ul>
<li>更新<code>Max Row ID</code>属性时产生的<code>redo</code>日志是不可分割的。</li>
<li>向聚簇索引对应<code>B+</code>树的页面中插入一条记录时产生的<code>redo</code>日志是不可分割的。</li>
<li>向某个二级索引对应<code>B+</code>树的页面中插入一条记录时产生的<code>redo</code>日志是不可分割的。</li>
<li>还有其他的一些对页面的访问操作时产生的<code>redo</code>日志是不可分割的。。。</li>
</ul>
<p>怎么理解这个<code>不可分割</code>的意思呢？我们以向某个索引对应的<code>B+</code>树插入一条记录为例，在向<code>B+</code>树中插入这条记录之前，需要先定位到这条记录应该被插入到哪个叶子节点代表的数据页中，定位到具体的数据页之后，有两种可能的情况：</p>
<ul>
<li><p>情况一：该数据页的剩余的空闲空间充足，足够容纳这一条待插入记录，那么事情很简单，直接把记录插入到这个数据页中，记录一条类型为<code>MLOG_COMP_REC_INSERT</code>的<code>redo</code>日志就好了，我们把这种情况称之为<code>乐观插入</code>。假如某个索引对应的<code>B+</code>树长这样：</p>
<p><img src="/../../../../../../imgs/MySQL%E5%8E%9F%E7%90%86%E4%B9%8B%E4%BA%8B%E5%8A%A1%E7%AF%87/1694892fe05a2603tplv-t2oaga2asx-jj-mark1890000q75.webp" alt="image_1d4fc7b6b1ftt16ji11as4a63h23.png-30.8kB"> </p>
<p>现在我们要插入一条键值为<code>10</code>的记录，很显然需要被插入到<code>页b</code>中，由于<code>页b</code>现在有足够的空间容纳一条记录，所以直接将该记录插入到<code>页b</code>中就好了，就像这样：</p>
<p><img src="/../../../../../../imgs/MySQL%E5%8E%9F%E7%90%86%E4%B9%8B%E4%BA%8B%E5%8A%A1%E7%AF%87/16948930120794a0tplv-t2oaga2asx-jj-mark1890000q75.webp" alt="image_1d4fcbg9e1m1b1qtj1emgphorrl2g.png-43.3kB">  </p>
</li>
<li><p>情况二：该数据页剩余的空闲空间不足，那么事情就悲剧了，我们前边说过，遇到这种情况要进行所谓的<code>页分裂</code>操作，也就是新建一个叶子节点，然后把原先数据页中的一部分记录复制到这个新的数据页中，然后再把记录插入进去，把这个叶子节点插入到叶子节点链表中，最后还要在内节点中添加一条<code>目录项记录</code>指向这个新创建的页面。很显然，这个过程要对多个页面进行修改，也就意味着会产生多条<code>redo</code>日志，我们把这种情况称之为<code>悲观插入</code>。假如某个索引对应的<code>B+</code>树长这样：</p>
<p><img src="/../../../../../../imgs/MySQL%E5%8E%9F%E7%90%86%E4%B9%8B%E4%BA%8B%E5%8A%A1%E7%AF%87/1694893011fc216etplv-t2oaga2asx-jj-mark1890000q75.webp" alt="image_1d4fcomne1lpsp691hg2o416hh2t.png-44.5kB"> </p>
<p>现在我们要插入一条键值为<code>10</code>的记录，很显然需要被插入到<code>页b</code>中，但是从图中也可以看出来，此时<code>页b</code>已经塞满了记录，没有更多的空闲空间来容纳这条新记录了，所以我们需要进行页面的分裂操作，就像这样：</p>
<p><img src="/../../../../../../imgs/MySQL%E5%8E%9F%E7%90%86%E4%B9%8B%E4%BA%8B%E5%8A%A1%E7%AF%87/16948930147d598etplv-t2oaga2asx-jj-mark1890000q75.webp" alt="image_1d4fkn8gv1n7enuq23kt1n1uvk3n.png-96.9kB"> </p>
<p>如果作为内节点的<code>页a</code>的剩余空闲空间也不足以容纳增加一条<code>目录项记录</code>，那需要继续做内节点<code>页a</code>的分裂操作，也就意味着会修改更多的页面，从而产生更多的<code>redo</code>日志。另外，对于<code>悲观插入</code>来说，由于需要新申请数据页，还需要改动一些系统页面，比方说要修改各种段、区的统计信息信息，各种链表的统计信息（比如什么<code>FREE</code>链表、<code>FSP_FREE_FRAG</code>链表吧啦吧啦我们在唠叨表空间那一章中介绍过的各种东东）等等等等，反正总共需要记录的<code>redo</code>日志有二、三十条。</p>
</li>
</ul>
<p>设计<code>InnoDB</code>的大叔们认为向某个索引对应的<code>B+</code>树中插入一条记录的这个过程必须是原子的，不能说插了一半之后就停止了。比方说在悲观插入过程中，新的页面已经分配好了，数据也复制过去了，新的记录也插入到页面中了，可是没有向内节点中插入一条<code>目录项记录</code>，这个插入过程就是不完整的，这样会形成一棵不正确的<code>B+</code>树。我们知道<code>redo</code>日志是为了在系统崩溃重启时恢复崩溃前的状态，如果在悲观插入的过程中只记录了一部分<code>redo</code>日志，那么在系统崩溃重启时会将索引对应的<code>B+</code>树恢复成一种不正确的状态，这是设计<code>InnoDB</code>的大叔们所不能忍受的。所以他们规定在执行这些需要保证原子性的操作时必须以<code>组</code>的形式来记录的<code>redo</code>日志，在进行系统崩溃重启恢复时，针对某个组中的<code>redo</code>日志，要么把全部的日志都恢复掉，要么一条也不恢复。怎么做到的呢？这得分情况讨论：</p>
<ul>
<li><p>有的需要保证原子性的操作会生成多条<code>redo</code>日志，比如向某个索引对应的<code>B+</code>树中进行一次悲观插入就需要生成许多条<code>redo</code>日志。</p>
<p>如何把这些<code>redo</code>日志划分到一个组里边儿呢？设计<code>InnoDB</code>的大叔做了一个很简单的小把戏，就是在该组中的最后一条<code>redo</code>日志后边加上一条特殊类型的<code>redo</code>日志，该类型名称为<code>MLOG_MULTI_REC_END</code>，<code>type</code>字段对应的十进制数字为<code>31</code>，该类型的<code>redo</code>日志结构很简单，只有一个<code>type</code>字段：</p>
<p><img src="/../../../../../../imgs/MySQL%E5%8E%9F%E7%90%86%E4%B9%8B%E4%BA%8B%E5%8A%A1%E7%AF%87/16948930162d677ftplv-t2oaga2asx-jj-mark1890000q75.webp" alt="image_1d4fna6k51fok1mpd1tikkmihg144.png-15kB"> </p>
<p>所以某个需要保证原子性的操作产生的一系列<code>redo</code>日志必须要以一个类型为<code>MLOG_MULTI_REC_END</code>结尾，就像这样：</p>
<p><img src="/../../../../../../imgs/MySQL%E5%8E%9F%E7%90%86%E4%B9%8B%E4%BA%8B%E5%8A%A1%E7%AF%87/16948930164d64a0tplv-t2oaga2asx-jj-mark1890000q75.webp" alt="image_1d4fol2v71fjalphluu1kuf1d8t4h.png-41.4kB"> </p>
<p>这样在系统崩溃重启进行恢复时，只有当解析到类型为<code>MLOG_MULTI_REC_END</code>的<code>redo</code>日志，才认为解析到了一组完整的<code>redo</code>日志，才会进行恢复。否则的话直接放弃前边解析到的<code>redo</code>日志。</p>
</li>
<li><p>有的需要保证原子性的操作只生成一条<code>redo</code>日志，比如更新<code>Max Row ID</code>属性的操作就只会生成一条<code>redo</code>日志。</p>
<p>其实在一条日志后边跟一个类型为<code>MLOG_MULTI_REC_END</code>的<code>redo</code>日志也是可以的，不过设计<code>InnoDB</code>的大叔比较勤俭节约，他们不想浪费一个比特位。别忘了虽然<code>redo</code>日志的类型比较多，但撑死了也就是几十种，是小于<code>127</code>这个数字的，也就是说我们用7个比特位就足以包括所有的<code>redo</code>日志类型，而<code>type</code>字段其实是占用1个字节的，也就是说我们可以省出来一个比特位用来表示该需要保证原子性的操作只产生单一的一条<code>redo</code>日志，示意图如下：</p>
<p><img src="/../../../../../../imgs/MySQL%E5%8E%9F%E7%90%86%E4%B9%8B%E4%BA%8B%E5%8A%A1%E7%AF%87/169489301685dcb4tplv-t2oaga2asx-jj-mark1890000q75.webp" alt="image_1d4fqlji7md35pdmvvhvibqb4u.png-27.4kB"> </p>
<p>如果<code>type</code>字段的第一个比特位为<code>1</code>，代表该需要保证原子性的操作只产生了单一的一条<code>redo</code>日志，否则表示该需要保证原子性的操作产生了一系列的<code>redo</code>日志。</p>
</li>
</ul>
<h4 id="2-3-2Mini-Transaction的概念"><a href="#2-3-2Mini-Transaction的概念" class="headerlink" title="2.3.2Mini-Transaction的概念"></a>2.3.2Mini-Transaction的概念</h4><p>设计<code>MySQL</code>的大叔把对底层页面中的一次原子访问的过程称之为一个<code>Mini-Transaction</code>，简称<code>mtr</code>，比如上边所说的修改一次<code>Max Row ID</code>的值算是一个<code>Mini-Transaction</code>，向某个索引对应的<code>B+</code>树中插入一条记录的过程也算是一个<code>Mini-Transaction</code>。通过上边的叙述我们也知道，一个所谓的<code>mtr</code>可以包含一组<code>redo</code>日志，在进行崩溃恢复时这一组<code>redo</code>日志作为一个不可分割的整体。</p>
<p>一个事务可以包含若干条语句，每一条语句其实是由若干个<code>mtr</code>组成，每一个<code>mtr</code>又可以包含若干条<code>redo</code>日志，画个图表示它们的关系就是这样：</p>
<p><img src="/../../../../../../imgs/MySQL%E5%8E%9F%E7%90%86%E4%B9%8B%E4%BA%8B%E5%8A%A1%E7%AF%87/169489303b9e5c9ftplv-t2oaga2asx-jj-mark1890000q75.webp" alt="image_1d4hgjr7t4es1v2mf2b1bt51rf95b.png-27.6kB"> </p>
<h3 id="2-4redo日志的写入过程"><a href="#2-4redo日志的写入过程" class="headerlink" title="2.4redo日志的写入过程"></a>2.4redo日志的写入过程</h3><h4 id="2-4-1redo-log-block"><a href="#2-4-1redo-log-block" class="headerlink" title="2.4.1redo log block"></a>2.4.1redo log block</h4><p>设计<code>InnoDB</code>的大叔为了更好的进行系统崩溃恢复，他们把通过<code>mtr</code>生成的<code>redo</code>日志都放在了大小为<code>512字节</code>的<code>页</code>中。为了和我们前边提到的表空间中的页做区别，我们这里把用来存储<code>redo</code>日志的页称为<code>block</code>（你心里清楚页和block的意思其实差不多就行了）。一个<code>redo log block</code>的示意图如下：</p>
<p><img src="/../../../../../../imgs/MySQL%E5%8E%9F%E7%90%86%E4%B9%8B%E4%BA%8B%E5%8A%A1%E7%AF%87/169489303bff8e20tplv-t2oaga2asx-jj-mark1890000q75.webp" alt="image_1d4hor6e7nq1mkm1sa41he71rif75.png-57.2kB"> </p>
<p>真正的<code>redo</code>日志都是存储到占用<code>496</code>字节大小的<code>log block body</code>中，图中的<code>log block header</code>和<code>log block trailer</code>存储的是一些管理信息。我们来看看这些所谓的<code>管理信息</code>都是啥：</p>
<p><img src="/../../../../../../imgs/MySQL%E5%8E%9F%E7%90%86%E4%B9%8B%E4%BA%8B%E5%8A%A1%E7%AF%87/169489303c1fb389tplv-t2oaga2asx-jj-mark1890000q75.webp" alt="image_1d4hp4u8g13e317mkngoag21clv7i.png-113.9kB"> </p>
<p>其中<code>log block header</code>的几个属性的意思分别如下：</p>
<ul>
<li><code>LOG_BLOCK_HDR_NO</code>：每一个block都有一个大于0的唯一标号，本属性就表示该标号值。</li>
<li><code>LOG_BLOCK_HDR_DATA_LEN</code>：表示block中已经使用了多少字节，初始值为<code>12</code>（因为<code>log block body</code>从第12个字节处开始）。随着往block中写入的redo日志越来也多，本属性值也跟着增长。如果<code>log block body</code>已经被全部写满，那么本属性的值被设置为<code>512</code>。</li>
<li><code>LOG_BLOCK_FIRST_REC_GROUP</code>：一条<code>redo</code>日志也可以称之为一条<code>redo</code>日志记录（<code>redo log record</code>），一个<code>mtr</code>会生产多条<code>redo</code>日志记录，这些<code>redo</code>日志记录被称之为一个<code>redo</code>日志记录组（<code>redo log record group</code>）。<code>LOG_BLOCK_FIRST_REC_GROUP</code>就代表该block中第一个<code>mtr</code>生成的<code>redo</code>日志记录组的偏移量（其实也就是这个block里第一个<code>mtr</code>生成的第一条<code>redo</code>日志的偏移量）。</li>
<li><code>LOG_BLOCK_CHECKPOINT_NO</code>：表示所谓的<code>checkpoint</code>的序号，<code>checkpoint</code>是我们后续内容的重点，现在先不用清楚它的意思，稍安勿躁。</li>
</ul>
<p><code>log block trailer</code>中属性的意思如下：</p>
<ul>
<li><code>LOG_BLOCK_CHECKSUM</code>：表示block的校验值，用于正确性校验，我们暂时不关心它。</li>
</ul>
<h4 id="2-4-2redo日志缓冲区"><a href="#2-4-2redo日志缓冲区" class="headerlink" title="2.4.2redo日志缓冲区"></a>2.4.2redo日志缓冲区</h4><p>我们前边说过，设计<code>InnoDB</code>的大叔为了解决磁盘速度过慢的问题而引入了<code>Buffer Pool</code>。同理，写入<code>redo</code>日志时也不能直接直接写到磁盘上，实际上在服务器启动时就向操作系统申请了一大片称之为<code>redo log buffer</code>的连续内存空间，翻译成中文就是<code>redo日志缓冲区</code>，我们也可以简称为<code>log buffer</code>。这片内存空间被划分成若干个连续的<code>redo log block</code>，就像这样：</p>
<p><img src="/../../../../../../imgs/MySQL%E5%8E%9F%E7%90%86%E4%B9%8B%E4%BA%8B%E5%8A%A1%E7%AF%87/169489303ceeb982tplv-t2oaga2asx-jj-mark1890000q75.webp" alt="image_1d4i4orkr17vl1m5l3hl1l341pad1j.png-76.5kB"> </p>
<p>我们可以通过启动参数<code>innodb_log_buffer_size</code>来指定<code>log buffer</code>的大小，在<code>MySQL 5.7.21</code>这个版本中，该启动参数的默认值为<code>16MB</code>。</p>
<h4 id="2-4-3redo日志写入log-buffer"><a href="#2-4-3redo日志写入log-buffer" class="headerlink" title="2.4.3redo日志写入log buffer"></a>2.4.3redo日志写入log buffer</h4><p>向<code>log buffer</code>中写入<code>redo</code>日志的过程是顺序的，也就是先往前边的block中写，当该block的空闲空间用完之后再往下一个block中写。当我们想往<code>log buffer</code>中写入<code>redo</code>日志时，第一个遇到的问题就是应该写在哪个<code>block</code>的哪个偏移量处，所以设计<code>InnoDB</code>的大叔特意提供了一个称之为<code>buf_free</code>的全局变量，该变量指明后续写入的<code>redo</code>日志应该写入到<code>log buffer</code>中的哪个位置，如图所示：</p>
<p><img src="/../../../../../../imgs/MySQL%E5%8E%9F%E7%90%86%E4%B9%8B%E4%BA%8B%E5%8A%A1%E7%AF%87/1694893043dc7344tplv-t2oaga2asx-jj-mark1890000q75.webp" alt="image_1d4jsb3pac9t1pl76drruf1b0574.png-98.4kB"> </p>
<p>我们前边说过一个<code>mtr</code>执行过程中可能产生若干条<code>redo</code>日志，这些<code>redo</code>日志是一个不可分割的组，所以其实并不是每生成一条<code>redo</code>日志，就将其插入到<code>log buffer</code>中，而是每个<code>mtr</code>运行过程中产生的日志先暂时存到一个地方，当该<code>mtr</code>结束的时候，将过程中产生的一组<code>redo</code>日志再全部复制到<code>log buffer</code>中。我们现在假设有两个名为<code>T1</code>、<code>T2</code>的事务，每个事务都包含2个<code>mtr</code>，我们给这几个<code>mtr</code>命名一下：</p>
<ul>
<li>事务<code>T1</code>的两个<code>mtr</code>分别称为<code>mtr_T1_1</code>和<code>mtr_T1_2</code>。</li>
<li>事务<code>T2</code>的两个<code>mtr</code>分别称为<code>mtr_T2_1</code>和<code>mtr_T2_2</code>。</li>
</ul>
<p>每个<code>mtr</code>都会产生一组<code>redo</code>日志，用示意图来描述一下这些<code>mtr</code>产生的日志情况：</p>
<p><img src="/../../../../../../imgs/MySQL%E5%8E%9F%E7%90%86%E4%B9%8B%E4%BA%8B%E5%8A%A1%E7%AF%87/1692548dcc3fe243tplv-t2oaga2asx-jj-mark1890000q75.webp" alt="image_1d4ie92r31t57c94e661n861skv2t.png-95.1kB"> </p>
<p>不同的事务可能是并发执行的，所以<code>T1</code>、<code>T2</code>之间的<code>mtr</code>可能是交替执行的。每当一个<code>mtr</code>执行完成时，伴随该<code>mtr</code>生成的一组<code>redo</code>日志就需要被复制到<code>log buffer</code>中，也就是说不同事务的<code>mtr</code>可能是交替写入<code>log buffer</code>的，我们画个示意图（为了美观，我们把一个<code>mtr</code>中产生的所有的<code>redo</code>日志当作一个整体来画）：</p>
<p><img src="/../../../../../../imgs/MySQL%E5%8E%9F%E7%90%86%E4%B9%8B%E4%BA%8B%E5%8A%A1%E7%AF%87/169489304969c9d7tplv-t2oaga2asx-jj-mark1890000q75.webp" alt="image_1d4jsd7861q6dn9n17gs1cdd1kek7h.png-102.6kB"> </p>
<p>从示意图中我们可以看出来，不同的<code>mtr</code>产生的一组<code>redo</code>日志占用的存储空间可能不一样，有的<code>mtr</code>产生的<code>redo</code>日志量很少，比如<code>mtr_t1_1</code>、<code>mtr_t2_1</code>就被放到同一个block中存储，有的<code>mtr</code>产生的<code>redo</code>日志量非常大，比如<code>mtr_t1_2</code>产生的<code>redo</code>日志甚至占用了3个block来存储。</p>
<h3 id="2-5redo日志文件"><a href="#2-5redo日志文件" class="headerlink" title="2.5redo日志文件"></a>2.5redo日志文件</h3><h4 id="2-5-1redo日志刷盘时机"><a href="#2-5-1redo日志刷盘时机" class="headerlink" title="2.5.1redo日志刷盘时机"></a>2.5.1redo日志刷盘时机</h4><p>我们前边说<code>mtr</code>运行过程中产生的一组<code>redo</code>日志在<code>mtr</code>结束时会被复制到<code>log buffer</code>中，可是这些日志总在内存里呆着也不是个办法，在一些情况下它们会被刷新到磁盘里，比如：</p>
<ul>
<li><p><code>log buffer</code>空间不足时</p>
<p><code>log buffer</code>的大小是有限的（通过系统变量<code>innodb_log_buffer_size</code>指定），如果不停的往这个有限大小的<code>log buffer</code>里塞入日志，很快它就会被填满。设计<code>InnoDB</code>的大叔认为如果当前写入<code>log buffer</code>的<code>redo</code>日志量已经占满了<code>log buffer</code>总容量的大约一半左右，就需要把这些日志刷新到磁盘上。</p>
</li>
<li><p>事务提交时</p>
<p>我们前边说过之所以使用<code>redo</code>日志主要是因为它占用的空间少，还是顺序写，在事务提交时可以不把修改过的<code>Buffer Pool</code>页面刷新到磁盘，但是为了保证持久性，必须要把修改这些页面对应的<code>redo</code>日志刷新到磁盘。</p>
</li>
<li><p>将某个脏页刷新到磁盘前，会保证先将该脏页对应的 redo 日志刷新到磁盘中（再一次强调，redo 日志是顺序刷新的，所以在将某个脏页对应的 redo 日志从 redo log buffer 刷新到磁盘时，也会保证将在其之前产生的 redo 日志也刷新到磁盘）。</p>
</li>
<li><p>后台线程不停的刷刷刷</p>
<p>后台有一个线程，大约每秒都会刷新一次<code>log buffer</code>中的<code>redo</code>日志到磁盘。</p>
</li>
<li><p>正常关闭服务器时</p>
</li>
<li><p>做所谓的<code>checkpoint</code>时（我们现在没介绍过<code>checkpoint</code>的概念，稍后会仔细唠叨，稍安勿躁）</p>
</li>
<li><p>其他的一些情况…</p>
</li>
</ul>
<h4 id="2-5-2redo日志文件组"><a href="#2-5-2redo日志文件组" class="headerlink" title="2.5.2redo日志文件组"></a>2.5.2redo日志文件组</h4><p><code>MySQL</code>的数据目录（使用<code>SHOW VARIABLES LIKE &#39;datadir&#39;</code>查看）下默认有两个名为<code>ib_logfile0</code>和<code>ib_logfile1</code>的文件，<code>log buffer</code>中的日志默认情况下就是刷新到这两个磁盘文件中。如果我们对默认的<code>redo</code>日志文件不满意，可以通过下边几个启动参数来调节：</p>
<ul>
<li><p><code>innodb_log_group_home_dir</code></p>
<p>该参数指定了<code>redo</code>日志文件所在的目录，默认值就是当前的数据目录。</p>
</li>
<li><p><code>innodb_log_file_size</code></p>
<p>该参数指定了每个<code>redo</code>日志文件的大小，在<code>MySQL 5.7.21</code>这个版本中的默认值为<code>48MB</code>，</p>
</li>
<li><p><code>innodb_log_files_in_group</code></p>
<p>该参数指定<code>redo</code>日志文件的个数，默认值为2，最大值为100。</p>
</li>
</ul>
<p>从上边的描述中可以看到，磁盘上的<code>redo</code>日志文件不只一个，而是以一个<code>日志文件组</code>的形式出现的。这些文件以<code>ib_logfile[数字]</code>（<code>数字</code>可以是<code>0</code>、<code>1</code>、<code>2</code>…）的形式进行命名。在将<code>redo</code>日志写入<code>日志文件组</code>时，是从<code>ib_logfile0</code>开始写，如果<code>ib_logfile0</code>写满了，就接着<code>ib_logfile1</code>写，同理，<code>ib_logfile1</code>写满了就去写<code>ib_logfile2</code>，依此类推。如果写到最后一个文件该咋办？那就重新转到<code>ib_logfile0</code>继续写，所以整个过程如下图所示：</p>
<p><img src="/../../../../../../imgs/MySQL%E5%8E%9F%E7%90%86%E4%B9%8B%E4%BA%8B%E5%8A%A1%E7%AF%87/169b899033f3b35dtplv-t2oaga2asx-jj-mark1890000q75.webp" alt="image_1d4mu4s6f7491l7l1jcc6pc1rbk16.png-49.7kB"> </p>
<p>总共的<code>redo</code>日志文件大小其实就是：<code>innodb_log_file_size × innodb_log_files_in_group</code>。</p>
<blockquote>
<p>如果采用循环使用的方式向redo日志文件组里写数据的话，那岂不是要追尾，也就是后写入的redo日志覆盖掉前边写的redo日志？当然可能了！所以设计InnoDB的大叔提出了checkpoint的概念，稍后我们重点唠叨～</p>
</blockquote>
<h4 id="2-5-3redo日志文件格式"><a href="#2-5-3redo日志文件格式" class="headerlink" title="2.5.3redo日志文件格式"></a>2.5.3redo日志文件格式</h4><p>我们前边说过<code>log buffer</code>本质上是一片连续的内存空间，被划分成了若干个<code>512</code>字节大小的<code>block</code>。将log buffer中的redo日志刷新到磁盘的本质就是把block的镜像写入日志文件中，所以<code>redo</code>日志文件其实也是由若干个<code>512</code>字节大小的block组成。</p>
<p><code>redo</code>日志文件组中的每个文件大小都一样，格式也一样，都是由两部分组成：</p>
<ul>
<li>前2048个字节，也就是前4个block是用来存储一些管理信息的。</li>
<li>从第2048字节往后是用来存储<code>log buffer</code>中的block镜像的。</li>
</ul>
<p>所以我们前边所说的<code>循环</code>使用redo日志文件，其实是从每个日志文件的第2048个字节开始算，画个示意图就是这样：</p>
<p><img src="/../../../../../../imgs/MySQL%E5%8E%9F%E7%90%86%E4%B9%8B%E4%BA%8B%E5%8A%A1%E7%AF%87/169b899033d57b7atplv-t2oaga2asx-jj-mark1890000q75.webp" alt="image_1d4njgt351je21kitk7u1gbioa46j.png-64.9kB"> </p>
<p>普通block的格式我们在唠叨<code>log buffer</code>的时候都说过了，就是<code>log block header</code>、<code>log block body</code>、<code>log block trialer</code>这三个部分，就不重复介绍了。这里需要介绍一下每个<code>redo</code>日志文件前2048个字节，也就是前4个特殊block的格式都是干嘛的，废话少说，先看图：</p>
<p><img src="/../../../../../../imgs/MySQL%E5%8E%9F%E7%90%86%E4%B9%8B%E4%BA%8B%E5%8A%A1%E7%AF%87/169b899033e1cb89tplv-t2oaga2asx-jj-mark1890000q75.webp" alt="image_1d4n63euu1t3u1ten1tgicecsar4c.png-51.1kB"> </p>
<p>从图中可以看出来，这4个block分别是：</p>
<ul>
<li><p><code>log file header</code>：描述该<code>redo</code>日志文件的一些整体属性，看一下它的结构：</p>
<p><img src="/../../../../../../imgs/MySQL%E5%8E%9F%E7%90%86%E4%B9%8B%E4%BA%8B%E5%8A%A1%E7%AF%87/169b899065200011tplv-t2oaga2asx-jj-mark1890000q75.webp" alt="image_1d4nfhoa914vbne4kao7cstr95m.png-65.5kB"> </p>
<p><img src="/../../../../../../imgs/MySQL%E5%8E%9F%E7%90%86%E4%B9%8B%E4%BA%8B%E5%8A%A1%E7%AF%87/image-20231220164259616.png" alt="image-20231220164259616"> </p>
</li>
<li><p><code>checkpoint1</code>：记录关于<code>checkpoint</code>的一些属性，看一下它的结构：</p>
<p><img src="/../../../../../../imgs/MySQL%E5%8E%9F%E7%90%86%E4%B9%8B%E4%BA%8B%E5%8A%A1%E7%AF%87/169b899037defb21tplv-t2oaga2asx-jj-mark1890000q75.webp" alt="image_1d4njq08pd2a5j9pc01qcn2ps7g.png-60.1kB"> </p>
<p><img src="/../../../../../../imgs/MySQL%E5%8E%9F%E7%90%86%E4%B9%8B%E4%BA%8B%E5%8A%A1%E7%AF%87/image-20231220164407649.png" alt="image-20231220164407649"> </p>
</li>
<li><p>第三个block未使用，忽略～</p>
</li>
<li><p><code>checkpoint2</code>：结构和<code>checkpoint1</code>一样。</p>
</li>
</ul>
<h3 id="2-6Log-Sequence-Number"><a href="#2-6Log-Sequence-Number" class="headerlink" title="2.6Log Sequence Number"></a>2.6Log Sequence Number</h3><p>自系统开始运行，就不断的在修改页面，也就意味着会不断的生成<code>redo</code>日志。<code>redo</code>日志的量在不断的递增，就像人的年龄一样，自打出生起就不断递增，永远不可能缩减了。设计<code>InnoDB</code>的大叔为记录已经写入的<code>redo</code>日志量，设计了一个称之为<code>Log Sequence Number</code>的全局变量，翻译过来就是：<code>日志序列号</code>，简称<code>lsn</code>。不过不像人一出生的年龄是<code>0</code>岁，设计<code>InnoDB</code>的大叔规定初始的<code>lsn</code>值为<code>8704</code>（也就是一条<code>redo</code>日志也没写入时，<code>lsn</code>的值为<code>8704</code>）。</p>
<p>我们知道在向<code>log buffer</code>中写入<code>redo</code>日志时不是一条一条写入的，而是以一个<code>mtr</code>生成的一组<code>redo</code>日志为单位进行写入的。而且实际上是把日志内容写在了<code>log block body</code>处。但是在统计<code>lsn</code>的增长量时，是按照实际写入的日志量加上占用的<code>log block header</code>和<code>log block trailer</code>来计算的。我们来看一个例子：</p>
<ul>
<li><p>系统第一次启动后初始化<code>log buffer</code>时，<code>buf_free</code>（就是标记下一条<code>redo</code>日志应该写入到<code>log buffer</code>的位置的变量）就会指向第一个<code>block</code>的偏移量为12字节（<code>log block header</code>的大小）的地方，那么<code>lsn</code>值也会跟着增加12：</p>
<p><img src="/../../../../../../imgs/MySQL%E5%8E%9F%E7%90%86%E4%B9%8B%E4%BA%8B%E5%8A%A1%E7%AF%87/169b899065393c60tplv-t2oaga2asx-jj-mark1890000q75.webp" alt="image_1d4v2r59mr10jdl1vs4fk61huv79.png-50.9kB"> </p>
</li>
<li><p>如果某个<code>mtr</code>产生的一组<code>redo</code>日志占用的存储空间比较小，也就是待插入的block剩余空闲空间能容纳这个<code>mtr</code>提交的日志时，<code>lsn</code>增长的量就是该<code>mtr</code>生成的<code>redo</code>日志占用的字节数，就像这样：</p>
<p><img src="/../../../../../../imgs/MySQL%E5%8E%9F%E7%90%86%E4%B9%8B%E4%BA%8B%E5%8A%A1%E7%AF%87/169b899036dc68a0tplv-t2oaga2asx-jj-mark1890000q75.webp" alt="image_1d4v57vgl1obr1kfcfuunp44bo2t.png-54kB"> </p>
<p>我们假设上图中<code>mtr_1</code>产生的<code>redo</code>日志量为200字节，那么<code>lsn</code>就要在<code>8716</code>的基础上增加<code>200</code>，变为<code>8916</code>。</p>
</li>
<li><p>如果某个<code>mtr</code>产生的一组<code>redo</code>日志占用的存储空间比较大，也就是待插入的block剩余空闲空间不足以容纳这个<code>mtr</code>提交的日志时，<code>lsn</code>增长的量就是该<code>mtr</code>生成的<code>redo</code>日志占用的字节数加上额外占用的<code>log block header</code>和<code>log block trailer</code>的字节数，就像这样：</p>
<p><img src="/../../../../../../imgs/MySQL%E5%8E%9F%E7%90%86%E4%B9%8B%E4%BA%8B%E5%8A%A1%E7%AF%87/169b899037f19b86tplv-t2oaga2asx-jj-mark1890000q75.webp" alt="image_1d4v37u011jhc1rpa1fpi5a82ca9.png-99.3kB"> </p>
<p>我们假设上图中<code>mtr_2</code>产生的<code>redo</code>日志量为1000字节，为了将<code>mtr_2</code>产生的<code>redo</code>日志写入<code>log buffer</code>，我们不得不额外多分配两个block，所以<code>lsn</code>的值需要在<code>8916</code>的基础上增加<code>1000 + 12×2 + 4 × 2 = 1032</code>。</p>
</li>
</ul>
<p>从上边的描述中可以看出来，每一组由mtr生成的redo日志都有一个唯一的LSN值与其对应，LSN值越小，说明redo日志产生的越早。</p>
<h4 id="2-6-1flushed-to-disk-lsn"><a href="#2-6-1flushed-to-disk-lsn" class="headerlink" title="2.6.1flushed_to_disk_lsn"></a>2.6.1flushed_to_disk_lsn</h4><p><code>redo</code>日志是首先写到<code>log buffer</code>中，之后才会被刷新到磁盘上的<code>redo</code>日志文件。所以设计<code>InnoDB</code>的大叔提出了一个称之为<code>buf_next_to_write</code>的全局变量，标记当前<code>log buffer</code>中已经有哪些日志被刷新到磁盘中了。画个图表示就是这样：</p>
<p><img src="/../../../../../../imgs/MySQL%E5%8E%9F%E7%90%86%E4%B9%8B%E4%BA%8B%E5%8A%A1%E7%AF%87/169b899065cd1697tplv-t2oaga2asx-jj-mark1890000q75.webp" alt="image_1d4q3upvq17n8cargmibugve29.png-84.3kB"> </p>
<p>我们前边说<code>lsn</code>是表示当前系统中写入的<code>redo</code>日志量，这包括了写到<code>log buffer</code>而没有刷新到磁盘的日志，相应的，设计<code>InnoDB</code>的大叔提出了一个表示刷新到磁盘中的<code>redo</code>日志量的全局变量，称之为<code>flushed_to_disk_lsn</code>。系统第一次启动时，该变量的值和初始的<code>lsn</code>值是相同的，都是<code>8704</code>。随着系统的运行，<code>redo</code>日志被不断写入<code>log buffer</code>，但是并不会立即刷新到磁盘，<code>lsn</code>的值就和<code>flushed_to_disk_lsn</code>的值拉开了差距。我们演示一下：</p>
<ul>
<li><p>系统第一次启动后，向<code>log buffer</code>中写入了<code>mtr_1</code>、<code>mtr_2</code>、<code>mtr_3</code>这三个<code>mtr</code>产生的<code>redo</code>日志，假设这三个<code>mtr</code>开始和结束时对应的lsn值分别是：</p>
<ul>
<li><code>mtr_1</code>：8716 ～ 8916</li>
<li><code>mtr_2</code>：8916 ～ 9948</li>
<li><code>mtr_3</code>：9948 ～ 10000</li>
</ul>
<p>此时的<code>lsn</code>已经增长到了10000，但是由于没有刷新操作，所以此时<code>flushed_to_disk_lsn</code>的值仍为<code>8704</code>，如图：</p>
<p><img src="/../../../../../../imgs/MySQL%E5%8E%9F%E7%90%86%E4%B9%8B%E4%BA%8B%E5%8A%A1%E7%AF%87/169b899065f16c34tplv-t2oaga2asx-jj-mark1890000q75.webp" alt="image_1d4v3ubbacgm13171s481trb6kj1m.png-88.5kB"> </p>
</li>
<li><p>随后进行将<code>log buffer</code>中的block刷新到<code>redo</code>日志文件的操作，假设将<code>mtr_1</code>和<code>mtr_2</code>的日志刷新到磁盘，那么<code>flushed_to_disk_lsn</code>就应该增长<code>mtr_1</code>和<code>mtr_2</code>写入的日志量，所以<code>flushed_to_disk_lsn</code>的值增长到了<code>9948</code>，如图：</p>
<p><img src="/../../../../../../imgs/MySQL%E5%8E%9F%E7%90%86%E4%B9%8B%E4%BA%8B%E5%8A%A1%E7%AF%87/169b899065ece690tplv-t2oaga2asx-jj-mark1890000q75.webp" alt="image_1d4v40upc1tnt1dpe1l14u2ar4n23.png-100.2kB"></p>
</li>
</ul>
<p>综上所述，当有新的<code>redo</code>日志写入到<code>log buffer</code>时，首先<code>lsn</code>的值会增长，但<code>flushed_to_disk_lsn</code>不变，随后随着不断有<code>log buffer</code>中的日志被刷新到磁盘上，<code>flushed_to_disk_lsn</code>的值也跟着增长。如果两者的值相同时，说明log buffer中的所有redo日志都已经刷新到磁盘中了。</p>
<h4 id="2-6-2lsn值和redo日志文件偏移量的对应关系"><a href="#2-6-2lsn值和redo日志文件偏移量的对应关系" class="headerlink" title="2.6.2lsn值和redo日志文件偏移量的对应关系"></a>2.6.2lsn值和redo日志文件偏移量的对应关系</h4><p>因为<code>lsn</code>的值是代表系统写入的<code>redo</code>日志量的一个总和，一个<code>mtr</code>中产生多少日志，<code>lsn</code>的值就增加多少（当然有时候要加上<code>log block header</code>和<code>log block trailer</code>的大小），这样<code>mtr</code>产生的日志写到磁盘中时，很容易计算某一个<code>lsn</code>值在<code>redo</code>日志文件组中的偏移量，如图：</p>
<p><img src="/../../../../../../imgs/MySQL%E5%8E%9F%E7%90%86%E4%B9%8B%E4%BA%8B%E5%8A%A1%E7%AF%87/169b8990864b2982tplv-t2oaga2asx-jj-mark1890000q75.webp" alt="image_1d4v5sdrj1p1jrhmnfrq4pa073n.png-49.3kB"> </p>
<p>初始时的<code>LSN</code>值是<code>8704</code>，对应文件偏移量<code>2048</code>，之后每个<code>mtr</code>向磁盘中写入多少字节日志，<code>lsn</code>的值就增长多少。</p>
<h4 id="2-6-3flush链表中的LSN"><a href="#2-6-3flush链表中的LSN" class="headerlink" title="2.6.3flush链表中的LSN"></a>2.6.3flush链表中的LSN</h4><p>我们知道一个<code>mtr</code>代表一次对底层页面的原子访问，在访问过程中可能会产生一组不可分割的<code>redo</code>日志，在<code>mtr</code>结束时，会把这一组<code>redo</code>日志写入到<code>log buffer</code>中。除此之外，在<code>mtr</code>结束时还有一件非常重要的事情要做，就是把在mtr执行过程中可能修改过的页面加入到Buffer Pool的flush链表。为了防止大家早已忘记<code>flush链表</code>是个啥，我们再看一下图：</p>
<p><img src="/../../../../../../imgs/MySQL%E5%8E%9F%E7%90%86%E4%B9%8B%E4%BA%8B%E5%8A%A1%E7%AF%87/169b899094bcc632tplv-t2oaga2asx-jj-mark1890000q75.webp" alt="image_1d4uln1ejrt4cerr6h1tc41uok3k.png-227kB"> </p>
<p>当第一次修改某个缓存在<code>Buffer Pool</code>中的页面时，就会把这个页面对应的控制块插入到<code>flush链表</code>的头部，之后再修改该页面时由于它已经在<code>flush</code>链表中了，就不再次插入了。也就是说flush链表中的脏页是按照页面的第一次修改时间从大到小进行排序的。在这个过程中会在缓存页对应的控制块中记录两个关于页面何时修改的属性：</p>
<ul>
<li><code>oldest_modification</code>：如果某个页面被加载到<code>Buffer Pool</code>后进行第一次修改，那么就将修改该页面的<code>mtr</code>开始时对应的<code>lsn</code>值写入这个属性。</li>
<li><code>newest_modification</code>：每修改一次页面，都会将修改该页面的<code>mtr</code>结束时对应的<code>lsn</code>值写入这个属性。也就是说该属性表示页面最近一次修改后对应的系统<code>lsn</code>值。</li>
</ul>
<p>我们接着上边唠叨<code>flushed_to_disk_lsn</code>的例子看一下：</p>
<ul>
<li><p>假设<code>mtr_1</code>执行过程中修改了<code>页a</code>，那么在<code>mtr_1</code>执行结束时，就会将<code>页a</code>对应的控制块加入到<code>flush链表</code>的头部。并且将<code>mtr_1</code>开始时对应的<code>lsn</code>，也就是<code>8716</code>写入<code>页a</code>对应的控制块的<code>oldest_modification</code>属性中，把<code>mtr_1</code>结束时对应的<code>lsn</code>，也就是8916写入<code>页a</code>对应的控制块的<code>newest_modification</code>属性中。画个图表示一下（为了让图片美观一些，我们把<code>oldest_modification</code>缩写成了<code>o_m</code>，把<code>newest_modification</code>缩写成了<code>n_m</code>）：</p>
<p><img src="/../../../../../../imgs/MySQL%E5%8E%9F%E7%90%86%E4%B9%8B%E4%BA%8B%E5%8A%A1%E7%AF%87/169b899088d4f875tplv-t2oaga2asx-jj-mark1890000q75.webp" alt="image_1d4v63pct1v9o14l3812gnj11de44.png-31.8kB"> </p>
</li>
<li><p>接着假设<code>mtr_2</code>执行过程中又修改了<code>页b</code>和<code>页c</code>两个页面，那么在<code>mtr_2</code>执行结束时，就会将<code>页b</code>和<code>页c</code>对应的控制块都加入到<code>flush链表</code>的头部。并且将<code>mtr_2</code>开始时对应的<code>lsn</code>，也就是8916写入<code>页b</code>和<code>页c</code>对应的控制块的<code>oldest_modification</code>属性中，把<code>mtr_2</code>结束时对应的<code>lsn</code>，也就是9948写入<code>页b</code>和<code>页c</code>对应的控制块的<code>newest_modification</code>属性中。画个图表示一下：</p>
<p><img src="/../../../../../../imgs/MySQL%E5%8E%9F%E7%90%86%E4%B9%8B%E4%BA%8B%E5%8A%A1%E7%AF%87/169b899094ab6caftplv-t2oaga2asx-jj-mark1890000q75.webp" alt="image_1d4v64vte14tq1oc911s1v8gnn51.png-59.4kB"> </p>
<p>从图中可以看出来，每次新插入到<code>flush链表</code>中的节点都是被放在了头部，也就是说<code>flush链表</code>中前边的脏页修改的时间比较晚，后边的脏页修改时间比较早。</p>
</li>
<li><p>接着假设<code>mtr_3</code>执行过程中修改了<code>页b</code>和<code>页d</code>，不过<code>页b</code>之前已经被修改过了，所以它对应的控制块已经被插入到了<code>flush</code>链表，所以在<code>mtr_3</code>执行结束时，只需要将<code>页d</code>对应的控制块都加入到<code>flush链表</code>的头部即可。所以需要将<code>mtr_3</code>开始时对应的<code>lsn</code>，也就是9948写入<code>页d</code>对应的控制块的<code>oldest_modification</code>属性中，把<code>mtr_3</code>结束时对应的<code>lsn</code>，也就是10000写入<code>页d</code>对应的控制块的<code>newest_modification</code>属性中。另外，由于<code>页b</code>在<code>mtr_3</code>执行过程中又发生了一次修改，所以需要更新<code>页b</code>对应的控制块中<code>newest_modification</code>的值为10000。画个图表示一下：</p>
<p><img src="/../../../../../../imgs/MySQL%E5%8E%9F%E7%90%86%E4%B9%8B%E4%BA%8B%E5%8A%A1%E7%AF%87/169b89909693bfe9tplv-t2oaga2asx-jj-mark1890000q75.webp" alt="image_1d4v68bhl1jb9r8m6vn1b157cn5e.png-110.8kB"> </p>
<p>总结一下上边说的，就是：flush链表中的脏页按照修改发生的时间顺序进行排序，也就是按照oldest_modification代表的LSN值进行排序，被多次更新的页面不会重复插入到flush链表中，但是会更新newest_modification属性的值。</p>
</li>
</ul>
<h3 id="2-7checkpoint"><a href="#2-7checkpoint" class="headerlink" title="2.7checkpoint"></a>2.7checkpoint</h3><p>有一个很不幸的事实就是我们的<code>redo</code>日志文件组容量是有限的，我们不得不选择循环使用<code>redo</code>日志文件组中的文件，但是这会造成最后写的<code>redo</code>日志与最开始写的<code>redo</code>日志<code>追尾</code>，这时应该想到：redo日志只是为了系统崩溃后恢复脏页用的，如果对应的脏页已经刷新到了磁盘，也就是说即使现在系统崩溃，那么在重启后也用不着使用redo日志恢复该页面了，所以该redo日志也就没有存在的必要了，那么它占用的磁盘空间就可以被后续的redo日志所重用。也就是说：判断某些redo日志占用的磁盘空间是否可以覆盖的依据就是它对应的脏页是否已经刷新到磁盘里。我们看一下前边一直唠叨的那个例子：</p>
<p><img src="/../../../../../../imgs/MySQL%E5%8E%9F%E7%90%86%E4%B9%8B%E4%BA%8B%E5%8A%A1%E7%AF%87/169b8990a1ec0f87tplv-t2oaga2asx-jj-mark1890000q75.webp" alt="image_1d4v6epcasjm11u4l131nj41vgs68.png-112.1kB"> </p>
<p>如图，虽然<code>mtr_1</code>和<code>mtr_2</code>生成的<code>redo</code>日志都已经被写到了磁盘上，但是它们修改的脏页仍然留在<code>Buffer Pool</code>中，所以它们生成的<code>redo</code>日志在磁盘上的空间是不可以被覆盖的。之后随着系统的运行，如果<code>页a</code>被刷新到了磁盘，那么它对应的控制块就会从<code>flush链表</code>中移除，就像这样子：</p>
<p><img src="/../../../../../../imgs/MySQL%E5%8E%9F%E7%90%86%E4%B9%8B%E4%BA%8B%E5%8A%A1%E7%AF%87/169b8990ad89ad77tplv-t2oaga2asx-jj-mark1890000q75.webp" alt="image_1d4v6h6kp7311ni21mkn1ejkm397i.png-99.3kB"> </p>
<p>这样<code>mtr_1</code>生成的<code>redo</code>日志就没有用了，它们占用的磁盘空间就可以被覆盖掉了。设计<code>InnoDB</code>的大叔提出了一个全局变量<code>checkpoint_lsn</code>来代表当前系统中可以被覆盖的<code>redo</code>日志总量是多少，这个变量初始值也是<code>8704</code>。</p>
<p>比方说现在<code>页a</code>被刷新到了磁盘，<code>mtr_1</code>生成的<code>redo</code>日志就可以被覆盖了，所以我们可以进行一个增加<code>checkpoint_lsn</code>的操作，我们把这个过程称之为做一次<code>checkpoint</code>。做一次<code>checkpoint</code>其实可以分为两个步骤：</p>
<ul>
<li><p>步骤一：计算一下当前系统中可以被覆盖的<code>redo</code>日志对应的<code>lsn</code>值最大是多少。</p>
<p><code>redo</code>日志可以被覆盖，意味着它对应的脏页被刷到了磁盘，只要我们计算出当前系统中被最早修改的脏页对应的<code>oldest_modification</code>值，那凡是在系统lsn值小于该节点的oldest_modification值时产生的redo日志都是可以被覆盖掉的，我们就把该脏页的<code>oldest_modification</code>赋值给<code>checkpoint_lsn</code>。</p>
<p>比方说当前系统中<code>页a</code>已经被刷新到磁盘，那么<code>flush链表</code>的尾节点就是<code>页c</code>，该节点就是当前系统中最早修改的脏页了，它的<code>oldest_modification</code>值为8916，我们就把8916赋值给<code>checkpoint_lsn</code>（也就是说在redo日志对应的lsn值小于8916时就可以被覆盖掉）。</p>
</li>
<li><p>步骤二：将<code>checkpoint_lsn</code>和对应的<code>redo</code>日志文件组偏移量以及此次<code>checkpint</code>的编号写到日志文件的管理信息（就是<code>checkpoint1</code>或者<code>checkpoint2</code>）中。</p>
<p>设计<code>InnoDB</code>的大叔维护了一个目前系统做了多少次<code>checkpoint</code>的变量<code>checkpoint_no</code>，每做一次<code>checkpoint</code>，该变量的值就加1。我们前边说过计算一个<code>lsn</code>值对应的<code>redo</code>日志文件组偏移量是很容易的，所以可以计算得到该<code>checkpoint_lsn</code>在<code>redo</code>日志文件组中对应的偏移量<code>checkpoint_offset</code>，然后把这三个值都写到<code>redo</code>日志文件组的管理信息中。</p>
<p>我们说过，每一个<code>redo</code>日志文件都有<code>2048</code>个字节的管理信息，但是上述关于checkpoint的信息只会被写到日志文件组的第一个日志文件的管理信息中。不过我们是存储到<code>checkpoint1</code>中还是<code>checkpoint2</code>中呢？设计<code>InnoDB</code>的大叔规定，当<code>checkpoint_no</code>的值是偶数时，就写到<code>checkpoint1</code>中，是奇数时，就写到<code>checkpoint2</code>中。</p>
</li>
</ul>
<p>记录完<code>checkpoint</code>的信息之后，<code>redo</code>日志文件组中各个<code>lsn</code>值的关系就像这样：</p>
<p><img src="/../../../../../../imgs/MySQL%E5%8E%9F%E7%90%86%E4%B9%8B%E4%BA%8B%E5%8A%A1%E7%AF%87/169b8990aeb41002tplv-t2oaga2asx-jj-mark1890000q75.webp" alt="image_1d678eiie125j1flp1tc617jp1dvo9.png-68.1kB"> </p>
<h4 id="2-7-1批量从flush链表中刷出脏页"><a href="#2-7-1批量从flush链表中刷出脏页" class="headerlink" title="2.7.1批量从flush链表中刷出脏页"></a>2.7.1批量从flush链表中刷出脏页</h4><p>我们在介绍<code>Buffer Pool</code>的时候说过，一般情况下都是后台的线程在对<code>LRU链表</code>和<code>flush链表</code>进行刷脏操作，这主要因为刷脏操作比较慢，不想影响用户线程处理请求。但是如果当前系统修改页面的操作十分频繁，这样就导致写日志操作十分频繁，系统<code>lsn</code>值增长过快。如果后台的刷脏操作不能将脏页刷出，那么系统无法及时做<code>checkpoint</code>，可能就需要用户线程同步的从<code>flush链表</code>中把那些最早修改的脏页（<code>oldest_modification</code>最小的脏页）刷新到磁盘，这样这些脏页对应的<code>redo</code>日志就没用了，然后就可以去做<code>checkpoint</code>了。</p>
<h4 id="2-7-2查看系统中的各种LSN值"><a href="#2-7-2查看系统中的各种LSN值" class="headerlink" title="2.7.2查看系统中的各种LSN值"></a>2.7.2查看系统中的各种LSN值</h4><p>我们可以使用<code>SHOW ENGINE INNODB STATUS</code>命令查看当前<code>InnoDB</code>存储引擎中的各种<code>LSN</code>值的情况，比如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SHOW</span> ENGINE INNODB STATUS\G</span><br><span class="line"></span><br><span class="line">(...省略前边的许多状态)</span><br><span class="line">LOG</span><br><span class="line"><span class="comment">---</span></span><br><span class="line">Log sequence number <span class="number">124476971</span></span><br><span class="line">Log flushed up <span class="keyword">to</span>   <span class="number">124099769</span></span><br><span class="line">Pages flushed up <span class="keyword">to</span> <span class="number">124052503</span></span><br><span class="line"><span class="keyword">Last</span> checkpoint <span class="keyword">at</span>  <span class="number">124052494</span></span><br><span class="line"><span class="number">0</span> pending log flushes, <span class="number">0</span> pending chkp writes</span><br><span class="line"><span class="number">24</span> log i<span class="operator">/</span>o<span class="string">&#x27;s done, 2.00 log i/o&#x27;</span>s<span class="operator">/</span><span class="keyword">second</span></span><br><span class="line"><span class="comment">----------------------</span></span><br><span class="line">(...省略后边的许多状态)</span><br></pre></td></tr></table></figure>

<ul>
<li><code>Log sequence number</code>：代表系统中的<code>lsn</code>值，也就是当前系统已经写入的<code>redo</code>日志量，包括写入<code>log buffer</code>中的日志。</li>
<li><code>Log flushed up to</code>：代表<code>flushed_to_disk_lsn</code>的值，也就是当前系统已经写入磁盘的<code>redo</code>日志量。</li>
<li><code>Pages flushed up to</code>：代表<code>flush链表</code>中被最早修改的那个页面对应的<code>oldest_modification</code>属性值。</li>
<li><code>Last checkpoint at</code>：当前系统的<code>checkpoint_lsn</code>值。</li>
</ul>
<h3 id="2-8崩溃恢复"><a href="#2-8崩溃恢复" class="headerlink" title="2.8崩溃恢复"></a>2.8崩溃恢复</h3><p>在服务器不挂的情况下，<code>redo</code>日志简直就是个大累赘，不仅没用，反而让性能变得更差。但是万一，我说万一啊，万一数据库挂了，那<code>redo</code>日志可是个宝了，我们就可以在重启时根据<code>redo</code>日志中的记录就可以将页面恢复到系统崩溃前的状态。我们接下来大致看一下恢复过程是个啥样。</p>
<h4 id="2-8-1确定恢复的起点"><a href="#2-8-1确定恢复的起点" class="headerlink" title="2.8.1确定恢复的起点"></a>2.8.1确定恢复的起点</h4><p>我们前边说过，<code>checkpoint_lsn</code>之前的<code>redo</code>日志都可以被覆盖，也就是说这些<code>redo</code>日志对应的脏页都已经被刷新到磁盘中了，既然它们已经被刷盘，我们就没必要恢复它们了。对于<code>checkpoint_lsn</code>之后的<code>redo</code>日志，它们对应的脏页可能没被刷盘，也可能被刷盘了，我们不能确定，所以需要从<code>checkpoint_lsn</code>开始读取<code>redo</code>日志来恢复页面。</p>
<p>当然，<code>redo</code>日志文件组的第一个文件的管理信息中有两个block都存储了<code>checkpoint_lsn</code>的信息，我们当然是要选取最近发生的那次checkpoint的信息。衡量<code>checkpoint</code>发生时间早晚的信息就是所谓的<code>checkpoint_no</code>，我们只要把<code>checkpoint1</code>和<code>checkpoint2</code>这两个block中的<code>checkpoint_no</code>值读出来比一下大小，哪个的<code>checkpoint_no</code>值更大，说明哪个block存储的就是最近的一次<code>checkpoint</code>信息。这样我们就能拿到最近发生的<code>checkpoint</code>对应的<code>checkpoint_lsn</code>值以及它在<code>redo</code>日志文件组中的偏移量<code>checkpoint_offset</code>。</p>
<h4 id="2-8-2确定恢复的终点"><a href="#2-8-2确定恢复的终点" class="headerlink" title="2.8.2确定恢复的终点"></a>2.8.2确定恢复的终点</h4><p><code>redo</code>日志恢复的起点确定了，那终点是哪个呢？这个还得从block的结构说起。我们说在写<code>redo</code>日志的时候都是顺序写的，写满了一个block之后会再往下一个block中写：</p>
<p><img src="/../../../../../../imgs/MySQL%E5%8E%9F%E7%90%86%E4%B9%8B%E4%BA%8B%E5%8A%A1%E7%AF%87/169b8990b6d085cdtplv-t2oaga2asx-jj-mark1890000q75.webp" alt="image_1d4viej35t9nvld8o3141s8pp.png-69.5kB"> </p>
<p>普通block的<code>log block header</code>部分有一个称之为<code>LOG_BLOCK_HDR_DATA_LEN</code>的属性，该属性值记录了当前block里使用了多少字节的空间。对于被填满的block来说，该值永远为<code>512</code>。如果该属性的值不为<code>512</code>，那么就是它了，它就是此次崩溃恢复中需要扫描的最后一个block。</p>
<h4 id="2-8-3怎么恢复"><a href="#2-8-3怎么恢复" class="headerlink" title="2.8.3怎么恢复"></a>2.8.3怎么恢复</h4><p>确定了需要扫描哪些<code>redo</code>日志进行崩溃恢复之后，接下来就是怎么进行恢复了。假设现在的<code>redo</code>日志文件中有5条<code>redo</code>日志，如图：</p>
<p><img src="/../../../../../../imgs/MySQL%E5%8E%9F%E7%90%86%E4%B9%8B%E4%BA%8B%E5%8A%A1%E7%AF%87/169b8990b9780dc2tplv-t2oaga2asx-jj-mark1890000q75.webp" alt="image_1d4vjuf9l17og1papl3e16is1m9f16.png-59.9kB"> </p>
<p>由于<code>redo 0</code>在<code>checkpoint_lsn</code>后边，恢复时可以不管它。我们现在可以按照<code>redo</code>日志的顺序依次扫描<code>checkpoint_lsn</code>之后的各条redo日志，按照日志中记载的内容将对应的页面恢复出来。这样没什么问题，不过设计<code>InnoDB</code>的大叔还是想了一些办法加快这个恢复的过程：</p>
<ul>
<li><p>使用哈希表</p>
<p>根据<code>redo</code>日志的<code>space ID</code>和<code>page number</code>属性计算出散列值，把<code>space ID</code>和<code>page number</code>相同的<code>redo</code>日志放到哈希表的同一个槽里，如果有多个<code>space ID</code>和<code>page number</code>都相同的<code>redo</code>日志，那么它们之间使用链表连接起来，按照生成的先后顺序链接起来的，如图所示：</p>
<p><img src="/../../../../../../imgs/MySQL%E5%8E%9F%E7%90%86%E4%B9%8B%E4%BA%8B%E5%8A%A1%E7%AF%87/169b8990d0161bfctplv-t2oaga2asx-jj-mark1890000q75.webp" alt="image_1d50lj9da176rojd12ja1lodognc.png-156.4kB"> </p>
<p>之后就可以遍历哈希表，因为对同一个页面进行修改的<code>redo</code>日志都放在了一个槽里，所以可以一次性将一个页面修复好（避免了很多读取页面的随机IO），这样可以加快恢复速度。另外需要注意一点的是，同一个页面的<code>redo</code>日志是按照生成时间顺序进行排序的，所以恢复的时候也是按照这个顺序进行恢复，如果不按照生成时间顺序进行排序的话，那么可能出现错误。比如原先的修改操作是先插入一条记录，再删除该条记录，如果恢复时不按照这个顺序来，就可能变成先删除一条记录，再插入一条记录，这显然是错误的。</p>
</li>
<li><p>跳过已经刷新到磁盘的页面</p>
<p>我们前边说过，<code>checkpoint_lsn</code>之前的<code>redo</code>日志对应的脏页确定都已经刷到磁盘了，但是<code>checkpoint_lsn</code>之后的<code>redo</code>日志我们不能确定是否已经刷到磁盘，主要是因为在最近做的一次<code>checkpoint</code>后，可能后台线程又不断的从<code>LRU链表</code>和<code>flush链表</code>中将一些脏页刷出<code>Buffer Pool</code>。这些在<code>checkpoint_lsn</code>之后的<code>redo</code>日志，如果它们对应的脏页在崩溃发生时已经刷新到磁盘，那在恢复时也就没有必要根据<code>redo</code>日志的内容修改该页面了。</p>
<p>那在恢复时怎么知道某个<code>redo</code>日志对应的脏页是否在崩溃发生时已经刷新到磁盘了呢？这还得从页面的结构说起，我们前边说过每个页面都有一个称之为<code>File Header</code>的部分，在<code>File Header</code>里有一个称之为<code>FIL_PAGE_LSN</code>的属性，该属性记载了最近一次修改页面时对应的<code>lsn</code>值（其实就是页面控制块中的<code>newest_modification</code>值）。如果在做了某次<code>checkpoint</code>之后有脏页被刷新到磁盘中，那么该页对应的<code>FIL_PAGE_LSN</code>代表的<code>lsn</code>值肯定大于<code>checkpoint_lsn</code>的值，凡是符合这种情况的页面就不需要重复执行lsn值小于<code>FIL_PAGE_LSN</code>的redo日志了，所以更进一步提升了崩溃恢复的速度。</p>
</li>
</ul>
<h2 id="三、Undo日志"><a href="#三、Undo日志" class="headerlink" title="三、Undo日志"></a>三、Undo日志</h2><h2 id="四、MVCC与隔离级别"><a href="#四、MVCC与隔离级别" class="headerlink" title="四、MVCC与隔离级别"></a>四、MVCC与隔离级别</h2><p>为了故事的顺利发展，我们需要创建一个表：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> hero (</span><br><span class="line">    number <span class="type">INT</span>,</span><br><span class="line">    name <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    country <span class="type">varchar</span>(<span class="number">100</span>),</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (number)</span><br><span class="line">) Engine<span class="operator">=</span>InnoDB CHARSET<span class="operator">=</span>utf8;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意我们把这个hero表的主键命名为number，而不是id，主要是想和后边要用到的事务id做区别，大家不用大惊小怪哈～</p>
</blockquote>
<p>然后向这个表里插入一条数据：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> hero <span class="keyword">VALUES</span>(<span class="number">1</span>, <span class="string">&#x27;刘备&#x27;</span>, <span class="string">&#x27;蜀&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>现在表里的数据就是这样的：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> hero;</span><br><span class="line"><span class="operator">+</span><span class="comment">--------+--------+---------+</span></span><br><span class="line"><span class="operator">|</span> number <span class="operator">|</span> name   <span class="operator">|</span> country <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------+--------+---------+</span></span><br><span class="line"><span class="operator">|</span>      <span class="number">1</span> <span class="operator">|</span> 刘备   <span class="operator">|</span> 蜀      <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------+--------+---------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

<h3 id="4-1事务隔离级别"><a href="#4-1事务隔离级别" class="headerlink" title="4.1事务隔离级别"></a>4.1事务隔离级别</h3><p>我们知道<code>MySQL</code>是一个<code>客户端／服务器</code>架构的软件，对于同一个服务器来说，可以有若干个客户端与之连接，每个客户端与服务器连接上之后，就可以称之为一个会话（<code>Session</code>）。每个客户端都可以在自己的会话中向服务器发出请求语句，一个请求语句可能是某个事务的一部分，也就是对于服务器来说可能同时处理多个事务。在事务简介的章节中我们说过事务有一个称之为<code>隔离性</code>的特性，理论上在某个事务对某个数据进行访问时，其他事务应该进行排队，当该事务提交之后，其他事务才可以继续访问这个数据。但是这样子的话对性能影响太大，我们既想保持事务的<code>隔离性</code>，又想让服务器在处理访问同一数据的多个事务时性能尽量高些，鱼和熊掌不可得兼，舍一部分<code>隔离性</code>而取性能者也。</p>
<h4 id="4-1-1事务并发执行遇到的问题"><a href="#4-1-1事务并发执行遇到的问题" class="headerlink" title="4.1.1事务并发执行遇到的问题"></a>4.1.1事务并发执行遇到的问题</h4><p>怎么个舍弃法呢？我们先得看一下访问相同数据的事务在不保证串行执行（也就是执行完一个再执行另一个）的情况下可能会出现哪些问题：</p>
<ul>
<li><p>脏写（<code>Dirty Write</code>）</p>
<p>如果一个事务修改了另一个未提交事务修改过的数据，那就意味着发生了<code>脏写</code>，示意图如下：</p>
<p><img src="/../../../../../../imgs/MySQL%E5%8E%9F%E7%90%86%E4%B9%8B%E4%BA%8B%E5%8A%A1%E7%AF%87/9dbb2113ed2744b99f599b5fc1b2bb32tplv-k3u1fbpfcp-jj-mark1890000q75.webp" alt="image_1d8nigfq618jd1cc56231rt0uq19.png-78.2kB"> </p>
<p>如上图，<code>Session A</code>和<code>Session B</code>各开启了一个事务，<code>Session B</code>中的事务先将<code>number</code>列为<code>1</code>的记录的<code>name</code>列更新为<code>&#39;关羽&#39;</code>，然后<code>Session A</code>中的事务接着又把这条<code>number</code>列为<code>1</code>的记录的<code>name</code>列更新为<code>张飞</code>。如果之后<code>Session B</code>中的事务进行了回滚，那么<code>Session A</code>中的更新也将不复存在，这种现象就称之为<code>脏写</code>。这时<code>Session A</code>中的事务就很懵逼，我明明把数据更新了，最后也提交事务了，怎么到最后说自己啥也没干呢？</p>
</li>
<li><p>脏读（<code>Dirty Read</code>）</p>
<p>如果一个事务读到了另一个未提交事务修改过的数据，那就意味着发生了<code>脏读</code>，示意图如下：</p>
<p><img src="/../../../../../../imgs/MySQL%E5%8E%9F%E7%90%86%E4%B9%8B%E4%BA%8B%E5%8A%A1%E7%AF%87/0e14e4fe30664ae398a29fba855afda8tplv-k3u1fbpfcp-jj-mark1890000q75.webp" alt="image_1d8nn50kndkd8641epplvelhk9.png-91.8kB"> </p>
<p>如上图，<code>Session A</code>和<code>Session B</code>各开启了一个事务，<code>Session B</code>中的事务先将<code>number</code>列为<code>1</code>的记录的<code>name</code>列更新为<code>&#39;关羽&#39;</code>，然后<code>Session A</code>中的事务再去查询这条<code>number</code>为<code>1</code>的记录，如果读到列<code>name</code>的值为<code>&#39;关羽&#39;</code>，而<code>Session B</code>中的事务稍后进行了回滚，那么<code>Session A</code>中的事务相当于读到了一个不存在的数据，这种现象就称之为<code>脏读</code>。</p>
</li>
<li><p>不可重复读（Non-Repeatable Read）</p>
<p>如果一个事务只能读到另一个已经提交的事务修改过的数据，并且其他事务每对该数据进行一次修改并提交后，该事务都能查询得到最新值，那就意味着发生了<code>不可重复读</code>，示意图如下：</p>
<p><img src="/../../../../../../imgs/MySQL%E5%8E%9F%E7%90%86%E4%B9%8B%E4%BA%8B%E5%8A%A1%E7%AF%87/2be4b2847fe64c4cb0d5db1a5505bd2atplv-k3u1fbpfcp-jj-mark1890000q75.webp" alt="image_1d8nk4k1e1mt51nsj1hg41cd7v5950.png-139.4kB"> </p>
</li>
<li><p>幻读（Phantom）</p>
<p>如果一个事务先根据某些条件查询出一些记录，之后另一个事务又向表中插入了符合这些条件的记录，原先的事务再次按照该条件查询时，能把另一个事务插入的记录也读出来，那就意味着发生了<code>幻读</code>，示意图如下：</p>
<p><img src="/../../../../../../imgs/MySQL%E5%8E%9F%E7%90%86%E4%B9%8B%E4%BA%8B%E5%8A%A1%E7%AF%87/8c5bef4507364a04854a088f68ba6c90tplv-k3u1fbpfcp-jj-mark1890000q75.webp" alt="image_1d8nl564faluogc1eqn1am812v79.png-96.1kB"> </p>
<p>如上图，<code>Session A</code>中的事务先根据条件<code>number &gt; 0</code>这个条件查询表<code>hero</code>，得到了<code>name</code>列值为<code>&#39;刘备&#39;</code>的记录；之后<code>Session B</code>中提交了一个隐式事务，该事务向表<code>hero</code>中插入了一条新记录；之后<code>Session A</code>中的事务再根据相同的条件<code>number &gt; 0</code>查询表<code>hero</code>，得到的结果集中包含<code>Session B</code>中的事务新插入的那条记录，这种现象也被称之为<code>幻读</code>。</p>
<p>有的同学会有疑问，那如果<code>Session B</code>中是删除了一些符合<code>number &gt; 0</code>的记录而不是插入新记录，那<code>Session A</code>中之后再根据<code>number &gt; 0</code>的条件读取的记录变少了，这种现象算不算<code>幻读</code>呢？明确说一下，这种现象不属于<code>幻读</code>，<code>幻读</code>强调的是一个事务按照某个相同条件多次读取记录时，后读取时读到了之前没有读到的记录。</p>
<blockquote>
<p>那对于先前已经读到的记录，之后又读取不到这种情况，算啥呢？其实这相当于对每一条记录都发生了不可重复读的现象。幻读只是重点强调了读取到了之前读取没有获取到的记录。</p>
</blockquote>
</li>
</ul>
<h4 id="4-1-2SQL标准中的四种隔离级别"><a href="#4-1-2SQL标准中的四种隔离级别" class="headerlink" title="4.1.2SQL标准中的四种隔离级别"></a>4.1.2SQL标准中的四种隔离级别</h4><p>我们上边介绍了几种并发事务执行过程中可能遇到的一些问题，这些问题也有轻重缓急之分，我们给这些问题按照严重性来排一下序：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">脏写 <span class="operator">&gt;</span> 脏读 <span class="operator">&gt;</span> 不可重复读 <span class="operator">&gt;</span> 幻读</span><br></pre></td></tr></table></figure>

<p>我们上边所说的舍弃一部分隔离性来换取一部分性能在这里就体现在：设立一些隔离级别，隔离级别越低，越严重的问题就越可能发生。有一帮人（并不是设计<code>MySQL</code>的大叔们）制定了一个所谓的<code>SQL标准</code>，在标准中设立了4个<code>隔离级别</code>：</p>
<ul>
<li><code>READ UNCOMMITTED</code>：未提交读。</li>
<li><code>READ COMMITTED</code>：已提交读。</li>
<li><code>REPEATABLE READ</code>：可重复读。</li>
<li><code>SERIALIZABLE</code>：可串行化。</li>
</ul>
<p><code>SQL标准</code>中规定，针对不同的隔离级别，并发事务可以发生不同严重程度的问题，具体情况如下：</p>
<p><img src="/../../../../../../imgs/MySQL%E5%8E%9F%E7%90%86%E4%B9%8B%E4%BA%8B%E5%8A%A1%E7%AF%87/image-20231220211709566.png" alt="image-20231220211709566"> </p>
<p>也就是说：</p>
<ul>
<li><code>READ UNCOMMITTED</code>隔离级别下，可能发生<code>脏读</code>、<code>不可重复读</code>和<code>幻读</code>问题。</li>
<li><code>READ COMMITTED</code>隔离级别下，可能发生<code>不可重复读</code>和<code>幻读</code>问题，但是不可以发生<code>脏读</code>问题。</li>
<li><code>REPEATABLE READ</code>隔离级别下，可能发生<code>幻读</code>问题，但是不可以发生<code>脏读</code>和<code>不可重复读</code>的问题。</li>
<li><code>SERIALIZABLE</code>隔离级别下，各种问题都不可以发生。</li>
</ul>
<p><code>脏写</code>是怎么回事儿？怎么里边都没写呢？这是因为脏写这个问题太严重了，不论是哪种隔离级别，都不允许脏写的情况发生。</p>
<h4 id="4-1-3MySQL中支持的四种隔离级别"><a href="#4-1-3MySQL中支持的四种隔离级别" class="headerlink" title="4.1.3MySQL中支持的四种隔离级别"></a>4.1.3MySQL中支持的四种隔离级别</h4><p>不同的数据库厂商对<code>SQL标准</code>中规定的四种隔离级别支持不一样，比方说<code>Oracle</code>就只支持<code>READ COMMITTED</code>和<code>SERIALIZABLE</code>隔离级别。本书中所讨论的<code>MySQL</code>虽然支持4种隔离级别，但与<code>SQL标准</code>中所规定的各级隔离级别允许发生的问题却有些出入，MySQL在REPEATABLE READ隔离级别下，是可以禁止幻读问题的发生的（关于如何禁止我们之后会详细说明的）。</p>
<p><code>MySQL</code>的默认隔离级别为<code>REPEATABLE READ</code>，我们可以手动修改一下事务的隔离级别。</p>
<p>我们可以通过下边的语句修改事务的隔离级别：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> [<span class="keyword">GLOBAL</span><span class="operator">|</span>SESSION] TRANSACTION ISOLATION LEVEL level;</span><br></pre></td></tr></table></figure>

<p>其中的<code>level</code>可选值有4个：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">level: &#123;</span><br><span class="line">     REPEATABLE READ</span><br><span class="line">   <span class="operator">|</span> READ COMMITTED</span><br><span class="line">   <span class="operator">|</span> READ UNCOMMITTED</span><br><span class="line">   <span class="operator">|</span> SERIALIZABLE</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>设置事务的隔离级别的语句中，在<code>SET</code>关键字后可以放置<code>GLOBAL</code>关键字、<code>SESSION</code>关键字或者什么都不放，这样会对不同范围的事务产生不同的影响，具体如下：</p>
<ul>
<li><p>使用<code>GLOBAL</code>关键字（在全局范围影响）：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> TRANSACTION ISOLATION LEVEL SERIALIZABLE;</span><br></pre></td></tr></table></figure>

<ul>
<li>只对执行完该语句之后产生的会话起作用。</li>
<li>当前已经存在的会话无效。</li>
</ul>
</li>
<li><p>使用<code>SESSION</code>关键字（在会话范围影响）：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> SESSION TRANSACTION ISOLATION LEVEL SERIALIZABLE;</span><br></pre></td></tr></table></figure>

<ul>
<li>对当前会话的所有后续的事务有效</li>
<li>该语句可以在已经开启的事务中间执行，但不会影响当前正在执行的事务。</li>
<li>如果在事务之间执行，则对后续的事务有效。</li>
</ul>
</li>
<li><p>上述两个关键字都不用（只对执行语句后的下一个事务产生影响）：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> TRANSACTION ISOLATION LEVEL SERIALIZABLE;</span><br></pre></td></tr></table></figure>

<ul>
<li>只对当前会话中下一个即将开启的事务有效。</li>
<li>下一个事务执行完后，后续事务将恢复到之前的隔离级别。</li>
<li>该语句不能在已经开启的事务中间执行，会报错的。</li>
</ul>
</li>
</ul>
<p>如果我们在服务器启动时想改变事务的默认隔离级别，可以修改启动参数<code>transaction-isolation</code>的值，比方说我们在启动服务器时指定了<code>--transaction-isolation=SERIALIZABLE</code>，那么事务的默认隔离级别就从原来的<code>REPEATABLE READ</code>变成了<code>SERIALIZABLE</code>。</p>
<p>想要查看当前会话默认的隔离级别可以通过查看系统变量<code>transaction_isolation</code>的值来确定：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;transaction_isolation&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------------+-----------------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name         <span class="operator">|</span> <span class="keyword">Value</span>           <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------------+-----------------+</span></span><br><span class="line"><span class="operator">|</span> transaction_isolation <span class="operator">|</span> REPEATABLE<span class="operator">-</span>READ <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------------+-----------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.02</span> sec)</span><br></pre></td></tr></table></figure>

<h3 id="4-2MVCC原理"><a href="#4-2MVCC原理" class="headerlink" title="4.2MVCC原理"></a>4.2MVCC原理</h3><h4 id="4-2-1版本链"><a href="#4-2-1版本链" class="headerlink" title="4.2.1版本链"></a>4.2.1版本链</h4><p>我们前边说过，对于使用<code>InnoDB</code>存储引擎的表来说，它的聚簇索引记录中都包含两个必要的隐藏列（<code>row_id</code>并不是必要的，我们创建的表中有主键或者非NULL的UNIQUE键时都不会包含<code>row_id</code>列）：</p>
<ul>
<li><code>trx_id</code>：每次一个事务对某条聚簇索引记录进行改动时，都会把该事务的<code>事务id</code>赋值给<code>trx_id</code>隐藏列。</li>
<li><code>roll_pointer</code>：每次对某条聚簇索引记录进行改动时，都会把旧的版本写入到<code>undo日志</code>中，然后这个隐藏列就相当于一个指针，可以通过它来找到该记录修改前的信息。</li>
</ul>
<p>比方说我们的表<code>hero</code>现在只包含一条记录：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> hero;</span><br><span class="line"><span class="operator">+</span><span class="comment">--------+--------+---------+</span></span><br><span class="line"><span class="operator">|</span> number <span class="operator">|</span> name   <span class="operator">|</span> country <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------+--------+---------+</span></span><br><span class="line"><span class="operator">|</span>      <span class="number">1</span> <span class="operator">|</span> 刘备   <span class="operator">|</span> 蜀      <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------+--------+---------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.07</span> sec)</span><br></pre></td></tr></table></figure>

<p>假设插入该记录的<code>事务id</code>为<code>80</code>，那么此刻该条记录的示意图如下所示：</p>
<p><img src="/../../../../../../imgs/MySQL%E5%8E%9F%E7%90%86%E4%B9%8B%E4%BA%8B%E5%8A%A1%E7%AF%87/b6c72ab37d5a42b9a431d737f3c3b5eetplv-k3u1fbpfcp-jj-mark1890000q75.webp" alt="image_1d8oab1ubb7v5f41j2pai21co19.png-22.4kB"> </p>
<blockquote>
<p>实际上insert undo只在事务回滚时起作用，当事务提交后，该类型的undo日志就没用了，它占用的Undo Log Segment也会被系统回收（也就是该undo日志占用的Undo页面链表要么被重用，要么被释放）。虽然真正的insert undo日志占用的存储空间被释放了，但是roll_pointer的值并不会被清除，roll_pointer属性占用7个字节，第一个比特位就标记着它指向的undo日志的类型，如果该比特位的值为1时，就代表着它指向的undo日志类型为insert undo。所以我们之后在画图时都会把insert undo给去掉，大家留意一下就好了。</p>
</blockquote>
<p>假设之后两个<code>事务id</code>分别为<code>100</code>、<code>200</code>的事务对这条记录进行<code>UPDATE</code>操作，操作流程如下：</p>
<p><img src="/../../../../../../imgs/MySQL%E5%8E%9F%E7%90%86%E4%B9%8B%E4%BA%8B%E5%8A%A1%E7%AF%87/7bc75c7f1def4be49e6bdc451e5af1adtplv-k3u1fbpfcp-jj-mark1890000q75.webp" alt="image_1d8obbc861ulkpt3no31gecrho16.png-92.3kB"> </p>
<blockquote>
<p>能不能在两个事务中交叉更新同一条记录呢？哈哈，这不就是一个事务修改了另一个未提交事务修改过的数据，沦为了脏写了么？InnoDB使用锁来保证不会有脏写情况的发生，也就是在第一个事务更新了某条记录后，就会给这条记录加锁，另一个事务再次更新时就需要等待第一个事务提交了，把锁释放之后才可以继续更新。关于锁的更多细节我们后续的文章中再唠叨哈～</p>
</blockquote>
<p>每次对记录进行改动，都会记录一条<code>undo日志</code>，每条<code>undo日志</code>也都有一个<code>roll_pointer</code>属性（<code>INSERT</code>操作对应的<code>undo日志</code>没有该属性，因为该记录并没有更早的版本），可以将这些<code>undo日志</code>都连起来，串成一个链表，所以现在的情况就像下图一样：</p>
<p><img src="/../../../../../../imgs/MySQL%E5%8E%9F%E7%90%86%E4%B9%8B%E4%BA%8B%E5%8A%A1%E7%AF%87/16a33e277a98dbectplv-t2oaga2asx-jj-mark1890000q75.webp" alt="image_1d8po6kgkejilj2g4t3t81evm20.png-81.7kB"> </p>
<p>对该记录每次更新后，都会将旧值放到一条<code>undo日志</code>中，就算是该记录的一个旧版本，随着更新次数的增多，所有的版本都会被<code>roll_pointer</code>属性连接成一个链表，我们把这个链表称之为<code>版本链</code>，版本链的头节点就是当前记录最新的值。另外，每个版本中还包含生成该版本时对应的<code>事务id</code>，这个信息很重要，我们稍后就会用到。</p>
<h4 id="4-2-2ReadView"><a href="#4-2-2ReadView" class="headerlink" title="4.2.2ReadView"></a>4.2.2ReadView</h4><p>对于使用<code>READ UNCOMMITTED</code>隔离级别的事务来说，由于可以读到未提交事务修改过的记录，所以直接读取记录的最新版本就好了；对于使用<code>SERIALIZABLE</code>隔离级别的事务来说，设计<code>InnoDB</code>的大叔规定使用加锁的方式来访问记录（加锁是啥我们后续文章中说哈）；对于使用<code>READ COMMITTED</code>和<code>REPEATABLE READ</code>隔离级别的事务来说，都必须保证读到已经提交了的事务修改过的记录，也就是说假如另一个事务已经修改了记录但是尚未提交，是不能直接读取最新版本的记录的，核心问题就是：需要判断一下版本链中的哪个版本是当前事务可见的。为此，设计<code>InnoDB</code>的大叔提出了一个<code>ReadView</code>的概念，这个<code>ReadView</code>中主要包含4个比较重要的内容：</p>
<ul>
<li><p><code>m_ids</code>：表示在生成<code>ReadView</code>时当前系统中活跃的读写事务的<code>事务id</code>列表。</p>
</li>
<li><p><code>min_trx_id</code>：表示在生成<code>ReadView</code>时当前系统中活跃的读写事务中最小的<code>事务id</code>，也就是<code>m_ids</code>中的最小值。</p>
</li>
<li><p><code>max_trx_id</code>：表示生成<code>ReadView</code>时系统中应该分配给下一个事务的<code>id</code>值。</p>
<blockquote>
<p>注意max_trx_id并不是m_ids中的最大值，事务id是递增分配的。比方说现在有id为1，2，3这三个事务，之后id为3的事务提交了。那么一个新的读事务在生成ReadView时，m_ids就包括1和2，min_trx_id的值就是1，max_trx_id的值就是4。</p>
</blockquote>
</li>
<li><p><code>creator_trx_id</code>：表示生成该<code>ReadView</code>的事务的<code>事务id</code>。</p>
<blockquote>
<p>我们前边说过，只有在对表中的记录做改动时（执行INSERT、DELETE、UPDATE这些语句时）才会为事务分配事务id，否则在一个只读事务中的事务id值都默认为0。</p>
</blockquote>
</li>
</ul>
<p>有了这个<code>ReadView</code>，这样在访问某条记录时，只需要按照下边的步骤判断记录的某个版本是否可见：</p>
<ul>
<li>如果被访问版本的<code>trx_id</code>属性值与<code>ReadView</code>中的<code>creator_trx_id</code>值相同，意味着当前事务在访问它自己修改过的记录，所以该版本可以被当前事务访问。</li>
<li>如果被访问版本的<code>trx_id</code>属性值小于<code>ReadView</code>中的<code>min_trx_id</code>值，表明生成该版本的事务在当前事务生成<code>ReadView</code>前已经提交，所以该版本可以被当前事务访问。</li>
<li>如果被访问版本的<code>trx_id</code>属性值大于或等于<code>ReadView</code>中的<code>max_trx_id</code>值，表明生成该版本的事务在当前事务生成<code>ReadView</code>后才开启，所以该版本不可以被当前事务访问。</li>
<li>如果被访问版本的<code>trx_id</code>属性值在<code>ReadView</code>的<code>min_trx_id</code>和<code>max_trx_id</code>之间，那就需要判断一下<code>trx_id</code>属性值是不是在<code>m_ids</code>列表中，如果在，说明创建<code>ReadView</code>时生成该版本的事务还是活跃的，该版本不可以被访问；如果不在，说明创建<code>ReadView</code>时生成该版本的事务已经被提交，该版本可以被访问。</li>
</ul>
<p>如果某个版本的数据对当前事务不可见的话，那就顺着版本链找到下一个版本的数据，继续按照上边的步骤判断可见性，依此类推，直到版本链中的最后一个版本。如果最后一个版本也不可见的话，那么就意味着该条记录对该事务完全不可见，查询结果就不包含该记录。</p>
<p>在<code>MySQL</code>中，<code>READ COMMITTED</code>和<code>REPEATABLE READ</code>隔离级别的的一个非常大的区别就是它们生成ReadView的时机不同。我们还是以表<code>hero</code>为例来，假设现在表<code>hero</code>中只有一条由<code>事务id</code>为<code>80</code>的事务插入的一条记录：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> hero;</span><br><span class="line"><span class="operator">+</span><span class="comment">--------+--------+---------+</span></span><br><span class="line"><span class="operator">|</span> number <span class="operator">|</span> name   <span class="operator">|</span> country <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------+--------+---------+</span></span><br><span class="line"><span class="operator">|</span>      <span class="number">1</span> <span class="operator">|</span> 刘备   <span class="operator">|</span> 蜀      <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------+--------+---------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.07</span> sec)</span><br></pre></td></tr></table></figure>

<p>接下来看一下<code>READ COMMITTED</code>和<code>REPEATABLE READ</code>所谓的生成ReadView的时机不同到底不同在哪里。</p>
<p><strong>READ COMMITTED —— 每次读取数据前都生成一个ReadView</strong></p>
<p>比方说现在系统里有两个<code>事务id</code>分别为<code>100</code>、<code>200</code>的事务在执行：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># Transaction <span class="number">100</span></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">UPDATE</span> hero <span class="keyword">SET</span> name <span class="operator">=</span> <span class="string">&#x27;关羽&#x27;</span> <span class="keyword">WHERE</span> number <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">UPDATE</span> hero <span class="keyword">SET</span> name <span class="operator">=</span> <span class="string">&#x27;张飞&#x27;</span> <span class="keyword">WHERE</span> number <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"># Transaction <span class="number">200</span></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"></span><br><span class="line"># 更新了一些别的表的记录</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<blockquote>
<p>再次强调一遍，事务执行过程中，只有在第一次真正修改记录时（比如使用INSERT、DELETE、UPDATE语句），才会被分配一个单独的事务id，这个事务id是递增的。所以我们才在Transaction 200中更新一些别的表的记录，目的是让它分配事务id。</p>
</blockquote>
<p>此刻，表<code>hero</code>中<code>number</code>为<code>1</code>的记录得到的版本链表如下所示：</p>
<p><img src="/../../../../../../imgs/MySQL%E5%8E%9F%E7%90%86%E4%B9%8B%E4%BA%8B%E5%8A%A1%E7%AF%87/ae389880792944b0b88ff81c9b86d7cctplv-k3u1fbpfcp-jj-mark1890000q75.webp" alt="image_1d8poeb056ck1d552it4t91aro2d.png-63.7kB"> </p>
<p>假设现在有一个使用<code>READ COMMITTED</code>隔离级别的事务开始执行：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 使用READ COMMITTED隔离级别的事务</span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"></span><br><span class="line"># SELECT1：Transaction <span class="number">100</span>、<span class="number">200</span>未提交</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> hero <span class="keyword">WHERE</span> number <span class="operator">=</span> <span class="number">1</span>; # 得到的列name的值为<span class="string">&#x27;刘备&#x27;</span></span><br></pre></td></tr></table></figure>

<p>这个<code>SELECT1</code>的执行过程如下：</p>
<ul>
<li>在执行<code>SELECT</code>语句时会先生成一个<code>ReadView</code>，<code>ReadView</code>的<code>m_ids</code>列表的内容就是<code>[100, 200]</code>，<code>min_trx_id</code>为<code>100</code>，<code>max_trx_id</code>为<code>201</code>，<code>creator_trx_id</code>为<code>0</code>。</li>
<li>然后从版本链中挑选可见的记录，从图中可以看出，最新版本的列<code>name</code>的内容是<code>&#39;张飞&#39;</code>，该版本的<code>trx_id</code>值为<code>100</code>，在<code>m_ids</code>列表内，所以不符合可见性要求，根据<code>roll_pointer</code>跳到下一个版本。</li>
<li>下一个版本的列<code>name</code>的内容是<code>&#39;关羽&#39;</code>，该版本的<code>trx_id</code>值也为<code>100</code>，也在<code>m_ids</code>列表内，所以也不符合要求，继续跳到下一个版本。</li>
<li>下一个版本的列<code>name</code>的内容是<code>&#39;刘备&#39;</code>，该版本的<code>trx_id</code>值为<code>80</code>，小于<code>ReadView</code>中的<code>min_trx_id</code>值<code>100</code>，所以这个版本是符合要求的，最后返回给用户的版本就是这条列<code>name</code>为<code>&#39;刘备&#39;</code>的记录。</li>
</ul>
<p>之后，我们把<code>事务id</code>为<code>100</code>的事务提交一下，就像这样：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># Transaction <span class="number">100</span></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">UPDATE</span> hero <span class="keyword">SET</span> name <span class="operator">=</span> <span class="string">&#x27;关羽&#x27;</span> <span class="keyword">WHERE</span> number <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">UPDATE</span> hero <span class="keyword">SET</span> name <span class="operator">=</span> <span class="string">&#x27;张飞&#x27;</span> <span class="keyword">WHERE</span> number <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure>

<p>然后再到<code>事务id</code>为<code>200</code>的事务中更新一下表<code>hero</code>中<code>number</code>为<code>1</code>的记录：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># Transaction <span class="number">200</span></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"></span><br><span class="line"># 更新了一些别的表的记录</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">UPDATE</span> hero <span class="keyword">SET</span> name <span class="operator">=</span> <span class="string">&#x27;赵云&#x27;</span> <span class="keyword">WHERE</span> number <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">UPDATE</span> hero <span class="keyword">SET</span> name <span class="operator">=</span> <span class="string">&#x27;诸葛亮&#x27;</span> <span class="keyword">WHERE</span> number <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>此刻，表<code>hero</code>中<code>number</code>为<code>1</code>的记录的版本链就长这样：</p>
<p><img src="/../../../../../../imgs/MySQL%E5%8E%9F%E7%90%86%E4%B9%8B%E4%BA%8B%E5%8A%A1%E7%AF%87/7fe2571121ec47948a52e0c233cda87atplv-k3u1fbpfcp-jj-mark1890000q75.webp" alt="image_1d8poudrjdrk4k0i22bj10g82q.png-78.6kB"> </p>
<p>然后再到刚才使用<code>READ COMMITTED</code>隔离级别的事务中继续查找这个<code>number</code>为<code>1</code>的记录，如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 使用READ COMMITTED隔离级别的事务</span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"></span><br><span class="line"># SELECT1：Transaction <span class="number">100</span>、<span class="number">200</span>均未提交</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> hero <span class="keyword">WHERE</span> number <span class="operator">=</span> <span class="number">1</span>; # 得到的列name的值为<span class="string">&#x27;刘备&#x27;</span></span><br><span class="line"></span><br><span class="line"># SELECT2：Transaction <span class="number">100</span>提交，Transaction <span class="number">200</span>未提交</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> hero <span class="keyword">WHERE</span> number <span class="operator">=</span> <span class="number">1</span>; # 得到的列name的值为<span class="string">&#x27;张飞&#x27;</span></span><br></pre></td></tr></table></figure>

<p>这个<code>SELECT2</code>的执行过程如下：</p>
<ul>
<li>在执行<code>SELECT</code>语句时会又会单独生成一个<code>ReadView</code>，该<code>ReadView</code>的<code>m_ids</code>列表的内容就是<code>[200]</code>（<code>事务id</code>为<code>100</code>的那个事务已经提交了，所以再次生成快照时就没有它了），<code>min_trx_id</code>为<code>200</code>，<code>max_trx_id</code>为<code>201</code>，<code>creator_trx_id</code>为<code>0</code>。</li>
<li>然后从版本链中挑选可见的记录，从图中可以看出，最新版本的列<code>name</code>的内容是<code>&#39;诸葛亮&#39;</code>，该版本的<code>trx_id</code>值为<code>200</code>，在<code>m_ids</code>列表内，所以不符合可见性要求，根据<code>roll_pointer</code>跳到下一个版本。</li>
<li>下一个版本的列<code>name</code>的内容是<code>&#39;赵云&#39;</code>，该版本的<code>trx_id</code>值为<code>200</code>，也在<code>m_ids</code>列表内，所以也不符合要求，继续跳到下一个版本。</li>
<li>下一个版本的列<code>name</code>的内容是<code>&#39;张飞&#39;</code>，该版本的<code>trx_id</code>值为<code>100</code>，小于<code>ReadView</code>中的<code>min_trx_id</code>值<code>200</code>，所以这个版本是符合要求的，最后返回给用户的版本就是这条列<code>name</code>为<code>&#39;张飞&#39;</code>的记录。</li>
</ul>
<p>以此类推，如果之后<code>事务id</code>为<code>200</code>的记录也提交了，再次在使用<code>READ COMMITTED</code>隔离级别的事务中查询表<code>hero</code>中<code>number</code>值为<code>1</code>的记录时，得到的结果就是<code>&#39;诸葛亮&#39;</code>了，具体流程我们就不分析了。</p>
<blockquote>
<p>总结一下就是：使用READ COMMITTED隔离级别的事务在每次查询开始时都会生成一个独立的ReadView。</p>
</blockquote>
<p><strong>REPEATABLE READ —— 在第一次读取数据时生成一个ReadView</strong></p>
<p>对于使用<code>REPEATABLE READ</code>隔离级别的事务来说，只会在第一次执行查询语句时生成一个<code>ReadView</code>，之后的查询就不会重复生成了。我们还是用例子看一下是什么效果。</p>
<p>比方说现在系统里有两个<code>事务id</code>分别为<code>100</code>、<code>200</code>的事务在执行：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># Transaction <span class="number">100</span></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">UPDATE</span> hero <span class="keyword">SET</span> name <span class="operator">=</span> <span class="string">&#x27;关羽&#x27;</span> <span class="keyword">WHERE</span> number <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">UPDATE</span> hero <span class="keyword">SET</span> name <span class="operator">=</span> <span class="string">&#x27;张飞&#x27;</span> <span class="keyword">WHERE</span> number <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"># Transaction <span class="number">200</span></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"></span><br><span class="line"># 更新了一些别的表的记录</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>此刻，表<code>hero</code>中<code>number</code>为<code>1</code>的记录得到的版本链表如下所示：</p>
<p><img src="/../../../../../../imgs/MySQL%E5%8E%9F%E7%90%86%E4%B9%8B%E4%BA%8B%E5%8A%A1%E7%AF%87/2bf361978769480eae58f2ed37f44f79tplv-k3u1fbpfcp-jj-mark1890000q75.webp" alt="image_1d8pt2nd6moqtjn12hibgj91f37.png-60.9kB"> </p>
<p>假设现在有一个使用<code>REPEATABLE READ</code>隔离级别的事务开始执行：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 使用REPEATABLE READ隔离级别的事务</span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"></span><br><span class="line"># SELECT1：Transaction <span class="number">100</span>、<span class="number">200</span>未提交</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> hero <span class="keyword">WHERE</span> number <span class="operator">=</span> <span class="number">1</span>; # 得到的列name的值为<span class="string">&#x27;刘备&#x27;</span></span><br></pre></td></tr></table></figure>

<p>这个<code>SELECT1</code>的执行过程如下：</p>
<ul>
<li>在执行<code>SELECT</code>语句时会先生成一个<code>ReadView</code>，<code>ReadView</code>的<code>m_ids</code>列表的内容就是<code>[100, 200]</code>，<code>min_trx_id</code>为<code>100</code>，<code>max_trx_id</code>为<code>201</code>，<code>creator_trx_id</code>为<code>0</code>。</li>
<li>然后从版本链中挑选可见的记录，从图中可以看出，最新版本的列<code>name</code>的内容是<code>&#39;张飞&#39;</code>，该版本的<code>trx_id</code>值为<code>100</code>，在<code>m_ids</code>列表内，所以不符合可见性要求，根据<code>roll_pointer</code>跳到下一个版本。</li>
<li>下一个版本的列<code>name</code>的内容是<code>&#39;关羽&#39;</code>，该版本的<code>trx_id</code>值也为<code>100</code>，也在<code>m_ids</code>列表内，所以也不符合要求，继续跳到下一个版本。</li>
<li>下一个版本的列<code>name</code>的内容是<code>&#39;刘备&#39;</code>，该版本的<code>trx_id</code>值为<code>80</code>，小于<code>ReadView</code>中的<code>min_trx_id</code>值<code>100</code>，所以这个版本是符合要求的，最后返回给用户的版本就是这条列<code>name</code>为<code>&#39;刘备&#39;</code>的记录。</li>
</ul>
<p>之后，我们把<code>事务id</code>为<code>100</code>的事务提交一下，就像这样：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># Transaction <span class="number">100</span></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">UPDATE</span> hero <span class="keyword">SET</span> name <span class="operator">=</span> <span class="string">&#x27;关羽&#x27;</span> <span class="keyword">WHERE</span> number <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">UPDATE</span> hero <span class="keyword">SET</span> name <span class="operator">=</span> <span class="string">&#x27;张飞&#x27;</span> <span class="keyword">WHERE</span> number <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure>

<p>然后再到<code>事务id</code>为<code>200</code>的事务中更新一下表<code>hero</code>中<code>number</code>为<code>1</code>的记录：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># Transaction <span class="number">200</span></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"></span><br><span class="line"># 更新了一些别的表的记录</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">UPDATE</span> hero <span class="keyword">SET</span> name <span class="operator">=</span> <span class="string">&#x27;赵云&#x27;</span> <span class="keyword">WHERE</span> number <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">UPDATE</span> hero <span class="keyword">SET</span> name <span class="operator">=</span> <span class="string">&#x27;诸葛亮&#x27;</span> <span class="keyword">WHERE</span> number <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>此刻，表<code>hero</code>中<code>number</code>为<code>1</code>的记录的版本链就长这样：</p>
<p><img src="/../../../../../../imgs/MySQL%E5%8E%9F%E7%90%86%E4%B9%8B%E4%BA%8B%E5%8A%A1%E7%AF%87/75fc78c0a6b34a0095fe019f35ac4698tplv-k3u1fbpfcp-jj-mark1890000q75.webp" alt="image_1d8ptbc339kdk0b1du3nef6s03k.png-78.2kB"> </p>
<p>然后再到刚才使用<code>REPEATABLE READ</code>隔离级别的事务中继续查找这个<code>number</code>为<code>1</code>的记录，如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 使用REPEATABLE READ隔离级别的事务</span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"></span><br><span class="line"># SELECT1：Transaction <span class="number">100</span>、<span class="number">200</span>均未提交</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> hero <span class="keyword">WHERE</span> number <span class="operator">=</span> <span class="number">1</span>; # 得到的列name的值为<span class="string">&#x27;刘备&#x27;</span></span><br><span class="line"></span><br><span class="line"># SELECT2：Transaction <span class="number">100</span>提交，Transaction <span class="number">200</span>未提交</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> hero <span class="keyword">WHERE</span> number <span class="operator">=</span> <span class="number">1</span>; # 得到的列name的值仍为<span class="string">&#x27;刘备&#x27;</span></span><br></pre></td></tr></table></figure>

<p>这个<code>SELECT2</code>的执行过程如下：</p>
<ul>
<li>因为当前事务的隔离级别为<code>REPEATABLE READ</code>，而之前在执行<code>SELECT1</code>时已经生成过<code>ReadView</code>了，所以此时直接复用之前的<code>ReadView</code>，之前的<code>ReadView</code>的<code>m_ids</code>列表的内容就是<code>[100, 200]</code>，<code>min_trx_id</code>为<code>100</code>，<code>max_trx_id</code>为<code>201</code>，<code>creator_trx_id</code>为<code>0</code>。</li>
<li>然后从版本链中挑选可见的记录，从图中可以看出，最新版本的列<code>name</code>的内容是<code>&#39;诸葛亮&#39;</code>，该版本的<code>trx_id</code>值为<code>200</code>，在<code>m_ids</code>列表内，所以不符合可见性要求，根据<code>roll_pointer</code>跳到下一个版本。</li>
<li>下一个版本的列<code>name</code>的内容是<code>&#39;赵云&#39;</code>，该版本的<code>trx_id</code>值为<code>200</code>，也在<code>m_ids</code>列表内，所以也不符合要求，继续跳到下一个版本。</li>
<li>下一个版本的列<code>name</code>的内容是<code>&#39;张飞&#39;</code>，该版本的<code>trx_id</code>值为<code>100</code>，而<code>m_ids</code>列表中是包含值为<code>100</code>的<code>事务id</code>的，所以该版本也不符合要求，同理下一个列<code>name</code>的内容是<code>&#39;关羽&#39;</code>的版本也不符合要求。继续跳到下一个版本。</li>
<li>下一个版本的列<code>name</code>的内容是<code>&#39;刘备&#39;</code>，该版本的<code>trx_id</code>值为<code>80</code>，小于<code>ReadView</code>中的<code>min_trx_id</code>值<code>100</code>，所以这个版本是符合要求的，最后返回给用户的版本就是这条列<code>c</code>为<code>&#39;刘备&#39;</code>的记录。</li>
</ul>
<p>也就是说两次<code>SELECT</code>查询得到的结果是重复的，记录的列<code>c</code>值都是<code>&#39;刘备&#39;</code>，这就是<code>可重复读</code>的含义。如果我们之后再把<code>事务id</code>为<code>200</code>的记录提交了，然后再到刚才使用<code>REPEATABLE READ</code>隔离级别的事务中继续查找这个<code>number</code>为<code>1</code>的记录，得到的结果还是<code>&#39;刘备&#39;</code>，具体执行过程大家可以自己分析一下。</p>
<h4 id="4-2-3MVCC小结"><a href="#4-2-3MVCC小结" class="headerlink" title="4.2.3MVCC小结"></a>4.2.3MVCC小结</h4><p>从上边的描述中我们可以看出来，所谓的<code>MVCC</code>（Multi-Version Concurrency Control ，多版本并发控制）指的就是在使用<code>READ COMMITTD</code>、<code>REPEATABLE READ</code>这两种隔离级别的事务在执行普通的<code>SELECT</code>操作时访问记录的版本链的过程，这样子可以使不同事务的<code>读-写</code>、<code>写-读</code>操作并发执行，从而提升系统性能。<code>READ COMMITTD</code>、<code>REPEATABLE READ</code>这两个隔离级别的一个很大不同就是：生成ReadView的时机不同，READ COMMITTD在每一次进行普通SELECT操作前都会生成一个ReadView，而REPEATABLE READ只在第一次进行普通SELECT操作前生成一个ReadView，之后的查询操作都重复使用这个ReadView就好了。</p>
<blockquote>
<p>我们之前说执行DELETE语句或者更新主键的UPDATE语句并不会立即把对应的记录完全从页面中删除，而是执行一个所谓的delete mark操作，相当于只是对记录打上了一个删除标志位，这主要就是为MVCC服务的，大家可以对比上边举的例子自己试想一下怎么使用。</p>
</blockquote>

  </div>
</article>

    <div class="blog-post-comments">
        <div id="disqus_thread">
            <noscript>Please enable JavaScript to view the comments.</noscript>
        </div>
    </div>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
        
          <li><a href="/">Home</a></li>
        
          <li><a href="/about/">About</a></li>
        
          <li><a href="/archives/">Writing</a></li>
        
          <li><a href="/tags/">Tag</a></li>
        
          <li><a target="_blank" rel="noopener" href="http://github.com/hulingF">Projects</a></li>
        
      </ul>
    </div>

    
    
      <div id="toc-footer" style="display: none">
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#MySQL%E5%8E%9F%E7%90%86%E4%B9%8B%E4%BA%8B%E5%8A%A1%E7%AF%87"><span class="toc-number">1.</span> <span class="toc-text">MySQL原理之事务篇</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E4%BA%8B%E5%8A%A1%E7%9A%84%E7%AE%80%E4%BB%8B"><span class="toc-number">1.1.</span> <span class="toc-text">一、事务的简介</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1%E4%BA%8B%E5%8A%A1%E7%9A%84%E8%B5%B7%E6%BA%90"><span class="toc-number">1.1.1.</span> <span class="toc-text">1.1事务的起源</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-1%E5%8E%9F%E5%AD%90%E6%80%A7%EF%BC%88Atomicity%EF%BC%89"><span class="toc-number">1.1.1.1.</span> <span class="toc-text">1.1.1原子性（Atomicity）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-2%E9%9A%94%E7%A6%BB%E6%80%A7%EF%BC%88Isolation%EF%BC%89"><span class="toc-number">1.1.1.2.</span> <span class="toc-text">1.1.2隔离性（Isolation）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-3%E4%B8%80%E8%87%B4%E6%80%A7%EF%BC%88Consistency%EF%BC%89"><span class="toc-number">1.1.1.3.</span> <span class="toc-text">1.1.3一致性（Consistency）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-4%E6%8C%81%E4%B9%85%E6%80%A7%EF%BC%88Durability%EF%BC%89"><span class="toc-number">1.1.1.4.</span> <span class="toc-text">1.1.4持久性（Durability）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2MySQL%E4%B8%AD%E4%BA%8B%E5%8A%A1%E7%9A%84%E8%AF%AD%E6%B3%95"><span class="toc-number">1.1.2.</span> <span class="toc-text">1.2MySQL中事务的语法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-1%E5%BC%80%E5%90%AF%E4%BA%8B%E5%8A%A1"><span class="toc-number">1.1.2.1.</span> <span class="toc-text">1.2.1开启事务</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-2%E6%8F%90%E4%BA%A4%E4%BA%8B%E5%8A%A1"><span class="toc-number">1.1.2.2.</span> <span class="toc-text">1.2.2提交事务</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-3%E6%89%8B%E5%8A%A8%E4%B8%AD%E6%AD%A2%E4%BA%8B%E5%8A%A1"><span class="toc-number">1.1.2.3.</span> <span class="toc-text">1.2.3手动中止事务</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-4%E8%87%AA%E5%8A%A8%E6%8F%90%E4%BA%A4"><span class="toc-number">1.1.2.4.</span> <span class="toc-text">1.2.4自动提交</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-5%E9%9A%90%E5%BC%8F%E6%8F%90%E4%BA%A4"><span class="toc-number">1.1.2.5.</span> <span class="toc-text">1.2.5隐式提交</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-6%E4%BF%9D%E5%AD%98%E7%82%B9"><span class="toc-number">1.1.2.6.</span> <span class="toc-text">1.2.6保存点</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81Redo%E6%97%A5%E5%BF%97"><span class="toc-number">1.2.</span> <span class="toc-text">二、Redo日志</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1redo%E6%97%A5%E5%BF%97%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.2.1.</span> <span class="toc-text">2.1redo日志介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2redo%E6%97%A5%E5%BF%97%E6%A0%BC%E5%BC%8F"><span class="toc-number">1.2.2.</span> <span class="toc-text">2.2redo日志格式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-1%E7%AE%80%E5%8D%95%E7%9A%84redo%E6%97%A5%E5%BF%97%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">2.2.1简单的redo日志类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-2%E5%A4%8D%E6%9D%82%E7%9A%84redo%E6%97%A5%E5%BF%97%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">2.2.2复杂的redo日志类型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3Mini-Transaction"><span class="toc-number">1.2.3.</span> <span class="toc-text">2.3Mini-Transaction</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-1%E4%BB%A5%E7%BB%84%E7%9A%84%E5%BD%A2%E5%BC%8F%E5%86%99%E5%85%A5redo%E6%97%A5%E5%BF%97"><span class="toc-number">1.2.3.1.</span> <span class="toc-text">2.3.1以组的形式写入redo日志</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-2Mini-Transaction%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">1.2.3.2.</span> <span class="toc-text">2.3.2Mini-Transaction的概念</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4redo%E6%97%A5%E5%BF%97%E7%9A%84%E5%86%99%E5%85%A5%E8%BF%87%E7%A8%8B"><span class="toc-number">1.2.4.</span> <span class="toc-text">2.4redo日志的写入过程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-1redo-log-block"><span class="toc-number">1.2.4.1.</span> <span class="toc-text">2.4.1redo log block</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-2redo%E6%97%A5%E5%BF%97%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="toc-number">1.2.4.2.</span> <span class="toc-text">2.4.2redo日志缓冲区</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-3redo%E6%97%A5%E5%BF%97%E5%86%99%E5%85%A5log-buffer"><span class="toc-number">1.2.4.3.</span> <span class="toc-text">2.4.3redo日志写入log buffer</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5redo%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6"><span class="toc-number">1.2.5.</span> <span class="toc-text">2.5redo日志文件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5-1redo%E6%97%A5%E5%BF%97%E5%88%B7%E7%9B%98%E6%97%B6%E6%9C%BA"><span class="toc-number">1.2.5.1.</span> <span class="toc-text">2.5.1redo日志刷盘时机</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5-2redo%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6%E7%BB%84"><span class="toc-number">1.2.5.2.</span> <span class="toc-text">2.5.2redo日志文件组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5-3redo%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F"><span class="toc-number">1.2.5.3.</span> <span class="toc-text">2.5.3redo日志文件格式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6Log-Sequence-Number"><span class="toc-number">1.2.6.</span> <span class="toc-text">2.6Log Sequence Number</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-6-1flushed-to-disk-lsn"><span class="toc-number">1.2.6.1.</span> <span class="toc-text">2.6.1flushed_to_disk_lsn</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-6-2lsn%E5%80%BC%E5%92%8Credo%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6%E5%81%8F%E7%A7%BB%E9%87%8F%E7%9A%84%E5%AF%B9%E5%BA%94%E5%85%B3%E7%B3%BB"><span class="toc-number">1.2.6.2.</span> <span class="toc-text">2.6.2lsn值和redo日志文件偏移量的对应关系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-6-3flush%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84LSN"><span class="toc-number">1.2.6.3.</span> <span class="toc-text">2.6.3flush链表中的LSN</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-7checkpoint"><span class="toc-number">1.2.7.</span> <span class="toc-text">2.7checkpoint</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-7-1%E6%89%B9%E9%87%8F%E4%BB%8Eflush%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%88%B7%E5%87%BA%E8%84%8F%E9%A1%B5"><span class="toc-number">1.2.7.1.</span> <span class="toc-text">2.7.1批量从flush链表中刷出脏页</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-7-2%E6%9F%A5%E7%9C%8B%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8DLSN%E5%80%BC"><span class="toc-number">1.2.7.2.</span> <span class="toc-text">2.7.2查看系统中的各种LSN值</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-8%E5%B4%A9%E6%BA%83%E6%81%A2%E5%A4%8D"><span class="toc-number">1.2.8.</span> <span class="toc-text">2.8崩溃恢复</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-8-1%E7%A1%AE%E5%AE%9A%E6%81%A2%E5%A4%8D%E7%9A%84%E8%B5%B7%E7%82%B9"><span class="toc-number">1.2.8.1.</span> <span class="toc-text">2.8.1确定恢复的起点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-8-2%E7%A1%AE%E5%AE%9A%E6%81%A2%E5%A4%8D%E7%9A%84%E7%BB%88%E7%82%B9"><span class="toc-number">1.2.8.2.</span> <span class="toc-text">2.8.2确定恢复的终点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-8-3%E6%80%8E%E4%B9%88%E6%81%A2%E5%A4%8D"><span class="toc-number">1.2.8.3.</span> <span class="toc-text">2.8.3怎么恢复</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81Undo%E6%97%A5%E5%BF%97"><span class="toc-number">1.3.</span> <span class="toc-text">三、Undo日志</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81MVCC%E4%B8%8E%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="toc-number">1.4.</span> <span class="toc-text">四、MVCC与隔离级别</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="toc-number">1.4.1.</span> <span class="toc-text">4.1事务隔离级别</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-1%E4%BA%8B%E5%8A%A1%E5%B9%B6%E5%8F%91%E6%89%A7%E8%A1%8C%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">1.4.1.1.</span> <span class="toc-text">4.1.1事务并发执行遇到的问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-2SQL%E6%A0%87%E5%87%86%E4%B8%AD%E7%9A%84%E5%9B%9B%E7%A7%8D%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="toc-number">1.4.1.2.</span> <span class="toc-text">4.1.2SQL标准中的四种隔离级别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-3MySQL%E4%B8%AD%E6%94%AF%E6%8C%81%E7%9A%84%E5%9B%9B%E7%A7%8D%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="toc-number">1.4.1.3.</span> <span class="toc-text">4.1.3MySQL中支持的四种隔离级别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2MVCC%E5%8E%9F%E7%90%86"><span class="toc-number">1.4.2.</span> <span class="toc-text">4.2MVCC原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-1%E7%89%88%E6%9C%AC%E9%93%BE"><span class="toc-number">1.4.2.1.</span> <span class="toc-text">4.2.1版本链</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-2ReadView"><span class="toc-number">1.4.2.2.</span> <span class="toc-text">4.2.2ReadView</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-3MVCC%E5%B0%8F%E7%BB%93"><span class="toc-number">1.4.2.3.</span> <span class="toc-text">4.2.3MVCC小结</span></a></li></ol></li></ol></li></ol></li></ol>
      </div>
    

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://hulingf.github.io/2023/12/20/MySQL%E5%8E%9F%E7%90%86%E4%B9%8B%E4%BA%8B%E5%8A%A1%E7%AF%87/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://hulingf.github.io/2023/12/20/MySQL%E5%8E%9F%E7%90%86%E4%B9%8B%E4%BA%8B%E5%8A%A1%E7%AF%87/&text=MySQL原理之事务篇"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://hulingf.github.io/2023/12/20/MySQL%E5%8E%9F%E7%90%86%E4%B9%8B%E4%BA%8B%E5%8A%A1%E7%AF%87/&title=MySQL原理之事务篇"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://hulingf.github.io/2023/12/20/MySQL%E5%8E%9F%E7%90%86%E4%B9%8B%E4%BA%8B%E5%8A%A1%E7%AF%87/&is_video=false&description=MySQL原理之事务篇"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=MySQL原理之事务篇&body=Check out this article: https://hulingf.github.io/2023/12/20/MySQL%E5%8E%9F%E7%90%86%E4%B9%8B%E4%BA%8B%E5%8A%A1%E7%AF%87/"><i class="fa-solid fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://hulingf.github.io/2023/12/20/MySQL%E5%8E%9F%E7%90%86%E4%B9%8B%E4%BA%8B%E5%8A%A1%E7%AF%87/&title=MySQL原理之事务篇"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://hulingf.github.io/2023/12/20/MySQL%E5%8E%9F%E7%90%86%E4%B9%8B%E4%BA%8B%E5%8A%A1%E7%AF%87/&title=MySQL原理之事务篇"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://hulingf.github.io/2023/12/20/MySQL%E5%8E%9F%E7%90%86%E4%B9%8B%E4%BA%8B%E5%8A%A1%E7%AF%87/&title=MySQL原理之事务篇"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://hulingf.github.io/2023/12/20/MySQL%E5%8E%9F%E7%90%86%E4%B9%8B%E4%BA%8B%E5%8A%A1%E7%AF%87/&title=MySQL原理之事务篇"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://hulingf.github.io/2023/12/20/MySQL%E5%8E%9F%E7%90%86%E4%B9%8B%E4%BA%8B%E5%8A%A1%E7%AF%87/&name=MySQL原理之事务篇&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://hulingf.github.io/2023/12/20/MySQL%E5%8E%9F%E7%90%86%E4%B9%8B%E4%BA%8B%E5%8A%A1%E7%AF%87/&t=MySQL原理之事务篇"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fa-solid fa-bars fa-lg" aria-hidden="true"></i> Menu</a>
        
          <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fa-solid fa-list fa-lg" aria-hidden="true"></i> TOC</a>
        
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fa-solid fa-share-alt fa-lg" aria-hidden="true"></i> Share</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2023
    hulingF
  </div>
  <div class="footer-right">
    <nav>
      <ul>
        <!--
       --><li><a href="/">Home</a></li><!--
     --><!--
       --><li><a href="/about/">About</a></li><!--
     --><!--
       --><li><a href="/archives/">Writing</a></li><!--
     --><!--
       --><li><a href="/tags/">Tag</a></li><!--
     --><!--
       --><li><a target="_blank" rel="noopener" href="http://github.com/hulingF">Projects</a></li><!--
     -->
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->



  <link rel="preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" crossorigin="anonymous" onload="this.onload=null;this.rel='stylesheet'"/>


    <!-- jquery -->

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" crossorigin="anonymous"></script>




<!-- clipboard -->

  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.7/clipboard.min.js" crossorigin="anonymous"></script>
  
  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"Copy to clipboard!\">";
    btn += '<i class="fa-regular fa-clone"></i>';
    btn += '</span>';
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "Copied!");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Disqus Comments -->

    <script type="text/javascript">
        var disqus_shortname = 'hulingF';

        (function(){
            var dsq = document.createElement('script');
            dsq.type = 'text/javascript';
            dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        }());
    </script>

<!-- utterances Comments -->

</body>
</html>
