<!DOCTYPE html>
<html lang=en>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5" />
    <meta name="description" content="第一部分：XV6操作系统简要剖析 学习目标：通过学习 MIT 的一套教学操作系统深度了解操作系统的内部简易实现机制，从代码层次更多把握OS 的内部机制，可以作为操作系统的实践部分进行阅读学习！注意：从我个人的角度出发，我不会细抠内部的每一行代码，我想达到的效果是能建立一个 OS 的全局观，打破这个”黑盒子”，但不是制作这个”盒子”，更多还是从 programmer 而不是自始而终的 builder">
<meta property="og:type" content="article">
<meta property="og:title" content="操作系统源码级剖析">
<meta property="og:url" content="https://hulingf.github.io/2023/10/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%BA%90%E7%A0%81%E7%BA%A7%E5%89%96%E6%9E%90/index.html">
<meta property="og:site_name" content="大军的秘密花园">
<meta property="og:description" content="第一部分：XV6操作系统简要剖析 学习目标：通过学习 MIT 的一套教学操作系统深度了解操作系统的内部简易实现机制，从代码层次更多把握OS 的内部机制，可以作为操作系统的实践部分进行阅读学习！注意：从我个人的角度出发，我不会细抠内部的每一行代码，我想达到的效果是能建立一个 OS 的全局观，打破这个”黑盒子”，但不是制作这个”盒子”，更多还是从 programmer 而不是自始而终的 builder">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://hulingf.github.io/imgs/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%BA%90%E7%A0%81%E7%BA%A7%E5%89%96%E6%9E%90/image-20221114094042087.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%BA%90%E7%A0%81%E7%BA%A7%E5%89%96%E6%9E%90/image-20221114094612346.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%BA%90%E7%A0%81%E7%BA%A7%E5%89%96%E6%9E%90/image-20221114141151380.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%BA%90%E7%A0%81%E7%BA%A7%E5%89%96%E6%9E%90/image-20221114141810611.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%BA%90%E7%A0%81%E7%BA%A7%E5%89%96%E6%9E%90/image-20221114153948359.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%BA%90%E7%A0%81%E7%BA%A7%E5%89%96%E6%9E%90/image-20221114154520842.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%BA%90%E7%A0%81%E7%BA%A7%E5%89%96%E6%9E%90/image-20221114155032464.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%BA%90%E7%A0%81%E7%BA%A7%E5%89%96%E6%9E%90/image-20221114180046008.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%BA%90%E7%A0%81%E7%BA%A7%E5%89%96%E6%9E%90/image-20221116160144854.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%BA%90%E7%A0%81%E7%BA%A7%E5%89%96%E6%9E%90/image-20221116191701662.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%BA%90%E7%A0%81%E7%BA%A7%E5%89%96%E6%9E%90/image-20221116200142968.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%BA%90%E7%A0%81%E7%BA%A7%E5%89%96%E6%9E%90/image-20221117091925084.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%BA%90%E7%A0%81%E7%BA%A7%E5%89%96%E6%9E%90/image-20221117092252966.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%BA%90%E7%A0%81%E7%BA%A7%E5%89%96%E6%9E%90/image-20221117163303777.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%BA%90%E7%A0%81%E7%BA%A7%E5%89%96%E6%9E%90/image-20221118151758126.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%BA%90%E7%A0%81%E7%BA%A7%E5%89%96%E6%9E%90/image-20221119142053545.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%BA%90%E7%A0%81%E7%BA%A7%E5%89%96%E6%9E%90/image-20221119195251727.png">
<meta property="og:image" content="c:\Users\lan\Pictures\%E5%A3%81%E7%BA%B8\wallhaven-o5dj1p.jpg">
<meta property="article:published_time" content="2023-10-24T03:10:52.022Z">
<meta property="article:modified_time" content="2023-10-24T14:29:42.819Z">
<meta property="article:author" content="hulingF">
<meta property="article:tag" content="操作系统">
<meta property="article:tag" content="XV6">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://hulingf.github.io/imgs/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%BA%90%E7%A0%81%E7%BA%A7%E5%89%96%E6%9E%90/image-20221114094042087.png">
    
    
      
        
          <link rel="shortcut icon" href="/images/favicon.ico">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
        
      
    
    <!-- title -->
    <title>操作系统源码级剖析</title>
    <!-- async scripts -->
    <!-- Google Analytics -->


    <!-- Umami Analytics -->


    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
    <!-- rss -->
    
    
	<!-- mathjax -->
	
<meta name="generator" content="Hexo 6.3.0"></head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#" aria-label="Menu"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#" aria-label="Menu"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" aria-label="Top" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa-solid fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
        <!--
       --><li><a href="/">Home</a></li><!--
     --><!--
       --><li><a href="/about/">About</a></li><!--
     --><!--
       --><li><a href="/archives/">Writing</a></li><!--
     --><!--
       --><li><a href="/tags/">Tag</a></li><!--
     --><!--
       --><li><a target="_blank" rel="noopener" href="http://github.com/hulingF">Projects</a></li><!--
     -->
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" aria-label="Previous post" href="/2023/10/30/Spring%E6%A0%B8%E5%BF%83%E4%B9%8BIOC%E8%AF%A6%E8%A7%A3%E7%AF%87/"><i class="fa-solid fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" aria-label="Next post" href="/2023/10/22/IDEA%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/"><i class="fa-solid fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" aria-label="Back to top" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" aria-label="Share post" href="#"><i class="fa-solid fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://hulingf.github.io/2023/10/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%BA%90%E7%A0%81%E7%BA%A7%E5%89%96%E6%9E%90/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://hulingf.github.io/2023/10/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%BA%90%E7%A0%81%E7%BA%A7%E5%89%96%E6%9E%90/&text=操作系统源码级剖析"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://hulingf.github.io/2023/10/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%BA%90%E7%A0%81%E7%BA%A7%E5%89%96%E6%9E%90/&title=操作系统源码级剖析"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://hulingf.github.io/2023/10/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%BA%90%E7%A0%81%E7%BA%A7%E5%89%96%E6%9E%90/&is_video=false&description=操作系统源码级剖析"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=操作系统源码级剖析&body=Check out this article: https://hulingf.github.io/2023/10/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%BA%90%E7%A0%81%E7%BA%A7%E5%89%96%E6%9E%90/"><i class="fa-solid fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://hulingf.github.io/2023/10/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%BA%90%E7%A0%81%E7%BA%A7%E5%89%96%E6%9E%90/&title=操作系统源码级剖析"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://hulingf.github.io/2023/10/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%BA%90%E7%A0%81%E7%BA%A7%E5%89%96%E6%9E%90/&title=操作系统源码级剖析"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://hulingf.github.io/2023/10/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%BA%90%E7%A0%81%E7%BA%A7%E5%89%96%E6%9E%90/&title=操作系统源码级剖析"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://hulingf.github.io/2023/10/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%BA%90%E7%A0%81%E7%BA%A7%E5%89%96%E6%9E%90/&title=操作系统源码级剖析"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://hulingf.github.io/2023/10/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%BA%90%E7%A0%81%E7%BA%A7%E5%89%96%E6%9E%90/&name=操作系统源码级剖析&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://hulingf.github.io/2023/10/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%BA%90%E7%A0%81%E7%BA%A7%E5%89%96%E6%9E%90/&t=操作系统源码级剖析"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    
    
      <div id="toc">
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86%EF%BC%9AXV6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AE%80%E8%A6%81%E5%89%96%E6%9E%90"><span class="toc-number">1.</span> <span class="toc-text">第一部分：XV6操作系统简要剖析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E7%AB%A0%EF%BC%9A%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.1.</span> <span class="toc-text">第一章：操作系统接口</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%86%85%E5%AD%98"><span class="toc-number">1.1.1.</span> <span class="toc-text">1.1进程与内存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2I-x2F-O%E5%92%8C%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6"><span class="toc-number">1.1.2.</span> <span class="toc-text">1.2I&#x2F;O和文件描述符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3%E7%AE%A1%E9%81%93"><span class="toc-number">1.1.3.</span> <span class="toc-text">1.3管道</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.1.4.</span> <span class="toc-text">1.4文件系统</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0%EF%BC%9A%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BB%84%E7%BB%87"><span class="toc-number">1.2.</span> <span class="toc-text">第二章：操作系统组织</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1%E6%8A%BD%E8%B1%A1%E7%89%A9%E7%90%86%E8%B5%84%E6%BA%90"><span class="toc-number">1.2.1.</span> <span class="toc-text">2.1抽象物理资源</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2%E6%A8%A1%E5%BC%8F%E5%8F%98%E6%8D%A2%E4%B8%8E%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-number">1.2.2.</span> <span class="toc-text">2.2模式变换与系统调用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3%E5%86%85%E6%A0%B8%E7%BB%84%E7%BB%87"><span class="toc-number">1.2.3.</span> <span class="toc-text">2.3内核组织</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4xv6%E4%BB%A3%E7%A0%81%E7%BB%84%E7%BB%87%E5%BD%A2%E5%BC%8F"><span class="toc-number">1.2.4.</span> <span class="toc-text">2.4xv6代码组织形式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5%E8%BF%9B%E7%A8%8B%E6%A6%82%E8%BF%B0"><span class="toc-number">1.2.5.</span> <span class="toc-text">2.5进程概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-6xv6%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B"><span class="toc-number">1.2.6.</span> <span class="toc-text">2.6xv6启动流程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E7%AB%A0%EF%BC%9A%E9%A1%B5%E8%A1%A8"><span class="toc-number">1.3.</span> <span class="toc-text">第三章：页表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1%E5%88%86%E9%A1%B5%E7%A1%AC%E4%BB%B6"><span class="toc-number">1.3.1.</span> <span class="toc-text">3.1分页硬件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2%E5%86%85%E6%A0%B8%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4"><span class="toc-number">1.3.2.</span> <span class="toc-text">3.2内核地址空间</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3%E5%88%9B%E5%BB%BA%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4"><span class="toc-number">1.3.3.</span> <span class="toc-text">3.3创建地址空间</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D"><span class="toc-number">1.3.4.</span> <span class="toc-text">3.4物理内存分配</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-5%E8%BF%9B%E7%A8%8B%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4"><span class="toc-number">1.3.5.</span> <span class="toc-text">3.5进程地址空间</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-6sbrk%E8%A7%A3%E6%9E%90"><span class="toc-number">1.3.6.</span> <span class="toc-text">3.6sbrk解析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-7exec%E8%A7%A3%E6%9E%90"><span class="toc-number">1.3.7.</span> <span class="toc-text">3.7exec解析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E7%AB%A0%EF%BC%9A%E9%99%B7%E5%85%A5%E5%92%8C%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-number">1.4.</span> <span class="toc-text">第四章：陷入和系统调用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1RISC-V%E9%99%B7%E5%85%A5%E6%9C%BA%E5%88%B6"><span class="toc-number">1.4.1.</span> <span class="toc-text">4.1RISC-V陷入机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4%E7%9A%84%E9%99%B7%E5%85%A5"><span class="toc-number">1.4.2.</span> <span class="toc-text">4.2用户空间的陷入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%87%BD%E6%95%B0%E6%89%A7%E8%A1%8C"><span class="toc-number">1.4.3.</span> <span class="toc-text">4.3系统调用函数执行</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-4%E5%86%85%E6%A0%B8%E7%A9%BA%E9%97%B4%E7%9A%84%E9%99%B7%E5%85%A5"><span class="toc-number">1.4.4.</span> <span class="toc-text">4.4内核空间的陷入</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%BA%94%E7%AB%A0%EF%BC%9A%E4%B8%AD%E6%96%AD%E5%92%8C%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8"><span class="toc-number">1.5.</span> <span class="toc-text">第五章：中断和设备驱动</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1%E6%8E%A7%E5%88%B6%E5%8F%B0%E8%BE%93%E5%85%A5"><span class="toc-number">1.5.1.</span> <span class="toc-text">5.1控制台输入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2%E6%8E%A7%E5%88%B6%E5%8F%B0%E8%BE%93%E5%87%BA"><span class="toc-number">1.5.2.</span> <span class="toc-text">5.2控制台输出</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3%E8%AE%BE%E5%A4%87%E5%B9%B6%E5%8F%91"><span class="toc-number">1.5.3.</span> <span class="toc-text">5.3设备并发</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-4%E6%97%B6%E9%92%9F%E4%B8%AD%E6%96%AD"><span class="toc-number">1.5.4.</span> <span class="toc-text">5.4时钟中断</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-5%E8%A1%A5%E5%85%85"><span class="toc-number">1.5.5.</span> <span class="toc-text">5.5补充</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E5%85%AD%E7%AB%A0%EF%BC%9A%E9%94%81"><span class="toc-number">1.6.</span> <span class="toc-text">第六章：锁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-1%E7%AB%9E%E4%BA%89%E6%83%85%E5%86%B5"><span class="toc-number">1.6.1.</span> <span class="toc-text">6.1竞争情况</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2%E8%87%AA%E6%97%8B%E9%94%81"><span class="toc-number">1.6.2.</span> <span class="toc-text">6.2自旋锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-3%E9%94%81%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">1.6.3.</span> <span class="toc-text">6.3锁的使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-4%E6%AD%BB%E9%94%81%E5%92%8C%E9%94%81%E6%8E%92%E5%BA%8F"><span class="toc-number">1.6.4.</span> <span class="toc-text">6.4死锁和锁排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-5%E9%94%81%E5%92%8C%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F"><span class="toc-number">1.6.5.</span> <span class="toc-text">6.5锁和中断处理程序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-6%E6%8C%87%E4%BB%A4%E5%92%8C%E5%86%85%E5%AD%98%E6%8E%92%E5%BA%8F"><span class="toc-number">1.6.6.</span> <span class="toc-text">6.6指令和内存排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-7%E7%9D%A1%E7%9C%A0%E9%94%81"><span class="toc-number">1.6.7.</span> <span class="toc-text">6.7睡眠锁</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%83%E7%AB%A0%EF%BC%9A%E8%B0%83%E5%BA%A6"><span class="toc-number">1.7.</span> <span class="toc-text">第七章：调度</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7-1%E5%85%B3%E4%BA%8E%E5%A4%8D%E7%94%A8"><span class="toc-number">1.7.1.</span> <span class="toc-text">7.1关于复用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-2%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2"><span class="toc-number">1.7.2.</span> <span class="toc-text">7.2上下文切换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-3%E8%B0%83%E5%BA%A6%E6%A0%B8%E5%BF%83%E4%BB%A3%E7%A0%81"><span class="toc-number">1.7.3.</span> <span class="toc-text">7.3调度核心代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-4mycpu%E5%92%8Cmyproc"><span class="toc-number">1.7.4.</span> <span class="toc-text">7.4mycpu和myproc</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-5sleep%E5%92%8Cwakeup%E6%9C%BA%E5%88%B6"><span class="toc-number">1.7.5.</span> <span class="toc-text">7.5sleep和wakeup机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-6sleep%E5%92%8Cwakeup%E4%BB%A3%E7%A0%81"><span class="toc-number">1.7.6.</span> <span class="toc-text">7.6sleep和wakeup代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-7%E7%AE%A1%E9%81%93%E4%BB%A3%E7%A0%81"><span class="toc-number">1.7.7.</span> <span class="toc-text">7.7管道代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-8wait%E3%80%81exit%E5%92%8Ckill%E4%BB%A3%E7%A0%81"><span class="toc-number">1.7.8.</span> <span class="toc-text">7.8wait、exit和kill代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E5%85%AB%E7%AB%A0%EF%BC%9A%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.8.</span> <span class="toc-text">第八章：文件系统</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#8-1%E6%A6%82%E8%BF%B0"><span class="toc-number">1.8.1.</span> <span class="toc-text">8.1概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-2Buffer%E7%BC%93%E5%AD%98%E5%B1%82"><span class="toc-number">1.8.2.</span> <span class="toc-text">8.2Buffer缓存层</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-3Logging%E6%97%A5%E5%BF%97%E5%B1%82"><span class="toc-number">1.8.3.</span> <span class="toc-text">8.3Logging日志层</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-4%E5%9D%97%E5%88%86%E9%85%8D%E5%99%A8"><span class="toc-number">1.8.4.</span> <span class="toc-text">8.4块分配器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-5Inode%E5%B1%82"><span class="toc-number">1.8.5.</span> <span class="toc-text">8.5Inode层</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-6%E7%9B%AE%E5%BD%95%E5%B1%82"><span class="toc-number">1.8.6.</span> <span class="toc-text">8.6目录层</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-7%E8%B7%AF%E5%BE%84%E5%91%BD%E5%90%8D%E5%B1%82"><span class="toc-number">1.8.7.</span> <span class="toc-text">8.7路径命名层</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-8%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E5%B1%82"><span class="toc-number">1.8.8.</span> <span class="toc-text">8.8文件描述符层</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-9%E8%A1%A5%E5%85%85"><span class="toc-number">1.8.9.</span> <span class="toc-text">8.9补充</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86%EF%BC%9AXV6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C"><span class="toc-number">2.</span> <span class="toc-text">第二部分：XV6操作系统实验</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Lab-1-Unix-utilities"><span class="toc-number">2.1.</span> <span class="toc-text">Lab 1: Unix utilities</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1Boot-xv6-easy"><span class="toc-number">2.1.1.</span> <span class="toc-text">1.1Boot xv6 (easy)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2sleep-easy"><span class="toc-number">2.1.2.</span> <span class="toc-text">1.2sleep (easy)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3pingpong-easy"><span class="toc-number">2.1.3.</span> <span class="toc-text">1.3pingpong (easy)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4primes-moderate"><span class="toc-number">2.1.4.</span> <span class="toc-text">1.4primes (moderate)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-5find-moderate"><span class="toc-number">2.1.5.</span> <span class="toc-text">1.5find (moderate)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-6xargs-moderate"><span class="toc-number">2.1.6.</span> <span class="toc-text">1.6xargs (moderate)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Lab-2-System-calls"><span class="toc-number">2.2.</span> <span class="toc-text">Lab 2: System calls</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1Tracing-moderate"><span class="toc-number">2.2.1.</span> <span class="toc-text">2.1Tracing (moderate)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-1-1%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%85%A8%E6%B5%81%E7%A8%8B"><span class="toc-number">2.2.1.1.</span> <span class="toc-text">2.1.1系统调用全流程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-1-2Tracing%E4%BB%A3%E7%A0%81"><span class="toc-number">2.2.1.2.</span> <span class="toc-text">2.1.2Tracing代码</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2Sysinfo-moderate"><span class="toc-number">2.2.2.</span> <span class="toc-text">2.2Sysinfo (moderate)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-2-1%E8%8E%B7%E5%8F%96%E7%A9%BA%E9%97%B2%E5%86%85%E5%AD%98"><span class="toc-number">2.2.2.1.</span> <span class="toc-text">2.2.1获取空闲内存</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-2-2%E8%8E%B7%E5%8F%96%E8%BF%90%E8%A1%8C%E7%9A%84%E8%BF%9B%E7%A8%8B%E6%95%B0"><span class="toc-number">2.2.2.2.</span> <span class="toc-text">2.2.2获取运行的进程数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-2-3%E5%AE%9E%E7%8E%B0-sysinfo-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-number">2.2.2.3.</span> <span class="toc-text">2.2.3实现 sysinfo 系统调用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Lab-3-Page-tables"><span class="toc-number">2.3.</span> <span class="toc-text">Lab 3: Page tables</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1Print-a-page-table-easy"><span class="toc-number">2.3.1.</span> <span class="toc-text">3.1Print a page table (easy)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2A-kernel-page-table-per-process-hard"><span class="toc-number">2.3.2.</span> <span class="toc-text">3.2A kernel page table per process (hard)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3-2-1%E5%88%9B%E5%BB%BA%E8%BF%9B%E7%A8%8B%E5%86%85%E6%A0%B8%E9%A1%B5%E8%A1%A8%E4%B8%8E%E5%86%85%E6%A0%B8%E6%A0%88"><span class="toc-number">2.3.2.1.</span> <span class="toc-text">3.2.1创建进程内核页表与内核栈</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-2-2%E5%88%87%E6%8D%A2%E5%88%B0%E8%BF%9B%E7%A8%8B%E5%86%85%E6%A0%B8%E9%A1%B5%E8%A1%A8"><span class="toc-number">2.3.2.2.</span> <span class="toc-text">3.2.2切换到进程内核页表</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-2-3%E9%87%8A%E6%94%BE%E8%BF%9B%E7%A8%8B%E5%86%85%E6%A0%B8%E9%A1%B5%E8%A1%A8"><span class="toc-number">2.3.2.3.</span> <span class="toc-text">3.2.3释放进程内核页表</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3Simplify-copyin-x2F-copyinstr-hard"><span class="toc-number">2.3.3.</span> <span class="toc-text">3.3Simplify copyin&#x2F;copyinstr (hard)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3-3-1%E5%87%86%E5%A4%87%E9%A1%B5%E8%A1%A8%E6%98%A0%E5%B0%84%E8%BD%AC%E6%8D%A2%E7%9A%84%E5%B7%A5%E5%85%B7%E6%96%B9%E6%B3%95"><span class="toc-number">2.3.3.1.</span> <span class="toc-text">3.3.1准备页表映射转换的工具方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-3-2%E5%90%8C%E6%AD%A5%E6%98%A0%E5%B0%84%E7%94%A8%E6%88%B7%E9%A1%B5%E8%A1%A8%E5%92%8C%E7%94%A8%E6%88%B7%E5%86%85%E6%A0%B8%E9%A1%B5%E8%A1%A8"><span class="toc-number">2.3.3.2.</span> <span class="toc-text">3.3.2同步映射用户页表和用户内核页表</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-3-3%E6%9B%BF%E6%8D%A2-copyin%E3%80%81copyinstr-%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.3.3.3.</span> <span class="toc-text">3.3.3替换 copyin、copyinstr 实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Lab-4-Traps"><span class="toc-number">2.4.</span> <span class="toc-text">Lab 4: Traps</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1RISC-V-assembly-easy"><span class="toc-number">2.4.1.</span> <span class="toc-text">4.1RISC-V assembly (easy)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2Backtrace-moderate"><span class="toc-number">2.4.2.</span> <span class="toc-text">4.2Backtrace (moderate)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3Alarm-hard"><span class="toc-number">2.4.3.</span> <span class="toc-text">4.3Alarm (hard)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Lab-5-Lazy-Page-Allocation"><span class="toc-number">2.5.</span> <span class="toc-text">Lab 5: Lazy Page Allocation</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Lab-6-Copy-on-write-fork"><span class="toc-number">2.6.</span> <span class="toc-text">Lab 6: Copy-on-write fork</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-1fork%E6%97%B6%E4%B8%8D%E7%AB%8B%E5%88%BB%E5%A4%8D%E5%88%B6%E5%86%85%E5%AD%98"><span class="toc-number">2.6.1.</span> <span class="toc-text">6.1fork时不立刻复制内存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2%E6%8D%95%E8%8E%B7%E5%86%99%E6%93%8D%E4%BD%9C%E5%B9%B6%E6%89%A7%E8%A1%8C%E5%A4%8D%E5%88%B6"><span class="toc-number">2.6.2.</span> <span class="toc-text">6.2捕获写操作并执行复制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-3%E7%89%A9%E7%90%86%E9%A1%B5%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E4%BB%A5%E5%8F%8A%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0"><span class="toc-number">2.6.3.</span> <span class="toc-text">6.3物理页生命周期以及引用计数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Lab-7-Multithreading"><span class="toc-number">2.7.</span> <span class="toc-text">Lab 7: Multithreading</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7-1Uthread-switching-between-threads-moderate"><span class="toc-number">2.7.1.</span> <span class="toc-text">7.1Uthread: switching between threads (moderate)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-2Using-threads-moderate"><span class="toc-number">2.7.2.</span> <span class="toc-text">7.2Using threads (moderate)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-3Barrier-moderate"><span class="toc-number">2.7.3.</span> <span class="toc-text">7.3Barrier (moderate)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Lab-8-Locks"><span class="toc-number">2.8.</span> <span class="toc-text">Lab 8: Locks</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#8-1Memory-allocator-moderate"><span class="toc-number">2.8.1.</span> <span class="toc-text">8.1Memory allocator (moderate)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#8-1-1%E5%8E%9F%E7%90%86%E4%B8%8E%E5%88%86%E6%9E%90"><span class="toc-number">2.8.1.1.</span> <span class="toc-text">8.1.1原理与分析</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#8-1-2%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.8.1.2.</span> <span class="toc-text">8.1.2代码实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Lab-9-File-Systems"><span class="toc-number">2.9.</span> <span class="toc-text">Lab 9: File Systems</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#9-1Large-files-moderate"><span class="toc-number">2.9.1.</span> <span class="toc-text">9.1Large files (moderate)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#9-1-1%E5%8E%9F%E7%90%86%E4%B8%8E%E5%88%86%E6%9E%90"><span class="toc-number">2.9.1.1.</span> <span class="toc-text">9.1.1原理与分析</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#9-1-2%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.9.1.2.</span> <span class="toc-text">9.1.2代码实现</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-2Symbolic-links-moderate"><span class="toc-number">2.9.2.</span> <span class="toc-text">9.2Symbolic links (moderate)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#9-2-1%E5%8E%9F%E7%90%86%E4%B8%8E%E5%88%86%E6%9E%90"><span class="toc-number">2.9.2.1.</span> <span class="toc-text">9.2.1原理与分析</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#9-2-2%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.9.2.2.</span> <span class="toc-text">9.2.2代码实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Lab-10-Mmap"><span class="toc-number">2.10.</span> <span class="toc-text">Lab 10: Mmap</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#10-1%E5%8E%9F%E7%90%86%E4%B8%8E%E5%88%86%E6%9E%90"><span class="toc-number">2.10.1.</span> <span class="toc-text">10.1原理与分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-2%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.10.2.</span> <span class="toc-text">10.2代码实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Lab-11-Networking"><span class="toc-number">2.11.</span> <span class="toc-text">Lab 11: Networking</span></a></li></ol></li></ol>
      </div>
    
  </span>
</div>

    
    <div class="content index py4 ">
        
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle p-name" itemprop="name headline">
        操作系统源码级剖析
    </h1>



    <div class="meta">
      <span class="author p-author h-card" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span class="p-name" itemprop="name">hulingF</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2023-10-24T03:10:52.022Z" class="dt-published" itemprop="datePublished">2023-10-24</time>
        
      
    </div>


      

      
    <div class="article-tag">
        <i class="fa-solid fa-tag"></i>
        <a class="p-category" href="/tags/XV6/" rel="tag">XV6</a>, <a class="p-category" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="tag">操作系统</a>
    </div>


    </div>
  </header>
  

  <div class="content e-content" itemprop="articleBody">
    <h2 id="第一部分：XV6操作系统简要剖析"><a href="#第一部分：XV6操作系统简要剖析" class="headerlink" title="第一部分：XV6操作系统简要剖析"></a>第一部分：XV6操作系统简要剖析</h2><blockquote>
<p>学习目标：通过学习 MIT 的一套教学操作系统深度了解操作系统的内部简易实现机制，从代码层次更多把握OS 的内部机制，可以作为操作系统的实践部分进行阅读学习！注意：从我个人的角度出发，我不会细抠内部的每一行代码，我想达到的效果是能建立一个 OS 的全局观，打破这个”黑盒子”，但不是制作这个”盒子”，更多还是从 programmer 而不是自始而终的 builder 出发看待问题！</p>
</blockquote>
<h3 id="第一章：操作系统接口"><a href="#第一章：操作系统接口" class="headerlink" title="第一章：操作系统接口"></a>第一章：操作系统接口</h3><p><code>操作系统的作用：</code></p>
<ul>
<li><p>在多个程序之间共享一台计算机，并提供一套比硬件单独支持更有用的服务，操作系统管理和抽象低级硬件，例如，文字处理程序不需要关心使用的何种磁盘硬件。</p>
</li>
<li><p>操作系统在多个程序之间共享硬件，使它们能同时运行（或看起来是同时运行）。</p>
</li>
<li><p>最后，操作系统为程序提供了可控的交互方式，使它们能够共享数据或共同工作。</p>
</li>
</ul>
<p><code>操作系统如何提供上层服务：</code></p>
<p>操作系统通过接口为用户程序提供服务。设计一个好的接口很困难的，一方面，我们希望接口是简单而单一的，因为这样更容易得到正确的实现。另一方面，我们可能会想为应用程序提供许多复杂的功能。解决这种矛盾的诀窍是设计出依靠一些机制的接口，这些机制可以通过组合提高通用性（如管道）。操作系统 xv6 提供了 Ken Thompson 和 Dennis Ritchie 的 Unix 操作系统所介绍的基本接口，同时也模仿了 Unix 的内部设计。</p>
<blockquote>
<p>Unix 提供了一个单一的接口，其机制结合得很好，提供了惊人的通用性。这种接口非常成功，以至于现代操作系统 BSD、Linux、MacOS X、Solaris，甚至微软 Windows 都有类似 Unix 的接口。理解 xv6 是理解这些系统和许多其它系统的一个良好开端。</p>
</blockquote>
<p><code>xv6的简单示意图：</code></p>
<p><img src="/../../../../../../imgs/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%BA%90%E7%A0%81%E7%BA%A7%E5%89%96%E6%9E%90/image-20221114094042087.png" alt="image-20221114094042087"></p>
<p>xv6采用了传统的&#x3D;&#x3D;内核&#x3D;&#x3D;形式，&#x3D;&#x3D;内核是一个特殊程序，可以为其他运行进程提供服务&#x3D;&#x3D;。每个正在运行的程序，称为进程，拥有自己的内存，其中包含指令、数据和堆栈。指令实现了程序的计算，数据是计算的操作对象，栈允许了函数调用。一台计算机通常有许多进程，但只有一个内核。当一个进程需要调用一个内核服务时，它就会调用系统调用，这是操作系统接口中的一个调用。系统调用进入内核，内核执行服务并返回。因此，一个进程在用户空间和内核空间中交替执行。</p>
<blockquote>
<p>内核使用 CPU 提供的硬件保护机制来确保在用户空间中执行的每个进程只能访问其自己的内存。内核运行时拥有硬件特权，可以访问这些受到保护的资源;用户程序执行时没有这些特权。当用户程序调用系统调用(接口)时，硬件提高特权级别并开始执行内核中预先安排的函数。</p>
</blockquote>
<p><code>内核提供的系统调用集合是用户程序看到的接口</code>。xv6 内核提供了传统 Unix 内核所提供的服务和系统调用的一个子集。图 1.2 列出了 xv6 的所有系统调用。</p>
<p><img src="/../../../../../../imgs/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%BA%90%E7%A0%81%E7%BA%A7%E5%89%96%E6%9E%90/image-20221114094612346.png" alt="image-20221114094612346"></p>
<h4 id="1-1进程与内存"><a href="#1-1进程与内存" class="headerlink" title="1.1进程与内存"></a>1.1进程与内存</h4><p>一个 xv6 进程由<code>用户空间内存</code>（指令、数据和堆栈）和<code>内核私有的进程状态</code>组成。xv6的进程共享 cpu，它透明地切换当前 cpu 正在执行的进程，当一个进程暂时不使用 cpu 时，xv6 会保存它的 CPU 寄存器，在下次运行该进程时恢复它们。内核为每个进程关联一个PID(进程标识符)。</p>
<p>我们可以使用 fork 系统调用创建一个新的进程。fork 创建的新进程，称为子进程，其内存内容与调用的进程完全相同，原进程被称为父进程。在父进程和子进程中，fork 都会返回。&#x3D;&#x3D;在父进程中，fork 返回子进程的 PID；在子进程中，fork 返回 0。&#x3D;&#x3D;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> pid = fork();</span><br><span class="line"><span class="keyword">if</span> (pid &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;parent: child=%d\n&quot;</span>, pid);</span><br><span class="line">pid = wait((<span class="type">int</span> *)<span class="number">0</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;child %d is done\n&quot;</span>, pid);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;child: exiting\n&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;fork error\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>exit 系统调用退出调用进程，并释放资源，如内存和打开的文件。exit 需要一个整数状态参数，通常 0 表示成功，1 表示失败。wait 系统调用返回当前进程的一个已退出（或被杀死）的子进程的 PID，并将该子进程的退出状态码复制到一个地址，该地址由 wait 参数提供。<code>如果调用者的子进程都没有退出，则 wait 等待一个子进程退出。如果调用者没有子进程，wait 立即返回-1。如果父进程不关心子进程的退出状态，可以传递一个 0 地址给 wait。</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">parent: child=<span class="number">3884</span></span><br><span class="line">child: exiting</span><br><span class="line">child <span class="number">3884</span> is done</span><br></pre></td></tr></table></figure>

<p>第一行和第二行可能会以任何一种顺序输出，这取决于是父进程还是子进程先执行它的 printf 调用。在子程序退出后，父进程的 wait 返回，父进程执行第三行。</p>
<blockquote>
<p>虽然子进程最初与父进程拥有相同的内存内容，但父进程和子进程是在不同的内存和不同的寄存器中执行的：改变其中一个进程中的变量不会影响另一个进程。例如，当 <strong>wait</strong> 的返回值存储到父进程的 <strong>pid</strong> 变量中时，并不会改变子进程中的变量 <strong>pid</strong>。子进程中的 <strong>pid</strong> 值仍然为零。</p>
</blockquote>
<p><code>exec 系统调用使用新内存映像来替换进程的内存， 新内存映像从文件系统中的文件中进行读取。</code>这个文件必须有特定的格式，它指定了文件中哪部分存放指令，哪部分是数据，在哪条指令开始等等，xv6 使用 ELF 格式。&#x3D;&#x3D;当 exec 成功时，它并不返回到调用程序；相反，从文件中加载的指令在 ELF 头声明的入口点开始执行。&#x3D;&#x3D;exec 需要两个参数：包含可执行文件的文件名和一个字符串参数数组。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *argv[<span class="number">3</span>];</span><br><span class="line">argv[<span class="number">0</span>] = <span class="string">&quot;echo&quot;</span>;</span><br><span class="line">argv[<span class="number">1</span>] = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">argv[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">exec(<span class="string">&quot;/bin/echo&quot;</span>, argv);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;exec error\n&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>说完了fork和exit系统调用，xv6 shell 正是使用上述调用来在用户空间运行程序。shell 的主结构很简单，主循环用 getcmd 读取用户的一行输入，然后调用 fork，创建 shell 副本。父进程调用 wait，而子进程则运行命令。例如，如果用户向 shell 输入了 echo hello，那么就会调用 runcmd，参数为 echo hello。runcmd  运行实际的命令。对于echo hello，它会调用 exec 。如果 exec 成功，那么子进程将执行 echo 程序的指令，而不是 runcmd 的。在某些时候，echo 会调用 exit，这将使父程序从 main中的 wait 返回。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Execute cmd.  Never returns.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">runcmd</span><span class="params">(<span class="keyword">struct</span> cmd *cmd)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> p[<span class="number">2</span>];</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">backcmd</span> *<span class="title">bcmd</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">execcmd</span> *<span class="title">ecmd</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">listcmd</span> *<span class="title">lcmd</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">pipecmd</span> *<span class="title">pcmd</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">redircmd</span> *<span class="title">rcmd</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(cmd == <span class="number">0</span>)</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="comment">// 根据cmd类型选择不同的执行策略</span></span><br><span class="line">  <span class="keyword">switch</span>(cmd-&gt;type)&#123;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    panic(<span class="string">&quot;runcmd&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">case</span> EXEC:</span><br><span class="line">    <span class="comment">// 首先强制转换为execcmd类型</span></span><br><span class="line">    ecmd = (<span class="keyword">struct</span> execcmd*)cmd;</span><br><span class="line">    <span class="comment">// 可执行文件名（argv[0]）不能为空</span></span><br><span class="line">    <span class="keyword">if</span>(ecmd-&gt;argv[<span class="number">0</span>] == <span class="number">0</span>)</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 执行exec系统调用，不会返回</span></span><br><span class="line">    exec(ecmd-&gt;argv[<span class="number">0</span>], ecmd-&gt;argv);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;exec %s failed\n&quot;</span>, ecmd-&gt;argv[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">case</span> REDIR:</span><br><span class="line">    rcmd = (<span class="keyword">struct</span> redircmd*)cmd;</span><br><span class="line">    close(rcmd-&gt;fd);</span><br><span class="line">    <span class="keyword">if</span>(open(rcmd-&gt;file, rcmd-&gt;mode) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;open %s failed\n&quot;</span>, rcmd-&gt;file);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    runcmd(rcmd-&gt;cmd);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">case</span> LIST:</span><br><span class="line">    <span class="comment">// 首先强制转换为listcmd类型</span></span><br><span class="line">    lcmd = (<span class="keyword">struct</span> listcmd*)cmd;</span><br><span class="line">    <span class="comment">// fork子进程优先执行lcmd-&gt;left</span></span><br><span class="line">    <span class="keyword">if</span>(fork1() == <span class="number">0</span>)</span><br><span class="line">      runcmd(lcmd-&gt;left);</span><br><span class="line">    <span class="comment">// 等待子进程执行完lcmd-&gt;left后父进程接着执行lcmd-&gt;right</span></span><br><span class="line">    wait(<span class="number">0</span>);</span><br><span class="line">    runcmd(lcmd-&gt;right);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">case</span> PIPE:</span><br><span class="line">    <span class="comment">// 首先强制转换为pipecmd</span></span><br><span class="line">    pcmd = (<span class="keyword">struct</span> pipecmd*)cmd;</span><br><span class="line">    <span class="comment">// 调用pipe系统调用</span></span><br><span class="line">    <span class="keyword">if</span>(pipe(p) &lt; <span class="number">0</span>)</span><br><span class="line">      panic(<span class="string">&quot;pipe&quot;</span>);</span><br><span class="line">    <span class="comment">// 子进程1标准输出重定向为p[1]即管道文件写端</span></span><br><span class="line">    <span class="keyword">if</span>(fork1() == <span class="number">0</span>)&#123;</span><br><span class="line">      close(<span class="number">1</span>);</span><br><span class="line">      dup(p[<span class="number">1</span>]);</span><br><span class="line">      close(p[<span class="number">0</span>]);</span><br><span class="line">      close(p[<span class="number">1</span>]);</span><br><span class="line">      runcmd(pcmd-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 子进程2标准输入重定向为p[0]即管道文件读端</span></span><br><span class="line">    <span class="keyword">if</span>(fork1() == <span class="number">0</span>)&#123;</span><br><span class="line">      close(<span class="number">0</span>);</span><br><span class="line">      dup(p[<span class="number">0</span>]);</span><br><span class="line">      close(p[<span class="number">0</span>]);</span><br><span class="line">      close(p[<span class="number">1</span>]);</span><br><span class="line">      runcmd(pcmd-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 父进程关闭管道文件描述符并且等待两个子进程的退出</span></span><br><span class="line">    close(p[<span class="number">0</span>]);</span><br><span class="line">    close(p[<span class="number">1</span>]);</span><br><span class="line">    wait(<span class="number">0</span>);</span><br><span class="line">    wait(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">case</span> BACK:</span><br><span class="line">    bcmd = (<span class="keyword">struct</span> backcmd*)cmd;</span><br><span class="line">    <span class="keyword">if</span>(fork1() == <span class="number">0</span>)</span><br><span class="line">      runcmd(bcmd-&gt;cmd);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">getcmd</span><span class="params">(<span class="type">char</span> *buf, <span class="type">int</span> nbuf)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 首先打印shell的“$ ”提示符</span></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;$ &quot;</span>);</span><br><span class="line">  <span class="comment">// 清空缓冲区</span></span><br><span class="line">  <span class="built_in">memset</span>(buf, <span class="number">0</span>, nbuf);</span><br><span class="line">  <span class="comment">// 读取字符到字符缓冲区buf中</span></span><br><span class="line">  gets(buf, nbuf);</span><br><span class="line">  <span class="comment">// 读取到结束位置EOF</span></span><br><span class="line">  <span class="keyword">if</span>(buf[<span class="number">0</span>] == <span class="number">0</span>) </span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">static</span> <span class="type">char</span> buf[<span class="number">100</span>];</span><br><span class="line">  <span class="type">int</span> fd;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Ensure that three file descriptors are open.</span></span><br><span class="line">  <span class="comment">// 确保有三个文件描述符0、1、2</span></span><br><span class="line">  <span class="keyword">while</span>((fd = open(<span class="string">&quot;console&quot;</span>, O_RDWR)) &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(fd &gt;= <span class="number">3</span>)&#123;</span><br><span class="line">      close(fd);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Read and run input commands.</span></span><br><span class="line">  <span class="comment">// 读取并解析允许命令</span></span><br><span class="line">  <span class="keyword">while</span>(getcmd(buf, <span class="keyword">sizeof</span>(buf)) &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">// cd命令比较特殊，由shell进程直接执行</span></span><br><span class="line">    <span class="keyword">if</span>(buf[<span class="number">0</span>] == <span class="string">&#x27;c&#x27;</span> &amp;&amp; buf[<span class="number">1</span>] == <span class="string">&#x27;d&#x27;</span> &amp;&amp; buf[<span class="number">2</span>] == <span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">      <span class="comment">// Chdir must be called by the parent, not the child.</span></span><br><span class="line">      buf[<span class="built_in">strlen</span>(buf)<span class="number">-1</span>] = <span class="number">0</span>;  <span class="comment">// 替换末尾的\n形成一个C风格字符串</span></span><br><span class="line">      <span class="keyword">if</span>(chdir(buf+<span class="number">3</span>) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;cannot cd %s\n&quot;</span>, buf+<span class="number">3</span>);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 子进程执行cmd命令</span></span><br><span class="line">    <span class="keyword">if</span>(fork1() == <span class="number">0</span>)</span><br><span class="line">      runcmd(parsecmd(buf));</span><br><span class="line">    <span class="comment">// shell进程等待子进程结束</span></span><br><span class="line">    wait(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>你可能会奇怪为什么 fork 和 exec 没有结合在一次调用中，我们后面会看到 shell 在实现 I&#x2F;O 重定向时利用了这种分离的特性。为了避免创建相同进程并立即替换它（使用 exec）所带来的浪费，内核通过使用虚拟内存技术（如 copy-on-write）来优化这种用例的 fork 实现。</p>
</blockquote>
<h4 id="1-2I-x2F-O和文件描述符"><a href="#1-2I-x2F-O和文件描述符" class="headerlink" title="1.2I&#x2F;O和文件描述符"></a>1.2I&#x2F;O和文件描述符</h4><p><code>文件描述符是一个小整数，代表一个可由进程读取或写入的内核管理对象。</code>一个进程可以通过打开一个文件、目录、设备，或者通过创建一个管道，或者通过复制一个现有的描述符来获得一个文件描述符。为了简单起见，我们通常将文件描述符所指向的对象称为文件；<code>文件描述符接口将文件、管道和设备之间的差异抽象化，使它们看起来都像字节流。</code>我们把输入和输出称为 I&#x2F;O。</p>
<p>&#x3D;&#x3D;在内部，xv6 内核为每一个进程单独维护一个以文件描述符为索引的表，因此每个进程都有一个从 0 开始的文件描述符私有空间。按照约定，一个进程从文件描述符 0(标准输入)读取数据，向文件描述符 1(标准输出)写入输出，向文件描述符 2(标准错误)写入错误信息。正如我们将看到的那样，shell 利用这个约定来实现 I&#x2F;O 重定向和管道。&#x3D;&#x3D;shell 确保自己总是有三个文件描述符打开，这些文件描述符默认是控制台的文件描述符。</p>
<p>read&#x2F;write 系统调用可以从文件描述符指向的文件读写数据。调用 read(fd, buf, n)从文件描述符 fd 中读取不超过 n 个字节的数据，将它们复制到 buf 中，并返回读取的字节数。每个引用文件的文件描述符都有一个与之相关的偏移量。读取从当前文件偏移量中读取数据，然后按读取的字节数推进偏移量，随后的读取将返回上次读取之后的数据。当没有更多的字节可读时，读返回零表示文件的结束。</p>
<p>write(fd, buf, n)表示将 buf 中的 n 个字节写入文件描述符 fd 中，并返回写入的字节数。若写入字节数小于 n 则该次写入发生错误。和 read 一样，write 在当前文件偏移量处写入数据，然后按写入的字节数将偏移量向前推进，每次写入都从上一次写入的地方开始。</p>
<p>下面的程序片段(程序 cat 的核心代码)将数据从其标准输入复制到其标准输出。如果出现错误，它会向标准错误写入一条消息。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> buf[<span class="number">512</span>];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="keyword">for</span> (;;)</span><br><span class="line">&#123;</span><br><span class="line">    n = read(<span class="number">0</span>, buf, <span class="keyword">sizeof</span> buf);</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;read error\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (write(<span class="number">1</span>, buf, n) != n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;write error\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在这个代码片段中，需要注意的是，cat 不知道它是从文件、控制台还是管道中读取的。同样，cat 也不知道它是在打印到控制台、文件还是其他什么地方。文件描述符的使用和 0代表输入，1 代表输出的约定，使得 cat 可以很容易实现。</p>
</blockquote>
<p>close 系统调用会释放一个文件描述符，使它可以被以后的 open、pipe 或 dup 系统调用所重用（见下文）。&#x3D;&#x3D;新分配的文件描述符总是当前进程中最小的未使用描述符。&#x3D;&#x3D;</p>
<p>文件描述符和fork相互作用，使 I&#x2F;O 重定向易于实现。fork 将父进程的文件描述符表和它的内存一起复制，这样子进程开始时打开的文件和父进程完全一样。<code>系统调用 exec 替换调用进程的内存，但会保留文件描述符表。这种行为允许 shell 通过 fork 实现 I/O 重定向，在子进程中重新打开所选的文件描述符，然后调用 exec 运行新程序。</code>下面是 shell 运行 cat &lt; input.txt 命令的简化版代码。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *argv[<span class="number">2</span>];</span><br><span class="line">argv[<span class="number">0</span>] = <span class="string">&quot;cat&quot;</span>;</span><br><span class="line">argv[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (fork() == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    close(<span class="number">0</span>); <span class="comment">// 释放标准输入的文件描述符</span></span><br><span class="line">    open(<span class="string">&quot;input.txt&quot;</span>, O_RDONLY); <span class="comment">// 这时 input.txt 的文件描述符为 0</span></span><br><span class="line">    <span class="comment">// 即标准输入为 input.txt</span></span><br><span class="line">    exec(<span class="string">&quot;cat&quot;</span>, argv); <span class="comment">// cat 从 0 读取，并输出到 1，见上个代码段</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在子进程关闭文件描述符 0 后，open 保证对新打开的 input.txt 使用该文件描述符 0。因为此时 0 将是最小的可用文件描述符。然后 cat 执行时，文件描述符 0（标准输入）引用input.txt。这不会改变父进程的文件描述符，它只会修改子进程的描述符。</p>
<blockquote>
<p>xv6 shell 中的 I&#x2F;O 重定向代码正是以这种方式工作的。回想一下 shell 的代码，shell 已经 fork 子 shell，runcmd 将调用 exec 来加载新的程序。</p>
</blockquote>
<p>open 的第二个参数由一组用位表示的标志组成，用来控制 open 的工作。可能的值在文件控制(fcntl)头中定义。<code>O_RDONLY</code>, <code>O_WRONLY</code>, <code>O_RDWR</code>, <code>O_CREATE</code>, 和 <code>O_TRUNC</code>, 它们指定 open 打开文件时的功能：读、写、读和写、如果文件不存在创建文件、将文件截断为零。</p>
<blockquote>
<p>现在应该清楚为什么 fork 和 exec 是分开调用的：在这两个调用之间，shell 有机会重定向子进程的 I&#x2F;O，而不干扰父进程的 I&#x2F;O 设置。我们可以假设一个由 fork 和 exec 组成的系统调用 forkexec，但是用这种调用来做 I&#x2F;O 重定向似乎很笨拙：shell 在调用 forkexec 之前修改自己的 I&#x2F;O 设置（然后取消这些修改），或者 forkexec 可以将 I&#x2F;O 重定向的指令作为参数，或者（最糟糕的方案）每个程序（比如 cat）都需要自己做 I&#x2F;O 重定向。</p>
</blockquote>
<p>虽然 fork 复制了文件描述符表，但每个底层文件的偏移量都是父子共享的。想一想下面的代码。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (fork() == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    write(<span class="number">1</span>, <span class="string">&quot;hello &quot;</span>, <span class="number">6</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    wait(<span class="number">0</span>);</span><br><span class="line">    write(<span class="number">1</span>, <span class="string">&quot;world\n&quot;</span>, <span class="number">6</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个片段的最后，文件描述符 1 所引用的文件将包含数据 hello world。父进程中的write（由于有了 wait，只有在子进程完成后才会运行）会从子进程的 write 结束位置开始。&#x3D;&#x3D;这种行为有助于从 shell 命令的序列中产生有序的输出&#x3D;&#x3D;，比如(echo hello; echo world) &gt;output.txt。</p>
<p><code>dup 系统调用复制一个现有的文件描述符，返回一个新的描述符，它指向同一个底层I/O 对象。两个文件描述符共享一个偏移量，就像被 fork 复制的文件描述符一样。</code>这是将hello world 写进文件的另一种方法。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fd = dup(<span class="number">1</span>);</span><br><span class="line">write(<span class="number">1</span>, <span class="string">&quot;hello &quot;</span>, <span class="number">6</span>);</span><br><span class="line">write(fd, <span class="string">&quot;world\n&quot;</span>, <span class="number">6</span>);</span><br></pre></td></tr></table></figure>

<p>如果两个文件描述符是通过一系列的 fork 和 dup 调用从同一个原始文件描述符衍生出来的，那么这两个文件描述符共享一个偏移量。否则，文件描述符不共享偏移量，即使它们是由同一个文件的打开调用产生的。dup 允许 shell 实现这样的命令：ls existing-file non-existing-file &gt; tmp1 2&gt;&amp;1。2&gt;&amp;1 表示 2 是 1 的复制品（dup(1)），即重定向错误信息到标准输出，已存在文件的名称和不存在文件的错误信息都会显示在文件 tmp1 中。</p>
<blockquote>
<p>文件描述符是一个强大的抽象，因为它们隐藏了它们连接的细节：一个向文件描述符写入的进程可能是在向一个文件、控制台等设备或向一个管道写入。</p>
</blockquote>
<h4 id="1-3管道"><a href="#1-3管道" class="headerlink" title="1.3管道"></a>1.3管道</h4><p><code>管道是一个小的内核缓冲区，作为一对文件描述符暴露给进程，一个用于读，一个用于写。</code>将数据写入管道的一端就可以从管道的另一端读取数据。管道为进程提供了一种通信方式。下面的示例代码运行程序 wc，标准输入连接到管道的读取端。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> p[<span class="number">2</span>];</span><br><span class="line"><span class="type">char</span> *argv[<span class="number">2</span>];</span><br><span class="line">argv[<span class="number">0</span>] = <span class="string">&quot;wc&quot;</span>;</span><br><span class="line">argv[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">pipe(p);</span><br><span class="line"><span class="keyword">if</span> (fork() == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    close(<span class="number">0</span>); <span class="comment">// 释放文件描述符 0</span></span><br><span class="line">    dup(p[<span class="number">0</span>]); <span class="comment">// 复制一个 p[0](管道读端)，此时文件描述符 0（标准输入）也引用管道读端，故改变了标准输入。</span></span><br><span class="line">    close(p[<span class="number">0</span>]);</span><br><span class="line">    close(p[<span class="number">1</span>]);</span><br><span class="line">    exec(<span class="string">&quot;/bin/wc&quot;</span>, argv); <span class="comment">// wc 从标准输入读取数据，并写入到参数中的每一个文件</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    close(p[<span class="number">0</span>]);</span><br><span class="line">    write(p[<span class="number">1</span>], <span class="string">&quot;hello world\n&quot;</span>, <span class="number">12</span>);</span><br><span class="line">    close(p[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序调用 pipe，创建一个新的管道，并将读写文件描述符记录在数组 p 中，经过 fork后，父进程和子进程的文件描述符都指向管道。子进程调用 close 和 dup 使文件描述符 0 引用管道的读端，并关闭 p 中的文件描述符，并调用 exec 运行 wc。当 wc 从其标准输入端读取时，它将从管道中读取。父进程关闭管道的读端，向管道写入，然后关闭写端。</p>
<blockquote>
<p>如果没有数据可用，管道上的 read 会等待数据被写入，或者等待所有指向写端的文件描述符被关闭；在后一种情况下，读将返回 0，就像数据文件的结束一样。事实上，如果没有数据写入，读会无限阻塞，直到新数据不可能到达为止（写端被关闭），这也是子进程在执行上面的 wc 之前关闭管道的写端很重要的一个原因：如果 wc 的一个文件描述符仍然引用了管道的写端，那么 wc 将永远看不到文件的关闭（被自己阻塞）。</p>
</blockquote>
<p>xv6 的 shell 实现了管道，如<code>grep fork sh.c | wc -l</code>，shell 的实现类似于上面的代码。执行 shell 的子进程创建一个管道来连接管道的左端和右端，然后它在管道左端（写入端）和右端（读取端）调用fork和 runcmd，并等待两者的完成。管道的右端（读取端）可以是一个命令，也可以是包含管道的多个命令（例如，a | b | c），它又会分叉为两个新的子进程（一个是 b，一个是 c）。<code>因此，shell 可以创建一棵进程树。这棵树的叶子是命令，内部（非叶子）节点是等待左右子进程完成的进程。</code></p>
<p>管道似乎没有比临时文件拥有更多的功能：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo hello world | wc</span><br></pre></td></tr></table></figure>

<p>不使用管道：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo hello world &gt;/tmp/xyz; wc &lt;/tmp/xyz</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在这种情况下，管道比临时文件至少有四个优势。首先，管道会自动清理自己；如果是文件重定向，shell 在完成后必须小心翼翼地删除&#x2F;tmp&#x2F;xyz。第二，管道可以传递任意长的数据流，而文件重定向则需要磁盘上有足够的空闲空间来存储所有数据。第三，管道可以分阶段的并行执行，而文件方式则需要在第二个程序开始之前完成第一个程序。第四，如果你要实现进程间的通信，管道阻塞读写比文件的非阻塞语义更有效率。</p>
</blockquote>
<h4 id="1-4文件系统"><a href="#1-4文件系统" class="headerlink" title="1.4文件系统"></a>1.4文件系统</h4><p>&#x3D;&#x3D;xv6 文件系统包含了数据文件（拥有字节数组）和目录（拥有对数据文件和其他目录的命名引用）。这些目录形成一棵树，从一个被称为根目录的特殊目录开始。&#x3D;&#x3D;像&#x2F;a&#x2F;b&#x2F;c 这样的路径指的是根目录&#x2F;中的 a 目录中的 b 目录中的名为 c 的文件或目录。不以&#x2F;开头的路径是相对于调用进程的当前目录进行计算其绝对位置的，可以<code>通过 chdir 系统调用来改变进程的当前目录</code>。下面两个 open 打开了同一个文件（假设所有涉及的目录都存在）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">chdir(<span class="string">&quot;/a&quot;</span>);</span><br><span class="line">chdir(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">open(<span class="string">&quot;c&quot;</span>, O_RDONLY);</span><br><span class="line">open(<span class="string">&quot;/a/b/c&quot;</span>, O_RDONLY);</span><br></pre></td></tr></table></figure>

<p>有一些系统调用来可以创建新的文件和目录：mkdir 创建一个新的目录，用open配合O_CREATE标志创建并打开一个新的数据文件，以及 mknod 创建一个新的设备文件。这个例子说明了这两个系统调用的使用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir(<span class="string">&quot;/dir&quot;</span>);</span><br><span class="line">fd = open(<span class="string">&quot;/dir/file&quot;</span>, O_CREATE | O_WRONLY);</span><br><span class="line">close(fd);</span><br><span class="line">mknod(<span class="string">&quot;/console&quot;</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>mknod</strong> 创建了一个引用设备的特殊文件。与设备文件相关联的是主设备号和次设备号(<strong>mknod</strong> 的两个参数)，它们唯一地标识一个内核设备。当一个进程打开设备文件后，内核会将系统的读写调用转移到内核设备实现上，而不是将它们传递给文件系统。</p>
</blockquote>
<p>文件名称与文件是不同的；底层文件（非磁盘上的文件）被称为 inode，一个 inode 可以有多个名称，称为链接。每个链接由目录中的一个项组成：该项包含一个文件名和对 inode的引用。inode 保存着一个文件的 metadata（元数据），包括它的类型（文件或目录或设备），它的长度，文件内容在磁盘上的位置，以及文件的链接数量。</p>
<p><code>fstat</code>系统调用从文件描述符引用的 inode 中检索信息。它定义在 stat.h的 stat 结构中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> T_DIR 1 <span class="comment">// Directory</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> T_FILE 2 <span class="comment">// File</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> T_DEVICE 3 <span class="comment">// Device</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">int</span> dev; <span class="comment">// File system’s disk device</span></span><br><span class="line">uint ino; <span class="comment">// Inode number</span></span><br><span class="line"><span class="type">short</span> type; <span class="comment">// Type of file</span></span><br><span class="line"><span class="type">short</span> nlink; <span class="comment">// Number of links to file</span></span><br><span class="line">uint64 size; <span class="comment">// Size of file in bytes</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>link</code>系统调用创建了一个引用了同一个 inode 的文件（文件名）。下面的片段创建了引用了同一个 inode 两个文件 a 和 b。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">open(<span class="string">&quot;a&quot;</span>, O_CREATE | O_WRONLY);</span><br><span class="line">link(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>读写 a 与读写 b 是一样的，每个 inode 都有一个唯一的 inode 号来标识。经过上面的代码序列后，可以通过检查 fstat 的结果来确定 a 和 b 指的是同一个底层内容：两者将返回相同的 inode 号（ino），并且 nlink 计数为 2。</p>
<p>inode 是 linux 和类 unix 操作系统用来储存除了文件名和实际数据的数据结构，它是用来连接实际数据和文件名的。</p>
</blockquote>
<p><code>unlink</code>系统调用会从文件系统中删除一个文件名。只有当文件的链接数为零且没有文件描述符引用它时，文件的 inode 和存放其内容的磁盘空间才会被释放。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unlink(<span class="string">&quot;a&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>上面这行代码会删除 a，此时只有 b 会引用 inode。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fd = open(<span class="string">&quot;/tmp/xyz&quot;</span>, O_CREATE | O_RDWR);</span><br><span class="line">unlink(<span class="string">&quot;/tmp/xyz&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>这段代码是创建一个临时文件的一种惯用方式，它创建了一个无名称 inode，故会在进程关闭 fd 或者退出时删除文件。</p>
<p>unix 提供了 shell 可调用的文件操作程序，作为用户级程序，例如 mkdir、ln 和 rm。这种设计允许任何人通过添加新的用户级程序来扩展命令行接口。现在看来，这个设计似乎是显而易见的，但在 Unix 时期设计的其他系统通常将这类命令内置到 shell 中（并将 shell 内置到内核中）。</p>
<blockquote>
<p>本文研究的是 xv6 如何实现其类似 Unix 的接口，但其思想和概念不仅仅适用于 Unix。任何操作系统都必须将进程复用到底层硬件上，将进程相互隔离，并提供受控进程间通信的机制。在学习了 xv6 之后，您应该能够研究其他更复杂的操作系统，并在这些系统中看到 xv6的基本概念。</p>
</blockquote>
<h3 id="第二章：操作系统组织"><a href="#第二章：操作系统组织" class="headerlink" title="第二章：操作系统组织"></a>第二章：操作系统组织</h3><p>操作系统的一个关键要求是同时支持多个进程。例如，使用第1章中描述的系统调用接口，一个进程可以用fork创建新进程。操作系统必须在这些进程之间分时共享计算机的资源。例如，即使进程的数量多于硬件CPU的数量，操作系统也必须保证所有的进程都有机会执行。操作系统还必须安排进程之间的隔离，也就是说，如果一个进程出现了 bug 并发生了故障，不应该影响不依赖 bug 进程的进程。然而，隔离性太强了也不可取，因为进程间可能需要进行交互，例如管道。因此，一个操作系统必须满足三个要求：<code>多路复用</code>、<code>隔离</code>和<code>交互</code>。</p>
<p>&#x3D;&#x3D;xv6 运行在多核RISC-V 微处理器上，它的许多底层功能（例如它的进程实现）是 RISC-V 所特有的。RISC-V 是一个 64 位的 CPU，xv6 是用 “LP64 “C 语言编写的，这意味着 C 编程语言中的 long(L)和指针(P)是 64 位的，但 int 是 32 位的。&#x3D;&#x3D;</p>
<p>一台完整的计算机中的 CPU 周围都是硬件，其中大部分是 I&#x2F;O 接口的形式。xv6 编写的代码是基于通过”-machine virt “选项的 qemu，这包括 RAM、包含启动代码的 ROM、与用户键盘&#x2F;屏幕的串行连接以及用于存储的磁盘。</p>
<h4 id="2-1抽象物理资源"><a href="#2-1抽象物理资源" class="headerlink" title="2.1抽象物理资源"></a>2.1抽象物理资源</h4><p>遇到一个操作系统，人们可能会问的第一个问题是为什么需要它呢？答案是，我们可以把图 1.2 中的系统调用作为一个库来实现，应用程序与之连接。在这个想法中，每个应用程序可以根据自己的需要定制自己的库。应用程序可以直接与硬件资源进行交互，并以最适合应用程序的方式使用这些资源（例如，实现高性能）。一些用于嵌入式设备或实时系统的操作系统就是以这种方式组织的。</p>
<p><code>这种系统库方式的缺点是，如果有多个应用程序在运行，这些应用程序必须正确执行。</code>例如，每个应用程序必须定期放弃 CPU，以便其他应用程序能够运行。如果所有的应用程序都相互信任并且没有 bug，这样的协作分时方案可能是 OK 的。<code>更典型的情况是，应用程序之间互不信任，并且有 bug，所以人们通常希望比协作方案提供更强的隔离性。</code></p>
<p><code>为了实现强隔离，禁止应用程序直接访问敏感的硬件资源，而将资源抽象为服务是很有帮助的。</code>例如，Unix 应用程序只通过文件系统的open、read、write 和 close系统调用与文件系统进行交互，而不是直接读写磁盘。这为应用程序带来了路径名的便利，而且它允许操作系统（作为接口的实现者）管理磁盘。即使不考虑隔离问题，那些有意交互的程序（或者只是希望互不干扰）很可能会发现文件系统是一个比直接使用磁盘更方便的抽象。</p>
<p><code>同样，Unix在进程之间透明地切换硬件CPU，必要时保存和恢复寄存器状态，这样应用程序就不必意识到时间共享。这种透明性允许操作系统共享CPU，即使一些应用程序处于无限循环中。</code></p>
<p>另一个例子是，Unix 进程使用 exec 来建立它们的内存映像，而不是直接与物理内存交互。这使得操作系统可以决定将进程放在内存的什么位置；如果内存紧张，操作系统甚至可能将进程的部分数据存储在磁盘上。exec 还允许用户将可执行文件储存在文件系统中。</p>
<p>&#x3D;&#x3D;Unix 进程之间的许多形式的交互都是通过文件描述符进行的。文件描述符不仅可以抽象出许多细节（例如，管道或文件中的数据存储在哪里），而且它们的定义方式也可以简化交互。例如，如果管道中的一个应用程序崩溃了，内核就会为管道中的另一个进程产生一个文件结束信号。&#x3D;&#x3D;</p>
<blockquote>
<p>图 1.2 中的系统调用接口经过精心设计，既为程序员提供了便利，又提供了强隔离的可能。Unix 接口并不是抽象资源的唯一方式，但事实证明它是一种非常好的方式。</p>
</blockquote>
<h4 id="2-2模式变换与系统调用"><a href="#2-2模式变换与系统调用" class="headerlink" title="2.2模式变换与系统调用"></a>2.2模式变换与系统调用</h4><p>强隔离要求应用程序和操作系统之间有一个分界线。如果应用程序发生错误，我们不希望操作系统崩溃，也不希望其他应用程序崩溃。相反，操作系统应该能够清理崩溃的应用程序并继续运行其他应用程序。为了实现强隔离，操作系统必须安排应用程序不能修改（甚至不能读取）操作系统的数据结构和指令，应用程序不能访问其他进程的内存。</p>
<p><code>CPU 提供了强隔离的硬件支持。</code>例如，RISC-V 有三种CPU指令执行模式：（machine）机器模式、监督者（supervisor）模式和（user）用户模式。<code>在机器模式下执行的指令具有完全的权限，一个 CPU 在机器模式下启动。机器模式主要用于配置计算机。xv6 会在机器模式下执行几条指令，然后转为监督者模式。</code></p>
<p><code>在监督者模式下，CPU 被允许执行特权指令：例如，启用和禁用中断，读写保存页表地址的寄存器等。如果用户模式下的应用程序试图执行一条特权指令，CPU不会执行该指令，而是切换到监督者模式，这样监督者模式的代码就可以终止应用程序，因为它做了不该做的事情。</code>第 1 章的图 1.1 说明了这种组织方式。一个应用程序只能执行用户模式的指令（如数字相加等），被称为运行在用户空间，而处于监督者模式的软件也可以执行特权指令，被称为运行在内核空间。运行在内核空间（或监督者模式）的软件称为内核。</p>
<p><code>一个应用程序如果要调用内核函数（如xv6中的read系统调用），必须过渡到内核。CPU提供了一个特殊的指令，可以将CPU从用户模式切换到监督者模式，并在内核指定的入口处进入内核。(RISC-V 为此提供了 ecall 指令。)</code>一旦 CPU 切换到监督者模式，内核就可以验证系统调用的参数，决定是否允许应用程序执行请求的操作，然后拒绝或执行该操作。内核控制监督者模式的入口点是很重要的；如果应用程序可以决定内核的入口点，那么恶意应用程序就能够进入内核，例如，通过跳过参数验证而进入内核。</p>
<h4 id="2-3内核组织"><a href="#2-3内核组织" class="headerlink" title="2.3内核组织"></a>2.3内核组织</h4><p>&#x3D;&#x3D;一个关键的设计问题是操作系统的哪一部分应该在监督者模式下运行。一种可能是整个操作系统驻留在内核中，这样所有系统调用的实现都在监督者模式下运行。这种组织方式称为宏内核。&#x3D;&#x3D;</p>
<p>在这种组织方式中，整个操作系统以全硬件权限运行。这种组织方式很方便，因为操作系统设计者不必决定操作系统的哪一部分不需要全硬件权限。此外，操作系统的不同部分更容易合作。例如，一个操作系统可能有一个缓冲区，缓存文件系统和虚拟内存系统共享的数据。</p>
<p>宏内核组织方式的一个缺点是操作系统的不同部分之间的接口通常是复杂的（我们将在本文的其余部分看到），因此操作系统开发者很容易写 bug。在宏内核中，一个错误是致命的，因为监督者模式下的错误往往会导致内核崩溃。如果内核崩溃，计算机就会停止工作，因此所有的应用程序也会崩溃。计算机必须重启。</p>
<p>&#x3D;&#x3D;为了降低内核出错的风险，操作系统设计者可以尽量减少在监督者模式下运行的操作系统代码量，而在用户模式下执行操作系统的大部分代码。这种内核组织方式称为微内核。&#x3D;&#x3D;</p>
<p><img src="/../../../../../../imgs/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%BA%90%E7%A0%81%E7%BA%A7%E5%89%96%E6%9E%90/image-20221114141151380.png" alt="image-20221114141151380"></p>
<p>图 2.1 说明了这种微内核设计。在图中，文件系统作为一个用户级进程运行。作为进程运行的 OS 服务称为服务器。为了让应用程序与文件服务器进行交互，内核提供了一种进程间通信机制，用于从一个用户模式进程向另一个进程发送消息。例如，如果一个像 shell 这样的应用程序想要读写文件，它就会向文件服务器发送一个消息，并等待响应。</p>
<p><code>在微内核中，内核接口由一些低级函数组成，用于启动应用程序、发送消息、访问设备硬件等。这种组织方式使得内核相对简单，因为大部分操作系统驻留在用户级服务器中。</code></p>
<p>&#x3D;&#x3D;xv6 和大多数 Unix 操作系统一样，是以宏内核的形式实现的。因此，xv6 内核接口与操作系统接口相对应，内核实现了完整的操作系统。由于 xv6 不提供很多服务，所以它的内核比一些微内核要小，但从概念上讲 xv6 是宏内核。&#x3D;&#x3D;</p>
<h4 id="2-4xv6代码组织形式"><a href="#2-4xv6代码组织形式" class="headerlink" title="2.4xv6代码组织形式"></a>2.4xv6代码组织形式</h4><p>xv6 内核源码在 <code>kernel</code> 目录下。按照模块化的概念，源码被分成了多个文件，下表列出了这些文件。模块间的接口在 <code>defs.h(kernel/defs.h)</code> 中定义。</p>
<table>
<thead>
<tr>
<th>File</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>bio.c</td>
<td>Disk block cache for the file system</td>
</tr>
<tr>
<td>console.c</td>
<td>Connect to the user keyboard and screen</td>
</tr>
<tr>
<td>entry.S</td>
<td>Very first boot instructions</td>
</tr>
<tr>
<td>exec.c</td>
<td>exec() system call</td>
</tr>
<tr>
<td>file.c</td>
<td>File descriptor support</td>
</tr>
<tr>
<td>fs.c</td>
<td>File system</td>
</tr>
<tr>
<td>kalloc.c</td>
<td>Physical page allocator</td>
</tr>
<tr>
<td>kernelvec.S</td>
<td>Handle traps from kernel, and timer interrupts</td>
</tr>
<tr>
<td>log.c</td>
<td>File system logging and crash recovery</td>
</tr>
<tr>
<td>pipe.c</td>
<td>Pipes</td>
</tr>
<tr>
<td>plic.c</td>
<td>RISC-V interrupt controller</td>
</tr>
<tr>
<td>printf.c</td>
<td>Formatted output to the console</td>
</tr>
<tr>
<td>proc.c</td>
<td>Processes and scheduling</td>
</tr>
<tr>
<td>sleeplock.c</td>
<td>Locks that yield the CPU</td>
</tr>
<tr>
<td>spinlock.c</td>
<td>Locks that don’t yield the CPU</td>
</tr>
<tr>
<td>start.c</td>
<td>Early machine-mode boot code</td>
</tr>
<tr>
<td>string.c</td>
<td>C string and byte-array library</td>
</tr>
<tr>
<td>swtch.S</td>
<td>Thread switching</td>
</tr>
<tr>
<td>syscall.c</td>
<td>Dispatch sysytem calls to handling function</td>
</tr>
<tr>
<td>sysfile.c</td>
<td>File-related system calls</td>
</tr>
<tr>
<td>sysproc.c</td>
<td>Process-related system calls</td>
</tr>
<tr>
<td>trampoline.S</td>
<td>Assembly code to switch between user and kernel</td>
</tr>
<tr>
<td>trap.c</td>
<td>C code to handle and return from traps and interrupt</td>
</tr>
<tr>
<td>uart.c</td>
<td>Serial-port console device driver</td>
</tr>
<tr>
<td>virtio_disk.c</td>
<td>Disk device driver</td>
</tr>
<tr>
<td>vm.c</td>
<td>Manage page tables and address spaces</td>
</tr>
</tbody></table>
<h4 id="2-5进程概述"><a href="#2-5进程概述" class="headerlink" title="2.5进程概述"></a>2.5进程概述</h4><p>xv6 中的隔离单位（和其他 Unix 操作系统一样）是一个进程。进程抽象可以防止一个进程破坏或监视另一个进程的内存、CPU、文件描述符等。它还可以防止进程破坏内核，所以进程不能破坏内核的隔离机制。内核必须小心翼翼地实现进程抽象，因为一个错误或恶意的应用程序可能会欺骗内核或硬件做一些不好的事情（例如，规避隔离）。<code>内核用来实现进程的机制包括：用户/监督模式标志、地址空间和线程的时间分割。</code></p>
<p>&#x3D;&#x3D;为了帮助实施隔离，进程抽象为程序提供了一种错觉，即它有自己的私有机器。一个进程为程序提供了一个看似私有的内存系统，或者说是地址空间，其他进程不能对其进行读写。进程还为程序提供了“私有”的 CPU，用来执行程序的指令。&#x3D;&#x3D;</p>
<p>xv6 使用<code>页表</code>（由硬件实现）给每个进程提供自己的地址空间。RISC-V 页表将<code>虚拟地址</code>(RISC-V 指令操作的地址)转换(或 “映射”)为<code>物理地址</code>(CPU 芯片发送到主存储器的地址)。</p>
<p><img src="/../../../../../../imgs/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%BA%90%E7%A0%81%E7%BA%A7%E5%89%96%E6%9E%90/image-20221114141810611.png" alt="image-20221114141810611"></p>
<p>xv6 为每个进程维护一个单独的页表，定义该进程的地址空间。如图 2.3 所示，进程的用户空间内存的地址空间从虚拟地址 0 开始的。指令存放在最前面，其次是全局变量，然后是栈，最后是一个堆区（用于malloc），进程可以根据需要扩展。有一些因素限制了进程地址空间的最大长度：<code>RISC-V 上的指针是 64 位宽；硬件在页表中查找虚拟地址时只使用低39 位；xv6 只使用 39 位中的 38 位</code>。因此，最大地址是 2^38^ -1 &#x3D; 0x3fffffffff，也就是 <code>MAXVA</code>。&#x3D;&#x3D;在地址空间的顶端，xv6 保留了一页，用于 trampoline 和映射进程 trapframe 的页，以便切换到内核。&#x3D;&#x3D;</p>
<p>xv6 内核为每个进程维护了许多状态，它将这些状态保存在 proc 结构体中。一个进程最重要的内核状态是它的页表、内核栈和运行状态。我们用 p-&gt;xx 来表示 proc 结构的元素，例如，p-&gt;pagetable 是指向进程页表的指针。</p>
<p>每个进程都有一个执行线程（简称线程），执行进程的指令。一个线程可以被暂停，然后再恢复。为了在进程之间透明地切换，内核会暂停当前运行的线程，并恢复另一个进程的线程。线程的大部分状态（局部变量、函数调用返回地址）都存储在线程的栈中。<code>每个进程有两个栈：用户栈和内核栈（p-&gt;kstack）。当进程在执行用户指令时，只有它的用户栈在使用，而它的内核栈是空的。当进程进入内核时（为了系统调用或中断），内核代码在进程的内核栈上执行；当进程在内核中时，它的用户栈仍然包含保存的数据，但不被主动使用。</code>进程的线程在用户栈和内核栈中交替执行。内核栈是独立的（并且受到保护，不受用户代码的影响），所以即使一个进程用户栈被破坏了，内核也可以执行。</p>
<p>一个进程可以通过执行 RISC-V <code>ecall</code> 指令进行系统调用。&#x3D;&#x3D;该指令提高硬件权限级别，并将程序计数器改变为内核定义的入口点。&#x3D;&#x3D;入口点的代码会切换到内核栈，并执行实现系统调用的内核指令。当系统调用完成后<code>内核切换回用户栈</code>，并通过调用 <code>sret</code> 指令&#x3D;&#x3D;返回用户空间，降低硬件特权级别，恢复执行系统调用前的用户指令&#x3D;&#x3D;。进程的线程可以在内核中阻塞等待 I&#x2F;O，当 I&#x2F;O 完成后，再从离开的地方恢复。</p>
<p>p-&gt;state 表示进程是创建、就绪、运行、等待，还是退出。p-&gt;pagetable 以 RISC-V 硬件需要的格式保存进程的页表，当进程在用户空间执行时，xv6 使分页硬件使用进程页表。进程页表也会记录分配给该进程内存的物理页地址。</p>
<h4 id="2-6xv6启动流程"><a href="#2-6xv6启动流程" class="headerlink" title="2.6xv6启动流程"></a>2.6xv6启动流程</h4><p>当 RISC-V 计算机开机时，它会初始化自己，并运行一个存储在只读存储器中的boot loader。Boot loader 将 xv6 内核加载到内存中。然后，在机器模式下，CPU 从 _entry开始执行 xv6。RISC-V 在禁用分页硬件的情况下启动：虚拟地址直接映射到物理地址。</p>
<p>loader 将 xv6 内核加载到物理地址 <code>0x80000000</code> 的内存中，之所以将内核放在0x80000000 而不是 0x0，是因为地址范围 0x0-0x80000000 包含 I&#x2F;O 设备。</p>
<p>_entry 处的指令设置了一个内核栈 ， 这样 xv6 就可以运行 C 代 码 。xv6 在文件start.c中声明了初始栈的空间即stack0。在_entry 处的代码<code>加载栈指针寄存器sp，地址为 stack0+4096，也就是栈的顶部，因为 RISC-V 的栈是向下扩张的</code>。现在内核就拥有了栈，_entry 调用 start，并执行其 C 代码。</p>
<p>函数 start 执行一些只有在机器模式下才允许的配置，然后切换到监督者模式。为了进入监督者模式，RISC-V 提供了指令 <code>mret</code>。这条指令最常用来从上一次的调用中返回，上一次调用从监督者模式到机器模式。&#x3D;&#x3D;start 并不是从这样的调用中返回，而是把事情设置得像有过这样的调用一样：它在寄存器 mstatus 中把上一次的特权模式设置为监督者模式，它把 main 的地址写入寄存器 mepc 中，把返回地址设置为 main 函数的地址，在机器模式中把 0 写入页表寄存器 satp 中，禁用虚拟地址转换，并把所有中断和异常委托给监督者模式。&#x3D;&#x3D;</p>
<p>在进入特权者模式之前，start 还要执行一项任务：<code>对时钟芯片进行编程以初始化定时器中断</code>。在完成了这些基本管理后，start 通过调用 mret 返回到监督者模式，这将导致程序计数器变为 main的地址。</p>
<p>在 main 初始化几个设备和子系统后 ， 它通过调用 userinit 来创建第一个进程。<code>第一个进程执行一个用 RISC-V 汇编编写的小程序 initcode.S，它通过调用 exec 系统调用重新进入内核。</code>正如我们在第一章中所看到的，exec 用一个新的程序（本例中是&#x2F;init）替换当前进程的内存和寄存器。一旦内核完成 exec，它就会在&#x2F;init 进程中返回到用户空间。init 在需要时会创建一个新的控制台设备文件，然后以文件描述符 0、1 和 2 的形式打开它。然后它在控制台上启动一个 shell。这样系统就启动了。</p>
<p><code>entry.S</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">	# qemu -kernel loads the kernel at 0x80000000</span><br><span class="line">        # and causes each CPU to jump there.</span><br><span class="line">        # kernel.ld causes the following code to</span><br><span class="line">        # be placed at 0x80000000.</span><br><span class="line">.section .text</span><br><span class="line">_entry:</span><br><span class="line">	# set up a stack for C.</span><br><span class="line">        # stack0 is declared in start.c,</span><br><span class="line">        # with a 4096-byte stack per CPU.</span><br><span class="line">        # sp = stack0 + (hartid * 4096)</span><br><span class="line">        # stack0作为CPU栈的基地址</span><br><span class="line">        la sp, stack0 </span><br><span class="line">        # 把 4096 这个立即数读到 a0 寄存器中</span><br><span class="line">        li a0, 1024*4</span><br><span class="line">        # 把当前 CPU 的 ID 读到 a1 寄存器中</span><br><span class="line">	csrr a1, mhartid</span><br><span class="line">        # cpuid从0开始，注意CPU初始栈大小都是4096byte，且栈向下生长</span><br><span class="line">        addi a1, a1, 1</span><br><span class="line">        # 计算当前CPU栈的偏移地址</span><br><span class="line">        mul a0, a0, a1</span><br><span class="line">        # 算出栈顶地址（栈向下生长）并且放到 sp 寄存器中</span><br><span class="line">        add sp, sp, a0</span><br><span class="line">	# jump to start() in start.c</span><br><span class="line">        call start</span><br><span class="line">spin:</span><br><span class="line">        j spin</span><br></pre></td></tr></table></figure>

<p><code>start.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;param.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;memlayout.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;riscv.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;defs.h&quot;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">timerinit</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">// entry.S needs one stack per CPU.</span></span><br><span class="line"><span class="comment">// 定义了 entry.S 中的 stack0 ，它要求 16bit 对齐</span></span><br><span class="line">__attribute__ ((aligned (<span class="number">16</span>))) <span class="type">char</span> stack0[<span class="number">4096</span> * NCPU];</span><br><span class="line"><span class="comment">// scratch area for timer interrupt, one per CPU.</span></span><br><span class="line"><span class="comment">// 定义了共享变量，即每个 CPU 的暂存区用于 machine-mode 定时器中断，它是和 timer 驱动之间传递数据用的。</span></span><br><span class="line">uint64 mscratch0[NCPU * <span class="number">32</span>];</span><br><span class="line"><span class="comment">// assembly code in kernelvec.S for machine-mode timer interrupt.</span></span><br><span class="line"><span class="comment">// 声明了 timer 中断处理函数，在接下来的 timer 初始化函数中被用到</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">timervec</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">// entry.S jumps here in machine mode on stack0.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">start</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// set M Previous Privilege mode to Supervisor, for mret.</span></span><br><span class="line">  <span class="comment">// 使 CPU 进入 supervisor mode </span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> x = r_mstatus();</span><br><span class="line">  x &amp;= ~MSTATUS_MPP_MASK;</span><br><span class="line">  x |= MSTATUS_MPP_S;</span><br><span class="line">  w_mstatus(x);</span><br><span class="line">  <span class="comment">// set M Exception Program Counter to main, for mret.</span></span><br><span class="line">  <span class="comment">// requires gcc -mcmodel=medany</span></span><br><span class="line">  <span class="comment">// 设置了汇编指令 mret 后 PC 指针跳转的函数，也就是 main 函数</span></span><br><span class="line">  w_mepc((uint64)main);</span><br><span class="line">  <span class="comment">// disable paging for now.</span></span><br><span class="line">  <span class="comment">// 暂时关闭了分页功能，即直接使用物理地址</span></span><br><span class="line">  w_satp(<span class="number">0</span>);</span><br><span class="line">  <span class="comment">// delegate all interrupts and exceptions to supervisor mode.</span></span><br><span class="line">  <span class="comment">// 将所有中断异常处理设定在给 supervisor mode 下</span></span><br><span class="line">  w_medeleg(<span class="number">0xffff</span>);</span><br><span class="line">  w_mideleg(<span class="number">0xffff</span>);</span><br><span class="line">  <span class="comment">// External Interupt | Software Interupt | Timer Interupt</span></span><br><span class="line">  w_sie(r_sie() | SIE_SEIE | SIE_STIE | SIE_SSIE);</span><br><span class="line">  <span class="comment">// ask for clock interrupts.</span></span><br><span class="line">  <span class="comment">// 请求时钟中断，也就是 clock 的初始化</span></span><br><span class="line">  timerinit();</span><br><span class="line">  <span class="comment">// keep each CPU&#x27;s hartid in its tp register, for cpuid().</span></span><br><span class="line">  <span class="comment">// 将 CPU 的 ID 值保存在寄存器 tp 中</span></span><br><span class="line">  <span class="type">int</span> id = r_mhartid();</span><br><span class="line">  w_tp(id);</span><br><span class="line">  <span class="comment">// switch to supervisor mode and jump to main().</span></span><br><span class="line">  <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;mret&quot;</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// set up to receive timer interrupts in machine mode,</span></span><br><span class="line"><span class="comment">// which arrive at timervec in kernelvec.S,</span></span><br><span class="line"><span class="comment">// which turns them into software interrupts for</span></span><br><span class="line"><span class="comment">// devintr() in trap.c.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">timerinit</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// each CPU has a separate source of timer interrupts.</span></span><br><span class="line">  <span class="comment">// 首先读出 CPU 的 ID</span></span><br><span class="line">  <span class="type">int</span> id = r_mhartid();</span><br><span class="line">  <span class="comment">// ask the CLINT for a timer interrupt.</span></span><br><span class="line">  <span class="comment">// 设置中断时间间隔，这里设置的是 0.1 秒</span></span><br><span class="line">  <span class="type">int</span> interval = <span class="number">1000000</span>; <span class="comment">// cycles; about 1/10th second in qemu.</span></span><br><span class="line">  *(uint64*)CLINT_MTIMECMP(id) = *(uint64*)CLINT_MTIME + interval;</span><br><span class="line">  <span class="comment">// prepare information in scratch[] for timervec.</span></span><br><span class="line">  <span class="comment">// scratch[0..3] : space for timervec to save registers.</span></span><br><span class="line">  <span class="comment">// scratch[4] : address of CLINT MTIMECMP register.</span></span><br><span class="line">  <span class="comment">// scratch[5] : desired interval (in cycles) between timer interrupts.</span></span><br><span class="line">  uint64 *scratch = &amp;mscratch0[<span class="number">32</span> * id];</span><br><span class="line">  scratch[<span class="number">4</span>] = CLINT_MTIMECMP(id);</span><br><span class="line">  scratch[<span class="number">5</span>] = interval;</span><br><span class="line">  w_mscratch((uint64)scratch);</span><br><span class="line">  <span class="comment">// set the machine-mode trap handler.</span></span><br><span class="line">  <span class="comment">// 设置中断处理函数</span></span><br><span class="line">  w_mtvec((uint64)timervec);</span><br><span class="line">  <span class="comment">// enable machine-mode interrupts.</span></span><br><span class="line">  <span class="comment">// 打开中断</span></span><br><span class="line">  w_mstatus(r_mstatus() | MSTATUS_MIE);</span><br><span class="line">  <span class="comment">// enable machine-mode timer interrupts.</span></span><br><span class="line">  <span class="comment">// 打开时钟中断</span></span><br><span class="line">  w_mie(r_mie() | MIE_MTIE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>memlayout.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Physical memory layout</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// qemu -machine virt is set up like this,</span></span><br><span class="line"><span class="comment">// based on qemu&#x27;s hw/riscv/virt.c:</span></span><br><span class="line"><span class="comment">// 00001000 -- boot ROM, provided by qemu</span></span><br><span class="line"><span class="comment">// 02000000 -- CLINT</span></span><br><span class="line"><span class="comment">// 0C000000 -- PLIC</span></span><br><span class="line"><span class="comment">// 10000000 -- uart0 </span></span><br><span class="line"><span class="comment">// 10001000 -- virtio disk </span></span><br><span class="line"><span class="comment">// 80000000 -- boot ROM jumps here in machine mode</span></span><br><span class="line"><span class="comment">//             -kernel loads the kernel here</span></span><br><span class="line"><span class="comment">// unused RAM after 80000000.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// the kernel uses physical memory thus:</span></span><br><span class="line"><span class="comment">// 80000000 -- entry.S, then kernel text and data</span></span><br><span class="line"><span class="comment">// end -- start of kernel page allocation area</span></span><br><span class="line"><span class="comment">// PHYSTOP -- end RAM used by the kernel</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// qemu puts UART registers here in physical memory.</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UART0 0x10000000L</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UART0_IRQ 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// virtio mmio interface</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VIRTIO0 0x10001000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VIRTIO0_IRQ 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// local interrupt controller, which contains the timer.</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CLINT 0x2000000L</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CLINT_MTIMECMP(hartid) (CLINT + 0x4000 + 8*(hartid))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CLINT_MTIME (CLINT + 0xBFF8) <span class="comment">// cycles since boot.</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// qemu puts programmable interrupt controller here.</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PLIC 0x0c000000L</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PLIC_PRIORITY (PLIC + 0x0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PLIC_PENDING (PLIC + 0x1000)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PLIC_MENABLE(hart) (PLIC + 0x2000 + (hart)*0x100)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PLIC_SENABLE(hart) (PLIC + 0x2080 + (hart)*0x100)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PLIC_MPRIORITY(hart) (PLIC + 0x200000 + (hart)*0x2000)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PLIC_SPRIORITY(hart) (PLIC + 0x201000 + (hart)*0x2000)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PLIC_MCLAIM(hart) (PLIC + 0x200004 + (hart)*0x2000)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PLIC_SCLAIM(hart) (PLIC + 0x201004 + (hart)*0x2000)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// the kernel expects there to be RAM</span></span><br><span class="line"><span class="comment">// for use by the kernel and user pages</span></span><br><span class="line"><span class="comment">// from physical address 0x80000000 to PHYSTOP.</span></span><br><span class="line"><span class="comment">// 物理内存实际只有128M</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KERNBASE 0x80000000L</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PHYSTOP (KERNBASE + 128*1024*1024)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// map the trampoline page to the highest address,</span></span><br><span class="line"><span class="comment">// in both user and kernel space.</span></span><br><span class="line"><span class="comment">// 用户空间和内核空间的最高地址都是trampoline页（用户态和内核态切换）</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TRAMPOLINE (MAXVA - PGSIZE)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// map kernel stacks beneath the trampoline,</span></span><br><span class="line"><span class="comment">// each surrounded by invalid guard pages.</span></span><br><span class="line"><span class="comment">// 内核内存trampoline页后面跟着内核栈页(每一个进程的内核栈都是两页，其中一页是守护页)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KSTACK(p) (TRAMPOLINE - ((p)+1)* 2*PGSIZE)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// User memory layout.</span></span><br><span class="line"><span class="comment">// Address zero first:</span></span><br><span class="line"><span class="comment">//   text</span></span><br><span class="line"><span class="comment">//   original data and bss</span></span><br><span class="line"><span class="comment">//   fixed-size stack</span></span><br><span class="line"><span class="comment">//   expandable heap</span></span><br><span class="line"><span class="comment">//   ...</span></span><br><span class="line"><span class="comment">//   TRAPFRAME (p-&gt;trapframe, used by the trampoline)</span></span><br><span class="line"><span class="comment">//   TRAMPOLINE (the same page as in the kernel)</span></span><br><span class="line"><span class="comment">// 用户内存的trampoline页后面跟着trapframe页</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TRAPFRAME (TRAMPOLINE - PGSIZE)</span></span><br></pre></td></tr></table></figure>

<blockquote>
<ol>
<li>内核地址空间顶部的trampoline页后面跟着内核栈页(每一个进程的内核栈都是两页，其中一页是守护页)</li>
<li>用户地址空间顶部的trampoline页后面跟着trapframe页</li>
</ol>
</blockquote>
<p><code>riscv.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// which hart (core) is this?</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> uint64</span><br><span class="line"><span class="title function_">r_mhartid</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  uint64 x;</span><br><span class="line">  <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;csrr %0, mhartid&quot;</span> : <span class="string">&quot;=r&quot;</span> (x) )</span>;</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Machine Status Register, mstatus</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MSTATUS_MPP_MASK (3L &lt;&lt; 11) <span class="comment">// previous mode.</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MSTATUS_MPP_M (3L &lt;&lt; 11)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MSTATUS_MPP_S (1L &lt;&lt; 11)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MSTATUS_MPP_U (0L &lt;&lt; 11)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MSTATUS_MIE (1L &lt;&lt; 3)    <span class="comment">// machine-mode interrupt enable.</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> uint64</span><br><span class="line"><span class="title function_">r_mstatus</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  uint64 x;</span><br><span class="line">  <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;csrr %0, mstatus&quot;</span> : <span class="string">&quot;=r&quot;</span> (x) )</span>;</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> </span><br><span class="line"><span class="title function_">w_mstatus</span><span class="params">(uint64 x)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;csrw mstatus, %0&quot;</span> : : <span class="string">&quot;r&quot;</span> (x))</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// machine exception program counter, holds the</span></span><br><span class="line"><span class="comment">// instruction address to which a return from</span></span><br><span class="line"><span class="comment">// exception will go.</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> </span><br><span class="line"><span class="title function_">w_mepc</span><span class="params">(uint64 x)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;csrw mepc, %0&quot;</span> : : <span class="string">&quot;r&quot;</span> (x))</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Supervisor Status Register, sstatus</span></span><br><span class="line"><span class="comment">// sstatus 中的 SIE 位控制设备中断是否被启用</span></span><br><span class="line"><span class="comment">// SPP 位表示 trap 是来自用户模式还是监督者模式，并控制sret 返回到什么模式</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SSTATUS_SPP (1L &lt;&lt; 8)  <span class="comment">// Previous mode, 1=Supervisor, 0=User</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SSTATUS_SPIE (1L &lt;&lt; 5) <span class="comment">// Supervisor Previous Interrupt Enable</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SSTATUS_UPIE (1L &lt;&lt; 4) <span class="comment">// User Previous Interrupt Enable</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SSTATUS_SIE (1L &lt;&lt; 1)  <span class="comment">// Supervisor Interrupt Enable</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SSTATUS_UIE (1L &lt;&lt; 0)  <span class="comment">// User Interrupt Enable</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> uint64</span><br><span class="line"><span class="title function_">r_sstatus</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  uint64 x;</span><br><span class="line">  <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;csrr %0, sstatus&quot;</span> : <span class="string">&quot;=r&quot;</span> (x) )</span>;</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> </span><br><span class="line"><span class="title function_">w_sstatus</span><span class="params">(uint64 x)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;csrw sstatus, %0&quot;</span> : : <span class="string">&quot;r&quot;</span> (x))</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Supervisor Interrupt Pending</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> uint64</span><br><span class="line"><span class="title function_">r_sip</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  uint64 x;</span><br><span class="line">  <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;csrr %0, sip&quot;</span> : <span class="string">&quot;=r&quot;</span> (x) )</span>;</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> </span><br><span class="line"><span class="title function_">w_sip</span><span class="params">(uint64 x)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;csrw sip, %0&quot;</span> : : <span class="string">&quot;r&quot;</span> (x))</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Supervisor Interrupt Enable</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIE_SEIE (1L &lt;&lt; 9) <span class="comment">// external</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIE_STIE (1L &lt;&lt; 5) <span class="comment">// timer</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIE_SSIE (1L &lt;&lt; 1) <span class="comment">// software</span></span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> uint64</span><br><span class="line"><span class="title function_">r_sie</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  uint64 x;</span><br><span class="line">  <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;csrr %0, sie&quot;</span> : <span class="string">&quot;=r&quot;</span> (x) )</span>;</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> </span><br><span class="line"><span class="title function_">w_sie</span><span class="params">(uint64 x)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;csrw sie, %0&quot;</span> : : <span class="string">&quot;r&quot;</span> (x))</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Machine-mode Interrupt Enable</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MIE_MEIE (1L &lt;&lt; 11) <span class="comment">// external</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MIE_MTIE (1L &lt;&lt; 7)  <span class="comment">// timer</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MIE_MSIE (1L &lt;&lt; 3)  <span class="comment">// software</span></span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> uint64</span><br><span class="line"><span class="title function_">r_mie</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  uint64 x;</span><br><span class="line">  <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;csrr %0, mie&quot;</span> : <span class="string">&quot;=r&quot;</span> (x) )</span>;</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> </span><br><span class="line"><span class="title function_">w_mie</span><span class="params">(uint64 x)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;csrw mie, %0&quot;</span> : : <span class="string">&quot;r&quot;</span> (x))</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// machine exception program counter, holds the</span></span><br><span class="line"><span class="comment">// instruction address to which a return from</span></span><br><span class="line"><span class="comment">// exception will go.</span></span><br><span class="line"><span class="comment">// 当 trap 发生时，RISC-V 会将程序计数器保存在这里（因为 PC 会被 stvec 覆盖）。sret(从 trap 中返回)指令将 sepc 复制到 pc 中。</span></span><br><span class="line"><span class="comment">// 内核可以写 sepc 来控制 sret的返回到哪里。</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> </span><br><span class="line"><span class="title function_">w_sepc</span><span class="params">(uint64 x)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;csrw sepc, %0&quot;</span> : : <span class="string">&quot;r&quot;</span> (x))</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> uint64</span><br><span class="line"><span class="title function_">r_sepc</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  uint64 x;</span><br><span class="line">  <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;csrr %0, sepc&quot;</span> : <span class="string">&quot;=r&quot;</span> (x) )</span>;</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Machine Exception Delegation</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> uint64</span><br><span class="line"><span class="title function_">r_medeleg</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  uint64 x;</span><br><span class="line">  <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;csrr %0, medeleg&quot;</span> : <span class="string">&quot;=r&quot;</span> (x) )</span>;</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> </span><br><span class="line"><span class="title function_">w_medeleg</span><span class="params">(uint64 x)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;csrw medeleg, %0&quot;</span> : : <span class="string">&quot;r&quot;</span> (x))</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Machine Interrupt Delegation</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> uint64</span><br><span class="line"><span class="title function_">r_mideleg</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  uint64 x;</span><br><span class="line">  <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;csrr %0, mideleg&quot;</span> : <span class="string">&quot;=r&quot;</span> (x) )</span>;</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> </span><br><span class="line"><span class="title function_">w_mideleg</span><span class="params">(uint64 x)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;csrw mideleg, %0&quot;</span> : : <span class="string">&quot;r&quot;</span> (x))</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Supervisor Trap-Vector Base Address</span></span><br><span class="line"><span class="comment">// low two bits are mode.</span></span><br><span class="line"><span class="comment">// 内核在这里写下 trap 处理程序的地址；RISC-V 到这里来处理 trap</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> </span><br><span class="line"><span class="title function_">w_stvec</span><span class="params">(uint64 x)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;csrw stvec, %0&quot;</span> : : <span class="string">&quot;r&quot;</span> (x))</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> uint64</span><br><span class="line"><span class="title function_">r_stvec</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  uint64 x;</span><br><span class="line">  <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;csrr %0, stvec&quot;</span> : <span class="string">&quot;=r&quot;</span> (x) )</span>;</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Machine-mode interrupt vector</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> </span><br><span class="line"><span class="title function_">w_mtvec</span><span class="params">(uint64 x)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;csrw mtvec, %0&quot;</span> : : <span class="string">&quot;r&quot;</span> (x))</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// use riscv&#x27;s sv39 page table scheme.</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SATP_SV39 (8L &lt;&lt; 60)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAKE_SATP(pagetable) (SATP_SV39 | (((uint64)pagetable) &gt;&gt; 12))</span></span><br><span class="line"><span class="comment">// supervisor address translation and protection;</span></span><br><span class="line"><span class="comment">// holds the address of the page table.</span></span><br><span class="line"><span class="comment">// 页表寄存器</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> </span><br><span class="line"><span class="title function_">w_satp</span><span class="params">(uint64 x)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;csrw satp, %0&quot;</span> : : <span class="string">&quot;r&quot;</span> (x))</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> uint64</span><br><span class="line"><span class="title function_">r_satp</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  uint64 x;</span><br><span class="line">  <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;csrr %0, satp&quot;</span> : <span class="string">&quot;=r&quot;</span> (x) )</span>;</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Supervisor Scratch register, for early trap handler in trampoline.S.</span></span><br><span class="line"><span class="comment">// 内核在这里放置了一个值，这个值会方便 trap 恢复/储存用户上下文</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> </span><br><span class="line"><span class="title function_">w_sscratch</span><span class="params">(uint64 x)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;csrw sscratch, %0&quot;</span> : : <span class="string">&quot;r&quot;</span> (x))</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> </span><br><span class="line"><span class="title function_">w_mscratch</span><span class="params">(uint64 x)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;csrw mscratch, %0&quot;</span> : : <span class="string">&quot;r&quot;</span> (x))</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Supervisor Trap Cause</span></span><br><span class="line"><span class="comment">// RISC -V 在这里放了一个数字，描述了 trap 的原因</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> uint64</span><br><span class="line"><span class="title function_">r_scause</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  uint64 x;</span><br><span class="line">  <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;csrr %0, scause&quot;</span> : <span class="string">&quot;=r&quot;</span> (x) )</span>;</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Supervisor Trap Value</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> uint64</span><br><span class="line"><span class="title function_">r_stval</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  uint64 x;</span><br><span class="line">  <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;csrr %0, stval&quot;</span> : <span class="string">&quot;=r&quot;</span> (x) )</span>;</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Machine-mode Counter-Enable</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> </span><br><span class="line"><span class="title function_">w_mcounteren</span><span class="params">(uint64 x)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;csrw mcounteren, %0&quot;</span> : : <span class="string">&quot;r&quot;</span> (x))</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> uint64</span><br><span class="line"><span class="title function_">r_mcounteren</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  uint64 x;</span><br><span class="line">  <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;csrr %0, mcounteren&quot;</span> : <span class="string">&quot;=r&quot;</span> (x) )</span>;</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// machine-mode cycle counter</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> uint64</span><br><span class="line"><span class="title function_">r_time</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  uint64 x;</span><br><span class="line">  <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;csrr %0, time&quot;</span> : <span class="string">&quot;=r&quot;</span> (x) )</span>;</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// enable device interrupts</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">intr_on</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  w_sstatus(r_sstatus() | SSTATUS_SIE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// disable device interrupts</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">intr_off</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  w_sstatus(r_sstatus() &amp; ~SSTATUS_SIE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// are device interrupts enabled?</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">intr_get</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  uint64 x = r_sstatus();</span><br><span class="line">  <span class="keyword">return</span> (x &amp; SSTATUS_SIE) != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> uint64</span><br><span class="line"><span class="title function_">r_sp</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  uint64 x;</span><br><span class="line">  <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;mv %0, sp&quot;</span> : <span class="string">&quot;=r&quot;</span> (x) )</span>;</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// read and write tp, the thread pointer, which holds</span></span><br><span class="line"><span class="comment">// this core&#x27;s hartid (core number), the index into cpus[].</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> uint64</span><br><span class="line"><span class="title function_">r_tp</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  uint64 x;</span><br><span class="line">  <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;mv %0, tp&quot;</span> : <span class="string">&quot;=r&quot;</span> (x) )</span>;</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> </span><br><span class="line"><span class="title function_">w_tp</span><span class="params">(uint64 x)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;mv tp, %0&quot;</span> : : <span class="string">&quot;r&quot;</span> (x))</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> uint64</span><br><span class="line"><span class="title function_">r_ra</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  uint64 x;</span><br><span class="line">  <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;mv %0, ra&quot;</span> : <span class="string">&quot;=r&quot;</span> (x) )</span>;</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// flush the TLB.</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">sfence_vma</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// the zero, zero means flush all TLB entries.</span></span><br><span class="line">  <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;sfence.vma zero, zero&quot;</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 页大小(4k字节)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PGSIZE 4096 <span class="comment">// bytes per page</span></span></span><br><span class="line"><span class="comment">// 页的偏移位(低12位)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PGSHIFT 12  <span class="comment">// bits of offset within a page</span></span></span><br><span class="line"><span class="comment">// 临近的初始开始页</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PGROUNDUP(sz)  (((sz)+PGSIZE-1) &amp; ~(PGSIZE-1))</span></span><br><span class="line"><span class="comment">// 当前页的起始地址</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PGROUNDDOWN(a) (((a)) &amp; ~(PGSIZE-1))</span></span><br><span class="line"><span class="comment">// 有效位</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_V (1L &lt;&lt; 0)</span></span><br><span class="line"><span class="comment">// 可读位 </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_R (1L &lt;&lt; 1)</span></span><br><span class="line"><span class="comment">// 可写位</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_W (1L &lt;&lt; 2)</span></span><br><span class="line"><span class="comment">// 可执行位</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_X (1L &lt;&lt; 3)</span></span><br><span class="line"><span class="comment">// 用户模式访问位</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_U (1L <span class="string">&lt;&lt; 4) // 1 -&gt;</span> user can access</span></span><br><span class="line"><span class="comment">// COW页标志</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_COW (1L &lt;&lt; 7)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// shift a physical address to the right place for a PTE.</span></span><br><span class="line"><span class="comment">// 物理地址转换为PTE项(低10位需要额外填充标志位)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PA2PTE(pa) ((((uint64)pa) &gt;&gt; 12) &lt;&lt; 10)</span></span><br><span class="line"><span class="comment">// PTE项转换为物理地址</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE2PA(pte) (((pte) &gt;&gt; 10) &lt;&lt; 12)</span></span><br><span class="line"><span class="comment">// 物理地址所在的块号</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PA2IDX(pa) (((uint64)pa) &gt;&gt; 12)</span></span><br><span class="line"><span class="comment">// PTE项的低10位标记位</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_FLAGS(pte) ((pte) &amp; 0x3FF)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// extract the three 9-bit page table indices from a virtual address.</span></span><br><span class="line"><span class="comment">// 抽取出页表项的页目录索引项(9位)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PXMASK          0x1FF <span class="comment">// 9 bits</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PXSHIFT(level)  (PGSHIFT+(9*(level)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PX(level, va) ((((uint64) (va)) &gt;&gt; PXSHIFT(level)) &amp; PXMASK)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// one beyond the highest possible virtual address.</span></span><br><span class="line"><span class="comment">// MAXVA is actually one bit less than the max allowed by</span></span><br><span class="line"><span class="comment">// Sv39, to avoid having to sign-extend virtual addresses</span></span><br><span class="line"><span class="comment">// that have the high bit set.</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXVA (1L &lt;&lt; (9 + 9 + 9 + 12 - 1))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> uint64 <span class="type">pte_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> uint64 *<span class="type">pagetable_t</span>; <span class="comment">// 512 PTEs，一页4096字节，一个pte8字节</span></span><br></pre></td></tr></table></figure>

<p><code>main.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;param.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;memlayout.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;riscv.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;defs.h&quot;</span></span></span><br><span class="line"><span class="comment">// 保证并发初始化正确</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="type">static</span> <span class="type">int</span> started = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// start() jumps here in supervisor mode on all CPUs.</span></span><br><span class="line"><span class="comment">// 进入main函数时系统为supervisor模式</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(cpuid() == <span class="number">0</span>)&#123;</span><br><span class="line">    consoleinit();</span><br><span class="line">    printfinit();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;xv6 kernel is booting\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    kinit();         <span class="comment">// physical page allocator</span></span><br><span class="line">    kvminit();       <span class="comment">// create kernel page table</span></span><br><span class="line">    kvminithart();   <span class="comment">// turn on paging</span></span><br><span class="line">    procinit();      <span class="comment">// process table</span></span><br><span class="line">    trapinit();      <span class="comment">// trap vectors</span></span><br><span class="line">    trapinithart();  <span class="comment">// install kernel trap vector</span></span><br><span class="line">    plicinit();      <span class="comment">// set up interrupt controller</span></span><br><span class="line">    plicinithart();  <span class="comment">// ask PLIC for device interrupts</span></span><br><span class="line">    binit();         <span class="comment">// buffer cache</span></span><br><span class="line">    iinit();         <span class="comment">// inode cache</span></span><br><span class="line">    fileinit();      <span class="comment">// file table</span></span><br><span class="line">    virtio_disk_init(); <span class="comment">// emulated hard disk</span></span><br><span class="line">    userinit();      <span class="comment">// first user process</span></span><br><span class="line">    __sync_synchronize(); <span class="comment">// gcc 提供的原子操作，保证内存访问的操作都是原子操作</span></span><br><span class="line">    started = <span class="number">1</span>; <span class="comment">//设置初始化完成的标志</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 如果不是主 CPU ，首先循环等待主 CPU 初始化完成，当主 CPU 初始化完成，则初始化完成标志 started 为 1 ，跳出循环</span></span><br><span class="line">    <span class="keyword">while</span>(started == <span class="number">0</span>)</span><br><span class="line">      ;</span><br><span class="line">    <span class="comment">// 原子屏障</span></span><br><span class="line">    __sync_synchronize();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hart %d starting\n&quot;</span>, cpuid());</span><br><span class="line">    kvminithart();    <span class="comment">// turn on paging</span></span><br><span class="line">    trapinithart();   <span class="comment">// install kernel trap vector</span></span><br><span class="line">    plicinithart();   <span class="comment">// ask PLIC for device interrupts</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  scheduler();        </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>proc.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Saved registers for kernel context switches.</span></span><br><span class="line"><span class="comment">// 内核上下文切换时需要保存相关的寄存器</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">context</span> &#123;</span></span><br><span class="line">  uint64 ra;</span><br><span class="line">  uint64 sp;</span><br><span class="line">  <span class="comment">// callee-saved</span></span><br><span class="line">  uint64 s0;</span><br><span class="line">  uint64 s1;</span><br><span class="line">  uint64 s2;</span><br><span class="line">  uint64 s3;</span><br><span class="line">  uint64 s4;</span><br><span class="line">  uint64 s5;</span><br><span class="line">  uint64 s6;</span><br><span class="line">  uint64 s7;</span><br><span class="line">  uint64 s8;</span><br><span class="line">  uint64 s9;</span><br><span class="line">  uint64 s10;</span><br><span class="line">  uint64 s11;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Per-CPU state.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cpu</span> &#123;</span></span><br><span class="line">  <span class="comment">// 当前运行在本CPU上的进程</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">proc</span>;</span>          <span class="comment">// The process running on this cpu, or null.</span></span><br><span class="line">  <span class="comment">// CPU的调度器上下文</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">context</span> <span class="title">context</span>;</span>     <span class="comment">// swtch() here to enter scheduler().</span></span><br><span class="line">  <span class="comment">// 嵌套加锁深度</span></span><br><span class="line">  <span class="type">int</span> noff;                   <span class="comment">// Depth of push_off() nesting.</span></span><br><span class="line">  <span class="comment">// 初始加锁之前的中断开启状态</span></span><br><span class="line">  <span class="type">int</span> intena;                 <span class="comment">// Were interrupts enabled before push_off()?</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">cpu</span> <span class="title">cpus</span>[<span class="title">NCPU</span>];</span></span><br><span class="line"><span class="comment">// per-process data for the trap handling code in trampoline.S.</span></span><br><span class="line"><span class="comment">// sits in a page by itself just under the trampoline page in the</span></span><br><span class="line"><span class="comment">// user page table. not specially mapped in the kernel page table.</span></span><br><span class="line"><span class="comment">// the sscratch register points here.</span></span><br><span class="line"><span class="comment">// uservec in trampoline.S saves user registers in the trapframe,</span></span><br><span class="line"><span class="comment">// then initializes registers from the trapframe&#x27;s</span></span><br><span class="line"><span class="comment">// kernel_sp, kernel_hartid, kernel_satp, and jumps to kernel_trap.</span></span><br><span class="line"><span class="comment">// usertrapret() and userret in trampoline.S set up</span></span><br><span class="line"><span class="comment">// the trapframe&#x27;s kernel_*, restore user registers from the</span></span><br><span class="line"><span class="comment">// trapframe, switch to the user page table, and enter user space.</span></span><br><span class="line"><span class="comment">// the trapframe includes callee-saved user registers like s0-s11 because the</span></span><br><span class="line"><span class="comment">// return-to-user path via usertrapret() doesn&#x27;t return through</span></span><br><span class="line"><span class="comment">// the entire kernel call stack.</span></span><br><span class="line"><span class="comment">// 在处理trap时用户页表中存放进程数据的页（紧随trampoline页），由sscrach寄存器指向该页</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> &#123;</span></span><br><span class="line">  <span class="comment">/*   0 */</span> uint64 kernel_satp;   <span class="comment">// kernel page table 内核页表</span></span><br><span class="line">  <span class="comment">/*   8 */</span> uint64 kernel_sp;     <span class="comment">// top of process&#x27;s kernel stack 进程内核栈顶</span></span><br><span class="line">  <span class="comment">/*  16 */</span> uint64 kernel_trap;   <span class="comment">// usertrap() 内核处理trap的入口</span></span><br><span class="line">  <span class="comment">/*  24 */</span> uint64 epc;           <span class="comment">// saved user program counter 保存上一次执行位置</span></span><br><span class="line">  <span class="comment">/*  32 */</span> uint64 kernel_hartid; <span class="comment">// saved kernel tp 内核tp寄存器的值(CPU的ID)</span></span><br><span class="line">  <span class="comment">/*  40 */</span> uint64 ra;</span><br><span class="line">  <span class="comment">/*  48 */</span> uint64 sp;</span><br><span class="line">  <span class="comment">/*  56 */</span> uint64 gp;</span><br><span class="line">  <span class="comment">/*  64 */</span> uint64 tp;</span><br><span class="line">  <span class="comment">/*  72 */</span> uint64 t0;</span><br><span class="line">  <span class="comment">/*  80 */</span> uint64 t1;</span><br><span class="line">  <span class="comment">/*  88 */</span> uint64 t2;</span><br><span class="line">  <span class="comment">/*  96 */</span> uint64 s0;</span><br><span class="line">  <span class="comment">/* 104 */</span> uint64 s1;</span><br><span class="line">  <span class="comment">/* 112 */</span> uint64 a0;</span><br><span class="line">  <span class="comment">/* 120 */</span> uint64 a1;</span><br><span class="line">  <span class="comment">/* 128 */</span> uint64 a2;</span><br><span class="line">  <span class="comment">/* 136 */</span> uint64 a3;</span><br><span class="line">  <span class="comment">/* 144 */</span> uint64 a4;</span><br><span class="line">  <span class="comment">/* 152 */</span> uint64 a5;</span><br><span class="line">  <span class="comment">/* 160 */</span> uint64 a6;</span><br><span class="line">  <span class="comment">/* 168 */</span> uint64 a7;</span><br><span class="line">  <span class="comment">/* 176 */</span> uint64 s2;</span><br><span class="line">  <span class="comment">/* 184 */</span> uint64 s3;</span><br><span class="line">  <span class="comment">/* 192 */</span> uint64 s4;</span><br><span class="line">  <span class="comment">/* 200 */</span> uint64 s5;</span><br><span class="line">  <span class="comment">/* 208 */</span> uint64 s6;</span><br><span class="line">  <span class="comment">/* 216 */</span> uint64 s7;</span><br><span class="line">  <span class="comment">/* 224 */</span> uint64 s8;</span><br><span class="line">  <span class="comment">/* 232 */</span> uint64 s9;</span><br><span class="line">  <span class="comment">/* 240 */</span> uint64 s10;</span><br><span class="line">  <span class="comment">/* 248 */</span> uint64 s11;</span><br><span class="line">  <span class="comment">/* 256 */</span> uint64 t3;</span><br><span class="line">  <span class="comment">/* 264 */</span> uint64 t4;</span><br><span class="line">  <span class="comment">/* 272 */</span> uint64 t5;</span><br><span class="line">  <span class="comment">/* 280 */</span> uint64 t6;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 进程状态有5种：未使用、休眠、可运行、运行中、僵死</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">procstate</span> &#123;</span> UNUSED, SLEEPING, RUNNABLE, RUNNING, ZOMBIE &#125;;</span><br><span class="line"><span class="comment">// Per-process state</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">  <span class="comment">// p-&gt;lock must be held when using these:</span></span><br><span class="line">  <span class="class"><span class="keyword">enum</span> <span class="title">procstate</span> <span class="title">state</span>;</span>        <span class="comment">// Process state 进程状态</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">parent</span>;</span>         <span class="comment">// Parent process 父进程</span></span><br><span class="line">  <span class="type">void</span> *chan;                  <span class="comment">// If non-zero, sleeping on chan 休眠链</span></span><br><span class="line">  <span class="type">int</span> killed;                  <span class="comment">// If non-zero, have been killed 进程杀死标志</span></span><br><span class="line">  <span class="type">int</span> xstate;                  <span class="comment">// Exit status to be returned to parent&#x27;s wait 返回给父进程wait的退出状态</span></span><br><span class="line">  <span class="type">int</span> pid;                     <span class="comment">// Process ID 进程ID</span></span><br><span class="line">  <span class="comment">// these are private to the process, so p-&gt;lock need not be held.</span></span><br><span class="line">  uint64 kstack;               <span class="comment">// Virtual address of kernel stack 内核栈虚拟地址</span></span><br><span class="line">  uint64 sz;                   <span class="comment">// Size of process memory (bytes) 进程占用内存大小</span></span><br><span class="line">  <span class="type">pagetable_t</span> pagetable;       <span class="comment">// User page table 页表</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> *<span class="title">trapframe</span>;</span> <span class="comment">// data page for trampoline.S trapframe页</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">context</span> <span class="title">context</span>;</span>      <span class="comment">// swtch() here to run process 进程上下文</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">ofile</span>[<span class="title">NOFILE</span>];</span>  <span class="comment">// Open files 打开的文件</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">cwd</span>;</span>           <span class="comment">// Current directory 当前工作目录</span></span><br><span class="line">  <span class="type">char</span> name[<span class="number">16</span>];               <span class="comment">// Process name (debugging) 进程名称</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>proc.c:userinit()</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// a user program that calls exec(&quot;/init&quot;)</span></span><br><span class="line"><span class="comment">// od -t xC initcode</span></span><br><span class="line">uchar initcode[] = &#123;</span><br><span class="line">  <span class="number">0x17</span>, <span class="number">0x05</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x13</span>, <span class="number">0x05</span>, <span class="number">0x45</span>, <span class="number">0x02</span>,</span><br><span class="line">  <span class="number">0x97</span>, <span class="number">0x05</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x93</span>, <span class="number">0x85</span>, <span class="number">0x35</span>, <span class="number">0x02</span>,</span><br><span class="line">  <span class="number">0x93</span>, <span class="number">0x08</span>, <span class="number">0x70</span>, <span class="number">0x00</span>, <span class="number">0x73</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">  <span class="number">0x93</span>, <span class="number">0x08</span>, <span class="number">0x20</span>, <span class="number">0x00</span>, <span class="number">0x73</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">  <span class="number">0xef</span>, <span class="number">0xf0</span>, <span class="number">0x9f</span>, <span class="number">0xff</span>, <span class="number">0x2f</span>, <span class="number">0x69</span>, <span class="number">0x6e</span>, <span class="number">0x69</span>,</span><br><span class="line">  <span class="number">0x74</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x24</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Set up first user process.</span></span><br><span class="line"><span class="comment">// 建立第一个用户进程</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">userinit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line">  <span class="comment">// 从进程表中分配一个进程作为initproc</span></span><br><span class="line">  p = allocproc();</span><br><span class="line">  initproc = p;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// allocate one user page and copy init&#x27;s instructions</span></span><br><span class="line">  <span class="comment">// and data into it.</span></span><br><span class="line">  <span class="comment">// 这个进程执行了一个initcode.S的汇编程序，这个汇编程序调用了exec这个system call来执行/init，重新进入kernel。</span></span><br><span class="line">  uvminit(p-&gt;pagetable, initcode, <span class="keyword">sizeof</span>(initcode));</span><br><span class="line">  <span class="comment">// init进程只有一页大小</span></span><br><span class="line">  p-&gt;sz = PGSIZE;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// prepare for the very first &quot;return&quot; from kernel to user.</span></span><br><span class="line">  <span class="comment">// 准备好initproc被内核调度器线程选中需要restore的信息(epc==0表示从initproc进程的一开始执行，sp==PGSIZE表示initproc的用户栈从PGSIZE开始)</span></span><br><span class="line">  p-&gt;trapframe-&gt;epc = <span class="number">0</span>;      <span class="comment">// user program counter</span></span><br><span class="line">  p-&gt;trapframe-&gt;sp = PGSIZE;  <span class="comment">// user stack pointer</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 初始化进程的信息(名称、工作目录、进程状态)</span></span><br><span class="line">  safestrcpy(p-&gt;name, <span class="string">&quot;initcode&quot;</span>, <span class="keyword">sizeof</span>(p-&gt;name));</span><br><span class="line">  p-&gt;cwd = namei(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">  p-&gt;state = RUNNABLE;</span><br><span class="line"></span><br><span class="line">  release(&amp;p-&gt;lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>initcode.S</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"># Initial process that execs /init.</span><br><span class="line"># This code runs in user space.</span><br><span class="line"># 初始进程/init进程</span><br><span class="line">#include &quot;syscall.h&quot;</span><br><span class="line"># exec(init, argv)</span><br><span class="line">.globl start</span><br><span class="line">start:</span><br><span class="line">        la a0, init</span><br><span class="line">        la a1, argv</span><br><span class="line">        li a7, SYS_exec</span><br><span class="line">        ecall</span><br><span class="line"></span><br><span class="line"># for(;;) exit();</span><br><span class="line">exit:</span><br><span class="line">        li a7, SYS_exit</span><br><span class="line">        ecall</span><br><span class="line">        jal exit</span><br><span class="line"></span><br><span class="line"># char init[] = &quot;/init\0&quot;;</span><br><span class="line">init:</span><br><span class="line">  .string &quot;/init\0&quot;</span><br><span class="line"></span><br><span class="line"># char *argv[] = &#123; init, 0 &#125;;</span><br><span class="line">.p2align 2</span><br><span class="line">argv:</span><br><span class="line">  .long init</span><br><span class="line">  .long 0</span><br></pre></td></tr></table></figure>

<p><code>init.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// init: The initial user-level program</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/spinlock.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/sleeplock.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/fs.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/file.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/fcntl.h&quot;</span></span></span><br><span class="line"><span class="type">char</span> *argv[] = &#123; <span class="string">&quot;sh&quot;</span>, <span class="number">0</span> &#125;;</span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> pid, wpid;</span><br><span class="line">  <span class="comment">// 打开三个文件描述符0、1、2</span></span><br><span class="line">  <span class="keyword">if</span>(open(<span class="string">&quot;console&quot;</span>, O_RDWR) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    mknod(<span class="string">&quot;console&quot;</span>, CONSOLE, <span class="number">0</span>);</span><br><span class="line">    open(<span class="string">&quot;console&quot;</span>, O_RDWR);</span><br><span class="line">  &#125;</span><br><span class="line">  dup(<span class="number">0</span>);  <span class="comment">// stdout</span></span><br><span class="line">  dup(<span class="number">0</span>);  <span class="comment">// stderr</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// init进程是一个无限死循环</span></span><br><span class="line">  <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;init: starting sh\n&quot;</span>);</span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid &lt; <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;init: fork failed\n&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="comment">// 子进程执行sh程序</span></span><br><span class="line">      exec(<span class="string">&quot;sh&quot;</span>, argv);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;init: exec sh failed\n&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">      <span class="comment">// this call to wait() returns if the shell exits,</span></span><br><span class="line">      <span class="comment">// or if a parentless process exits.</span></span><br><span class="line">      <span class="comment">// 注意：如果一个父进程退出，子进程会被委托给init进程</span></span><br><span class="line">      <span class="comment">// 因此wait的返回不一定是因为shell进程的退出</span></span><br><span class="line">      wpid = wait((<span class="type">int</span> *) <span class="number">0</span>);</span><br><span class="line">      <span class="keyword">if</span>(wpid == pid)&#123;</span><br><span class="line">        <span class="comment">// the shell exited; restart it.</span></span><br><span class="line">        <span class="comment">// shell程序退出，需要重启一个shell子进程</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span>(wpid &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">// init进程肯定存在子进程，所以wait不可能返回-1</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;init: wait returned an error\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 委托给init进程的子进程退出，init进程继续等待</span></span><br><span class="line">        <span class="comment">// it was a parentless process; do nothing.</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="第三章：页表"><a href="#第三章：页表" class="headerlink" title="第三章：页表"></a>第三章：页表</h3><p>页表是操作系统为每个进程提供自己私有地址空间和内存的机制。<code>页表决定了内存地址的含义，以及物理内存的哪些部分可以被访问。它们允许xv6隔离不同进程的地址空间，并将它们映射到物理内存上。</code>页表还提供了一个间接层次，允许 xv6 执行一些技巧：&#x3D;&#x3D;在几个地址空间中映射同一内存(trampoline 页)，以及用一个未映射页来保护内核和用户的栈。&#x3D;&#x3D;本章其余部分将解释 RISC-V 硬件提供的页表以及 xv6 如何使用它们。</p>
<h4 id="3-1分页硬件"><a href="#3-1分页硬件" class="headerlink" title="3.1分页硬件"></a>3.1分页硬件</h4><p>提醒一下，RISC-V 指令(包括用户和内核)操作的是虚拟地址。机器的 RAM，或者说物理内存，是用物理地址来做索引的，RISC-V 分页硬件将这两种地址联系起来，通过将每个虚拟地址映射到物理地址上。</p>
<p>xv6 运行在 Sv39 RISC-V 上，这意味着只使用 64 位虚拟地址的底部 39 位，顶部 25 位未被使用。在这种 Sv39 配置中，一个 RISC-V 页表在逻辑上是一个 2^27^（134,217,728）页表项（Page Table Entry, PTE）的数组。<code>每个 PTE 包含一个 44 位的物理页号(Physical Page Number，PPN)和一些标志位。分页硬件通过利用 39 位中的高 27 位索引到页表中找到一个 PTE 来转换一个虚拟地址，并计算出一个 56 位的物理地址，它的前 44 位来自于 PTE 中的 PPN，而它的后 12 位则是从原来的虚拟地址复制过来的。</code>图 3.1 显示了这个过程，在逻辑上可以把页表看成是一个简单的 PTE 数组（更完整的描述见图 3.2）。页表让操作系统控制虚拟地址到物理地址的转换，其粒度为 4096（2^12^）字节的对齐块。这样的分块称为页。</p>
<p>在 Sv39 RISC-V 中，虚拟地址的前 25 位不用于转换地址；&#x3D;&#x3D;将来，RISC-V 可能会使用这些位来定义更多的转换层。物理地址也有增长的空间：在 PTE 格式中，物理页号还有 10 位的增长空间。&#x3D;&#x3D;</p>
<p><img src="/../../../../../../imgs/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%BA%90%E7%A0%81%E7%BA%A7%E5%89%96%E6%9E%90/image-20221114153948359.png" alt="image-20221114153948359"></p>
<p>如图 3.2 所示，实际转换分三步进行。<code>一个页表以三层树的形式存储在物理内存中。</code>树的根部是一个 4096 字节的页表页，它包含 512 个 PTE，这些 PTE 包含树的下一级页表页的物理地址。每一页都包含 512 个 PTE，用于指向下一个页表或物理地址。分页硬件用 27 位中的顶 9 位选择根页表页中的 PTE，用中间 9 位选择树中下一级页表页中的 PTE，用底 9 位选择最后的 PTE。</p>
<blockquote>
<p>如果转换一个地址所需的三个 PTE 中的任何一个不存在，分页硬件就会引发一个页面错误的异常(page-fault exception)，让内核来处理这个异常。这种三层结构的一种好处是，当有大范围的虚拟地址没有被映射时，可以省略整个页表页。</p>
</blockquote>
<p><code>每个 PTE 包含标志位，告诉分页硬件如何允许使用相关的虚拟地址。</code>PTE_V 表示 PTE 是否存在：如果没有设置，对该页的引用会引起异常（即不允许）。PTE_R 控制是否允许指令读取到页。PTE_W 控制是否允许指令向写该页。PTE_X 控制 CPU 是否可以将页面的内容解释为指令并执行。PTE_U 控制是否允许用户模式下的指令访问页面；如果不设置 PTE_U，PTE 只能在监督者模式下使用。</p>
<p><img src="/../../../../../../imgs/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%BA%90%E7%A0%81%E7%BA%A7%E5%89%96%E6%9E%90/image-20221114154520842.png" alt="image-20221114154520842"></p>
<p><code>要告诉硬件使用页表，内核必须将根页表页的物理地址写入 satp 寄存器中。</code>每个 CPU都有自己的 satp 寄存器。一个 CPU 将使用自己的 satp 所指向的页表来翻译后续指令产生的所有地址。每个 CPU 都有自己的 satp，这样不同的 CPU 可以运行不同的进程，每个进程都有自己的页表所描述的私有地址空间。</p>
<p>关于术语的一些说明：<code>物理内存指的是 DRAM 中的存储单元。物理存储器的一个字节有一个地址，称为物理地址。当指令操作虚拟地址时，分页硬件会将其翻译成物理地址，然后发送给 DRAM 硬件，以读取或写入存储。</code>不像物理内存和虚拟地址，虚拟内存不是一个物理对象，而是指内核提供的管理物理内存和虚拟地址的抽象和机制的集合。</p>
<h4 id="3-2内核地址空间"><a href="#3-2内核地址空间" class="headerlink" title="3.2内核地址空间"></a>3.2内核地址空间</h4><p>xv6 为每个进程维护页表，一个是进程的用户地址空间，外加一个内核地址空间的单页表。内核配置其地址空间的布局，使其能够通过可预测的虚拟地址访问物理内存和各种硬件资源 。 图 3.3 显示了这个设计是如何将内核虚拟地址映射到物理地址的。</p>
<p><img src="/../../../../../../imgs/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%BA%90%E7%A0%81%E7%BA%A7%E5%89%96%E6%9E%90/image-20221114155032464.png" alt="image-20221114155032464"></p>
<p>QEMU模拟的计算机包含 RAM（物理内存），从物理地址 0x80000000至少到0x86400000，(xv6 称之为 PHYSTOP)。QEMU模拟还包括 I&#x2F;O 设备如磁盘接口。QEMU将设备接口作为<code>memory-mapped(内存映射)控制寄存器</code>暴露给软件，这些寄存器位于物理地址空间0x80000000 以下。&#x3D;&#x3D;内核可以通过读取&#x2F;写入这些特殊的物理地址与设备进行交互，这种读取和写入与设备硬件而不是与 RAM 进行通信。&#x3D;&#x3D;</p>
<p>内核使用<code>直接映射</code>RAM 和内存映射设备寄存器，也就是<code>在虚拟地址上映射硬件资源，这些地址与物理地址相等</code>。例如，内核本身在虚拟地址空间和物理内存中的位置都是KERNBASE，即0x80000000。</p>
<blockquote>
<p>直接映射简化了读&#x2F;写物理内存的内核代码。例如，当 fork 为子进程分配用户内存时，分配器返回该内存的物理地址；fork 在将父进程的用户内存复制到子进程时，直接使用该地址作为虚拟地址。</p>
</blockquote>
<p>有几个内核虚拟地址不是直接映射的:</p>
<p>1．trampoline 页。<code>它被映射在虚拟地址空间的顶端，用户页表也有这个映射。</code>我们在这里看到了页表的一个有趣的用例；一个物理页（存放 trampoline 代码）在内核的虚拟地址空间中被映射了两次：一次是在虚拟地址空间的顶部，一次是直接映射。</p>
<p>2．内核栈页。每个进程都有自己的内核栈，内核栈被映射到地址高处，所以在它后面xv6 可以留下一个未映射的守护页。<code>守护页的 PTE 是无效的（设置PTE_V），这样如果内核溢出内核栈，很可能会引起异常，内核会报错。如果没有守护页，栈溢出时会覆盖其他内核内存，导致不正确的操作。</code></p>
<p>&#x3D;&#x3D;内核为trampoline和text (可执行程序的代码段)映射的页会有 PTE_R 和 PTE_X 权限。&#x3D;&#x3D;内核从这些页读取和执行指令。内核映射的其他页会有 PTE_R 和 PTE_W 权限，以便内核读写这些页面的内存。守护页的映射是无效的（设置 PTE_V）。</p>
<h4 id="3-3创建地址空间"><a href="#3-3创建地址空间" class="headerlink" title="3.3创建地址空间"></a>3.3创建地址空间</h4><p>大部分用于操作地址空间和页表的 xv6 代码都在 vm.c中。<code>核心数据结构是 pagetable_t，它实际上是一个指向 RISC-V 根页表页的指针；pagetable_t可以是内核页表，也可以是进程的页表。</code>核心函数是 walk 和 mappages，前者通过虚拟地址得到 PTE，后者将虚拟地址映射到物理地址。以 kvm 开头的函数操作内核页表；以 uvm 开头的函数操作用户页表；其他函数用于这两种页表。<code>copyout 可以将内核数据复制到用户虚拟地址，copyin 可以将用户虚拟地址的数据复制到内核空间地址</code>，用户虚拟地址由系统调用的参数指定；它们在 vm.c 中，因为它们需要显式转换这些地址以便找到相应的物理内存。</p>
<p>在启动序列的前面，main 调用 kvminit 来创建内核的页表。这个调用发生在 xv6 在 RISC-V 启用分页之前，所以地址直接指向物理内存。</p>
<blockquote>
<p>kvminit 首先分配一页物理内存来存放根页表页，然后调用kvmmap将内核所需要的硬件资源映射到物理地址，这些资源包括内核的指令和数据，KERNBASE到PHYSTOP(0x86400000)的物理内存，以及实际上是设备的内存范围。</p>
</blockquote>
<p>kvmmap调用 mappages，它将一个虚拟地址范围映射到一个物理地址范围。它将范围内地址分割成多页（忽略余数），每次映射一页的顶端地址。</p>
<blockquote>
<p>对于每个要映射的虚拟地址（页的顶端地址），mappages 调用 walk 找到该地址的最后一级 PTE 的地址。然后，它配置 PTE，使其持有相关的物理页号、所需的权限(PTE_W、PTE_X和&#x2F;或 PTE_R)，以及 PTE_V来标记 PTE 为有效。</p>
</blockquote>
<p><code>walk模仿 RISC-V 分页硬件查找虚拟地址的 PTE</code>。walk 每次降低 3 级页表的 9 位。&#x3D;&#x3D;它使用每一级的 9 位虚拟地址来查找下一级页表或最后一级的 PTE。如果 PTE 无效，那么所需的物理页还没有被分配；如果 alloc 参数被设置 true，walk 会分配一个新的页表页，并把它的物理地址放在 PTE 中。它返回 PTE在树的最低层的地址。&#x3D;&#x3D;</p>
<p><code>main 调用 kvminithart 来映射内核页表，它将根页表页的物理地址写入寄存器 satp 中。</code>在这之后，CPU 将使用内核页表翻译地址。由于内核使用唯一映射，所以指令的虚拟地址将映射到正确的物理内存地址。</p>
<p><code>main 调用 procinit 为每个进程分配一个内核栈，它将每个栈映射在 KSTACK 生成的虚拟地址上，这就为栈守护页留下了空间。</code>kvmmap 栈的虚拟地址映射到申请的物理内存上，然后调用 kvminithart 将内核页表重新加载到 satp 中，这样硬件就知道新的 PTE 了。</p>
<p>&#x3D;&#x3D;每个 RISC-V CPU 都会在 Translation Look-aside Buffer(TLB) 中缓存页表项，当 xv6 改变页表时，必须告诉 CPU 使相应的缓存 TLB 项无效。&#x3D;&#x3D;如果它不这样做，那么在以后的某个时刻，TLB 可能会使用一个旧的缓存映射，指向一个物理页，而这个物理页在此期间已经分配给了另一个进程，这样的话，一个进程可能会在其他进程的内存上<code>乱写乱画</code>。</p>
<blockquote>
<p>RISC-V 有一条指令 sfence.vma，可以刷新当前 CPU 的TLB。xv6 在重新加载 satp 寄存器后，在kvminithart中执行 sfence.vma，也会在从内核空间返回用户空间前，切换到用户页表的trampoline代码中执行 sfence.vma。</p>
</blockquote>
<p><code>vm.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;param.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;memlayout.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;elf.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;riscv.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;defs.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;fs.h&quot;</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * the kernel&#x27;s page table.</span></span><br><span class="line"><span class="comment"> * 内核页表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">pagetable_t</span> kernel_pagetable;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">char</span> etext[];  <span class="comment">// kernel.ld sets this to end of kernel code.</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">char</span> trampoline[]; <span class="comment">// trampoline.S</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * create a direct-map page table for the kernel.</span></span><br><span class="line"><span class="comment"> * 为内核建立直接映射的页表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">kvminit</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 首先分配一页物理内存来存放根页表页</span></span><br><span class="line">  kernel_pagetable = (<span class="type">pagetable_t</span>) kalloc();</span><br><span class="line">  <span class="built_in">memset</span>(kernel_pagetable, <span class="number">0</span>, PGSIZE);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 调用 kvmmap 将内核所需要的硬件资源映射到物理地址,内存映射IO</span></span><br><span class="line">  <span class="comment">// uart registers</span></span><br><span class="line">  kvmmap(UART0, UART0, PGSIZE, PTE_R | PTE_W);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// virtio mmio disk interface</span></span><br><span class="line">  kvmmap(VIRTIO0, VIRTIO0, PGSIZE, PTE_R | PTE_W);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// CLINT</span></span><br><span class="line">  kvmmap(CLINT, CLINT, <span class="number">0x10000</span>, PTE_R | PTE_W);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// PLIC</span></span><br><span class="line">  kvmmap(PLIC, PLIC, <span class="number">0x400000</span>, PTE_R | PTE_W);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// map kernel text executable and read-only.</span></span><br><span class="line">  kvmmap(KERNBASE, KERNBASE, (uint64)etext-KERNBASE, PTE_R | PTE_X);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// map kernel data and the physical RAM we&#x27;ll make use of.</span></span><br><span class="line">  kvmmap((uint64)etext, (uint64)etext, PHYSTOP-(uint64)etext, PTE_R | PTE_W);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// map the trampoline for trap entry/exit to</span></span><br><span class="line">  <span class="comment">// the highest virtual address in the kernel.</span></span><br><span class="line">  kvmmap(TRAMPOLINE, (uint64)trampoline, PGSIZE, PTE_R | PTE_X);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Switch h/w page table register to the kernel&#x27;s page table,</span></span><br><span class="line"><span class="comment">// and enable paging.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">kvminithart</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 将根页表页的物理地址写入寄存器 satp 中</span></span><br><span class="line">  w_satp(MAKE_SATP(kernel_pagetable));</span><br><span class="line">  <span class="comment">// 刷新当前 CPU 的 TLB</span></span><br><span class="line">  sfence_vma();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Return the address of the PTE in page table pagetable</span></span><br><span class="line"><span class="comment">// that corresponds to virtual address va.  If alloc!=0,</span></span><br><span class="line"><span class="comment">// create any required page-table pages.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The risc-v Sv39 scheme has three levels of page-table</span></span><br><span class="line"><span class="comment">// pages. A page-table page contains 512 64-bit PTEs.</span></span><br><span class="line"><span class="comment">// A 64-bit virtual address is split into five fields:</span></span><br><span class="line"><span class="comment">//   39..63 -- must be zero.</span></span><br><span class="line"><span class="comment">//   30..38 -- 9 bits of level-2 index.</span></span><br><span class="line"><span class="comment">//   21..29 -- 9 bits of level-1 index.</span></span><br><span class="line"><span class="comment">//   12..20 -- 9 bits of level-0 index.</span></span><br><span class="line"><span class="comment">//    0..11 -- 12 bits of byte offset within the page.</span></span><br><span class="line"><span class="type">pte_t</span> *</span><br><span class="line"><span class="title function_">walk</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 va, <span class="type">int</span> alloc)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 虚拟地址不能超出最大范围</span></span><br><span class="line">  <span class="keyword">if</span>(va &gt;= MAXVA)</span><br><span class="line">    panic(<span class="string">&quot;walk&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> level = <span class="number">2</span>; level &gt; <span class="number">0</span>; level--) &#123;</span><br><span class="line">    <span class="comment">//使用每一级的 9 位虚拟地址来查找下一级页表或最后一级PTE</span></span><br><span class="line">    <span class="type">pte_t</span> *pte = &amp;pagetable[PX(level, va)];</span><br><span class="line">    <span class="comment">//PTE项有效</span></span><br><span class="line">    <span class="keyword">if</span>(*pte &amp; PTE_V) &#123;</span><br><span class="line">      <span class="comment">//当前PTE指向的下一级页表</span></span><br><span class="line">      pagetable = (<span class="type">pagetable_t</span>)PTE2PA(*pte);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//alloc为0或者新页表分配内存失败，直接退出</span></span><br><span class="line">      <span class="keyword">if</span>(!alloc || (pagetable = (<span class="type">pte_t</span>*)kalloc()) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      <span class="built_in">memset</span>(pagetable, <span class="number">0</span>, PGSIZE);</span><br><span class="line">      <span class="comment">//填充当前的PTE</span></span><br><span class="line">      *pte = PA2PTE(pagetable) | PTE_V;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//最终返回最后一级PTE</span></span><br><span class="line">  <span class="keyword">return</span> &amp;pagetable[PX(<span class="number">0</span>, va)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Look up a virtual address, return the physical address,</span></span><br><span class="line"><span class="comment">// or 0 if not mapped.</span></span><br><span class="line"><span class="comment">// Can only be used to look up user pages.</span></span><br><span class="line">uint64</span><br><span class="line"><span class="title function_">walkaddr</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 va)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">pte_t</span> *pte;</span><br><span class="line">  uint64 pa;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 校验虚拟地址范围正确性</span></span><br><span class="line">  <span class="keyword">if</span>(va &gt;= MAXVA)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 获得最后一级PTE</span></span><br><span class="line">  pte = walk(pagetable, va, <span class="number">0</span>);</span><br><span class="line">  <span class="comment">// ptr==0说明该虚拟地址没有对应的物理地址与之映射</span></span><br><span class="line">  <span class="keyword">if</span>(pte == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 当前pte已失效</span></span><br><span class="line">  <span class="keyword">if</span>((*pte &amp; PTE_V) == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 允许用户模式下的指令查看页面</span></span><br><span class="line">  <span class="keyword">if</span>((*pte &amp; PTE_U) == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="comment">//pte转为物理地址</span></span><br><span class="line">  pa = PTE2PA(*pte);</span><br><span class="line">  <span class="keyword">return</span> pa;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// add a mapping to the kernel page table.</span></span><br><span class="line"><span class="comment">// only used when booting.</span></span><br><span class="line"><span class="comment">// does not flush TLB or enable paging.</span></span><br><span class="line"><span class="comment">// 仅在boot启动阶段使用，映射的虚拟地址和物理地址都是连续的，注意在此之前end~PHYSTOP的物理内存块都被串联成单链表供内存分配</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">kvmmap</span><span class="params">(uint64 va, uint64 pa, uint64 sz, <span class="type">int</span> perm)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 它将一个虚拟地址范围映射到一个物理地址范围。它将范围内地址分割成多页（忽略余数），每次映射一页的顶端地址</span></span><br><span class="line">  <span class="keyword">if</span>(mappages(kernel_pagetable, va, sz, pa, perm) != <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;kvmmap&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// translate a kernel virtual address to</span></span><br><span class="line"><span class="comment">// a physical address. only needed for</span></span><br><span class="line"><span class="comment">// addresses on the stack.</span></span><br><span class="line"><span class="comment">// assumes va is page aligned.</span></span><br><span class="line">uint64</span><br><span class="line"><span class="title function_">kvmpa</span><span class="params">(uint64 va)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint64 off = va % PGSIZE;</span><br><span class="line">  <span class="type">pte_t</span> *pte;</span><br><span class="line">  uint64 pa;</span><br><span class="line">  </span><br><span class="line">  pte = walk(kernel_pagetable, va, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span>(pte == <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;kvmpa&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span>((*pte &amp; PTE_V) == <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;kvmpa&quot;</span>);</span><br><span class="line">  pa = PTE2PA(*pte);</span><br><span class="line">  <span class="keyword">return</span> pa+off;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create PTEs for virtual addresses starting at va that refer to</span></span><br><span class="line"><span class="comment">// physical addresses starting at pa. va and size might not</span></span><br><span class="line"><span class="comment">// be page-aligned. Returns 0 on success, -1 if walk() couldn&#x27;t</span></span><br><span class="line"><span class="comment">// allocate a needed page-table page.</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">mappages</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 va, uint64 size, uint64 pa, <span class="type">int</span> perm)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint64 a, last;</span><br><span class="line">  <span class="type">pte_t</span> *pte;</span><br><span class="line"></span><br><span class="line">  a = PGROUNDDOWN(va);<span class="comment">// 开始页地址</span></span><br><span class="line">  last = PGROUNDDOWN(va + size - <span class="number">1</span>);<span class="comment">// 终止页地址</span></span><br><span class="line">  <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">    <span class="comment">//调用 walk 找到该地址的最后一级 PTE 的地址</span></span><br><span class="line">    <span class="keyword">if</span>((pte = walk(pagetable, a, <span class="number">1</span>)) == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//如果PTE不空且有效则说明是重新映射</span></span><br><span class="line">    <span class="keyword">if</span>(*pte &amp; PTE_V)</span><br><span class="line">      panic(<span class="string">&quot;remap&quot;</span>);</span><br><span class="line">    <span class="comment">//PTE的0~9位是标志位，10~53位是物理页号，54~63位保留</span></span><br><span class="line">    *pte = PA2PTE(pa) | perm | PTE_V;</span><br><span class="line">    <span class="comment">//如果map的虚拟页到达终止页，结束该次mappages</span></span><br><span class="line">    <span class="keyword">if</span>(a == last)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">//当前映射页后移一页</span></span><br><span class="line">    a += PGSIZE;</span><br><span class="line">    pa += PGSIZE;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Remove npages of mappings starting from va. va must be</span></span><br><span class="line"><span class="comment">// page-aligned. The mappings must exist.</span></span><br><span class="line"><span class="comment">// Optionally free the physical memory.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">uvmunmap</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 va, uint64 npages, <span class="type">int</span> do_free)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint64 a;</span><br><span class="line">  <span class="type">pte_t</span> *pte;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//虚拟地址必须页对齐</span></span><br><span class="line">  <span class="keyword">if</span>((va % PGSIZE) != <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;uvmunmap: not aligned&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(a = va; a &lt; va + npages*PGSIZE; a += PGSIZE)&#123;</span><br><span class="line">    <span class="comment">// 页目录项必须存在</span></span><br><span class="line">    <span class="keyword">if</span>((pte = walk(pagetable, a, <span class="number">0</span>)) == <span class="number">0</span>)</span><br><span class="line">      panic(<span class="string">&quot;uvmunmap: walk&quot;</span>);</span><br><span class="line">    <span class="comment">// 页目录项必须有效</span></span><br><span class="line">    <span class="keyword">if</span>((*pte &amp; PTE_V) == <span class="number">0</span>)</span><br><span class="line">      panic(<span class="string">&quot;uvmunmap: not mapped&quot;</span>);</span><br><span class="line">    <span class="comment">// PTE是中间目录项(不是叶子目录项)</span></span><br><span class="line">    <span class="keyword">if</span>(PTE_FLAGS(*pte) == PTE_V)</span><br><span class="line">      panic(<span class="string">&quot;uvmunmap: not a leaf&quot;</span>);</span><br><span class="line">    <span class="comment">// 可选项，是否释放物理内存页</span></span><br><span class="line">    <span class="keyword">if</span>(do_free)&#123;</span><br><span class="line">      uint64 pa = PTE2PA(*pte);</span><br><span class="line">      kfree((<span class="type">void</span>*)pa);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//清空pte表项</span></span><br><span class="line">    *pte = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// create an empty user page table.</span></span><br><span class="line"><span class="comment">// returns 0 if out of memory.</span></span><br><span class="line"><span class="comment">// 创建一个空用户页表</span></span><br><span class="line"><span class="type">pagetable_t</span></span><br><span class="line"><span class="title function_">uvmcreate</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">pagetable_t</span> pagetable;</span><br><span class="line">  pagetable = (<span class="type">pagetable_t</span>) kalloc();</span><br><span class="line">  <span class="keyword">if</span>(pagetable == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 创建一个空的user页表</span></span><br><span class="line">  <span class="built_in">memset</span>(pagetable, <span class="number">0</span>, PGSIZE);</span><br><span class="line">  <span class="keyword">return</span> pagetable;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Load the user initcode into address 0 of pagetable,</span></span><br><span class="line"><span class="comment">// for the very first process.</span></span><br><span class="line"><span class="comment">// sz must be less than a page.</span></span><br><span class="line"><span class="comment">// uvminit(p-&gt;pagetable, initcode, sizeof(initcode));</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">uvminit</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uchar *src, uint sz)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> *mem;</span><br><span class="line">  <span class="comment">// initcode.S不超过一页</span></span><br><span class="line">  <span class="keyword">if</span>(sz &gt;= PGSIZE)</span><br><span class="line">    panic(<span class="string">&quot;inituvm: more than a page&quot;</span>);</span><br><span class="line">  mem = kalloc();</span><br><span class="line">  <span class="comment">// 空页初始化</span></span><br><span class="line">  <span class="built_in">memset</span>(mem, <span class="number">0</span>, PGSIZE);</span><br><span class="line">  <span class="comment">// 初始化进程的虚拟地址0映射到实际分配的物理页</span></span><br><span class="line">  mappages(pagetable, <span class="number">0</span>, PGSIZE, (uint64)mem, PTE_W|PTE_R|PTE_X|PTE_U);</span><br><span class="line">  <span class="comment">// 给实际的物理页填充内容</span></span><br><span class="line">  memmove(mem, src, sz);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Allocate PTEs and physical memory to grow process from oldsz to</span></span><br><span class="line"><span class="comment">// newsz, which need not be page aligned.  Returns new size or 0 on error.</span></span><br><span class="line">uint64</span><br><span class="line"><span class="title function_">uvmalloc</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 oldsz, uint64 newsz)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> *mem;</span><br><span class="line">  uint64 a;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(newsz &lt; oldsz)</span><br><span class="line">    <span class="keyword">return</span> oldsz;</span><br><span class="line">  <span class="comment">// 需要映射的下一个地址</span></span><br><span class="line">  oldsz = PGROUNDUP(oldsz);</span><br><span class="line">  <span class="keyword">for</span>(a = oldsz; a &lt; newsz; a += PGSIZE)&#123;</span><br><span class="line">    <span class="comment">// 分配一页物理内存</span></span><br><span class="line">    mem = kalloc();</span><br><span class="line">    <span class="keyword">if</span>(mem == <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="comment">// 分配过程中失败，则页表应该恢复到原来的大小</span></span><br><span class="line">      uvmdealloc(pagetable, a, oldsz);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 初始化物理页内容</span></span><br><span class="line">    <span class="built_in">memset</span>(mem, <span class="number">0</span>, PGSIZE);</span><br><span class="line">    <span class="comment">// 扩展的虚拟地址映射到新的物理地址</span></span><br><span class="line">    <span class="keyword">if</span>(mappages(pagetable, a, PGSIZE, (uint64)mem, PTE_W|PTE_X|PTE_R|PTE_U) != <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="comment">// 映射失败则释放当前分配的内存页，页表应该恢复到原来的大小</span></span><br><span class="line">      kfree(mem);</span><br><span class="line">      uvmdealloc(pagetable, a, oldsz);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newsz;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Deallocate user pages to bring the process size from oldsz to</span></span><br><span class="line"><span class="comment">// newsz.  oldsz and newsz need not be page-aligned, nor does newsz</span></span><br><span class="line"><span class="comment">// need to be less than oldsz.  oldsz can be larger than the actual</span></span><br><span class="line"><span class="comment">// process size.  Returns the new process size.</span></span><br><span class="line">uint64</span><br><span class="line"><span class="title function_">uvmdealloc</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 oldsz, uint64 newsz)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(newsz &gt;= oldsz)</span><br><span class="line">    <span class="keyword">return</span> oldsz;</span><br><span class="line">  <span class="comment">// 解除用户页表的部分内存映射</span></span><br><span class="line">  <span class="keyword">if</span>(PGROUNDUP(newsz) &lt; PGROUNDUP(oldsz))&#123;</span><br><span class="line">    <span class="comment">// 计算需要解除映射的页数</span></span><br><span class="line">    <span class="type">int</span> npages = (PGROUNDUP(oldsz) - PGROUNDUP(newsz)) / PGSIZE;</span><br><span class="line">    <span class="comment">// 从PGROUNDUP(newsz)开始移除npages页，并且释放对应的物理内存(do_free=1)</span></span><br><span class="line">    uvmunmap(pagetable, PGROUNDUP(newsz), npages, <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> newsz;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Recursively free page-table pages.</span></span><br><span class="line"><span class="comment">// All leaf mappings must already have been removed.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">freewalk</span><span class="params">(<span class="type">pagetable_t</span> pagetable)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// there are 2^9 = 512 PTEs in a page table.</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">512</span>; i++)&#123;</span><br><span class="line">    <span class="type">pte_t</span> pte = pagetable[i];</span><br><span class="line">    <span class="comment">// this PTE points to a lower-level page table.</span></span><br><span class="line">    <span class="comment">// PTE项是中间页表目录项</span></span><br><span class="line">    <span class="keyword">if</span>((pte &amp; PTE_V) &amp;&amp; (pte &amp; (PTE_R|PTE_W|PTE_X)) == <span class="number">0</span>)&#123;    </span><br><span class="line">      <span class="comment">// 进入下一级页表进行页表页释放</span></span><br><span class="line">      uint64 child = PTE2PA(pte);</span><br><span class="line">      freewalk((<span class="type">pagetable_t</span>)child);</span><br><span class="line">      <span class="comment">// PTE对应的下级页表释放完毕，PTE项置零</span></span><br><span class="line">      pagetable[i] = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(pte &amp; PTE_V)&#123;</span><br><span class="line">      <span class="comment">// 所有叶子目录的映射本应该在此之前全部移除</span></span><br><span class="line">      panic(<span class="string">&quot;freewalk: leaf&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 页目录项全部置零后释放该级页表</span></span><br><span class="line">  kfree((<span class="type">void</span>*)pagetable);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Free user memory pages,</span></span><br><span class="line"><span class="comment">// then free page-table pages.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">uvmfree</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 sz)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 释放用户内存页</span></span><br><span class="line">  <span class="keyword">if</span>(sz &gt; <span class="number">0</span>)</span><br><span class="line">    uvmunmap(pagetable, <span class="number">0</span>, PGROUNDUP(sz)/PGSIZE, <span class="number">1</span>);</span><br><span class="line">  <span class="comment">// 释放页表页</span></span><br><span class="line">  freewalk(pagetable);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Given a parent process&#x27;s page table, copy</span></span><br><span class="line"><span class="comment">// its memory into a child&#x27;s page table.</span></span><br><span class="line"><span class="comment">// Copies both the page table and the</span></span><br><span class="line"><span class="comment">// physical memory.</span></span><br><span class="line"><span class="comment">// returns 0 on success, -1 on failure.</span></span><br><span class="line"><span class="comment">// frees any allocated pages on failure.</span></span><br><span class="line"><span class="comment">// fork创建子进程时会默认为子进程分配物理内存，并将父进程的内存复制到子进程中</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">uvmcopy</span><span class="params">(<span class="type">pagetable_t</span> old, <span class="type">pagetable_t</span> new, uint64 sz)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">pte_t</span> *pte;</span><br><span class="line">  uint64 pa, i;</span><br><span class="line">  uint flags;</span><br><span class="line">  <span class="type">char</span> *mem;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; sz; i += PGSIZE)&#123;</span><br><span class="line">    <span class="comment">// 页目录项必须存在</span></span><br><span class="line">    <span class="keyword">if</span>((pte = walk(old, i, <span class="number">0</span>)) == <span class="number">0</span>)</span><br><span class="line">      panic(<span class="string">&quot;uvmcopy: pte should exist&quot;</span>);</span><br><span class="line">    <span class="comment">// 页目录项必须有效</span></span><br><span class="line">    <span class="keyword">if</span>((*pte &amp; PTE_V) == <span class="number">0</span>)</span><br><span class="line">      panic(<span class="string">&quot;uvmcopy: page not present&quot;</span>);</span><br><span class="line">    <span class="comment">// 虚拟地址从0开始的i对应的物理地址</span></span><br><span class="line">    pa = PTE2PA(*pte);</span><br><span class="line">    <span class="comment">// 页目录项的低10位标志位</span></span><br><span class="line">    flags = PTE_FLAGS(*pte);</span><br><span class="line">    <span class="comment">// 为子进程分配物理内存</span></span><br><span class="line">    <span class="keyword">if</span>((mem = kalloc()) == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">goto</span> err;</span><br><span class="line">    <span class="comment">// 把父进程的内存搬至子进程</span></span><br><span class="line">    memmove(mem, (<span class="type">char</span>*)pa, PGSIZE);</span><br><span class="line">    <span class="comment">// 完成子进程的页表地址映射</span></span><br><span class="line">    <span class="keyword">if</span>(mappages(new, i, PGSIZE, (uint64)mem, flags) != <span class="number">0</span>)&#123;</span><br><span class="line">      kfree(mem);</span><br><span class="line">      <span class="keyword">goto</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"> err:</span><br><span class="line">  <span class="comment">// 失败情况下需要释放所有已分配的页</span></span><br><span class="line">  uvmunmap(new, <span class="number">0</span>, i / PGSIZE, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// mark a PTE invalid for user access.</span></span><br><span class="line"><span class="comment">// used by exec for the user stack guard page.</span></span><br><span class="line"><span class="comment">// PTE项标记为用户模式无法访问，用于exec执行用户程序的用户栈后的守护页(发生栈溢出时就会报错无法访问特权内存区)</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">uvmclear</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 va)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">pte_t</span> *pte;</span><br><span class="line">  </span><br><span class="line">  pte = walk(pagetable, va, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span>(pte == <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;uvmclear&quot;</span>);</span><br><span class="line">  *pte &amp;= ~PTE_U;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Copy from kernel to user.</span></span><br><span class="line"><span class="comment">// Copy len bytes from src to virtual address dstva in a given page table.</span></span><br><span class="line"><span class="comment">// Return 0 on success, -1 on error.</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">copyout</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 dstva, <span class="type">char</span> *src, uint64 len)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint64 n, va0, pa0;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(len &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">// 虚拟地址dstva开始页</span></span><br><span class="line">    va0 = PGROUNDDOWN(dstva);</span><br><span class="line">    <span class="comment">// 虚拟地址对应的物理地址</span></span><br><span class="line">    pa0 = walkaddr(pagetable, va0);</span><br><span class="line">    <span class="keyword">if</span>(pa0 == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">// 需要copy的字节数，开始页比较特殊（不一定全部copy）</span></span><br><span class="line">    n = PGSIZE - (dstva - va0);</span><br><span class="line">    <span class="comment">// 多出的部分需要截断</span></span><br><span class="line">    <span class="keyword">if</span>(n &gt; len)</span><br><span class="line">      n = len;</span><br><span class="line">    <span class="comment">// 把src开始处的n个字节拷贝到实际的物理地址处pa0 + (dstva - va0)</span></span><br><span class="line">    memmove((<span class="type">void</span> *)(pa0 + (dstva - va0)), src, n);</span><br><span class="line">    <span class="comment">// 待拷贝字节数减少n，src后移n，dstva跳到下一页开始处（page aligend）</span></span><br><span class="line">    len -= n;</span><br><span class="line">    src += n;</span><br><span class="line">    dstva = va0 + PGSIZE;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Copy from user to kernel.</span></span><br><span class="line"><span class="comment">// Copy len bytes to dst from virtual address srcva in a given page table.</span></span><br><span class="line"><span class="comment">// Return 0 on success, -1 on error.</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">copyin</span><span class="params">(<span class="type">pagetable_t</span> pagetable, <span class="type">char</span> *dst, uint64 srcva, uint64 len)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint64 n, va0, pa0;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(len &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">// 虚拟地址srcva的开始页</span></span><br><span class="line">    va0 = PGROUNDDOWN(srcva);</span><br><span class="line">    <span class="comment">// 虚拟地址对应的物理地址</span></span><br><span class="line">    pa0 = walkaddr(pagetable, va0);</span><br><span class="line">    <span class="keyword">if</span>(pa0 == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">// 当前页实际需要拷贝的字节数</span></span><br><span class="line">    n = PGSIZE - (srcva - va0);</span><br><span class="line">    <span class="keyword">if</span>(n &gt; len)</span><br><span class="line">      n = len;</span><br><span class="line">    <span class="comment">// 把物理地址pa0 + (srcva - va0)处的n个字节拷贝到dst处</span></span><br><span class="line">    memmove(dst, (<span class="type">void</span> *)(pa0 + (srcva - va0)), n);</span><br><span class="line">    <span class="comment">// 待拷贝字节数减少n，dst后移n，srcva跳到下一页开始处（page aligend）</span></span><br><span class="line">    len -= n;</span><br><span class="line">    dst += n;</span><br><span class="line">    srcva = va0 + PGSIZE;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Copy a null-terminated string from user to kernel.</span></span><br><span class="line"><span class="comment">// Copy bytes to dst from virtual address srcva in a given page table,</span></span><br><span class="line"><span class="comment">// until a &#x27;\0&#x27;, or max.</span></span><br><span class="line"><span class="comment">// Return 0 on success, -1 on error.</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">copyinstr</span><span class="params">(<span class="type">pagetable_t</span> pagetable, <span class="type">char</span> *dst, uint64 srcva, uint64 max)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint64 n, va0, pa0;</span><br><span class="line">  <span class="comment">// 字符串终止结束符标志位</span></span><br><span class="line">  <span class="type">int</span> got_null = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 没有遇到字符串终止&#x27;\0&#x27;并且复制字符数还没有达到max</span></span><br><span class="line">  <span class="keyword">while</span>(got_null == <span class="number">0</span> &amp;&amp; max &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">// srcva虚拟地址的起始页</span></span><br><span class="line">    va0 = PGROUNDDOWN(srcva);</span><br><span class="line">    <span class="comment">// walkaddr模拟分页硬件确定 va0 的物理地址 pa0</span></span><br><span class="line">    pa0 = walkaddr(pagetable, va0);</span><br><span class="line">    <span class="keyword">if</span>(pa0 == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">// 需要复制的字节数</span></span><br><span class="line">    n = PGSIZE - (srcva - va0);</span><br><span class="line">    <span class="comment">// 确保不多复制</span></span><br><span class="line">    <span class="keyword">if</span>(n &gt; max)</span><br><span class="line">      n = max;</span><br><span class="line">    <span class="comment">// 待复制字节的源物理地址开始处</span></span><br><span class="line">    <span class="type">char</span> *p = (<span class="type">char</span> *) (pa0 + (srcva - va0));</span><br><span class="line">    <span class="keyword">while</span>(n &gt; <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="comment">// 遇到终止符结束copy</span></span><br><span class="line">      <span class="keyword">if</span>(*p == <span class="string">&#x27;\0&#x27;</span>)&#123;</span><br><span class="line">        *dst = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        got_null = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 否则一直复制</span></span><br><span class="line">        *dst = *p;</span><br><span class="line">      &#125;</span><br><span class="line">      --n;</span><br><span class="line">      --max;</span><br><span class="line">      p++;</span><br><span class="line">      <span class="comment">// 可以看出，目标地址(dst==buf)应该是连续一块内存</span></span><br><span class="line">      dst++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 切换到下一页继续复制</span></span><br><span class="line">    srcva = va0 + PGSIZE;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(got_null)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-4物理内存分配"><a href="#3-4物理内存分配" class="headerlink" title="3.4物理内存分配"></a>3.4物理内存分配</h4><p>内核必须在运行时为页表、用户内存、内核堆栈和管道缓冲区分配和释放物理内存。<code>xv6使用内核地址结束 end 到 PHYSTOP 之间的物理内存进行运行时分配。</code>它每次分配和释放整个4096 字节的页面。它通过保存空闲页链表，来记录哪些页是空闲的。分配包括从链表中删除一页；释放包括将释放的页面添加到空闲页链表中。</p>
<p>分配器在 kalloc.c 中。<code>分配器的数据结构是一个可供分配的物理内存页的空闲页链表，每个空闲页的链表元素是一个结构体 run。</code>分配器从哪里获得内存来存放这个结构体呢？&#x3D;&#x3D;它把每个空闲页的 run 结构体存储在空闲页本身，因为那里没有其他东西存储。&#x3D;&#x3D;空闲链表由一个自旋锁保护。链表和锁被包裹在一个结构体中，以明确锁保护的是结构体中的空闲链表字段。</p>
<p>main 函数调用 kinit 来初始化分配器。kinit 初始空闲页链表，以保存内核地址结束 end 到 PHYSTOP 之间的每一页。<code>xv6 应该通过解析硬件提供的配置信息来确定有多少物理内存可用，但是它没有做，而是假设机器有 128M 字节的 RAM。</code>kinit 通过调用freerange 来添加内存到空闲页链表，freerange 则对每一页都调用 kfree。PTE 只能引用按4096 字节边界对齐的物理地址(4096 的倍数)，因此 freerange 使用 PGROUNDUP 来确保它只添加对齐的物理地址到空闲链表中。分配器开始时没有内存，这些对 kfree 的调用给了它一些内存管理。</p>
<blockquote>
<p>分配器有时把地址当作整数来处理，以便对其进行运算（如 freerange 遍历所有页），有时把地址当作指针来读写内存（如操作存储在每页中的 run 结构体）；这种对地址的双重使用是分配器代码中充满 C 类型转换的主要原因。另一个原因是，释放和分配本质上改变了内存的类型。</p>
</blockquote>
<p><code>kalloc.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Physical memory allocator, for user processes,</span></span><br><span class="line"><span class="comment">// kernel stacks, page-table pages,</span></span><br><span class="line"><span class="comment">// and pipe buffers. Allocates whole 4096-byte pages.</span></span><br><span class="line"><span class="comment">// 物理内存分配器，分配单位是4k字节</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;param.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;memlayout.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;spinlock.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;riscv.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;defs.h&quot;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">freerange</span><span class="params">(<span class="type">void</span> *pa_start, <span class="type">void</span> *pa_end)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">char</span> end[]; <span class="comment">// first address after kernel.</span></span><br><span class="line">                   <span class="comment">// defined by kernel.ld.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 每个空闲页的 run 结构体存储在空闲页本身</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">run</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 空闲链表由一个自旋锁保护</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">freelist</span>;</span></span><br><span class="line">&#125; kmem;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">kinit</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  initlock(&amp;kmem.lock, <span class="string">&quot;kmem&quot;</span>);</span><br><span class="line">  <span class="comment">// 初始空闲页链表，以保存内核地址结束end到PHYSTOP之间的每一页</span></span><br><span class="line">  <span class="comment">// xv6 应该通过解析硬件提供的配置信息来确定有多少物理内存可用。</span></span><br><span class="line">  <span class="comment">// 但是它没有做，而是假设机器有128M字节的RAM</span></span><br><span class="line">  freerange(end, (<span class="type">void</span>*)PHYSTOP);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">freerange</span><span class="params">(<span class="type">void</span> *pa_start, <span class="type">void</span> *pa_end)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> *p;</span><br><span class="line">  p = (<span class="type">char</span>*)PGROUNDUP((uint64)pa_start);</span><br><span class="line">  <span class="keyword">for</span>(; p + PGSIZE &lt;= (<span class="type">char</span>*)pa_end; p += PGSIZE)</span><br><span class="line">    kfree(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Free the page of physical memory pointed at by v,</span></span><br><span class="line"><span class="comment">// which normally should have been returned by a</span></span><br><span class="line"><span class="comment">// call to kalloc().  (The exception is when</span></span><br><span class="line"><span class="comment">// initializing the allocator; see kinit above.)</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">kfree</span><span class="params">(<span class="type">void</span> *pa)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span>;</span></span><br><span class="line">  <span class="keyword">if</span>(((uint64)pa % PGSIZE) != <span class="number">0</span> || (<span class="type">char</span>*)pa &lt; end || (uint64)pa &gt;= PHYSTOP)</span><br><span class="line">    panic(<span class="string">&quot;kfree&quot;</span>);</span><br><span class="line">  <span class="comment">// Fill with junk to catch dangling refs.</span></span><br><span class="line">  <span class="comment">// 这将使得释放内存后使用内存的代码(使用悬空引用)读取垃圾而不是旧的有效内容；</span></span><br><span class="line">  <span class="comment">// 希望这将导致这类代码更快地崩溃</span></span><br><span class="line">  <span class="built_in">memset</span>(pa, <span class="number">1</span>, PGSIZE);</span><br><span class="line">  r = (<span class="keyword">struct</span> run*)pa;</span><br><span class="line">  acquire(&amp;kmem.lock);</span><br><span class="line">  r-&gt;next = kmem.freelist;</span><br><span class="line">  kmem.freelist = r;</span><br><span class="line">  release(&amp;kmem.lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Allocate one 4096-byte page of physical memory.</span></span><br><span class="line"><span class="comment">// Returns a pointer that the kernel can use.</span></span><br><span class="line"><span class="comment">// Returns 0 if the memory cannot be allocated.</span></span><br><span class="line"><span class="type">void</span> *</span><br><span class="line"><span class="title function_">kalloc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span>;</span></span><br><span class="line">  acquire(&amp;kmem.lock);</span><br><span class="line">  r = kmem.freelist;</span><br><span class="line">  <span class="keyword">if</span>(r)</span><br><span class="line">    kmem.freelist = r-&gt;next;</span><br><span class="line">  release(&amp;kmem.lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(r)&#123;</span><br><span class="line">    <span class="built_in">memset</span>((<span class="type">char</span>*)r, <span class="number">5</span>, PGSIZE); <span class="comment">// fill with junk</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// kalloc 移除并返回空闲链表中的第一个元素</span></span><br><span class="line">  <span class="keyword">return</span> (<span class="type">void</span>*)r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-5进程地址空间"><a href="#3-5进程地址空间" class="headerlink" title="3.5进程地址空间"></a>3.5进程地址空间</h4><p>每个进程都有一个单独的页表，当 xv6 在进程间切换时，也会改变页表。如图 2.3 所示，一个进程的用户内存从虚拟地址 0 开始，可以增长到 MAXVA，原则上允许一个进程寻址 256GB 的内存。</p>
<p><code>当一个进程要求 xv6 提供更多的用户内存时，xv6 首先使用 kalloc 来分配物理页，然后将指向新物理页的 PTE 添加到进程的页表中，xv6 在这些 PTE 中设置 PTE_W、PTE_X、PTE_R、PTE_U 和 PTE_V 标志。</code>大多数进程不使用整个用户地址空间；xv6 使用 PTE_V 来清除不使用的 PTE。</p>
<p>我们在这里看到了几个例子，是关于使用页表的。首先，不同的进程页表将用户地址转化为物理内存的不同页，这样每个进程都有私有的用户内存。第二，每个进程都认为自己的内存具有从零开始的连续的虚拟地址，而进程的物理内存可以是不连续的。第三，内核会映射带有 trampoline 代码的页，该 trampoline 处于用户地址空间顶端，因此，在所有地址空间中都会出现一页物理内存。</p>
<p><img src="/../../../../../../imgs/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%BA%90%E7%A0%81%E7%BA%A7%E5%89%96%E6%9E%90/image-20221114180046008.png" alt="image-20221114180046008"></p>
<p>图 3.4 更详细地显示了 xv6 中执行进程的用户内存布局。栈只有一页，图中显示的是由exec 创建的初始内容。字符串的值，以及指向这些参数的指针数组，位于栈的最顶端。下面是允许程序在 main 启动的值，就像函数 main(argc, argv)刚刚被调用一样。</p>
<p>&#x3D;&#x3D;为了检测用户栈溢出分配的栈内存，xv6 会在 stack 的下方放置一个无效的保护页。如果用户栈溢出，而进程试图使用栈下面的地址，硬件会因为该映射无效而产生一个页错误异常。现实世界中的操作系统可能会在用户栈溢出时自动为其分配更多的内存。&#x3D;&#x3D;</p>
<h4 id="3-6sbrk解析"><a href="#3-6sbrk解析" class="headerlink" title="3.6sbrk解析"></a>3.6sbrk解析</h4><p><code>sbrk 是一个进程收缩或增长内存的系统调用。</code>该系统调用由函数growproc实现，growproc 调用 uvmalloc 或 uvmdealloc，取决于 n 是正数还是负数。uvmdealloc 调用 uvmunmap ，它使用 walk 来查找 PTE，使用 kfree 来释放它们所引用的物理内存。</p>
<p><code>xv6 使用进程的页表不仅是为了告诉硬件如何映射用户虚拟地址，也是将其作为分配给该进程的物理地址的唯一记录。</code>这就是为什么释放用户内存（uvmunmap中）需要检查用户页表的原因。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Grow or shrink user memory by n bytes.</span></span><br><span class="line"><span class="comment">// Return 0 on success, -1 on failure.</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">growproc</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint sz;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">  sz = p-&gt;sz;</span><br><span class="line">  <span class="keyword">if</span>(n &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>((sz = uvmalloc(p-&gt;pagetable, sz, sz + n)) == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>(n &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    sz = uvmdealloc(p-&gt;pagetable, sz, sz + n);</span><br><span class="line">  &#125;</span><br><span class="line">  p-&gt;sz = sz;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-7exec解析"><a href="#3-7exec解析" class="headerlink" title="3.7exec解析"></a>3.7exec解析</h4><blockquote>
<p>参考资料：<a target="_blank" rel="noopener" href="https://paper.seebug.org/papers/Archive/refs/elf/Understanding_ELF.pdf">https://paper.seebug.org/papers/Archive/refs/elf/Understanding_ELF.pdf</a></p>
</blockquote>
<p>exec 是创建用户地址空间的系统调用。<code>它读取储存在文件系统上的文件用来初始化用户地址空间。</code>exec使用 namei 打开二进制文件路径，然后它读取 ELF 头。xv6 应用程序用 ELF 格式来描述可执行文件，它定义在kernel&#x2F;elf.h。一个 ELF 二进制文件包括一个 ELF 头(elfhdr 结构体)，后面是一个程序节头 (program section header) 序列， 程序节头为一个结构体proghdr。每一个 proghdr 描述了一个必须加载到内存中的程序节；xv6 程序只有一个程序节头，但其他系统可能有单独的指令节和数据节需要加载到内存。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Format of an ELF executable file</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ELF_MAGIC 0x464C457FU  <span class="comment">// &quot;\x7FELF&quot; in little endian</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// File header</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">elfhdr</span> &#123;</span></span><br><span class="line">  <span class="comment">// 最开始处的这 16 个字节含有 ELF 文件的识别标志，并且提供了一些用于解码和解析文件内容的数据，是不依赖于具体操作系统的。ELF 文件最开始的这一部分的格式是固定并通用的，在所有平台上都一样。所有处理器都可能用固定的格式去读取这一部分的内容，从而获知这个 ELF 文件中接下来的内容应该如何读取和解析。</span></span><br><span class="line">  uint magic;  <span class="comment">// must equal ELF_MAGIC</span></span><br><span class="line">  <span class="comment">// ELF 标识，即前述 ELF 文件头结构最开始的 16 个字节，作为一个数组，它的各个索引位置的字节数据有固定的含义。</span></span><br><span class="line">  uchar elf[<span class="number">12</span>];</span><br><span class="line">  <span class="comment">// 此字段表明本目标文件属于哪种类型:可重定位文件/可执行文件/动态链接库文件</span></span><br><span class="line">  ushort type;</span><br><span class="line">  <span class="comment">// 此字段用于指定该文件适用的处理器体系结构。</span></span><br><span class="line">  ushort machine;</span><br><span class="line">  <span class="comment">// 此字段指明目标文件的版本。</span></span><br><span class="line">  uint version;</span><br><span class="line">  <span class="comment">// 此字段指明程序入口的虚拟地址。即当文件被加载到进程空间里后，入口程序在进程地址空间里的地址。对于可执行程序文件来说，当 ELF 文件完成加载之后，程序将从这里开始运行；而对于其它文件来说，这个值应该是 0。</span></span><br><span class="line">  uint64 entry;</span><br><span class="line">  <span class="comment">// 此字段指明程序头表(program header table)开始处在文件中的偏移量。如果没有程序头表，该值应设为 0。</span></span><br><span class="line">  uint64 phoff;</span><br><span class="line">  <span class="comment">// 此字段指明节头表(section header table)开始处在文件中的偏移量。如果没有节头表，该值应设为 0。</span></span><br><span class="line">  uint64 shoff;</span><br><span class="line">  <span class="comment">// 此字段含有处理器特定的标志位.</span></span><br><span class="line">  uint flags;</span><br><span class="line">  <span class="comment">// 此字段表明 ELF 文件头的大小，以字节为单位。</span></span><br><span class="line">  ushort ehsize;</span><br><span class="line">  <span class="comment">// 此字段表明在程序头表中每一个表项的大小，以字节为单位。</span></span><br><span class="line">  ushort phentsize;</span><br><span class="line">  <span class="comment">// 此字段表明程序头表中总共有多少个表项。如果一个目标文件中没有程序头表，该值应设为 0。</span></span><br><span class="line">  ushort phnum;</span><br><span class="line">  <span class="comment">// 此字段表明在节头表中每一个表项的大小，以字节为单位。</span></span><br><span class="line">  ushort shentsize;</span><br><span class="line">  <span class="comment">// 此字段表明节头表中总共有多少个表项。如果一个目标文件中没有节头表，该值应设为 0。</span></span><br><span class="line">  ushort shnum;</span><br><span class="line">  <span class="comment">// 节头表中与节名字表相对应的表项的索引。如果文件没有节名字表，此值应设置为 SHN_UNDEF。</span></span><br><span class="line">  ushort shstrndx;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Program section header</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proghdr</span> &#123;</span></span><br><span class="line">  <span class="comment">// 此数据成员说明了本程序头所描述的段的类型，或者如何解析本程序头的信息。</span></span><br><span class="line">  uint32 type;</span><br><span class="line">  <span class="comment">// 此数据成员给出了本段内容的属性。</span></span><br><span class="line">  uint32 flags;</span><br><span class="line">  <span class="comment">// 此数据成员给出本段内容在文件中的位置，即段内容的开始位置相对于文件开头的偏移量。</span></span><br><span class="line">  uint64 off;</span><br><span class="line">  <span class="comment">// 此数据成员给出本段内容的开始位置在进程空间中的虚拟地址。</span></span><br><span class="line">  uint64 vaddr;</span><br><span class="line">  <span class="comment">// 此数据成员给出本段内容的开始位置在进程空间中的物理地址。对于目前大多数现代操作系统而言，应用程序中段的物理地址事先是不可知的，所以目前这个成员多数情况下保留不用，或者被操作系统改作它用。</span></span><br><span class="line">  uint64 paddr;</span><br><span class="line">  <span class="comment">// 此数据成员给出本段内容在文件中的大小，单位是字节，可以是 0。</span></span><br><span class="line">  uint64 filesz;</span><br><span class="line">  <span class="comment">// 此数据成员给出本段内容在内容镜像中的大小，单位是字节，可以是 0。</span></span><br><span class="line">  uint64 memsz;</span><br><span class="line">  <span class="comment">// 对于可装载的段来说，其 p_vaddr 和 p_offset 的值至少要向内存页面大小对齐。此数据成员指明本段内容如何在内存和文件中对齐。如果该值为 0 或 1，表明没有对齐要求；否则，p_align 应该是一个正整数，并且是 2 的幂次数。p_vaddr 和p_offset 在对 p_align 取模后应该相等。</span></span><br><span class="line">  uint64 align;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Values for Proghdr type</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ELF_PROG_LOAD           1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Flag bits for Proghdr flags</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ELF_PROG_FLAG_EXEC      1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ELF_PROG_FLAG_WRITE     2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ELF_PROG_FLAG_READ      4</span></span><br></pre></td></tr></table></figure>

<p>第一步是快速检查文件是否包含一个 ELF 二进制文件。一个 ELF 二进制文件以<code>四个字节的魔法数字0x7FELF</code>或 <code>ELF_MAGIC</code>开始。如果 ELF 头有正确的魔法数字，exec 就会认为该二进制文件是正确的类型。</p>
<p><code>exec使用proc_pagetable分配一个没有使用的页表，使用uvmalloc为每一个ELF段分配内存，通过 loadseg加载每一个段到内存中。loadseg使用walkaddr找到分配内存的物理地址，在该地址写入 ELF段的每一页，页的内容通过readi从文件中读取。</code></p>
<p>&#x3D;&#x3D;exec 在栈页的下方放置了一个不可访问页，这样程序如果试图使用多个页面，就会出现故障。这个不可访问的页允许 exec 处理过大的参数；在这种情况下，exec 用来复制参数到栈的 copyout函数会注意到目标页不可访问，并返回-1。&#x3D;&#x3D;</p>
<p>在准备新的内存映像的过程中，如果 exec 检测到一个错误，比如一个无效的程序段，它就会跳转到标签 bad，释放新的映像，并返回-1。exec 必须延迟释放旧映像，直到它确定exec 系统调用会成功：如果旧映像消失了，系统调用就不能返回-1。exec 中唯一的错误情况发生在创建映像的过程中。一旦镜像完成，exec 就可以提交到新的页表并释放旧的页表。</p>
<p><code>Exec 将 ELF 文件中的字节按 ELF 文件指定的地址加载到内存中。用户或进程可以将任何他们想要的地址放入 ELF 文件中。因此，Exec 是有风险的，因为 ELF 文件中的地址可能会意外地或故意地指向内核。</code>对于一个不小心的内核来说，后果可能从崩溃到恶意颠覆内核的隔离机制(即安全漏洞)。xv6 执行了一些检查来避免这些风险。例如 if(ph.vaddr + ph.memsz &lt; ph.vaddr)检查总和是否溢出一个 64 位整数。<code>危险的是，用户可以用指向用户选择的地址的 ph.vaddr 和足够大的 ph.memsz 来构造一个 ELF 二进制，使总和溢出到 0x1000，这看起来像是一个有效值。</code>在旧版本的 xv6 中，用户地址空间也包含内核（但在用户模式下不可读&#x2F;写），用户可以选择一个对应内核内存的地址，从而将 ELF 二进制中的数据复制到内核中。<code>在 RISC-V 版本的 xv6 中，这是不可能的，因为内核有自己独立的页表；loadseg 加载到进程的页表中，而不是内核的页表中。</code></p>
<p>&#x3D;&#x3D;内核开发人员很容易忽略一个关键的检查，现实中的内核有很长一段缺少检查的空档期，用户程序可以利用缺少这些检查来获得内核特权。xv6 在验证需要提供给内核的用户程序数据的时候，并没有完全验证其是否是恶意的，恶意用户程序可能利用这些数据来绕过 xv6 的隔离。&#x3D;&#x3D;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">exec</span><span class="params">(<span class="type">char</span> *path, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> *s, *last;</span><br><span class="line">  <span class="type">int</span> i, off;</span><br><span class="line">  uint64 argc, sz = <span class="number">0</span>, sp, ustack[MAXARG+<span class="number">1</span>], stackbase;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">elfhdr</span> <span class="title">elf</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">ip</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proghdr</span> <span class="title">ph</span>;</span></span><br><span class="line">  <span class="type">pagetable_t</span> pagetable = <span class="number">0</span>, oldpagetable;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">  begin_op();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>((ip = namei(path)) == <span class="number">0</span>)&#123;</span><br><span class="line">    end_op();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ilock(ip);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Check ELF header</span></span><br><span class="line">  <span class="comment">// 一个 ELF 二进制文件包括一个 ELF 头，elfhdr 结构体</span></span><br><span class="line">  <span class="keyword">if</span>(readi(ip, <span class="number">0</span>, (uint64)&amp;elf, <span class="number">0</span>, <span class="keyword">sizeof</span>(elf)) != <span class="keyword">sizeof</span>(elf))</span><br><span class="line">    <span class="keyword">goto</span> bad;</span><br><span class="line">  <span class="comment">// 如果 ELF 头有正确的&quot;魔法数字&quot;，exec 就会认为该二进制文件是正确的类型。</span></span><br><span class="line">  <span class="keyword">if</span>(elf.magic != ELF_MAGIC)</span><br><span class="line">    <span class="keyword">goto</span> bad;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 分配一个没有使用的页表</span></span><br><span class="line">  <span class="keyword">if</span>((pagetable = proc_pagetable(p)) == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">goto</span> bad;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Load program into memory.</span></span><br><span class="line">  <span class="comment">// 根据程序头表把程序加载进内存中</span></span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>, off=elf.phoff; i&lt;elf.phnum; i++, off+=<span class="keyword">sizeof</span>(ph))&#123;</span><br><span class="line">    <span class="keyword">if</span>(readi(ip, <span class="number">0</span>, (uint64)&amp;ph, off, <span class="keyword">sizeof</span>(ph)) != <span class="keyword">sizeof</span>(ph))</span><br><span class="line">      <span class="keyword">goto</span> bad;</span><br><span class="line">    <span class="keyword">if</span>(ph.type != ELF_PROG_LOAD)</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">if</span>(ph.memsz &lt; ph.filesz)</span><br><span class="line">      <span class="keyword">goto</span> bad;</span><br><span class="line">    <span class="keyword">if</span>(ph.vaddr + ph.memsz &lt; ph.vaddr)</span><br><span class="line">      <span class="keyword">goto</span> bad;</span><br><span class="line">    uint64 sz1;</span><br><span class="line">    <span class="keyword">if</span>((sz1 = uvmalloc(pagetable, sz, ph.vaddr + ph.memsz)) == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">goto</span> bad;</span><br><span class="line">    sz = sz1;</span><br><span class="line">    <span class="keyword">if</span>(ph.vaddr % PGSIZE != <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">goto</span> bad;</span><br><span class="line">    <span class="keyword">if</span>(loadseg(pagetable, ph.vaddr, ip, ph.off, ph.filesz) &lt; <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">goto</span> bad;</span><br><span class="line">  &#125;</span><br><span class="line">  iunlockput(ip);</span><br><span class="line">  end_op();</span><br><span class="line">  ip = <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 保存原进程的大小便于内存清理</span></span><br><span class="line">  p = myproc();</span><br><span class="line">  uint64 oldsz = p-&gt;sz;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Allocate two pages at the next page boundary.</span></span><br><span class="line">  <span class="comment">// Use the second as the user stack.</span></span><br><span class="line">  <span class="comment">// 分配两页作为用户栈使用</span></span><br><span class="line">  sz = PGROUNDUP(sz);</span><br><span class="line">  uint64 sz1;</span><br><span class="line">  <span class="keyword">if</span>((sz1 = uvmalloc(pagetable, sz, sz + <span class="number">2</span>*PGSIZE)) == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">goto</span> bad;</span><br><span class="line">  sz = sz1;</span><br><span class="line">  uvmclear(pagetable, sz<span class="number">-2</span>*PGSIZE);</span><br><span class="line">  sp = sz;</span><br><span class="line">  stackbase = sp - PGSIZE;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Push argument strings, prepare rest of stack in ustack.</span></span><br><span class="line">  <span class="keyword">for</span>(argc = <span class="number">0</span>; argv[argc]; argc++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(argc &gt;= MAXARG)</span><br><span class="line">      <span class="keyword">goto</span> bad;</span><br><span class="line">    sp -= <span class="built_in">strlen</span>(argv[argc]) + <span class="number">1</span>;</span><br><span class="line">    sp -= sp % <span class="number">16</span>; <span class="comment">// riscv sp must be 16-byte aligned</span></span><br><span class="line">    <span class="keyword">if</span>(sp &lt; stackbase)</span><br><span class="line">      <span class="keyword">goto</span> bad;</span><br><span class="line">    <span class="keyword">if</span>(copyout(pagetable, sp, argv[argc], <span class="built_in">strlen</span>(argv[argc]) + <span class="number">1</span>) &lt; <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">goto</span> bad;</span><br><span class="line">    ustack[argc] = sp;</span><br><span class="line">  &#125;</span><br><span class="line">  ustack[argc] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// push the array of argv[] pointers.</span></span><br><span class="line">  sp -= (argc+<span class="number">1</span>) * <span class="keyword">sizeof</span>(uint64);</span><br><span class="line">  sp -= sp % <span class="number">16</span>;</span><br><span class="line">  <span class="keyword">if</span>(sp &lt; stackbase)</span><br><span class="line">    <span class="keyword">goto</span> bad;</span><br><span class="line">  <span class="keyword">if</span>(copyout(pagetable, sp, (<span class="type">char</span> *)ustack, (argc+<span class="number">1</span>)*<span class="keyword">sizeof</span>(uint64)) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">goto</span> bad;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// arguments to user main(argc, argv)</span></span><br><span class="line">  <span class="comment">// argc is returned via the system call return</span></span><br><span class="line">  <span class="comment">// value, which goes in a0.</span></span><br><span class="line">  p-&gt;trapframe-&gt;a1 = sp;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Save program name for debugging.</span></span><br><span class="line">  <span class="keyword">for</span>(last=s=path; *s; s++)</span><br><span class="line">    <span class="keyword">if</span>(*s == <span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">      last = s+<span class="number">1</span>;</span><br><span class="line">  safestrcpy(p-&gt;name, last, <span class="keyword">sizeof</span>(p-&gt;name));</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// Commit to the user image.</span></span><br><span class="line">  <span class="comment">// 进程镜像切换</span></span><br><span class="line">  oldpagetable = p-&gt;pagetable;</span><br><span class="line">  p-&gt;pagetable = pagetable;</span><br><span class="line">  p-&gt;sz = sz;</span><br><span class="line">  p-&gt;trapframe-&gt;epc = elf.entry;  <span class="comment">// initial program counter = main</span></span><br><span class="line">  p-&gt;trapframe-&gt;sp = sp; <span class="comment">// initial stack pointer</span></span><br><span class="line">  proc_freepagetable(oldpagetable, oldsz);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> argc; <span class="comment">// this ends up in a0, the first argument to main(argc, argv)</span></span><br><span class="line"></span><br><span class="line"> bad:</span><br><span class="line">  <span class="keyword">if</span>(pagetable)</span><br><span class="line">    proc_freepagetable(pagetable, sz);</span><br><span class="line">  <span class="keyword">if</span>(ip)&#123;</span><br><span class="line">    iunlockput(ip);</span><br><span class="line">    end_op();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第四章：陷入和系统调用"><a href="#第四章：陷入和系统调用" class="headerlink" title="第四章：陷入和系统调用"></a>第四章：陷入和系统调用</h3><p>有三种事件会导致 CPU 搁置普通指令的执行，强制将控制权转移给处理该事件的特殊代码。一种情况是<code>系统调用</code>，当用户程序执行 ecall 指令要求内核为其做某事时。另一种情况是<code>异常</code>，一条指令（用户或内核）做了一些非法的事情，如除以零或使用无效的虚拟地址。第三种情况是<code>设备中断</code>，当一个设备发出需要注意的信号时，例如当磁盘硬件完成一个读写请求时。</p>
<p>本文使用 trap 作为这些情况的通用术语。通常，代码在执行时发生 trap，之后都会被恢复，而且不需要意识到发生了什么特殊的事情。也就是说，我们通常希望 trap 是透明的，这一点对于中断来说尤其重要，被中断的代码通常不会意识到会发生 trap。通常的顺序是：</p>
<p>&#x3D;&#x3D;trap 迫使控制权转移到内核；内核保存寄存器和其他状态，以便恢复执行；内核执行适当的处理程序代码（例如，系统调用实现或设备驱动程序）；内核恢复保存的状态，并从 trap 中返回；代码从原来的地方恢复。&#x3D;&#x3D;</p>
<blockquote>
<p>xv6 内核会处理所有的 trap。这对于系统调用来说是很自然的。这对中断来说也是合理的，因为隔离要求用户进程不能直接使用设备，而且只有内核才有设备处理所需的状态。这对异常处理来说也是合理的，因为 xv6 响应所有来自用户空间的异常，并杀死该违规程序。</p>
</blockquote>
<p><code>xv6 trap 处理分为四个阶段：RISC-V CPU采取的硬件行为，为内核C代码准备的汇编入口，处理 trap的C处理程序，以及系统调用或设备驱动服务。</code>虽然三种 trap 类型之间的共性表明，内核可以用单一的代码入口处理所有的 trap，但事实证明，为三种不同的情况，即来自用户空间的 trap、来自内核空间的 trap 和定时器中断，设置单独的汇编入口和 C trap处理程序是很方便的。</p>
<h4 id="4-1RISC-V陷入机制"><a href="#4-1RISC-V陷入机制" class="headerlink" title="4.1RISC-V陷入机制"></a>4.1RISC-V陷入机制</h4><p>每个 RISC-V CPU都有一组控制寄存器，内核写入这些寄存器来告诉CPU 如何处理 trap，内核可以通过读取这些寄存器来发现已经发生的 trap。RISC-V 文档包含了完整的叙述。riscv.h包含了 xv6 使用的定义，这里是最重要的寄存器的概述。</p>
<ul>
<li><p>stvec：内核在这里写下 trap 处理程序的地址，RISC-V 到这里来处理 trap。</p>
</li>
<li><p>sepc：当 trap 发生时，RISC-V 会将程序计数器保存在这里，因为pc寄存器会被 stvec 覆盖。sret(从 trap 中返回)指令将 sepc 复制到 pc 中。内核可以写 sepc 来控制 sret的返回到哪里。</p>
</li>
<li><p>scause：RISC -V 在这里放了一个数字，描述了 trap 的原因。</p>
</li>
<li><p>sscratch：内核在这里放置了一个值，这个值会方便 trap 恢复&#x2F;储存用户上下文。</p>
</li>
<li><p>sstatus：sstatus 中的 SIE 位控制设备中断是否被启用，如果内核清除 SIE，RISC-V 将推迟设备中断，直到内核设置 SIE。SPP 位表示 trap 是来自用户模式还是监督者模式，并控制 sret 返回到什么模式</p>
</li>
</ul>
<p><code>上述寄存器与在监督者模式下处理的 trap 有关，在用户模式下不能读或写。对于机器模式下处理的 trap，有一组等效的控制寄存器；xv6 只在定时器中断的特殊情况下使用它们。</code></p>
<p>多核芯片上的每个 CPU 都有自己的一组这些寄存器，而且在任何时候都可能有多个CPU在处理一个 trap。当需要执行 trap 时，RISC-V 硬件对所有的 trap 类型（除定时器中断外）进行以下操作：</p>
<ol>
<li>如果该 trap 是设备中断，且 sstatus SIE 位为 0，则不要执行以下任何操作。</li>
<li>通过清除 sstatus SIE 位来禁用中断。</li>
<li>复制 pc 到 sepc。</li>
<li>将当前模式(用户或监督者)保存在 sstatus 的 SPP 位。</li>
<li>在 scause 设置该次 trap 的原因。</li>
<li>将模式转换为监督者。</li>
<li>将 stvec 复制到 pc。</li>
<li>执行新的 pc。</li>
</ol>
<p>&#x3D;&#x3D;注意，CPU 不会切换到内核页表，不会切换到内核中的栈，也不会保存 pc 以外的任何寄存器。内核软件必须执行这些任务。CPU 在 trap 期间做很少的工作的一个原因是为了给软件提供灵活性，例如，一些操作系统在某些情况下不需要页表切换，这可以提高性能。&#x3D;&#x3D;</p>
<p>你可能会想 CPU 的 trap 处理流程是否可以进一步简化。例如，假设 CPU 没有切换程序计数器PC。那么 trap 可以切换到监督者模式时，还在运行用户指令。这些用户指令可以打破用户空间&#x2F;内核空间的隔离，例如通过修改 satp 寄存器指向一个允许访问所有物理内存的内核页表。因此，CPU 必须切换到内核指定的指令地址，即stvec。</p>
<h4 id="4-2用户空间的陷入"><a href="#4-2用户空间的陷入" class="headerlink" title="4.2用户空间的陷入"></a>4.2用户空间的陷入</h4><p>在用户空间执行时，如果用户程序进行了系统调用(<code>ecall 指令</code>)或者做了一些非法的事情或者设备中断，都可能发生trap。来自用户空间的 trap 的处理路径是uservec，然后usertrap；返回时是usertrapret，然后是userret。</p>
<blockquote>
<p>来自用户代码的 trap 比来自内核的 trap 更具挑战性，因为 satp 指向的用户页表并不映射内核，而且栈指针可能包含一个无效甚至恶意的值。</p>
</blockquote>
<p>&#x3D;&#x3D;因为 RISC-V 硬件在 trap 过程中不切换页表，所以用户页表必须包含 uservec 的映射，即 stvec 指向的 trap 处理程序地址。uservec 必须切换 satp，使其指向内核页表；为了在切换后继续执行指令，uservec 必须被映射到内核页表与用户页表相同的地址。&#x3D;&#x3D;</p>
<p><code>xv6 用一个包含 uservec 的 trampoline 页来满足这些条件。</code>xv6 在内核页表(kenel page)和每个用户页表(user page)中的同一个虚拟地址TRAMPOLINE上映射了 trampoline 页。trampoline.S 中包含 trampoline 的内容，当执行用户代码时 stvec 设置为 uservec。</p>
<p>当 uservec 启动时，所有 32 个寄存器都包含被中断的代码所拥有的值。但是 uservec需要能够修改一些寄存器，以便设置 satp 和生成保存寄存器的地址。RISC-V 通过 sscratch寄存器提供了帮助。uservec 开始时的 csrw 指令将 a0 和 sscratch 的内容互换。现在用户代码的 a0 被保存了；uservec 有一个寄存器（a0）可以使用；a0 包含了内核之前放在 sscratch中的值。</p>
<p>uservec 的下一个任务是保存用户寄存器。在进入用户空间之前，内核先设置 sscratch指向该进程的 trapframe，这个 trapframe 可以保存所有用户寄存器。因为 satp 仍然是指用户页表，所以 uservec 需要将 trapframe 映射到用户地址空间中。当创建每个进程时，xv6 为进程的 trapframe 分配一页内存，并将它映射在用户虚拟地址TRAPFRAME，也就是 TRAMPOLINE 的下面。进程的 p-&gt;trapframe 也指向 trapframe，不过是指向它的物理地址，这样内核可以通过内核页表来使用它。</p>
<p><code>因此，在交换a0和sscratch后，a0将指向当前进程的trapframe。uservec将在trapframe保存全部的寄存器，包括从sscratch读取的a0。</code></p>
<p>&#x3D;&#x3D;trapframe包含指向当前进程的内核栈、当前CPU的 hartid、usertrap的地址和内核页表的地址的指针，uservec将这些值设置到相应的寄存器中，并将satp切换到内核页表和刷新TLB，然后调用 usertrap。&#x3D;&#x3D;</p>
<p><code>usertrap 的作用是确定 trap 的原因，处理它，然后返回。</code>如上所述，它首先改变 stvec，这样在内核中发生的 trap 将由 kernelvec 处理。<code>它保存了sepc(用户 PC)，这也是因为usertrap 中可能会有一个进程切换，导致sepc被覆盖。</code>如果 trap 是系统调用，syscall 会处理它；如果是设备中断，devintr 会处理；否则就是异常，内核会杀死故障进程。usertrap 会把用户pc加4，因为 RISC-V 在执行系统调用时，会留下指向 ecall 指令的程序指针。在退出时，usertrap 检查进程是否已经被杀死或应该让出 CPU（如果这个 trap 是一个定时器中断）。</p>
<p>回到用户空间的第一步是调用 usertrapret。<code>这个函数设置 RISC-V 控制寄存器，为以后用户空间 trap 做准备。这包括改变 stvec 来引用 uservec，准备 uservec 所依赖的 trapframe 字段，并将 sepc 设置为先前保存的用户程序计数器。</code>最后，usertrapret在用户页表和内核页表中映射的 trampoline 页上调用 userret，因为 userret 中的汇编代码会切换页表。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line"># 用户空间和内核空间切换的代码</span><br><span class="line"># trampoline.S被映射到用户空间和内核空间的相同的虚拟地址TRAMPOLINE</span><br><span class="line"># 这样以便于页表切换时这段代码能够继续完整执行</span><br><span class="line"># kernel.ld链接器程序会使得trampoline.S对齐成一页边界大小</span><br><span class="line">.section trampsec</span><br><span class="line">.globl trampoline</span><br><span class="line">trampoline:</span><br><span class="line">.align 4</span><br><span class="line">.globl uservec</span><br><span class="line">uservec:    </span><br><span class="line"># trap.c设置stvec寄存器指向uservec，这样来自用户空间的各种traps先从这里开始执行</span><br><span class="line"># 此时处于监督者模式，但是还没有切换到内核页表</span><br><span class="line"># sscratch寄存器指向进程的p-&gt;trapframe（被映射到用户空间的TRAPFRAME虚拟地址处）</span><br><span class="line"># a0指向TRAPFRAME地址，sscratch保存a0的值</span><br><span class="line">        csrrw a0, sscratch, a0</span><br><span class="line">        # 保存现场，把用户寄存器的值保存在TRAPFRAME中以便后续恢复现场</span><br><span class="line">        sd ra, 40(a0)# 返回地址</span><br><span class="line">        sd sp, 48(a0)# 栈指针</span><br><span class="line">        sd gp, 56(a0)# 全局指针</span><br><span class="line">        sd tp, 64(a0)# CPU-ID</span><br><span class="line">        sd t0, 72(a0)</span><br><span class="line">        sd t1, 80(a0)</span><br><span class="line">        sd t2, 88(a0)</span><br><span class="line">        sd s0, 96(a0)# frame pointer</span><br><span class="line">        sd s1, 104(a0)</span><br><span class="line">        sd a1, 120(a0)</span><br><span class="line">        sd a2, 128(a0)</span><br><span class="line">        sd a3, 136(a0)</span><br><span class="line">        sd a4, 144(a0)</span><br><span class="line">        sd a5, 152(a0)</span><br><span class="line">        sd a6, 160(a0)</span><br><span class="line">        sd a7, 168(a0)</span><br><span class="line">        sd s2, 176(a0)</span><br><span class="line">        sd s3, 184(a0)</span><br><span class="line">        sd s4, 192(a0)</span><br><span class="line">        sd s5, 200(a0)</span><br><span class="line">        sd s6, 208(a0)</span><br><span class="line">        sd s7, 216(a0)</span><br><span class="line">        sd s8, 224(a0)</span><br><span class="line">        sd s9, 232(a0)</span><br><span class="line">        sd s10, 240(a0)</span><br><span class="line">        sd s11, 248(a0)</span><br><span class="line">        sd t3, 256(a0)</span><br><span class="line">        sd t4, 264(a0)</span><br><span class="line">        sd t5, 272(a0)</span><br><span class="line">        sd t6, 280(a0)</span><br><span class="line"></span><br><span class="line">		# save the user a0 in p-&gt;trapframe-&gt;a0</span><br><span class="line">        # 保存原来a0寄存器的值</span><br><span class="line">        csrr t0, sscratch</span><br><span class="line">        sd t0, 112(a0)</span><br><span class="line"></span><br><span class="line">        # restore kernel stack pointer from p-&gt;trapframe-&gt;kernel_sp</span><br><span class="line">        # 进入内核态之前设置sp指向p-&gt;trapframe-&gt;kernel_sp</span><br><span class="line">        ld sp, 8(a0)</span><br><span class="line"></span><br><span class="line">        # make tp hold the current hartid, from p-&gt;trapframe-&gt;kernel_hartid</span><br><span class="line">        # 进入内核态之前设置tp为p-&gt;trapframe-&gt;kernel_hartid</span><br><span class="line">        ld tp, 32(a0)</span><br><span class="line"></span><br><span class="line">        # load the address of usertrap(), p-&gt;trapframe-&gt;kernel_trap</span><br><span class="line">        # 加载usertrap函数入口</span><br><span class="line">        ld t0, 16(a0)</span><br><span class="line"></span><br><span class="line">        # restore kernel page table from p-&gt;trapframe-&gt;kernel_satp</span><br><span class="line">        # t1寄存器保存p-&gt;trapframe-&gt;kernel_satp（内核页表）</span><br><span class="line">        ld t1, 0(a0)</span><br><span class="line">        # 切换页表为内核页表</span><br><span class="line">        csrw satp, t1</span><br><span class="line">        # 页表发生改变，需要刷新TLB</span><br><span class="line">        sfence.vma zero, zero</span><br><span class="line"></span><br><span class="line">        # a0 is no longer valid, since the kernel page</span><br><span class="line">        # table does not specially map p-&gt;tf.</span><br><span class="line">        # a0(p-&gt;trapframe)不再有效，因为现在切换成了内核页表，而内核页表中没有p-&gt;trapframe页映射</span><br><span class="line"></span><br><span class="line">        # jump to usertrap(), which does not return</span><br><span class="line">        # 跳转到usertrap函数内</span><br><span class="line">        jr t0</span><br><span class="line"></span><br><span class="line">.globl userret</span><br><span class="line">userret:</span><br><span class="line">        # userret(TRAPFRAME, pagetable)从内核空间切换回用户空间</span><br><span class="line">        # a0: TRAPFRAME, in user page table.</span><br><span class="line">        # a1: user page table, for satp.</span><br><span class="line"></span><br><span class="line">        # switch to the user page table.</span><br><span class="line">        csrw satp, a1</span><br><span class="line">        sfence.vma zero, zero</span><br><span class="line"></span><br><span class="line">        # put the saved user a0 in sscratch, so we</span><br><span class="line">        # can swap it with our a0 (TRAPFRAME) in the last step.</span><br><span class="line">        # 将trapframe中保存的a0复制到sscratch中，为最后a0与TRAPFRAME交换做准备</span><br><span class="line">        ld t0, 112(a0)</span><br><span class="line">        csrw sscratch, t0</span><br><span class="line"></span><br><span class="line">        # restore all but a0 from TRAPFRAME</span><br><span class="line">        # 恢复用户寄存器的值（除了a0）</span><br><span class="line">        ld ra, 40(a0)</span><br><span class="line">        ld sp, 48(a0)</span><br><span class="line">        ld gp, 56(a0)</span><br><span class="line">        ld tp, 64(a0)</span><br><span class="line">        ld t0, 72(a0)</span><br><span class="line">        ld t1, 80(a0)</span><br><span class="line">        ld t2, 88(a0)</span><br><span class="line">        ld s0, 96(a0)</span><br><span class="line">        ld s1, 104(a0)</span><br><span class="line">        ld a1, 120(a0)</span><br><span class="line">        ld a2, 128(a0)</span><br><span class="line">        ld a3, 136(a0)</span><br><span class="line">        ld a4, 144(a0)</span><br><span class="line">        ld a5, 152(a0)</span><br><span class="line">        ld a6, 160(a0)</span><br><span class="line">        ld a7, 168(a0)</span><br><span class="line">        ld s2, 176(a0)</span><br><span class="line">        ld s3, 184(a0)</span><br><span class="line">        ld s4, 192(a0)</span><br><span class="line">        ld s5, 200(a0)</span><br><span class="line">        ld s6, 208(a0)</span><br><span class="line">        ld s7, 216(a0)</span><br><span class="line">        ld s8, 224(a0)</span><br><span class="line">        ld s9, 232(a0)</span><br><span class="line">        ld s10, 240(a0)</span><br><span class="line">        ld s11, 248(a0)</span><br><span class="line">        ld t3, 256(a0)</span><br><span class="line">        ld t4, 264(a0)</span><br><span class="line">        ld t5, 272(a0)</span><br><span class="line">        ld t6, 280(a0)</span><br><span class="line"></span><br><span class="line">		# restore user a0, and save TRAPFRAME in sscratch</span><br><span class="line">		# 对a0和sscratch做最后的交换，恢复用户a0并保存TRAPFRAME，为下一次 trap 做准备</span><br><span class="line">        csrrw a0, sscratch, a0</span><br><span class="line">        </span><br><span class="line">        # return to user mode and user pc.</span><br><span class="line">        # usertrapret() set up sstatus and sepc.</span><br><span class="line">        # 返回到用户模式下并且沿着发生异常的下一条指令继续执行</span><br><span class="line">        sret</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>trap.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;param.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;memlayout.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;riscv.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;spinlock.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;proc.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;defs.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">tickslock</span>;</span></span><br><span class="line">uint ticks;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">char</span> trampoline[], uservec[], userret[];</span><br><span class="line"><span class="comment">// in kernelvec.S, calls kerneltrap()</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">kernelvec</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">devintr</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">trapinit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  initlock(&amp;tickslock, <span class="string">&quot;time&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// set up to take exceptions and traps while in the kernel.</span></span><br><span class="line"><span class="comment">// 设置内核空间的异常/陷入处理程序入口</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">trapinithart</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  w_stvec((uint64)kernelvec);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// handle an interrupt, exception, or system call from user space.</span></span><br><span class="line"><span class="comment">// called from trampoline.S</span></span><br><span class="line"><span class="comment">// 处理来自用户空间的中断、异常、系统调用</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">usertrap</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> which_dev = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// SPP 位表示 trap 是来自用户模式还是监督者模式，并控制sret 返回到什么模式</span></span><br><span class="line">  <span class="comment">// 只能处理来自用户空间的中断、异常、系统调用</span></span><br><span class="line">  <span class="keyword">if</span>((r_sstatus() &amp; SSTATUS_SPP) != <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;usertrap: not from user mode&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// send interrupts and exceptions to kerneltrap(),</span></span><br><span class="line">  <span class="comment">// since we&#x27;re now in the kernel.</span></span><br><span class="line">  <span class="comment">// 我们现在已经进入内核空间了，在内核中再发生的 trap 将由 kernelvec 处理</span></span><br><span class="line">  w_stvec((uint64)kernelvec);</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// save user program counter.</span></span><br><span class="line">  <span class="comment">// 它保存了 sepc(用户 PC)，这也是因为 usertrap 中可能会有一个进程切换，导致 sepc 被覆盖</span></span><br><span class="line">  p-&gt;trapframe-&gt;epc = r_sepc();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 系统调用交给syscall处理</span></span><br><span class="line">  <span class="keyword">if</span>(r_scause() == <span class="number">8</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;killed)</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    <span class="comment">// 返回地址为ecall指令的下一个指令</span></span><br><span class="line">    p-&gt;trapframe-&gt;epc += <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// an interrupt will change sstatus &amp;c registers,</span></span><br><span class="line">    <span class="comment">// so don&#x27;t enable until done with those registers.</span></span><br><span class="line">    <span class="comment">// 开启设备中断</span></span><br><span class="line">    intr_on();</span><br><span class="line"></span><br><span class="line">    syscall();</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>((which_dev = devintr()) != <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">// ok</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 发生异常，内核杀死异常进程</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;usertrap(): unexpected scause %p pid=%d\n&quot;</span>, r_scause(), p-&gt;pid);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;            sepc=%p stval=%p\n&quot;</span>, r_sepc(), r_stval());</span><br><span class="line">    p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(p-&gt;killed)</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// give up the CPU if this is a timer interrupt.</span></span><br><span class="line">  <span class="comment">// 时钟中断处理，让出CPU重新调度</span></span><br><span class="line">  <span class="keyword">if</span>(which_dev == <span class="number">2</span>)</span><br><span class="line">    yield();</span><br><span class="line"></span><br><span class="line">  usertrapret();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// return to user space</span></span><br><span class="line"><span class="comment">// 开始回到用户空间，首先设置 RISC-V 控制寄存器，为以后用户空间 trap 做准备</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">usertrapret</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// we&#x27;re about to switch the destination of traps from</span></span><br><span class="line">  <span class="comment">// kerneltrap() to usertrap(), so turn off interrupts until</span></span><br><span class="line">  <span class="comment">// we&#x27;re back in user space, where usertrap() is correct.</span></span><br><span class="line">  <span class="comment">// 返回用户空间时关闭中断</span></span><br><span class="line">  intr_off();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// send syscalls, interrupts, and exceptions to trampoline.S</span></span><br><span class="line">  <span class="comment">// 改变 stvec 指向 uservec</span></span><br><span class="line">  w_stvec(TRAMPOLINE + (uservec - trampoline));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// set up trapframe values that uservec will need when</span></span><br><span class="line">  <span class="comment">// the process next re-enters the kernel.</span></span><br><span class="line">  <span class="comment">// 准备 uservec 所依赖的 trapframe 字段</span></span><br><span class="line">  p-&gt;trapframe-&gt;kernel_satp = r_satp();         <span class="comment">// kernel page table</span></span><br><span class="line">  p-&gt;trapframe-&gt;kernel_sp = p-&gt;kstack + PGSIZE; <span class="comment">// process&#x27;s kernel stack</span></span><br><span class="line">  p-&gt;trapframe-&gt;kernel_trap = (uint64)usertrap; </span><br><span class="line">  p-&gt;trapframe-&gt;kernel_hartid = r_tp();         <span class="comment">// hartid for cpuid()</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// set up the registers that trampoline.S&#x27;s sret will use</span></span><br><span class="line">  <span class="comment">// to get to user space.</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// set S Previous Privilege mode to User.</span></span><br><span class="line">  <span class="comment">// 在sret前设置sstatus寄存器，确保返回用户模式</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> x = r_sstatus();</span><br><span class="line">  x &amp;= ~SSTATUS_SPP; <span class="comment">// clear SPP to 0 for user mode</span></span><br><span class="line">  x |= SSTATUS_SPIE; <span class="comment">// enable interrupts in user mode</span></span><br><span class="line">  w_sstatus(x);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// set S Exception Program Counter to the saved user pc.</span></span><br><span class="line">  <span class="comment">// 将 sepc 设置为先前保存的用户程序计数器</span></span><br><span class="line">  w_sepc(p-&gt;trapframe-&gt;epc);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// tell trampoline.S the user page table to switch to.</span></span><br><span class="line">  <span class="comment">// 用户进程页表</span></span><br><span class="line">  uint64 satp = MAKE_SATP(p-&gt;pagetable);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// jump to trampoline.S at the top of memory, which </span></span><br><span class="line">  <span class="comment">// switches to the user page table, restores user registers,</span></span><br><span class="line">  <span class="comment">// and switches to user mode with sret.</span></span><br><span class="line">  <span class="comment">// 调用 userret</span></span><br><span class="line">  uint64 fn = TRAMPOLINE + (userret - trampoline);</span><br><span class="line">  ((<span class="type">void</span> (*)(uint64,uint64))fn)(TRAPFRAME, satp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// interrupts and exceptions from kernel code go here via kernelvec,</span></span><br><span class="line"><span class="comment">// on whatever the current kernel stack is.</span></span><br><span class="line"><span class="type">void</span> </span><br><span class="line"><span class="title function_">kerneltrap</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> which_dev = <span class="number">0</span>;</span><br><span class="line">  uint64 sepc = r_sepc();</span><br><span class="line">  uint64 sstatus = r_sstatus();</span><br><span class="line">  uint64 scause = r_scause();</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>((sstatus &amp; SSTATUS_SPP) == <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;kerneltrap: not from supervisor mode&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span>(intr_get() != <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;kerneltrap: interrupts enabled&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>((which_dev = devintr()) == <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;scause %p\n&quot;</span>, scause);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sepc=%p stval=%p\n&quot;</span>, r_sepc(), r_stval());</span><br><span class="line">    panic(<span class="string">&quot;kerneltrap&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// give up the CPU if this is a timer interrupt.</span></span><br><span class="line">  <span class="keyword">if</span>(which_dev == <span class="number">2</span> &amp;&amp; myproc() != <span class="number">0</span> &amp;&amp; myproc()-&gt;state == RUNNING)</span><br><span class="line">    yield();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// the yield() may have caused some traps to occur,</span></span><br><span class="line">  <span class="comment">// so restore trap registers for use by kernelvec.S&#x27;s sepc instruction.</span></span><br><span class="line">  w_sepc(sepc);</span><br><span class="line">  w_sstatus(sstatus);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">clockintr</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  acquire(&amp;tickslock);</span><br><span class="line">  ticks++;</span><br><span class="line">  wakeup(&amp;ticks);</span><br><span class="line">  release(&amp;tickslock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// check if it&#x27;s an external interrupt or software interrupt,</span></span><br><span class="line"><span class="comment">// and handle it.</span></span><br><span class="line"><span class="comment">// returns 2 if timer interrupt,</span></span><br><span class="line"><span class="comment">// 1 if other device,</span></span><br><span class="line"><span class="comment">// 0 if not recognized.</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">devintr</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  uint64 scause = r_scause();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// this is a supervisor external interrupt, via PLIC.</span></span><br><span class="line">  <span class="comment">// 经PLIC而来的外部设备中断</span></span><br><span class="line">  <span class="keyword">if</span>((scause &amp; <span class="number">0x8000000000000000</span>L) &amp;&amp;</span><br><span class="line">     (scause &amp; <span class="number">0xff</span>) == <span class="number">9</span>)&#123;</span><br><span class="line">    <span class="comment">// irq indicates which device interrupted.</span></span><br><span class="line">    <span class="comment">// IRQ表明了具体哪个设备导致的中断</span></span><br><span class="line">    <span class="type">int</span> irq = plic_claim();</span><br><span class="line">    <span class="keyword">if</span>(irq == UART0_IRQ)&#123;</span><br><span class="line">      <span class="comment">// 键盘串口中断</span></span><br><span class="line">      uartintr();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(irq == VIRTIO0_IRQ)&#123;</span><br><span class="line">      <span class="comment">// 磁盘中断</span></span><br><span class="line">      virtio_disk_intr();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(irq)&#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;unexpected interrupt irq=%d\n&quot;</span>, irq);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// the PLIC allows each device to raise at most one</span></span><br><span class="line">    <span class="comment">// interrupt at a time; tell the PLIC the device is</span></span><br><span class="line">    <span class="comment">// now allowed to interrupt again.</span></span><br><span class="line">    <span class="comment">// PLIC只允许同一时刻一个设备至多被打断一次</span></span><br><span class="line">    <span class="keyword">if</span>(irq)</span><br><span class="line">      plic_complete(irq);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="comment">// software interrupt from a machine-mode timer interrupt,</span></span><br><span class="line">  <span class="comment">// forwarded by timervec in kernelvec.S</span></span><br><span class="line">  <span class="comment">// 来自机器模式的时钟中断的软件中断</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(scause == <span class="number">0x8000000000000001</span>L)&#123;</span><br><span class="line">    <span class="keyword">if</span>(cpuid() == <span class="number">0</span>)&#123;</span><br><span class="line">      clockintr();</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// acknowledge the software interrupt by clearing</span></span><br><span class="line">    <span class="comment">// the SSIP bit in sip.</span></span><br><span class="line">    w_sip(r_sip() &amp; ~<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-3系统调用函数执行"><a href="#4-3系统调用函数执行" class="headerlink" title="4.3系统调用函数执行"></a>4.3系统调用函数执行</h4><p>第 2 章以 initcode.S 调用 exec 系统调用结束。让我们来看看用户调用是如何在内核中实现 exec 系统调用的。</p>
<p><code>用户代码将 exec 的参数放在寄存器 a0 和 a1 中，并将系统调用号放在 a7 中。系统调用号与函数指针表 syscalls 数组中的项匹配。ecall 指令进入内核，执行uservec、usertrap，然后执行 syscall，就像我们上面看到的那样。</code></p>
<p>syscall从 trapframe 中的 a7 中得到系统调用号，并其作为索引在syscalls 查找相应函数。对于第一个系统调用 exec，a7 将为 SYS_exec，这会让 syscall 调用 exec 的实现函数 sys_exec。</p>
<p><code>当系统调用函数返回时，syscall将其返回值记录在p-&gt;trapframe-&gt;a0中。用户空间的exec()将会返回该值，因为RISC-V上的C调用通常将返回值放在a0中。</code>系统调用返回负数表示错误，0 或正数表示成功。如果系统调用号无效，syscall 会打印错误并返回 1。</p>
<p>内核的系统调用实现需要找到用户代码传递的参数。因为用户代码调用系统调用的包装函数，参数首先会存放在寄存器中，这是C语言存放参数的惯例位置。内核 trap 代码将用户寄存器保存到当前进程的 trapframe 中，内核代码可以在那里找到它们。函数 argint、argaddr 和 argfd 从 trapframe 中以整数、指针或文件描述符的形式检索第 n 个系统调用参数。它们都调用 argraw 在 trapframe 中检索相应的数据。</p>
<p>一些系统调用传递指针作为参数，而内核必须使用这些指针来读取或写入用户内存。例如，exec 系统调用会向内核传递一个指向用户空间中的字符串的指针数组。这些指针带来了两个挑战。首先，用户程序可能是错误的或恶意的，可能会传递给内核一个无效的指针或一个旨在欺骗内核访问内核内存而不是用户内存的指针。第二，xv6 内核页表映射与用户页表映射不一样，所以内核不能使用普通指令从用户提供的地址加载或存储。</p>
<p><code>内核实现了安全地将数据复制到用户提供的地址或从用户提供的地址复制数据的函数。例如 fetchstr。文件系统调用，如exec,使用fetchstr从用户空间中检索字符串文件名参数，fetchstr 调用copyinstr来做这些困难的工作。</code></p>
<blockquote>
<p>copyinstr 将用户页表 pagetable 中的虚拟地址 srcva 复制到 dst，需指定最大复制字节数。它使用 walkaddr（调用 walk 函数）在软件中模拟分页硬件的操作，以确定 srcva 的物理地址 pa0。walkaddr 检查用户提供的虚拟地址是否是进程用户地址空间的一部分，所以程序不能欺骗内核读取其他内存。类似的函数 copyout，可以将数据从内核复制到用户提供的地址。</p>
</blockquote>
<p><code>syscall.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;param.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;memlayout.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;riscv.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;spinlock.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;proc.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;syscall.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;defs.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Fetch the uint64 at addr from the current process.</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">fetchaddr</span><span class="params">(uint64 addr, uint64 *ip)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  <span class="keyword">if</span>(addr &gt;= p-&gt;sz || addr+<span class="keyword">sizeof</span>(uint64) &gt; p-&gt;sz)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">if</span>(copyin(p-&gt;pagetable, (<span class="type">char</span> *)ip, addr, <span class="keyword">sizeof</span>(*ip)) != <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Fetch the nul-terminated string at addr from the current process.</span></span><br><span class="line"><span class="comment">// Returns length of string, not including nul, or -1 for error.</span></span><br><span class="line"><span class="comment">// 安全地将数据复制到用户提供的地址或从用户提供的地址复制数据</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">fetchstr</span><span class="params">(uint64 addr, <span class="type">char</span> *buf, <span class="type">int</span> max)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  <span class="type">int</span> err = copyinstr(p-&gt;pagetable, buf, addr, max);</span><br><span class="line">  <span class="keyword">if</span>(err &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">strlen</span>(buf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 trapframe 中检索相应的数据(第n个系统调用参数)</span></span><br><span class="line"><span class="type">static</span> uint64</span><br><span class="line"><span class="title function_">argraw</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  <span class="keyword">switch</span> (n) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">    <span class="keyword">return</span> p-&gt;trapframe-&gt;a0;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">return</span> p-&gt;trapframe-&gt;a1;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">    <span class="keyword">return</span> p-&gt;trapframe-&gt;a2;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">    <span class="keyword">return</span> p-&gt;trapframe-&gt;a3;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">    <span class="keyword">return</span> p-&gt;trapframe-&gt;a4;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">    <span class="keyword">return</span> p-&gt;trapframe-&gt;a5;</span><br><span class="line">  &#125;</span><br><span class="line">  panic(<span class="string">&quot;argraw&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Fetch the nth 32-bit system call argument.</span></span><br><span class="line"><span class="comment">// 以整数的形式检索第n个系统调用参数</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">argint</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> *ip)</span></span><br><span class="line">&#123;</span><br><span class="line">  *ip = argraw(n);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Retrieve an argument as a pointer.</span></span><br><span class="line"><span class="comment">// Doesn&#x27;t check for legality, since</span></span><br><span class="line"><span class="comment">// copyin/copyout will do that.</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">argaddr</span><span class="params">(<span class="type">int</span> n, uint64 *ip)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 以指针的形式检索第n个系统调用参数</span></span><br><span class="line">  *ip = argraw(n);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Fetch the nth word-sized system call argument as a null-terminated string.</span></span><br><span class="line"><span class="comment">// Copies into buf, at most max.</span></span><br><span class="line"><span class="comment">// Returns string length if OK (including nul), -1 if error.</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">argstr</span><span class="params">(<span class="type">int</span> n, <span class="type">char</span> *buf, <span class="type">int</span> max)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 以字符串的形式检索第n个系统调用参数</span></span><br><span class="line">  uint64 addr;</span><br><span class="line">  <span class="keyword">if</span>(argaddr(n, &amp;addr) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">return</span> fetchstr(addr, buf, max);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_chdir</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_close</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_dup</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_exec</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_exit</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_fork</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_fstat</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_getpid</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_kill</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_link</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_mkdir</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_mknod</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_open</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_pipe</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_read</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_sbrk</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_sleep</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_unlink</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_wait</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_write</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_uptime</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="title function_">uint64</span> <span class="params">(*syscalls[])</span><span class="params">(<span class="type">void</span>)</span> = &#123;</span><br><span class="line">[SYS_fork]    sys_fork,</span><br><span class="line">[SYS_exit]    sys_exit,</span><br><span class="line">[SYS_wait]    sys_wait,</span><br><span class="line">[SYS_pipe]    sys_pipe,</span><br><span class="line">[SYS_read]    sys_read,</span><br><span class="line">[SYS_kill]    sys_kill,</span><br><span class="line">[SYS_exec]    sys_exec,</span><br><span class="line">[SYS_fstat]   sys_fstat,</span><br><span class="line">[SYS_chdir]   sys_chdir,</span><br><span class="line">[SYS_dup]     sys_dup,</span><br><span class="line">[SYS_getpid]  sys_getpid,</span><br><span class="line">[SYS_sbrk]    sys_sbrk,</span><br><span class="line">[SYS_sleep]   sys_sleep,</span><br><span class="line">[SYS_uptime]  sys_uptime,</span><br><span class="line">[SYS_open]    sys_open,</span><br><span class="line">[SYS_write]   sys_write,</span><br><span class="line">[SYS_mknod]   sys_mknod,</span><br><span class="line">[SYS_unlink]  sys_unlink,</span><br><span class="line">[SYS_link]    sys_link,</span><br><span class="line">[SYS_mkdir]   sys_mkdir,</span><br><span class="line">[SYS_close]   sys_close,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">syscall</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> num;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//从 trapframe 中的 a7 中得到系统调用号，并其作为索引在 syscalls 查找相应函数</span></span><br><span class="line">  num = p-&gt;trapframe-&gt;a7;</span><br><span class="line">  <span class="keyword">if</span>(num &gt; <span class="number">0</span> &amp;&amp; num &lt; NELEM(syscalls) &amp;&amp; syscalls[num]) &#123;</span><br><span class="line">    <span class="comment">// 当系统调用函数返回时，syscall 将其返回值记录在 p-&gt;trapframe-&gt;a0 中</span></span><br><span class="line">    p-&gt;trapframe-&gt;a0 = syscalls[num]();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %s: unknown sys call %d\n&quot;</span>,</span><br><span class="line">            p-&gt;pid, p-&gt;name, num);</span><br><span class="line">    p-&gt;trapframe-&gt;a0 = <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-4内核空间的陷入"><a href="#4-4内核空间的陷入" class="headerlink" title="4.4内核空间的陷入"></a>4.4内核空间的陷入</h4><p>xv6 对异常的响应是相当固定：如果一个异常发生在用户空间，内核就会杀死故障进程。如果一个异常发生在内核中，内核就会 panic。真正的操作系统通常会以更有趣的方式进行响应。</p>
<p>举个例子，许多内核使用页面故障来实现写时复制COW_fork。要解释写时复制 fork，可以想一 想 xv6 的 fork。fork 通过调用uvmcopy为子进程分配物理内存，并将父进程的内存复制到子进程中，使子进程拥有与父进程相同的内存内容。如果子进程和父进程能够共享父进程的物理内存，效率会更高。然而，直接实现这种方法是行不通的，因为父进程和子进程对共享栈和堆的写入会中断彼此的执行。</p>
<p>通过使用写时复制 fork，可以让父进程和子进程安全地共享物理内存，通过页面故障来实现。当 CPU 不能将虚拟地址翻译成物理地址时，CPU 会产生一个页面故障异常(page-fault exception)。 RISC-V 有三种不同的页故障：load 页故障（当加载指令不能翻译其虚拟地址时）、store 页故障（当存储指令不能翻译其虚拟地址时）和指令页故障（当指令的地址不能翻译时）。scause 寄存器中的值表示页面故障的类型，stval 寄存器中包含无法翻译的地址。</p>
<p>&#x3D;&#x3D;COW fork 中的基本设计是父进程和子进程最初共享所有的物理页面，但将它们映射设置为只读。因此，当子进程或父进程执行 store 指令时，RISC-V CPU 会引发一个页面故障异常。作为对这个异常的响应，内核会拷贝一份包含故障地址的页。然后将一个副本的读&#x2F;写映射在子进程地址空间，另一个副本的读&#x2F;写映射在父进程地址空间。更新页表后，内核在引起故障的指令处恢复故障处理。因为内核已经更新了相关的 PTE，允许写入，所以现在故障指令将正常执行。&#x3D;&#x3D;</p>
<p>这个 COW 设计对 fork 很有效，因为往往子程序在 fork 后立即调用 exec，用新的地址空间替换其地址空间。在这种常见的情况下，子程序只会遇到一些页面故障，而内核可以避免进行完整的复制。<code>此外，COW fork是透明的：不需要对应用程序进行修改，应用程序就能受益。</code></p>
<p>页表和页故障的结合，将会有更多种有趣的可能性的应用。另一个被广泛使用的特性叫做<code>懒分配 (lazy allocation)</code>，它有两个部分。&#x3D;&#x3D;首先，当一个应用程序调用 sbrk 时，内核会增长地址空间，但在页表中把新的地址标记为无效。第二，当这些新地址中的一个出现页面故障时，内核分配物理内存并将其映射到页表中。由于应用程序经常要求获得比他们需要的更多的内存，所以懒分配是一个胜利：内核只在应用程序实际使用时才分配内存。像 COW fork一样，内核可以对应用程序透明地实现这个功能。&#x3D;&#x3D;</p>
<p>另一个被广泛使用的利用页面故障的功能是从<code>磁盘上分页(paging from disk)</code>。如果应用程序需要的内存超过了可用的物理 RAM，内核可以交换出一些页：将它们写入一个存储设备，比如磁盘，并将其 PTE 标记为无效。如果一个应用程序读取或写入一个被换出到磁盘的页，CPU 将遇到一个页面故障。内核就可以检查故障地址。如果该地址属于磁盘上的页面，内核就会分配一个物理内存的页面，从磁盘上读取页面到该内存，更新 PTE 为有效并引用该内存，然后恢复应用程序。为了给该页腾出空间，内核可能要交换另一个页。这个特性不需要对应用程序进行任何修改，如果应用程序具有引用的位置性（即它们在任何时候都只使用其内存的一个子集），这个特性就能很好地发挥作用。</p>
<p>其他结合分页和分页错误异常的功能包括自动扩展堆栈和内存映射文件。</p>
<h3 id="第五章：中断和设备驱动"><a href="#第五章：中断和设备驱动" class="headerlink" title="第五章：中断和设备驱动"></a>第五章：中断和设备驱动</h3><p><code>驱动是操作系统中管理特定设备的代码</code>，它有如下功能：<code>1、配置设备相关的硬件</code>，<code>2、告诉设备需要怎样执行</code>，<code>3、处理设备产生的中断</code>，<code>4、与等待设备 I/O 的进程进行交互</code>。驱动程序的代码写起来可能很棘手，因为驱动程序与它所管理的设备会同时执行。此外，驱动程序编写人员必须了解设备的硬件接口，但硬件接口可能是很复杂的，而且文档不够完善。</p>
<p>&#x3D;&#x3D;需要操作系统关注的设备通常可以被配置为产生中断，这是 trap 的一种类型。内核 trap 处理代码可以知道设备何时引发了中断，并调用驱动的中断处理程序；在 xv6 中，这个处理发生在 devintr中。&#x3D;&#x3D;</p>
<p>许多设备驱动程序在两个 context 中执行代码：上半部分(top half)在进程的内核线程中运行，下半部分(bottom half)在中断时执行。上半部分是通过系统调用，如希望执行 I&#x2F;O 的read 和 write。这段代码可能会要求硬件开始一个操作（比如要求磁盘读取一个块）；然后代码等待操作完成。最终设备完成操作并引发一个中断。驱动程序的中断处理程序，作为下半部分，推算出什么操作已经完成，如果合适的话，唤醒一个等待该操作的进程，并告诉硬件执行下一个操作。</p>
<h4 id="5-1控制台输入"><a href="#5-1控制台输入" class="headerlink" title="5.1控制台输入"></a>5.1控制台输入</h4><p>控制台驱动(console.c)是驱动结构的一个简单说明。<code>控制台驱动通过连接到RISC-V上的UART串行端口硬件，接受输入的字符。控制台驱动程序每次累计一行输入，处理特殊的输入字符，如退格键和control-U。用户进程如shell，使用read系统调用从控制台获取输入行。</code>当你在 QEMU 中向 xv6 输入时，你的按键会通过 QEMU 的模拟 UART 硬件传递给xv6。</p>
<p>与驱动交互的 UART 硬件是由 QEMU 仿真的 16550 芯片。在真实的计算机上，16550将管理一个连接到终端或其他计算机的 RS232 串行链接。当运行 QEMU 时，它连接到你的键盘和显示器上。</p>
<p><code>UART 硬件在软件看来是一组内存映射的控制寄存器。</code>也就是说，有一些 RISC-V 硬件的物理内存地址会连接到 UART 设备，因此加载和存储与设备硬件而不是 RAM 交互。UART的内存映射地址0x10000000 开始，即 UART0。&#x3D;&#x3D;这里有一些 UART控制寄存器，每个寄存器的宽度是一个字节。例如，LSR 寄存器中一些位表示是否有输入字符在等待软件读取。这些字符（如果有的话）可以从 RHR 寄存器中读取。每次读取一个字符，UART 硬件就会将其从内部等待字符的 FIFO中删除，并在 FIFO 为空时清除 LSR 中的就绪位。UART 传输硬件在很大程度上是独立于接收硬件的，如果软件向 THR 写入一个字节，UART 就会发送该字节。&#x3D;&#x3D;</p>
<p>xv6 的 main 调用 consoleinit 来初始化 UART 硬件。<code>这段代码配置了UART，当UART接收到一个字节的输入时，就产生一个接收中断，当UART每次完成发送一个字节的输出时，产生一个传输完成(transmit complete)中断。</code></p>
<p><code>console.c的consoleinit</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">consoleinit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  initlock(&amp;cons.lock, <span class="string">&quot;cons&quot;</span>);</span><br><span class="line"></span><br><span class="line">  uartinit();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// connect read and write system calls</span></span><br><span class="line">  <span class="comment">// to consoleread and consolewrite.</span></span><br><span class="line">  devsw[CONSOLE].read = consoleread;</span><br><span class="line">  devsw[CONSOLE].write = consolewrite;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>uart.c的uartinit</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">uartinit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// disable interrupts.</span></span><br><span class="line">  <span class="comment">// 初始化UART硬件过程中需要先关闭UART硬件中断</span></span><br><span class="line">  WriteReg(IER, <span class="number">0x00</span>);</span><br><span class="line">  <span class="comment">// special mode to set baud rate.</span></span><br><span class="line">  <span class="comment">// 开启LCR_BAUD_LATCH模式设置波特率</span></span><br><span class="line">  WriteReg(LCR, LCR_BAUD_LATCH);</span><br><span class="line">  <span class="comment">// LSB for baud rate of 38.4K.</span></span><br><span class="line">  WriteReg(<span class="number">0</span>, <span class="number">0x03</span>);</span><br><span class="line">  <span class="comment">// MSB for baud rate of 38.4K.</span></span><br><span class="line">  WriteReg(<span class="number">1</span>, <span class="number">0x00</span>);</span><br><span class="line">  <span class="comment">// leave set-baud mode,</span></span><br><span class="line">  <span class="comment">// and set word length to 8 bits, no parity.</span></span><br><span class="line">  <span class="comment">// 设置为LCR_EIGHT_BITS模式</span></span><br><span class="line">  WriteReg(LCR, LCR_EIGHT_BITS);</span><br><span class="line">  <span class="comment">// reset and enable FIFOs.</span></span><br><span class="line">  <span class="comment">// 重置并开启字符FIFO队列</span></span><br><span class="line">  WriteReg(FCR, FCR_FIFO_ENABLE | FCR_FIFO_CLEAR);</span><br><span class="line">  <span class="comment">// enable transmit and receive interrupts.</span></span><br><span class="line">  <span class="comment">// 初始化UART硬件结束后开启对应的中断（包括接受和发送中断）</span></span><br><span class="line">  WriteReg(IER, IER_TX_ENABLE | IER_RX_ENABLE);</span><br><span class="line">  initlock(&amp;uart_tx_lock, <span class="string">&quot;uart&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>printf.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// formatted console output -- printf, panic.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;param.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;spinlock.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sleeplock.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;fs.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;file.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;memlayout.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;riscv.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;defs.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;proc.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">volatile</span> <span class="type">int</span> panicked = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// lock to avoid interleaving concurrent printf&#x27;s.</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">  <span class="type">int</span> locking;</span><br><span class="line">&#125; pr;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> digits[] = <span class="string">&quot;0123456789abcdef&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">printint</span><span class="params">(<span class="type">int</span> xx, <span class="type">int</span> base, <span class="type">int</span> sign)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">16</span>];</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  uint x;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 计算xx的绝对值</span></span><br><span class="line">  <span class="keyword">if</span>(sign &amp;&amp; (sign = xx &lt; <span class="number">0</span>))</span><br><span class="line">    x = -xx;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    x = xx;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// xx的绝对值的各位数字(个位、十位、百位...)放在buf中(0位、1位、2位...)</span></span><br><span class="line">  i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    buf[i++] = digits[x % base];</span><br><span class="line">  &#125; <span class="keyword">while</span>((x /= base) != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果xx&lt;0，最后需要加上一个&#x27;-&#x27;符号位</span></span><br><span class="line">  <span class="keyword">if</span>(sign)</span><br><span class="line">    buf[i++] = <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 从后往前逆序输出完整的整数</span></span><br><span class="line">  <span class="keyword">while</span>(--i &gt;= <span class="number">0</span>)</span><br><span class="line">    consputc(buf[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">printptr</span><span class="params">(uint64 x)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="comment">// 输出十六进制标志&quot;0x&quot;</span></span><br><span class="line">  consputc(<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">  consputc(<span class="string">&#x27;x&#x27;</span>);</span><br><span class="line">  <span class="comment">// 十六进制的输出按照4位对齐(如0x00000000003fffff)</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; (<span class="keyword">sizeof</span>(uint64) * <span class="number">2</span>); i++, x &lt;&lt;= <span class="number">4</span>)</span><br><span class="line">    consputc(digits[x &gt;&gt; (<span class="keyword">sizeof</span>(uint64) * <span class="number">8</span> - <span class="number">4</span>)]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Print to the console. only understands %d, %x, %p, %s</span></span><br><span class="line"><span class="comment">// printf格式化输出字符，仅限于处理 %d十进制整型 %x十六进制整型 %p指针类型 %s字符串类型</span></span><br><span class="line"><span class="comment">// printf输出的内容都是字符数据，即使是整数也被拆分为个位、十位、百位等字符一个个输出(注意负数要额外输出一个负号)</span></span><br><span class="line"><span class="comment">// 每次调用printf真正打印字符之前都需要先acquire(&amp;pr.lock),输出完毕再释放锁，避免交叉打印</span></span><br><span class="line"><span class="comment">// 交互流程：printf函数通过consputc与控制台驱动console.c交互--&gt;console.c通过uartputc_sync与UART硬件交互--&gt;屏幕显示字符</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">printf</span><span class="params">(<span class="type">char</span> *fmt, ...)</span></span><br><span class="line">&#123;</span><br><span class="line">  va_list ap;</span><br><span class="line">  <span class="type">int</span> i, c, locking;</span><br><span class="line">  <span class="type">char</span> *s;</span><br><span class="line">  <span class="comment">// 开启锁定标志，每次调用printf都需要串行化等待获得pr.lock</span></span><br><span class="line">  locking = pr.locking;</span><br><span class="line">  <span class="keyword">if</span>(locking)</span><br><span class="line">    acquire(&amp;pr.lock);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// fmt内容不能为空</span></span><br><span class="line">  <span class="keyword">if</span> (fmt == <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;null fmt&quot;</span>);</span><br><span class="line"></span><br><span class="line">  va_start(ap, fmt);</span><br><span class="line">  <span class="comment">// 开始逐个解析字符并打印到控制台</span></span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; (c = fmt[i] &amp; <span class="number">0xff</span>) != <span class="number">0</span>; i++)&#123;</span><br><span class="line">    <span class="comment">// 一般的字符直接输出即可</span></span><br><span class="line">    <span class="keyword">if</span>(c != <span class="string">&#x27;%&#x27;</span>)&#123;</span><br><span class="line">      consputc(c);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 遇到&#x27;%&#x27;需要判断输出格式，依据是&quot;%&quot;的后一个字符</span></span><br><span class="line">    c = fmt[++i] &amp; <span class="number">0xff</span>;</span><br><span class="line">    <span class="keyword">if</span>(c == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">switch</span>(c)&#123;</span><br><span class="line">    <span class="comment">// 10进制整数</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;d&#x27;</span>:</span><br><span class="line">      printint(va_arg(ap, <span class="type">int</span>), <span class="number">10</span>, <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">// 16进制整数</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;x&#x27;</span>:</span><br><span class="line">      printint(va_arg(ap, <span class="type">int</span>), <span class="number">16</span>, <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">// 指针类型</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;p&#x27;</span>:</span><br><span class="line">      printptr(va_arg(ap, uint64));</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">// 字符串类型</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;s&#x27;</span>:</span><br><span class="line">      <span class="comment">// 如果字符串为空，则默认输出&quot;(null)&quot;</span></span><br><span class="line">      <span class="keyword">if</span>((s = va_arg(ap, <span class="type">char</span>*)) == <span class="number">0</span>)</span><br><span class="line">        s = <span class="string">&quot;(null)&quot;</span>;</span><br><span class="line">      <span class="keyword">for</span>(; *s; s++)</span><br><span class="line">        consputc(*s);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">// 如果想要输出%需要两个连续的%</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;%&#x27;</span>:</span><br><span class="line">      consputc(<span class="string">&#x27;%&#x27;</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="comment">// Print unknown % sequence to draw attention.</span></span><br><span class="line">      <span class="comment">// 位置格式的按照原样输出，例如&quot;%f&quot;</span></span><br><span class="line">      consputc(<span class="string">&#x27;%&#x27;</span>);</span><br><span class="line">      consputc(c);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 输出完后释放自旋锁</span></span><br><span class="line">  <span class="keyword">if</span>(locking)</span><br><span class="line">    release(&amp;pr.lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">panic</span><span class="params">(<span class="type">char</span> *s)</span></span><br><span class="line">&#123;</span><br><span class="line">  pr.locking = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;panic: &quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(s);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">  panicked = <span class="number">1</span>; <span class="comment">// freeze uart output from other CPUs</span></span><br><span class="line">  <span class="keyword">for</span>(;;)</span><br><span class="line">    ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">printfinit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  initlock(&amp;pr.lock, <span class="string">&quot;pr&quot;</span>);</span><br><span class="line">  pr.locking = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>console.c的consputc</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// send one character to the uart.</span></span><br><span class="line"><span class="comment">// called by printf, and to echo input characters,</span></span><br><span class="line"><span class="comment">// but not from write().</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">consputc</span><span class="params">(<span class="type">int</span> c)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(c == BACKSPACE)&#123;</span><br><span class="line">    <span class="comment">// if the user typed backspace, overwrite with a space.</span></span><br><span class="line">    uartputc_sync(<span class="string">&#x27;\b&#x27;</span>); uartputc_sync(<span class="string">&#x27; &#x27;</span>); uartputc_sync(<span class="string">&#x27;\b&#x27;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    uartputc_sync(c);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>uart.c的uartputc_sync</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// UART 硬件在软件看来是一组内存映射的控制寄存器。</span></span><br><span class="line"><span class="comment">// 也就是说，有一些 RISC-V 硬件的物理内存地址会连接到 UART 设备，因此加载和存储与设备硬件而不是 RAM 交互.</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Reg(reg) ((volatile unsigned char *)(UART0 + reg))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LSR 5                 <span class="comment">// line status register</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LSR_RX_READY (1&lt;&lt;0)   <span class="comment">// input is waiting to be read from RHR</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LSR_TX_IDLE (1&lt;&lt;5)    <span class="comment">// THR can accept another character to send</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// alternate version of uartputc() that doesn&#x27;t </span></span><br><span class="line"><span class="comment">// use interrupts, for use by kernel printf() and</span></span><br><span class="line"><span class="comment">// to echo characters. it spins waiting for the uart&#x27;s</span></span><br><span class="line"><span class="comment">// output register to be empty.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">uartputc_sync</span><span class="params">(<span class="type">int</span> c)</span></span><br><span class="line">&#123;</span><br><span class="line">  push_off();</span><br><span class="line">  <span class="keyword">if</span>(panicked)&#123;</span><br><span class="line">    <span class="keyword">for</span>(;;)</span><br><span class="line">      ;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// wait for Transmit Holding Empty to be set in LSR.</span></span><br><span class="line">  <span class="keyword">while</span>((ReadReg(LSR) &amp; LSR_TX_IDLE) == <span class="number">0</span>)</span><br><span class="line">    ;</span><br><span class="line">  WriteReg(THR, c);</span><br><span class="line">  pop_off();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>xv6 shell 通过 init.c打开的文件描述符从控制台读取。consoleread 等待输入的到来(通过中断)，输入会被缓冲在 cons.buf，然后将输入复制到用户空间，再然后(在一整行到达后)返回到用户进程。如果用户还没有输入完整的行，任何 read 进程将在 sleep调用中等待。</p>
<blockquote>
<p>当用户键入一个字符时，UART 硬件向 RISC-V 抛出一个中断，从而激活 xv6 的 trap处理程序。trap 处理程序调用 devintr，它查看 RISC-V 的 scause 寄存器，发现中断来自一个外部设备。然后它向一个叫做 PLIC的硬件单元询问哪个设备中断了。如果是 UART，devintr 调用 uartintr。</p>
</blockquote>
<p>uartintr从 UART 硬件中读取在等待的输入字符，并将它们交给consoleintr；它不会等待输入字符，因为以后的输入会引发一个新的中断。<code>consoleintr 的工作是将中输入字符积累 cons.buf中，直到有一行字符。consoleintr会特别处理退格键和其他一些字符。当一个新行到达时，consoleintr会唤醒一个等待的consoleread（如果有的话）。</code>一旦被唤醒，consoleread 将会注意到 cons.buf 中的完整行，并将其将其复制到用户空间，并返回（通过系统调用）到用户空间。</p>
<p><code>trap.c的设备中断devintr</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// check if it&#x27;s an external interrupt or software interrupt,</span></span><br><span class="line"><span class="comment">// and handle it.</span></span><br><span class="line"><span class="comment">// returns 2 if timer interrupt,</span></span><br><span class="line"><span class="comment">// 1 if other device,</span></span><br><span class="line"><span class="comment">// 0 if not recognized.</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">devintr</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  uint64 scause = r_scause();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// this is a supervisor external interrupt, via PLIC.</span></span><br><span class="line">  <span class="keyword">if</span>((scause &amp; <span class="number">0x8000000000000000</span>L) &amp;&amp;</span><br><span class="line">     (scause &amp; <span class="number">0xff</span>) == <span class="number">9</span>)&#123;</span><br><span class="line">    <span class="comment">// irq indicates which device interrupted.</span></span><br><span class="line">    <span class="type">int</span> irq = plic_claim();</span><br><span class="line">    <span class="keyword">if</span>(irq == UART0_IRQ)&#123;</span><br><span class="line">      uartintr();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(irq == VIRTIO0_IRQ)&#123;</span><br><span class="line">      virtio_disk_intr();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(irq)&#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;unexpected interrupt irq=%d\n&quot;</span>, irq);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// the PLIC allows each device to raise at most one</span></span><br><span class="line">    <span class="comment">// interrupt at a time; tell the PLIC the device is</span></span><br><span class="line">    <span class="comment">// now allowed to interrupt again.</span></span><br><span class="line">    <span class="keyword">if</span>(irq)</span><br><span class="line">      plic_complete(irq);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="comment">// software interrupt from a machine-mode timer interrupt,</span></span><br><span class="line">  <span class="comment">// forwarded by timervec in kernelvec.S</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(scause == <span class="number">0x8000000000000001</span>L)&#123;</span><br><span class="line">    <span class="keyword">if</span>(cpuid() == <span class="number">0</span>)&#123;</span><br><span class="line">      clockintr();</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// acknowledge the software interrupt by clearing</span></span><br><span class="line">    <span class="comment">// the SSIP bit in sip.</span></span><br><span class="line">    w_sip(r_sip() &amp; ~<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>uart.c的uartintr</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> LSR 5                 <span class="comment">// line status register</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LSR_RX_READY (1&lt;&lt;0)   <span class="comment">// input is waiting to be read from RHR</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LSR_TX_IDLE (1&lt;&lt;5)    <span class="comment">// THR can accept another character to send</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// read one input character from the UART.</span></span><br><span class="line"><span class="comment">// return -1 if none is waiting.</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">uartgetc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(ReadReg(LSR) &amp; <span class="number">0x01</span>)&#123;</span><br><span class="line">    <span class="comment">// input data is ready.</span></span><br><span class="line">    <span class="keyword">return</span> ReadReg(RHR);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// handle a uart interrupt, raised because input has</span></span><br><span class="line"><span class="comment">// arrived, or the uart is ready for more output, or</span></span><br><span class="line"><span class="comment">// both. called from trap.c.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">uartintr</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// read and process incoming characters.</span></span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="comment">// 读取来自UART的一个输入字符</span></span><br><span class="line">    <span class="type">int</span> c = uartgetc();</span><br><span class="line">    <span class="keyword">if</span>(c == <span class="number">-1</span>)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">// 字符追加到cons.buffer并唤醒可能休眠的consoleread()</span></span><br><span class="line">    consoleintr(c);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// send buffered characters.</span></span><br><span class="line">  acquire(&amp;uart_tx_lock);</span><br><span class="line">  uartstart();</span><br><span class="line">  release(&amp;uart_tx_lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>console.c的consoleintr</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="comment">// 串行化访问console硬件，避免乱序的输出</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span>  </span><br><span class="line">  <span class="meta">#<span class="keyword">define</span> INPUT_BUF 128</span></span><br><span class="line">  <span class="type">char</span> buf[INPUT_BUF];</span><br><span class="line">  uint r;  <span class="comment">// Read index</span></span><br><span class="line">  uint w;  <span class="comment">// Write index</span></span><br><span class="line">  uint e;  <span class="comment">// Edit index</span></span><br><span class="line">&#125; cons;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// the console input interrupt handler.</span></span><br><span class="line"><span class="comment">// uartintr() calls this for input character.</span></span><br><span class="line"><span class="comment">// do erase/kill processing, append to cons.buf,</span></span><br><span class="line"><span class="comment">// wake up consoleread() if a whole line has arrived.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">consoleintr</span><span class="params">(<span class="type">int</span> c)</span></span><br><span class="line">&#123;</span><br><span class="line">  acquire(&amp;cons.lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span>(c)&#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="title function_">C</span><span class="params">(<span class="string">&#x27;P&#x27;</span>)</span>:  <span class="comment">// Print process list.</span></span><br><span class="line">    <span class="title function_">procdump</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="title function_">C</span><span class="params">(<span class="string">&#x27;U&#x27;</span>)</span>:  <span class="comment">// Kill line.</span></span><br><span class="line">    <span class="title function_">while</span><span class="params">(cons.e != cons.w &amp;&amp;</span></span><br><span class="line"><span class="params">          cons.buf[(cons.e<span class="number">-1</span>) % INPUT_BUF] != <span class="string">&#x27;\n&#x27;</span>)</span>&#123;</span><br><span class="line">      cons.e--;</span><br><span class="line">      consputc(BACKSPACE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="title function_">C</span><span class="params">(<span class="string">&#x27;H&#x27;</span>)</span>: <span class="comment">// Backspace</span></span><br><span class="line">  <span class="keyword">case</span> &#x27;\x7f&#x27;:</span><br><span class="line">    <span class="title function_">if</span><span class="params">(cons.e != cons.w)</span>&#123;</span><br><span class="line">      cons.e--;</span><br><span class="line">      consputc(BACKSPACE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">if</span>(c != <span class="number">0</span> &amp;&amp; cons.e-cons.r &lt; INPUT_BUF)&#123;</span><br><span class="line">      c = (c == <span class="string">&#x27;\r&#x27;</span>) ? <span class="string">&#x27;\n&#x27;</span> : c;</span><br><span class="line">      <span class="comment">// echo back to the user.</span></span><br><span class="line">      <span class="comment">// 字符回显到屏幕！！</span></span><br><span class="line">      consputc(c);</span><br><span class="line">      <span class="comment">// store for consumption by consoleread().</span></span><br><span class="line">      <span class="comment">// 字符添加到cons.buffer中！！</span></span><br><span class="line">      cons.buf[cons.e++ % INPUT_BUF] = c;</span><br><span class="line">      <span class="keyword">if</span>(c == <span class="string">&#x27;\n&#x27;</span> || c == C(<span class="string">&#x27;D&#x27;</span>) || cons.e == cons.r+INPUT_BUF)&#123;</span><br><span class="line">        <span class="comment">// wake up consoleread() if a whole line (or end-of-file)</span></span><br><span class="line">        <span class="comment">// has arrived.</span></span><br><span class="line">        <span class="comment">// 一整行或者文件结束符到达后唤醒休眠的consoleread()</span></span><br><span class="line">        cons.w = cons.e;</span><br><span class="line">        wakeup(&amp;cons.r);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  release(&amp;cons.lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Print a process listing to console.  For debugging.</span></span><br><span class="line"><span class="comment">// Runs when user types ^P on console.</span></span><br><span class="line"><span class="comment">// No lock to avoid wedging a stuck machine further.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">procdump</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">static</span> <span class="type">char</span> *states[] = &#123;</span><br><span class="line">  [UNUSED]    <span class="string">&quot;unused&quot;</span>,</span><br><span class="line">  [SLEEPING]  <span class="string">&quot;sleep &quot;</span>,</span><br><span class="line">  [RUNNABLE]  <span class="string">&quot;runble&quot;</span>,</span><br><span class="line">  [RUNNING]   <span class="string">&quot;run   &quot;</span>,</span><br><span class="line">  [ZOMBIE]    <span class="string">&quot;zombie&quot;</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line">  <span class="type">char</span> *state;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span>(p = proc; p &lt; &amp;proc[NPROC]; p++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;state == UNUSED)</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;state &gt;= <span class="number">0</span> &amp;&amp; p-&gt;state &lt; NELEM(states) &amp;&amp; states[p-&gt;state])</span><br><span class="line">      state = states[p-&gt;state];</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      state = <span class="string">&quot;???&quot;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %s %s&quot;</span>, p-&gt;pid, state, p-&gt;name);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>console.c的consoleread</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// user read()s from the console go here.</span></span><br><span class="line"><span class="comment">// copy (up to) a whole input line to dst.</span></span><br><span class="line"><span class="comment">// user_dist indicates whether dst is a user</span></span><br><span class="line"><span class="comment">// or kernel address.</span></span><br><span class="line"><span class="comment">// 读取键盘的数据并拷贝至目标地址（实际上数据最终被放入shell的buf中）</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">consoleread</span><span class="params">(<span class="type">int</span> user_dst, uint64 dst, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint target;</span><br><span class="line">  <span class="type">int</span> c;</span><br><span class="line">  <span class="type">char</span> cbuf;</span><br><span class="line"></span><br><span class="line">  target = n;</span><br><span class="line">  acquire(&amp;cons.lock);</span><br><span class="line">  <span class="keyword">while</span>(n &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">// wait until interrupt handler has put some</span></span><br><span class="line">    <span class="comment">// input into cons.buffer.</span></span><br><span class="line">    <span class="keyword">while</span>(cons.r == cons.w)&#123;</span><br><span class="line">      <span class="keyword">if</span>(myproc()-&gt;killed)&#123;</span><br><span class="line">        release(&amp;cons.lock);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// cons.buf为空，则休眠等待中断处理函数把数据放入cons.buffer</span></span><br><span class="line">      sleep(&amp;cons.r, &amp;cons.lock);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    c = cons.buf[cons.r++ % INPUT_BUF];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(c == C(<span class="string">&#x27;D&#x27;</span>))&#123;  <span class="comment">// end-of-file</span></span><br><span class="line">      <span class="keyword">if</span>(n &lt; target)&#123;</span><br><span class="line">        <span class="comment">// Save ^D for next time, to make sure</span></span><br><span class="line">        <span class="comment">// caller gets a 0-byte result.</span></span><br><span class="line">        cons.r--;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// copy the input byte to the user-space buffer.</span></span><br><span class="line">    cbuf = c;</span><br><span class="line">    <span class="keyword">if</span>(either_copyout(user_dst, dst, &amp;cbuf, <span class="number">1</span>) == <span class="number">-1</span>)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    dst++;</span><br><span class="line">    --n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(c == <span class="string">&#x27;\n&#x27;</span>)&#123;</span><br><span class="line">      <span class="comment">// a whole line has arrived, return to</span></span><br><span class="line">      <span class="comment">// the user-level read().</span></span><br><span class="line">      <span class="comment">// 读取到一整行的末尾则结束</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  release(&amp;cons.lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> target - n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-2控制台输出"><a href="#5-2控制台输出" class="headerlink" title="5.2控制台输出"></a>5.2控制台输出</h4><p>向控制台写数据的 write 系统调用最终会到达 uartputc。<code>设备驱动维护了一个输出缓冲uart_tx_buf，这样写入过程就不需要等待UART完成发送；相反，uartputc将每个字符追加到缓冲区，调用uartstart来启动设备发送(如果还没有的话)，然后返回。</code>uartputc只有在缓冲区满的时候才会等待。</p>
<p>&#x3D;&#x3D;每次 UART 发送完成一个字节，它都会产生一个中断。uartintr 调用 uartstart，uartintr检查设备是否真的发送完毕，并将下一个缓冲输出字符交给设备，每当 UART 发送完一个字节，就会产生一个中断。因此，如果一个进程向控制台写入多个字节，通常第一个字节将由uartputc调用 uartstart 发送，其余的缓冲字节将由 uartintr 调用 uartstart 发送，因为发送完成中断到来。&#x3D;&#x3D;</p>
<p><code>有一个通用模式需要注意，设备活动和进程活动需要解耦，这将通过缓冲和中断来实现。</code>&#x3D;&#x3D;控制台驱动程序可以处理输入，即使没有进程等待读取它，随后的读取将看到输入。同样，进程可以发送输出字节，而不必等待设备。&#x3D;&#x3D;<code>这种解耦可以通过允许进程与设备I/O并发执行来提高性能，当设备速度很慢如 UART或需要立即关注（如打印键入的字节）时，这种解耦尤为重要。</code>这个 idea 有时被称为 I&#x2F;O 并发。</p>
<p>5.1的代码完成了字符从键盘的中断输入并回显，那么用户空间的printf函数如何打印字符的呢？</p>
<p><code>user/printf.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> digits[] = <span class="string">&quot;0123456789ABCDEF&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">putc</span><span class="params">(<span class="type">int</span> fd, <span class="type">char</span> c)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 重点在这里，系统调用write</span></span><br><span class="line">  write(fd, &amp;c, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">printint</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> xx, <span class="type">int</span> base, <span class="type">int</span> sgn)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">16</span>];</span><br><span class="line">  <span class="type">int</span> i, neg;</span><br><span class="line">  uint x;</span><br><span class="line"></span><br><span class="line">  neg = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span>(sgn &amp;&amp; xx &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    neg = <span class="number">1</span>;</span><br><span class="line">    x = -xx;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    x = xx;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">do</span>&#123;</span><br><span class="line">    buf[i++] = digits[x % base];</span><br><span class="line">  &#125;<span class="keyword">while</span>((x /= base) != <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span>(neg)</span><br><span class="line">    buf[i++] = <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(--i &gt;= <span class="number">0</span>)</span><br><span class="line">    putc(fd, buf[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">printptr</span><span class="params">(<span class="type">int</span> fd, uint64 x)</span> &#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  putc(fd, <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">  putc(fd, <span class="string">&#x27;x&#x27;</span>);</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; (<span class="keyword">sizeof</span>(uint64) * <span class="number">2</span>); i++, x &lt;&lt;= <span class="number">4</span>)</span><br><span class="line">    putc(fd, digits[x &gt;&gt; (<span class="keyword">sizeof</span>(uint64) * <span class="number">8</span> - <span class="number">4</span>)]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Print to the given fd. Only understands %d, %x, %p, %s.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">vprintf</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">char</span> *fmt, va_list ap)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> *s;</span><br><span class="line">  <span class="type">int</span> c, i, state;</span><br><span class="line"></span><br><span class="line">  state = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; fmt[i]; i++)&#123;</span><br><span class="line">    c = fmt[i] &amp; <span class="number">0xff</span>;</span><br><span class="line">    <span class="keyword">if</span>(state == <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="keyword">if</span>(c == <span class="string">&#x27;%&#x27;</span>)&#123;</span><br><span class="line">        state = <span class="string">&#x27;%&#x27;</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        putc(fd, c);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(state == <span class="string">&#x27;%&#x27;</span>)&#123;</span><br><span class="line">      <span class="keyword">if</span>(c == <span class="string">&#x27;d&#x27;</span>)&#123;</span><br><span class="line">        printint(fd, va_arg(ap, <span class="type">int</span>), <span class="number">10</span>, <span class="number">1</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">&#x27;l&#x27;</span>) &#123;</span><br><span class="line">        printint(fd, va_arg(ap, uint64), <span class="number">10</span>, <span class="number">0</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">&#x27;x&#x27;</span>) &#123;</span><br><span class="line">        printint(fd, va_arg(ap, <span class="type">int</span>), <span class="number">16</span>, <span class="number">0</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">&#x27;p&#x27;</span>) &#123;</span><br><span class="line">        printptr(fd, va_arg(ap, uint64));</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">&#x27;s&#x27;</span>)&#123;</span><br><span class="line">        s = va_arg(ap, <span class="type">char</span>*);</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="number">0</span>)</span><br><span class="line">          s = <span class="string">&quot;(null)&quot;</span>;</span><br><span class="line">        <span class="keyword">while</span>(*s != <span class="number">0</span>)&#123;</span><br><span class="line">          putc(fd, *s);</span><br><span class="line">          s++;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">&#x27;c&#x27;</span>)&#123;</span><br><span class="line">        putc(fd, va_arg(ap, uint));</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">&#x27;%&#x27;</span>)&#123;</span><br><span class="line">        putc(fd, c);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Unknown % sequence.  Print it to draw attention.</span></span><br><span class="line">        putc(fd, <span class="string">&#x27;%&#x27;</span>);</span><br><span class="line">        putc(fd, c);</span><br><span class="line">      &#125;</span><br><span class="line">      state = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">fprintf</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">char</span> *fmt, ...)</span></span><br><span class="line">&#123;</span><br><span class="line">  va_list ap;</span><br><span class="line"></span><br><span class="line">  va_start(ap, fmt);</span><br><span class="line">  <span class="built_in">vprintf</span>(fd, fmt, ap);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">printf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *fmt, ...)</span></span><br><span class="line">&#123;</span><br><span class="line">  va_list ap;</span><br><span class="line"></span><br><span class="line">  va_start(ap, fmt);</span><br><span class="line">  <span class="built_in">vprintf</span>(<span class="number">1</span>, fmt, ap);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>sysfile.c的sys_write</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_write</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">f</span>;</span></span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line">  uint64 p;</span><br><span class="line">  <span class="comment">//解析系统调用参数</span></span><br><span class="line">  <span class="keyword">if</span>(argfd(<span class="number">0</span>, <span class="number">0</span>, &amp;f) &lt; <span class="number">0</span> || argint(<span class="number">2</span>, &amp;n) &lt; <span class="number">0</span> || argaddr(<span class="number">1</span>, &amp;p) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> filewrite(f, p, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>file.c的filewrite</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Write to file f.</span></span><br><span class="line"><span class="comment">// addr is a user virtual address.</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">filewrite</span><span class="params">(<span class="keyword">struct</span> file *f, uint64 addr, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> r, ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 检查文件读写权限</span></span><br><span class="line">  <span class="keyword">if</span>(f-&gt;writable == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 根据文件类型选择不同的写入函数</span></span><br><span class="line">  <span class="keyword">if</span>(f-&gt;type == FD_PIPE)&#123;</span><br><span class="line">    ret = pipewrite(f-&gt;pipe, addr, n);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>(f-&gt;type == FD_DEVICE)&#123;</span><br><span class="line">    <span class="keyword">if</span>(f-&gt;major &lt; <span class="number">0</span> || f-&gt;major &gt;= NDEV || !devsw[f-&gt;major].write)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">// Linux中一切皆文件包括设备，这里的思想也一样：对于文件的读写深入底层其实是不同设备的读写接口</span></span><br><span class="line">    ret = devsw[f-&gt;major].write(<span class="number">1</span>, addr, n);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>(f-&gt;type == FD_INODE)&#123;</span><br><span class="line">    <span class="comment">// write a few blocks at a time to avoid exceeding</span></span><br><span class="line">    <span class="comment">// the maximum log transaction size, including</span></span><br><span class="line">    <span class="comment">// i-node, indirect block, allocation blocks,</span></span><br><span class="line">    <span class="comment">// and 2 blocks of slop for non-aligned writes.</span></span><br><span class="line">    <span class="comment">// this really belongs lower down, since writei()</span></span><br><span class="line">    <span class="comment">// might be writing a device like the console.</span></span><br><span class="line">    <span class="type">int</span> max = ((MAXOPBLOCKS<span class="number">-1</span><span class="number">-1</span><span class="number">-2</span>) / <span class="number">2</span>) * BSIZE;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; n)&#123;</span><br><span class="line">      <span class="type">int</span> n1 = n - i;</span><br><span class="line">      <span class="keyword">if</span>(n1 &gt; max)</span><br><span class="line">        n1 = max;</span><br><span class="line"></span><br><span class="line">      begin_op();</span><br><span class="line">      ilock(f-&gt;ip);</span><br><span class="line">      <span class="keyword">if</span> ((r = writei(f-&gt;ip, <span class="number">1</span>, addr + i, f-&gt;off, n1)) &gt; <span class="number">0</span>)</span><br><span class="line">        f-&gt;off += r;</span><br><span class="line">      iunlock(f-&gt;ip);</span><br><span class="line">      end_op();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span>(r &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">if</span>(r != n1)</span><br><span class="line">        panic(<span class="string">&quot;short filewrite&quot;</span>);</span><br><span class="line">      i += r;</span><br><span class="line">    &#125;</span><br><span class="line">    ret = (i == n ? n : <span class="number">-1</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    panic(<span class="string">&quot;filewrite&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>console.c的consolewrite</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// user write()s to the console go here.</span></span><br><span class="line"><span class="comment">// user_src=1表示src是用户空间的虚拟地址，src表示字符数据的地址，n表示要写入的字符数</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">consolewrite</span><span class="params">(<span class="type">int</span> user_src, uint64 src, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  acquire(&amp;cons.lock);</span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    <span class="keyword">if</span>(either_copyin(&amp;c, user_src, src+i, <span class="number">1</span>) == <span class="number">-1</span>)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">// 把一个字符写入输出缓冲区</span></span><br><span class="line">    uartputc(c);</span><br><span class="line">  &#125;</span><br><span class="line">  release(&amp;cons.lock);</span><br><span class="line">  <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>proc.c的either_copyin</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Copy from either a user address, or kernel address,</span></span><br><span class="line"><span class="comment">// depending on usr_src.</span></span><br><span class="line"><span class="comment">// Returns 0 on success, -1 on error.</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">either_copyin</span><span class="params">(<span class="type">void</span> *dst, <span class="type">int</span> user_src, uint64 src, uint64 len)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  <span class="keyword">if</span>(user_src)&#123;</span><br><span class="line">    <span class="comment">// 用户空间的数据需要通过copyin使用用户页表拷贝数据</span></span><br><span class="line">    <span class="keyword">return</span> copyin(p-&gt;pagetable, dst, src, len);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 内核空间的数据可以直接通过memmove复制数据(因为此时系统就处于内核态)</span></span><br><span class="line">    memmove(dst, (<span class="type">char</span>*)src, len);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>uart.c的uartputc</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// the transmit output buffer.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">uart_tx_lock</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UART_TX_BUF_SIZE 32</span></span><br><span class="line"><span class="type">char</span> uart_tx_buf[UART_TX_BUF_SIZE];</span><br><span class="line"><span class="type">int</span> uart_tx_w; <span class="comment">// write next to uart_tx_buf[uart_tx_w++]</span></span><br><span class="line"><span class="type">int</span> uart_tx_r; <span class="comment">// read next from uart_tx_buf[uar_tx_r++]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// add a character to the output buffer and tell the</span></span><br><span class="line"><span class="comment">// UART to start sending if it isn&#x27;t already.</span></span><br><span class="line"><span class="comment">// blocks if the output buffer is full.</span></span><br><span class="line"><span class="comment">// because it may block, it can&#x27;t be called</span></span><br><span class="line"><span class="comment">// from interrupts; it&#x27;s only suitable for use</span></span><br><span class="line"><span class="comment">// by write().</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">uartputc</span><span class="params">(<span class="type">int</span> c)</span></span><br><span class="line">&#123;</span><br><span class="line">  acquire(&amp;uart_tx_lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(panicked)&#123;</span><br><span class="line">    <span class="keyword">for</span>(;;)</span><br><span class="line">      ;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 外层的while循环防止假唤醒</span></span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(((uart_tx_w + <span class="number">1</span>) % UART_TX_BUF_SIZE) == uart_tx_r)&#123;</span><br><span class="line">      <span class="comment">// buffer is full.</span></span><br><span class="line">      <span class="comment">// wait for uartstart() to open up space in the buffer.</span></span><br><span class="line">      <span class="comment">// 循环缓冲区满了，则休眠在最近等待发送的字符位置uart_tx_r处等待uartstart的唤醒</span></span><br><span class="line">      sleep(&amp;uart_tx_r, &amp;uart_tx_lock);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 正常情况下输出缓冲区有空间，字符直接追加写入即可</span></span><br><span class="line">      uart_tx_buf[uart_tx_w] = c;</span><br><span class="line">      uart_tx_w = (uart_tx_w + <span class="number">1</span>) % UART_TX_BUF_SIZE;</span><br><span class="line">      <span class="comment">// 准备好数据就可以发送</span></span><br><span class="line">      uartstart();</span><br><span class="line">      release(&amp;uart_tx_lock);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>uart.c的uartstart</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// if the UART is idle, and a character is waiting</span></span><br><span class="line"><span class="comment">// in the transmit buffer, send it.</span></span><br><span class="line"><span class="comment">// caller must hold uart_tx_lock.</span></span><br><span class="line"><span class="comment">// called from both the top- and bottom-half.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">uartstart</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(uart_tx_w == uart_tx_r)&#123;</span><br><span class="line">      <span class="comment">// transmit buffer is empty.</span></span><br><span class="line">      <span class="comment">// 发送缓冲区为空直接退出</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>((ReadReg(LSR) &amp; LSR_TX_IDLE) == <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="comment">// the UART transmit holding register is full,</span></span><br><span class="line">      <span class="comment">// so we cannot give it another byte.</span></span><br><span class="line">      <span class="comment">// it will interrupt when it&#x27;s ready for a new byte.</span></span><br><span class="line">      <span class="comment">// UART传输寄存器有内容，我们不能覆盖，这个函数会在UART硬件传输完上一个字符准备新字符输出时被uartintr中断调用</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="type">int</span> c = uart_tx_buf[uart_tx_r];</span><br><span class="line">    uart_tx_r = (uart_tx_r + <span class="number">1</span>) % UART_TX_BUF_SIZE;</span><br><span class="line">    <span class="comment">// maybe uartputc() is waiting for space in the buffer.</span></span><br><span class="line">    <span class="comment">// 发送一个字符后，唤醒可能休眠的uartputc()</span></span><br><span class="line">    wakeup(&amp;uart_tx_r);</span><br><span class="line">    </span><br><span class="line">    WriteReg(THR, c);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>发送的关键：uartintr</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// handle a uart interrupt, raised because input has</span></span><br><span class="line"><span class="comment">// arrived, or the uart is ready for more output, or</span></span><br><span class="line"><span class="comment">// both. called from trap.c</span></span><br><span class="line"><span class="comment">// uartintr不仅处理键盘的字符输入中断，还需要处理UART硬件的字符输出完毕中断</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">uartintr</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// read and process incoming characters.</span></span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="comment">// 读取来自UART的一个输入字符</span></span><br><span class="line">    <span class="type">int</span> c = uartgetc();</span><br><span class="line">    <span class="keyword">if</span>(c == <span class="number">-1</span>)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">// 字符追加到cons.buffer并唤醒可能休眠的consoleread()</span></span><br><span class="line">    consoleintr(c);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// send buffered characters.</span></span><br><span class="line">  <span class="comment">// UART传输完毕中断，尝试传输新的uart_tx_buf字符</span></span><br><span class="line">  acquire(&amp;uart_tx_lock);</span><br><span class="line">  uartstart();</span><br><span class="line">  release(&amp;uart_tx_lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-3设备并发"><a href="#5-3设备并发" class="headerlink" title="5.3设备并发"></a>5.3设备并发</h4><p>你可能已经注意到在 consoleread 和 consoleintr 中会调用 acquire。<code>acquire 调用会获取一个锁，保护控制台驱动的数据结构不被并发访问。</code>这里有三个并发风险：&#x3D;&#x3D;不同 CPU 上的两个进程可能会同时调用 consoleread；硬件可能会在一个 CPU 正在执行 consoleread 时，向该 CPU 抛出一个控制台（实际上是 UART）中断；硬件可能会在 consoleread 执行时向另一个 CPU 抛出一个控制台中断。&#x3D;&#x3D;第 6 章探讨锁如何在这些情况下提供帮助。</p>
<p>需要关注驱动并发安全的另一个原因是，一个进程可能正在等待来自设备的输入，但是此时该进程已经没有在运行（被切换）。因此，中断处理程序不允许知道被中断的进程或代码。例如，一个中断处理程序不能安全地用当前进程的页表调用 copyout。中断处理程序通常只做相对较少的工作（例如，只是将输入数据复制到缓冲区），并唤醒上半部分代码来做剩下的工作。</p>
<h4 id="5-4时钟中断"><a href="#5-4时钟中断" class="headerlink" title="5.4时钟中断"></a>5.4时钟中断</h4><p>xv6 使用定时器中断来维护它的时钟，并使它能够切换正在运行的进程；usertrap 和kerneltrap 中的 yield 调用会导致这种切换。<code>每个RISC-V CPU的时钟硬件都会抛出时钟中断。xv6对这个时钟硬件进行编程，使其定期中断相应的CPU。</code></p>
<p>&#x3D;&#x3D;RISC-V 要求在机器模式下处理定时器中断，而不是监督者模式。RISC-V 机器模式执行时没有分页，并且有一套单独的控制寄存器，因此在机器模式下运行普通的 xv6 内核代码是不实用的。因此，xv6 对定时器中断的处理与上面谈到的 trap 机制完全分离了。&#x3D;&#x3D;</p>
<p>在 main 执行之前的 start.c，是在机器模式下执行的，设置了接收定时器中断。<code>一部分工作是对CLINT硬件（core-local interruptor）进行编程，使其每隔一定时间产生一次中断。另一部分是设置一个类似于trapframe的scratch区域，帮助定时器中断处理程序保存寄存器和CLINT寄存器的地址。最后，start将mtvec设置为timervec，启用定时器中断。</code></p>
<p><code>start.c的timerinit</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// set up to receive timer interrupts in machine mode,</span></span><br><span class="line"><span class="comment">// which arrive at timervec in kernelvec.S,</span></span><br><span class="line"><span class="comment">// which turns them into software interrupts for</span></span><br><span class="line"><span class="comment">// devintr() in trap.c.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">timerinit</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// each CPU has a separate source of timer interrupts.</span></span><br><span class="line">  <span class="comment">// 首先读出 CPU 的 ID</span></span><br><span class="line">  <span class="type">int</span> id = r_mhartid();</span><br><span class="line">  <span class="comment">// ask the CLINT for a timer interrupt.</span></span><br><span class="line">  <span class="comment">// 设置中断时间间隔，这里设置的是 0.1 秒</span></span><br><span class="line">  <span class="type">int</span> interval = <span class="number">1000000</span>; <span class="comment">// cycles; about 1/10th second in qemu.</span></span><br><span class="line">  *(uint64*)CLINT_MTIMECMP(id) = *(uint64*)CLINT_MTIME + interval;</span><br><span class="line">  <span class="comment">// prepare information in scratch[] for timervec.</span></span><br><span class="line">  <span class="comment">// scratch[0..3] : space for timervec to save registers.</span></span><br><span class="line">  <span class="comment">// scratch[4] : address of CLINT MTIMECMP register.</span></span><br><span class="line">  <span class="comment">// scratch[5] : desired interval (in cycles) between timer interrupts.</span></span><br><span class="line">  uint64 *scratch = &amp;mscratch0[<span class="number">32</span> * id];</span><br><span class="line">  scratch[<span class="number">4</span>] = CLINT_MTIMECMP(id);</span><br><span class="line">  scratch[<span class="number">5</span>] = interval;</span><br><span class="line">  w_mscratch((uint64)scratch);</span><br><span class="line">  <span class="comment">// set the machine-mode trap handler.</span></span><br><span class="line">  <span class="comment">// 设置时钟中断处理函数</span></span><br><span class="line">  w_mtvec((uint64)timervec);</span><br><span class="line">  <span class="comment">// enable machine-mode interrupts.</span></span><br><span class="line">  <span class="comment">// 打开中断</span></span><br><span class="line">  w_mstatus(r_mstatus() | MSTATUS_MIE);</span><br><span class="line">  <span class="comment">// enable machine-mode timer interrupts.</span></span><br><span class="line">  <span class="comment">// 打开时钟中断</span></span><br><span class="line">  w_mie(r_mie() | MIE_MTIE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>定时器中断可能发生在用户或内核代码执行的任何时候；内核没有办法在关键操作中禁用定时器中断。因此，定时器中断处理程序必须以保证不干扰被中断的内核代码的方式进行工作。</code>&#x3D;&#x3D;基本策略是处理程序要求 RISC-V 引发一个软件中断并立即返回。&#x3D;&#x3D;RISC-V 用普通的trap 机制将软件中断传递给内核，并允许内核禁用它们。处理定时器中断产生的软件中断的代码可以在 devintr中看到。</p>
<p><code>trap.c的devintr</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">tickslock</span>;</span></span><br><span class="line">uint ticks;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">clockintr</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  acquire(&amp;tickslock);</span><br><span class="line">  ticks++;</span><br><span class="line">  wakeup(&amp;ticks);</span><br><span class="line">  release(&amp;tickslock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// check if it&#x27;s an external interrupt or software interrupt,</span></span><br><span class="line"><span class="comment">// and handle it.</span></span><br><span class="line"><span class="comment">// returns 2 if timer interrupt,</span></span><br><span class="line"><span class="comment">// 1 if other device,</span></span><br><span class="line"><span class="comment">// 0 if not recognized.</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">devintr</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  uint64 scause = r_scause();</span><br><span class="line">  <span class="comment">// this is a supervisor external interrupt, via PLIC.</span></span><br><span class="line">  <span class="keyword">if</span>((scause &amp; <span class="number">0x8000000000000000</span>L) &amp;&amp;</span><br><span class="line">     (scause &amp; <span class="number">0xff</span>) == <span class="number">9</span>)&#123;</span><br><span class="line">    <span class="comment">// irq indicates which device interrupted.</span></span><br><span class="line">    <span class="type">int</span> irq = plic_claim();</span><br><span class="line">    <span class="keyword">if</span>(irq == UART0_IRQ)&#123;</span><br><span class="line">      uartintr();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(irq == VIRTIO0_IRQ)&#123;</span><br><span class="line">      virtio_disk_intr();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(irq)&#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;unexpected interrupt irq=%d\n&quot;</span>, irq);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// the PLIC allows each device to raise at most one</span></span><br><span class="line">    <span class="comment">// interrupt at a time; tell the PLIC the device is</span></span><br><span class="line">    <span class="comment">// now allowed to interrupt again.</span></span><br><span class="line">    <span class="keyword">if</span>(irq)</span><br><span class="line">      plic_complete(irq);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="comment">// software interrupt from a machine-mode timer interrupt,</span></span><br><span class="line">  <span class="comment">// forwarded by timervec in kernelvec.S</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(scause == <span class="number">0x8000000000000001</span>L)&#123;</span><br><span class="line">    <span class="keyword">if</span>(cpuid() == <span class="number">0</span>)&#123;</span><br><span class="line">      clockintr();</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// acknowledge the software interrupt by clearing</span></span><br><span class="line">    <span class="comment">// the SSIP bit in sip.</span></span><br><span class="line">    w_sip(r_sip() &amp; ~<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>机器模式的定时器中断向量是timervec。它在 start 准备的scratch区域保存一些寄存器，告诉 CLINT何时产生下一个定时器中断，使RISC-V产生一个软件中断，恢复寄存器，然后返回。</code>在定时器中断处理程序中没有 C 代码。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">.globl timervec</span><br><span class="line">.align 4</span><br><span class="line">timervec:</span><br><span class="line">        # start.c has set up the memory that mscratch points to:</span><br><span class="line">        # scratch[0,8,16] : register save area.</span><br><span class="line">        # scratch[32] : address of CLINT&#x27;s MTIMECMP register.</span><br><span class="line">        # scratch[40] : desired interval between interrupts.</span><br><span class="line">        csrrw a0, mscratch, a0</span><br><span class="line">        # 恢复寄存器</span><br><span class="line">        sd a1, 0(a0)</span><br><span class="line">        sd a2, 8(a0)</span><br><span class="line">        sd a3, 16(a0)</span><br><span class="line">        # schedule the next timer interrupt</span><br><span class="line">        # by adding interval to mtimecmp.</span><br><span class="line">        # 告诉 CLINT 何时产生下一个定时器中断</span><br><span class="line">        ld a1, 32(a0) # CLINT_MTIMECMP(hart)</span><br><span class="line">        ld a2, 40(a0) # interval</span><br><span class="line">        ld a3, 0(a1)</span><br><span class="line">        add a3, a3, a2</span><br><span class="line">        sd a3, 0(a1)</span><br><span class="line">        # raise a supervisor software interrupt.</span><br><span class="line">        # 使 RISC-V 产生一个软件中断</span><br><span class="line">		li a1, 2</span><br><span class="line">        csrw sip, a1</span><br><span class="line">		# 保存寄存器</span><br><span class="line">        ld a3, 16(a0)</span><br><span class="line">        ld a2, 8(a0)</span><br><span class="line">        ld a1, 0(a0)</span><br><span class="line">        csrrw a0, mscratch, a0</span><br><span class="line">        mret</span><br></pre></td></tr></table></figure>

<p>usertrap()的最后几行代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// give up the CPU if this is a timer interrupt.</span></span><br><span class="line"><span class="comment">// 时钟中断处理，让出CPU重新调度 </span></span><br><span class="line"><span class="keyword">if</span>(which_dev == <span class="number">2</span>)</span><br><span class="line">  yield();</span><br><span class="line">usertrapret();</span><br></pre></td></tr></table></figure>

<p><code>proc.c中有关进程切换的代码</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cpu</span> <span class="title">cpus</span>[<span class="title">NCPU</span>];</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> <span class="title">proc</span>[<span class="title">NPROC</span>];</span></span><br><span class="line"><span class="type">int</span> nextpid = <span class="number">1</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">pid_lock</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Switch to scheduler.  Must hold only p-&gt;lock</span></span><br><span class="line"><span class="comment">// and have changed proc-&gt;state. Saves and restores</span></span><br><span class="line"><span class="comment">// intena because intena is a property of this</span></span><br><span class="line"><span class="comment">// kernel thread, not this CPU. It should</span></span><br><span class="line"><span class="comment">// be proc-&gt;intena and proc-&gt;noff, but that would</span></span><br><span class="line"><span class="comment">// break in the few places where a lock is held but</span></span><br><span class="line"><span class="comment">// there&#x27;s no process.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">sched</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> intena;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 必须持有p-&gt;lock</span></span><br><span class="line">  <span class="keyword">if</span>(!holding(&amp;p-&gt;lock))</span><br><span class="line">    panic(<span class="string">&quot;sched p-&gt;lock&quot;</span>);</span><br><span class="line">  <span class="comment">// 禁止进程切换前持有其它锁（避免死锁）</span></span><br><span class="line">  <span class="keyword">if</span>(mycpu()-&gt;noff != <span class="number">1</span>)</span><br><span class="line">    panic(<span class="string">&quot;sched locks&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span>(p-&gt;state == RUNNING)</span><br><span class="line">    panic(<span class="string">&quot;sched running&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span>(intr_get())</span><br><span class="line">    panic(<span class="string">&quot;sched interruptible&quot;</span>);</span><br><span class="line">  <span class="comment">// 保存mycpu()-&gt;intena</span></span><br><span class="line">  intena = mycpu()-&gt;intena;</span><br><span class="line">  <span class="comment">// 保存进程的寄存器组到p-&gt;context中，下次再回到当前进程会紧接着运行</span></span><br><span class="line">  <span class="comment">// 切换到CPU的scheduler()进行进程调度</span></span><br><span class="line">  swtch(&amp;p-&gt;context, &amp;mycpu()-&gt;context);</span><br><span class="line">  <span class="comment">// 恢复mycpu()-&gt;intena</span></span><br><span class="line">  mycpu()-&gt;intena = intena;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Give up the CPU for one scheduling round.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">yield</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  acquire(&amp;p-&gt;lock);</span><br><span class="line">  p-&gt;state = RUNNABLE;</span><br><span class="line">  <span class="comment">// 拿到p-&gt;lock后不能在这里立刻释放，因为此时可能有其他核心的调度线程会发现该线程可运行，此时多个核心运行一个线程，线程栈瞬间崩溃</span></span><br><span class="line">  <span class="comment">// 只有在scheduler内核调度线程中才能释放p-&gt;lock，因为此时线程使用的是scheduler的内核栈，用户线程已经完全放弃CPU使用</span></span><br><span class="line">  sched();</span><br><span class="line">  release(&amp;p-&gt;lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>swtch.S</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"># 上下文切换</span><br><span class="line"># void swtch(struct context *old, struct context *new);</span><br><span class="line"># Save current registers in old. Load from new.	</span><br><span class="line">.globl swtch</span><br><span class="line">swtch:</span><br><span class="line">        sd ra, 0(a0)</span><br><span class="line">        sd sp, 8(a0)</span><br><span class="line">        sd s0, 16(a0)</span><br><span class="line">        sd s1, 24(a0)</span><br><span class="line">        sd s2, 32(a0)</span><br><span class="line">        sd s3, 40(a0)</span><br><span class="line">        sd s4, 48(a0)</span><br><span class="line">        sd s5, 56(a0)</span><br><span class="line">        sd s6, 64(a0)</span><br><span class="line">        sd s7, 72(a0)</span><br><span class="line">        sd s8, 80(a0)</span><br><span class="line">        sd s9, 88(a0)</span><br><span class="line">        sd s10, 96(a0)</span><br><span class="line">        sd s11, 104(a0)</span><br><span class="line"></span><br><span class="line">        ld ra, 0(a1)</span><br><span class="line">        ld sp, 8(a1)</span><br><span class="line">        ld s0, 16(a1)</span><br><span class="line">        ld s1, 24(a1)</span><br><span class="line">        ld s2, 32(a1)</span><br><span class="line">        ld s3, 40(a1)</span><br><span class="line">        ld s4, 48(a1)</span><br><span class="line">        ld s5, 56(a1)</span><br><span class="line">        ld s6, 64(a1)</span><br><span class="line">        ld s7, 72(a1)</span><br><span class="line">        ld s8, 80(a1)</span><br><span class="line">        ld s9, 88(a1)</span><br><span class="line">        ld s10, 96(a1)</span><br><span class="line">        ld s11, 104(a1)   </span><br><span class="line">        ret</span><br></pre></td></tr></table></figure>

<p><code>proc.c的scheduler</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Per-CPU process scheduler.</span></span><br><span class="line"><span class="comment">// Each CPU calls scheduler() after setting itself up.</span></span><br><span class="line"><span class="comment">// Scheduler never returns.  It loops, doing:</span></span><br><span class="line"><span class="comment">//  - choose a process to run.</span></span><br><span class="line"><span class="comment">//  - swtch to start running that process.</span></span><br><span class="line"><span class="comment">//  - eventually that process transfers control</span></span><br><span class="line"><span class="comment">//    via swtch back to the scheduler.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">scheduler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">cpu</span> *<span class="title">c</span> =</span> mycpu();</span><br><span class="line">  c-&gt;proc = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">    <span class="comment">// Avoid deadlock by ensuring that devices can interrupt.</span></span><br><span class="line">    <span class="comment">// CPU核心通过设置SSTATUS寄存器（SSTATUS_SIE）开启设备中断</span></span><br><span class="line">    intr_on();</span><br><span class="line">    <span class="type">int</span> found = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(p = proc; p &lt; &amp;proc[NPROC]; p++) &#123;</span><br><span class="line">      acquire(&amp;p-&gt;lock);</span><br><span class="line">      <span class="keyword">if</span>(p-&gt;state == RUNNABLE) &#123;</span><br><span class="line">        <span class="comment">// Switch to chosen process.  It is the process&#x27;s job</span></span><br><span class="line">        <span class="comment">// to release its lock and then reacquire it</span></span><br><span class="line">        <span class="comment">// before jumping back to us.</span></span><br><span class="line">        p-&gt;state = RUNNING;</span><br><span class="line">        c-&gt;proc = p;</span><br><span class="line">        <span class="comment">// 切换到选中的进程执行</span></span><br><span class="line">        swtch(&amp;c-&gt;context, &amp;p-&gt;context);</span><br><span class="line">        <span class="comment">// Process is done running for now.</span></span><br><span class="line">        <span class="comment">// It should have changed its p-&gt;state before coming back.</span></span><br><span class="line">        c-&gt;proc = <span class="number">0</span>;</span><br><span class="line">        found = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 这一步很重要，每次通过shced()--&gt;scheduler()--&gt;swtch()执行，到达这里会释放之前保	  持的p-&gt;lock</span></span><br><span class="line">      <span class="comment">// 一个具体的例子就是sleep()沿着函数调用到达这里后释放了p-&gt;lock，wakeup()可以获得p-	   &gt;lock并唤醒p</span></span><br><span class="line">      release(&amp;p-&gt;lock);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(found == <span class="number">0</span>) &#123;</span><br><span class="line">      intr_on();</span><br><span class="line">      <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;wfi&quot;</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-5补充"><a href="#5-5补充" class="headerlink" title="5.5补充"></a>5.5补充</h4><p><code>UART 驱动器通过读取 UART 控制寄存器，一次读取一个字节的数据；这种模式被称为编程 I/O，因为软件在控制数据移动。</code>程序化 I&#x2F;O 简单，但速度太慢，无法在高数据速率下使用。<code>需要高速移动大量数据的设备通常使用直接内存访问(direct memory access, DMA)。DMA 设备硬件直接将传入数据写入 RAM，并从 RAM 中读取传出数据。</code>现代磁盘和网络设备都使用 DMA。DMA 设备的驱动程序会在 RAM 中准备数据，然后使用对控制寄存器的一次写入来告诉设备处理准备好的数据。</p>
<p>&#x3D;&#x3D;当设备在不可预知的时间需要关注时，中断是很有用的，而且不会太频繁。但中断对 CPU的开销很大。因此，高速设备，如网络和磁盘控制器，使用了减少对中断需求的技巧。其中一个技巧是对整批传入或传出的请求提出一个单一的中断。另一个技巧是让驱动程序完全禁用中断，并定期检查设备是否需要关注。这种技术称为轮询（polling）。如果设备执行操作的速度非常快，轮询是有意义的，但如果设备大部分时间处于空闲状态，则会浪费 CPU 时间。一些驱动程序会根据当前设备的负载情况，在轮询和中断之间动态切换。&#x3D;&#x3D;</p>
<p><code>UART 驱动首先将输入的数据复制到内核的缓冲区，然后再复制到用户空间。这在低数据速率下是有意义的，但对于那些快速生成或消耗数据的设备来说，这样的双重拷贝会大大降低性能。一些操作系统能够直接在用户空间缓冲区和设备硬件之间移动数据，通常使用DMA。</code></p>
<h3 id="第六章：锁"><a href="#第六章：锁" class="headerlink" title="第六章：锁"></a>第六章：锁</h3><p>大多数内核，包括 xv6，都会交错执行多个任务。多处理器硬件可以交错执行任务：具有多个 CPU 独立执行的计算机，如 xv6 的 RISC-V。这些多个 CPU 共享物理 RAM，xv6 利用共享来维护所有 CPU 读写的数据结构。这种共享带来了一种可能性，即一个 CPU 读取一个数据结构，而另一个 CPU 正在中途更新它，甚至多个 CPU 同时更新同一个数据；如果不仔细设计，这种并行访问很可能产生不正确的结果或破坏数据结构。即使在单处理器上，内核也可能在多个线程之间切换 CPU，导致它们的执行交错。最后，如果中断发生的时间不对，一个设备中断处理程序可能会修改与一些可中断代码相同的数据，从而破坏数据。<code>并发一词指的是由于多处理器并行、线程切换或中断而导致多个指令流交错的情况。</code></p>
<p>&#x3D;&#x3D;内核中充满了并发访问的数据。例如，两个 CPU 可以同时调用 kalloc，从而并发地从空闲内存链表的头部 push。内核设计者喜欢允许大量的并发，因为它可以通过并行来提高性能，提高响应速度。然而，结果是内核设计者花了很多精力说服自己，尽管存在并发，但仍然是正确的。&#x3D;&#x3D;有很多方法可以写出正确的代码，有些方法比其他方法更简单。以并发下的正确性为目标的策略，以及支持这些策略的抽象，被称为并发控制技术。</p>
<p>xv6 根据不同的情况，使用了很多并发控制技术，还有更多的可能。本章重点介绍一种广泛使用的技术：锁。<code>锁提供了相互排斥的功能，确保一次只有一个 CPU 可以持有锁。如果程序员为每个共享数据项关联一个锁，并且代码在使用某项时总是持有关联的锁，那么该项每次只能由一个 CPU 使用。在这种情况下，我们说锁保护了数据项。虽然锁是一种简单易懂的并发控制机制，但锁的缺点是会扼杀性能，因为锁将并发操作串行化了。</code></p>
<h4 id="6-1竞争情况"><a href="#6-1竞争情况" class="headerlink" title="6.1竞争情况"></a>6.1竞争情况</h4><p>作为我们为什么需要锁的一个例子，考虑两个进程在两个不同的 CPU 上调用 wait，wait释放子进程的内存。因此，在每个 CPU 上，内核都会调用 kfree 来释放子进程的内存页。内核分配器维护了一个链表：kalloc() 从空闲页链表中 pop 一页内存，kfree()将一页 push 空闲链表中。为了达到最好的性能，我们可能希望两个父进程的 kfrees 能够并行执行，而不需要任何一个进程等待另一个进程，但是考虑到xv6 的 kfree 实现，这是不正确的。</p>
<p><img src="/../../../../../../imgs/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%BA%90%E7%A0%81%E7%BA%A7%E5%89%96%E6%9E%90/image-20221116160144854.png" alt="image-20221116160144854"></p>
<p>图 6.1 更详细地说明了这种设置：链表在两个 CPU 共享的内存中，CPU 使用加载和存储指令操作链表。(在现实中，处理器有缓存，但在概念上，多处理器系统的行为就像有一个单一的共享内存一样)。如果没有并发请求，你可能会实现如下的链表 push 操作：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">element</span>&#123;</span></span><br><span class="line">  <span class="type">int</span> data;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">element</span> *<span class="title">next</span>;</span> </span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">element</span> *<span class="title">list</span> =</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">push</span><span class="params">(<span class="type">int</span> data)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">element</span> *<span class="title">l</span>;</span></span><br><span class="line">  l = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span> *l);</span><br><span class="line">  l-&gt;data = data;</span><br><span class="line">  l-&gt;next = <span class="built_in">list</span>;</span><br><span class="line">  <span class="built_in">list</span> = l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果单独执行，这个实现是正确的。但是，如果多个副本同时执行，代码就不正确。如果两个 CPU 同时执行 push，那么两个 CPU 可能都会执行图 6.1 所示的第 12 行，然后其中一个才执行第 13行，这就会产生一个不正确的结果。这样就会出现两个 list元素，将 next 设为 list 的前值。当对 list 的两次赋值发生在第 13 行时，第二次赋值将覆盖第一次赋值；第一次赋值中涉及的元素将丢失。</p>
<p>第 13 行的丢失更新是<code>竞争条件(race condition)</code>的一个例子。<code>竞争条件是指同时访问一个内存位置，并且至少有一次访问是写的情况。</code>竞争通常是一个错误的标志，要么是丢失更新（如果访问是写），要么是读取一个不完全更新的数据结构。&#x3D;&#x3D;竞争的结果取决于所涉及的两个 CPU 的确切时间，以及它们的内存操作如何被内存系统排序，这可能会使竞争引起的错误难以重现和调试。例如，在调试 push 时加入 print 语句可能会改变执行的时机，足以使竞争消失。&#x3D;&#x3D;</p>
<p>避免竞争的通常方法是使用锁。锁确保了相互排斥，因此一次只能有一个CPU执行 push的哪一行；这就使得上面的情况不可能发生。上面代码的正确 lock 版本只增加了几行代码。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">element</span> *<span class="title">list</span> =</span> <span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">lock</span> <span class="title">listlock</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">push</span><span class="params">(<span class="type">int</span> data)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">element</span> *<span class="title">l</span>;</span></span><br><span class="line">l = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span> *l);</span><br><span class="line">l-&gt;data = data;</span><br><span class="line">acquire(&amp;listlock);</span><br><span class="line">l-&gt;next = <span class="built_in">list</span>;</span><br><span class="line"><span class="built_in">list</span> = l;</span><br><span class="line">release(&amp;listlock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>acquire 和 release 之间的指令序列通常被称为临界区。这里的锁保护 list。</code></p>
<p>当我们说锁保护数据时，我们真正的意思是锁保护了一些适用于数据的不变式集合。invariant 是数据结构的属性，这些属性在不同的操作中都得到了维护。<code>通常情况下，一个操作的正确行为取决于操作开始时的invariant是否为真。操作可能会暂时违反invariant，但必须在结束前重新建立invariant。</code>例如，在链表的情况下，invariant 是 list指向列表中的第一个元素，并且每个元素的下一个字段指向下一个元素。push 的实现暂时违反了这个 invariant：在第11行，l 指向下一个 list 元素，但 list 还没有指向 l（在第 12 行重新建立）。我们上面所研究的竞争条件之所以发生，是因为第二个 CPU 执行了依赖于链表invariant的代码，而它们被暂时违反了。<code>正确地使用锁可以保证一次只能有一个CPU对关键部分的数据结构进行操作，所以当数据结构的invariant不成立时，没有CPU会执行数据结构操作。</code></p>
<p>你可以把锁看成是把并发的临界区<code>串行化(serializing)</code>的一种工具，使它们同时只运行一个，从而保护 invariant（假设临界区是独立的）。&#x3D;&#x3D;你也可以认为由同一个锁保护的临界区，相互之间是原子的，这样每个临界区都只能看到来自之前临界区的完整变化，而永远不会看到部分完成的更新。&#x3D;&#x3D;</p>
<p>虽然正确使用锁可以使不正确的代码变得正确，但锁会限制性能。例如，如果两个进程同时调用 kfree，锁会将两个调用串行化，我们在不同的 CPU 上运行它们不会获得任何好处。<code>我们说，如果多个进程同时想要同一个锁，就会发生冲突，或者说锁经历了争夺。内核设计的一个主要挑战是避免锁的争用。xv6在这方面做得很少，但是复杂的内核会专门组织数据结构和算法来避免锁争用。</code>&#x3D;&#x3D;例如链表，一个内核可以为每个 CPU 维护一个空闲页链表，只有当自己的链表为空时，并且它必须从另一个 CPU 获取内存时，才会接触另一个 CPU 的空闲链表。其他用例可能需要更复杂的设计。&#x3D;&#x3D;</p>
<p><code>锁的位置对性能也很重要。</code>例如，在push中把acquire移到较早的位置是正确的：把acquire的调用移到第 8 行之前是可以的。这可能会降低性能，因为这样对malloc的调用也会被锁住。</p>
<h4 id="6-2自旋锁"><a href="#6-2自旋锁" class="headerlink" title="6.2自旋锁"></a>6.2自旋锁</h4><p>xv6 有两种类型的锁：自旋锁和睡眠锁。我们先说说自旋锁。xv6 将自旋锁表示为一个结构体 spinlock。该结构中重要的字段是 locked，当锁可获得时，locked 为零，当锁被持有时，locked 为非零。从逻辑上讲，xv6 获取锁的的代码类似于：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">acquire</span><span class="params">(<span class="keyword">struct</span> spinlock *lk)</span> <span class="comment">// does not work!</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span> (;;)&#123;</span><br><span class="line">		<span class="keyword">if</span> (lk-&gt;locked == <span class="number">0</span>)&#123;</span><br><span class="line">			lk-&gt;locked = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>不幸的是，这种实现并不能保证多处理器上的相互排斥。</code>可能会出现这样的情况：两个CPU 同时到达 if 语句，看到 lk-&gt;locked 为零，然后都通过设置 lk-&gt;locked &#x3D; 1 来抢夺锁。此时，两个不同的 CPU 持有锁，这就违反了互斥属性。<code>我们需要的是让第 5 行和第 6 行作为一个原子即不可分割步骤来执行。</code></p>
<p>&#x3D;&#x3D;由于锁被广泛使用，多核处理器通常提供了一些原子版的指令。在 RISC-V 上，这条指令是 amoswap r, a。amoswap 读取内存地址 a 处的值，将寄存器 r 的内容写入该地址，并将其读取的值放入 r 中，也就是说，它将寄存器的内容和内存地址进行了交换。它原子地执行这个序列，使用特殊的硬件来防止任何其他 CPU 使用读和写之间的内存地址。&#x3D;&#x3D;</p>
<p><code>xv6的acquire使用了可移植的C库调用__sync_lock_test_and_set，它本质上为 amoswap 指令；返回值是 lk-&gt;locked 的旧（交换）内容。</code>acquire 函数循环交换，重试（旋转）直到获取了锁。每一次迭代都会将 1 交换到lk-&gt;locked 中，并检查之前的值；如果之前的值为 0，那么我们已经获得了锁，并且交换将lk-&gt;locked 设置为 1。如果之前的值是 1，那么其他 CPU 持有该锁，而我们原子地将 1 换成 lk-&gt;locked 并没有改变它的值。</p>
<p>一旦锁被获取，acquire 就会记录获取该锁的 CPU，这方便调试。lk-&gt;cpu 字段受到锁的保护，只有在持有锁的时候才能改变。</p>
<p><code>函数release与acquire相反：它清除lk-&gt;cpu字段，然后释放锁。从概念上讲，释放只需要给lk-&gt;locked赋值为0。C标准允许编译器用多条存储指令来实现赋值，所以C赋值对于并发代码来说可能是非原子性的。相反，release使用C库函数__sync_lock_release执行原子赋值。这个函数也是使用了 RISC-V的amoswap指令。</code></p>
<p><code>spinlock.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Mutual exclusion lock.</span></span><br><span class="line"><span class="comment">// 自旋锁</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> &#123;</span></span><br><span class="line">  <span class="comment">// 锁是否被持有，0表示锁空闲，1表示锁已占用</span></span><br><span class="line">  uint locked;       <span class="comment">// Is the lock held?】</span></span><br><span class="line">  <span class="comment">// For debugging:</span></span><br><span class="line">  <span class="comment">// 锁的名字</span></span><br><span class="line">  <span class="type">char</span> *name;        <span class="comment">// Name of lock.</span></span><br><span class="line">  <span class="comment">// 持有锁的CPU</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">cpu</span> *<span class="title">cpu</span>;</span>   <span class="comment">// The cpu holding the lock.</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>spinlock.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Mutual exclusion spin locks.</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;param.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;memlayout.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;spinlock.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;riscv.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;proc.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;defs.h&quot;</span></span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">initlock</span><span class="params">(<span class="keyword">struct</span> spinlock *lk, <span class="type">char</span> *name)</span></span><br><span class="line">&#123;</span><br><span class="line">  lk-&gt;name = name;</span><br><span class="line">  lk-&gt;locked = <span class="number">0</span>;</span><br><span class="line">  lk-&gt;cpu = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Acquire the lock.</span></span><br><span class="line"><span class="comment">// Loops (spins) until the lock is acquired.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">acquire</span><span class="params">(<span class="keyword">struct</span> spinlock *lk)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 关中断，保存最外层临界区开始时的中断状态</span></span><br><span class="line">  push_off(); <span class="comment">// disable interrupts to avoid deadlock.</span></span><br><span class="line">  <span class="comment">// CPU拿到锁后并且还没有release之前不能再次获取锁，否则会发生死锁</span></span><br><span class="line">  <span class="keyword">if</span>(holding(lk))</span><br><span class="line">    panic(<span class="string">&quot;acquire&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// On RISC-V, sync_lock_test_and_set turns into an atomic swap:</span></span><br><span class="line">  <span class="comment">//   a5 = 1</span></span><br><span class="line">  <span class="comment">//   s1 = &amp;lk-&gt;locked</span></span><br><span class="line">  <span class="comment">//   amoswap.w.aq a5, a5, (s1)</span></span><br><span class="line">  <span class="comment">// 原子指令，自旋swap</span></span><br><span class="line">  <span class="keyword">while</span>(__sync_lock_test_and_set(&amp;lk-&gt;locked, <span class="number">1</span>) != <span class="number">0</span>)</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Tell the C compiler and the processor to not move loads or stores</span></span><br><span class="line">  <span class="comment">// past this point, to ensure that the critical section&#x27;s memory</span></span><br><span class="line">  <span class="comment">// references happen strictly after the lock is acquired.</span></span><br><span class="line">  <span class="comment">// On RISC-V, this emits a fence instruction.</span></span><br><span class="line">  <span class="comment">// 设置内存屏障，防止指令重排</span></span><br><span class="line">  __sync_synchronize();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Record info about lock acquisition for holding() and debugging.</span></span><br><span class="line">  lk-&gt;cpu = mycpu();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Release the lock.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">release</span><span class="params">(<span class="keyword">struct</span> spinlock *lk)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// CPU首先已经拿到了锁才能释放锁</span></span><br><span class="line">  <span class="keyword">if</span>(!holding(lk))</span><br><span class="line">    panic(<span class="string">&quot;release&quot;</span>);</span><br><span class="line"></span><br><span class="line">  lk-&gt;cpu = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Tell the C compiler and the CPU to not move loads or stores</span></span><br><span class="line">  <span class="comment">// past this point, to ensure that all the stores in the critical</span></span><br><span class="line">  <span class="comment">// section are visible to other CPUs before the lock is released,</span></span><br><span class="line">  <span class="comment">// and that loads in the critical section occur strictly before</span></span><br><span class="line">  <span class="comment">// the lock is released.</span></span><br><span class="line">  <span class="comment">// On RISC-V, this emits a fence instruction.</span></span><br><span class="line">  <span class="comment">// 设置内存屏障，防止指令重排</span></span><br><span class="line">  __sync_synchronize();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Release the lock, equivalent to lk-&gt;locked = 0.</span></span><br><span class="line">  <span class="comment">// This code doesn&#x27;t use a C assignment, since the C standard</span></span><br><span class="line">  <span class="comment">// implies that an assignment might be implemented with</span></span><br><span class="line">  <span class="comment">// multiple store instructions.</span></span><br><span class="line">  <span class="comment">// On RISC-V, sync_lock_release turns into an atomic swap:</span></span><br><span class="line">  <span class="comment">//   s1 = &amp;lk-&gt;locked</span></span><br><span class="line">  <span class="comment">//   amoswap.w zero, zero, (s1)</span></span><br><span class="line">  <span class="comment">// 原子指令，swap复制</span></span><br><span class="line">  __sync_lock_release(&amp;lk-&gt;locked);</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">  pop_off();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check whether this cpu is holding the lock.</span></span><br><span class="line"><span class="comment">// Interrupts must be off.</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">holding</span><span class="params">(<span class="keyword">struct</span> spinlock *lk)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> r;</span><br><span class="line">  r = (lk-&gt;locked &amp;&amp; lk-&gt;cpu == mycpu());</span><br><span class="line">  <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// push_off/pop_off are like intr_off()/intr_on() except that they are matched:</span></span><br><span class="line"><span class="comment">// it takes two pop_off()s to undo two push_off()s.  Also, if interrupts</span></span><br><span class="line"><span class="comment">// are initially off, then push_off, pop_off leaves them off.</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">push_off</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 开始的中断状态</span></span><br><span class="line">  <span class="type">int</span> old = intr_get();</span><br><span class="line">  <span class="comment">// 关闭中断</span></span><br><span class="line">  intr_off();</span><br><span class="line">  <span class="comment">// 当前CPU第一次想要获取锁时，保存此前的中断状态</span></span><br><span class="line">  <span class="keyword">if</span>(mycpu()-&gt;noff == <span class="number">0</span>)</span><br><span class="line">    mycpu()-&gt;intena = old;</span><br><span class="line">  <span class="comment">// 锁嵌套级别+1(进程内可以获得多个锁如锁1、锁2，只有全部都release后才能开中断)</span></span><br><span class="line">  mycpu()-&gt;noff += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">pop_off</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">cpu</span> *<span class="title">c</span> =</span> mycpu();</span><br><span class="line">  <span class="comment">// 当前中断必须是关闭状态</span></span><br><span class="line">  <span class="keyword">if</span>(intr_get())</span><br><span class="line">    panic(<span class="string">&quot;pop_off - interruptible&quot;</span>);</span><br><span class="line">  <span class="comment">// 嵌套级别错误</span></span><br><span class="line">  <span class="keyword">if</span>(c-&gt;noff &lt; <span class="number">1</span>)</span><br><span class="line">    panic(<span class="string">&quot;pop_off&quot;</span>);</span><br><span class="line">  <span class="comment">// 锁嵌套级别-1</span></span><br><span class="line">  c-&gt;noff -= <span class="number">1</span>;</span><br><span class="line">  <span class="comment">// 到达最外层退出区并且最外层临界区保存的中断状态是开启，则恢复中断开启</span></span><br><span class="line">  <span class="keyword">if</span>(c-&gt;noff == <span class="number">0</span> &amp;&amp; c-&gt;intena)</span><br><span class="line">    intr_on();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6-3锁的使用"><a href="#6-3锁的使用" class="headerlink" title="6.3锁的使用"></a>6.3锁的使用</h4><p>xv6 在很多地方使用锁来避免竞争条件。如上所述，kalloc和 kfree就是一个很好的例子。xv6 也会有一些竞争。使用锁的一个难点是决定使用多少个锁，以及每个锁应该保护哪些数据和 invariant。有几个基本原则。<code>首先，任何时候，当一个CPU在另一个CPU读写数据的同时写入变量，都应该使用锁来防止这两个操作重叠。其次，记住锁保护的是invariant：如果一个invariant涉及到多个内存位置，通常需要用一个锁保护所有的位置，以确保invariant得到维护。</code></p>
<p>上面的规则说了什么时候需要锁，但没说什么时候不需要锁，为了效率，不要太多锁，因为锁会降低并行性。如果并行性不重要，那么可以只安排一个线程，而不用担心锁的问题。一个简单的内核可以在多处理器上像这样做，通过一个单一的锁，这个锁必须在进入内核时获得，并在退出内核时释放（尽管系统调用，如管道读取或等待会带来一个问题）。许多单处理器操作系统已经被改造成使用这种方法在多处理器上运行，有时被称为<code>大内核锁</code>，但这种方法牺牲了并行性：内核中一次只能执行一个 CPU。如果内核做任何繁重的计算，那么使用一组更大的更精细的锁，这样内核可以同时在多个 CPU 上执行，效率会更高。</p>
<p><code>作为粗粒度锁的一个例子，xv6的kalloc.c分配器有一个单一的空闲页链表，由一个锁保护。</code>如果不同 CPU 上的多个进程试图同时分配内存页，每个进程都必须通过在 acquire 中自旋来等待获取锁。&#x3D;&#x3D;自旋会降低性能，因为这是无意义的。如果对锁的争夺浪费了很大一部分 CPU 时间，也许可以通过改变分配器的设计来提高性能，使其拥有多个空闲页链表，每个链表都有自己的锁，从而实现真正的并行分配。&#x3D;&#x3D;</p>
<p><code>作为细粒度锁的一个例子，xv6对每个文件都有一个单独的锁，这样操作不同文件的进程往往可以不等待对方的锁就可以进行。</code>如果想让进程同时写入同一文件的不同区域，文件锁方案可以做得更细。最后，锁粒度的决定需要考虑性能以及复杂性。</p>
<p><img src="/../../../../../../imgs/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%BA%90%E7%A0%81%E7%BA%A7%E5%89%96%E6%9E%90/image-20221116191701662.png" alt="image-20221116191701662"></p>
<h4 id="6-4死锁和锁排序"><a href="#6-4死锁和锁排序" class="headerlink" title="6.4死锁和锁排序"></a>6.4死锁和锁排序</h4><p><code>如果一个穿过内核的代码路径必须同时持有多个锁，那么所有的代码路径以相同的顺序获取这些锁是很重要的。如果他们不这样做，就会有死锁的风险。</code>假设线程 T1执行代码 path1并获取锁 A，线程 T2 执行代码 path2 并获取锁 B，接下来 T1 会尝试获取锁 B，T2 会尝试获取锁 A，这两次获取都会无限期地阻塞，因为在这两种情况下，另一个线程都持有所需的锁，并且不会释放它，直到它的获取返回。&#x3D;&#x3D;为了避免这样的死锁，所有的代码路径必须以相同的顺序获取锁。对全局锁获取顺序的需求意味着锁实际上是每个函数规范的一部分：调用者调用函数的方式必须使锁按照约定的顺序被获取。&#x3D;&#x3D;</p>
<p>由于 sleep 的工作方式，xv6 有许多长度为 2 的锁序链，涉及到进程锁（struct proc 中的锁）。例如，consoleintr是处理类型化字符的中断例程。当一个新数据到达时，任何正在等待控制台输入的进程都应该被唤醒。为此，consoleintr 在调用 wakeup 时持有 cons.lock，以获取进程锁来唤醒它。<code>因此，全局避免死锁的锁顺序包括了 cons.lock 必须在任何进程锁之前获取的规则。</code>&#x3D;&#x3D;文件系统代码包含 xv6 最长的锁链。例如，创建一个文件需要同时持有目录的锁、新文件的 inode 的锁、磁盘块缓冲区的锁、磁盘驱动器的 vdisk_lock 和调用进程的 p-&gt;lock。为了避免死锁，文件系统代码总是按照上一句提到的顺序获取锁。&#x3D;&#x3D;</p>
<p><code>遵守全局避免死锁的顺序可能会非常困难。</code>有时锁的顺序与逻辑程序结构相冲突，例如，也许代码模块 M1 调用模块 M2，但锁的顺序要求 M2 中的锁在 M1 中的锁之前被获取。有时锁的身份并不是事先知道的，也许是因为必须持有一个锁才能发现接下来要获取的锁的身份。这种情况出现在文件系统中，因为它在路径名中查找连续的组件，也出现在wait和exit的代码中，因为它们搜索进程表寻找子进程。&#x3D;&#x3D;最后，死锁的危险往往制约着人们对锁方案的细化程度，因为更多的锁往往意味着更多的死锁机会。避免死锁是内核实现的重要需求。&#x3D;&#x3D;</p>
<h4 id="6-5锁和中断处理程序"><a href="#6-5锁和中断处理程序" class="headerlink" title="6.5锁和中断处理程序"></a>6.5锁和中断处理程序</h4><p>一些 xv6 自旋锁保护的数据会被线程和中断处理程序两者使用。<code>例如，clockintr定时器中断处理程序可能会在内核线程读取sys_sleep中的ticks的同时递增ticks。锁tickslock将保护两次临界区。</code></p>
<p>&#x3D;&#x3D;自旋锁和中断的相互作用带来了一个潜在的危险。假设 sys_sleep 持有tickslock，而它的 CPU 被一个定时器中断。 clockintr会尝试获取tickslock，看到它被持有，并等待它被释放。在这种情况下，tickslock永远不会被释放：只有 sys_sleep 可以释放它，但sys_sleep不会继续运行，直到 clockintr 返回。所以 CPU 会死锁，任何需要其他锁的代码也会冻结。&#x3D;&#x3D;</p>
<p><code>为了避免这种情况，如果一个中断处理程序使用了自旋锁，CPU决不能在启用中断的情况下持有该锁。</code>&#x3D;&#x3D;xv6 比较保守：当一个 CPU 获取任何锁时，xv6 总是禁用该 CPU 上的中断。中断仍然可能发生在其他 CPU 上，所以一个中断程序获取锁会等待一个线程释放自旋锁；它们不在同一个 CPU 上。&#x3D;&#x3D;</p>
<p><code>xv6在CPU没有持有自旋锁时重新启用中断；它必须做一点记录来应对嵌套的临界区。acquire调用push_off和release调用pop_off来跟踪当前CPU上锁的嵌套级别。当该计数达到零时，pop_off会恢复最外层临界区开始时的中断启用状态。intr_off和intr_on函数分别执行RISC-V指令来禁用和启用中断。</code></p>
<p>&#x3D;&#x3D;在设置 lk-&gt;locked 之前，严格调用 push_off 是很重要的。如果两者反过来，那么在启用中断的情况下，锁会有一个窗口（未锁到的位置），在未禁止中断时持有锁，不幸的是，一个定时的中断会使系统死锁。同样，释放锁后才调用 pop_off 也很重要。&#x3D;&#x3D;</p>
<h4 id="6-6指令和内存排序"><a href="#6-6指令和内存排序" class="headerlink" title="6.6指令和内存排序"></a>6.6指令和内存排序</h4><p>人们很自然地认为程序是按照源代码语句出现的顺序来执行的。然而，许多编译器和CPU 为了获得更高的性能，会不按顺序执行代码。如果一条指令需要很多周期才能完成，CPU 可能会提前发出该指令，以便与其他指令重叠，避免 CPU 停顿。例如，CPU 可能会注意到在一个串行序列中，指令 A 和 B 互不依赖。CPU 可能先启动指令 B，这是因为它的输入在 A 的输入之前已经准备好了，或者是为了使 A 和 B 的执行重叠。 编译器可以执行类似的重新排序，在一条语句的指令之前发出另一条语句的指令，由于它们原来的顺序。</p>
<p><code>编译器和CPU在指令重排序时遵循相应规则，以确保它们不会改变正确编写的串行代码的结果。然而，这些规则确实允许重排序，从而改变并发代码的结果，并且很容易导致多处理器上的不正确行为。CPU的重排序规则称为内存模型。</code></p>
<p>例如，在这段 push 的代码中，如果编译器或 CPU 将第 4 行对应的存储移到第 6 行释放后的某个点，那将是一场灾难。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">l = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span> *l);</span><br><span class="line">l-&gt;data = data;</span><br><span class="line">acquire(&amp;listlock);</span><br><span class="line">l-&gt;next = <span class="built_in">list</span>;</span><br><span class="line"><span class="built_in">list</span> = l;</span><br><span class="line">release(&amp;listlock);</span><br></pre></td></tr></table></figure>

<p>如果发生这样的 re-order，就会有一个窗口，在这个窗口中，另一个 CPU 可以获取锁并观察更新的链表，但看到的是一个未初始化的 list-&gt;next。</p>
<p><code>为了告诉硬件和编译器不要执行这样的重排序，xv6在获取和释放中都使用sync_synchronize()。__sync_synchronize()是一个内存屏障(memory barrier)：它告诉编译器和 CPU 不要在屏障上 re-order 加载或存储。xv6中的内存屏障几乎在所有重要的情况下都会 acquire和release强制顺序，因为xv6在访问共享数据的周围使用锁。</code></p>
<h4 id="6-7睡眠锁"><a href="#6-7睡眠锁" class="headerlink" title="6.7睡眠锁"></a>6.7睡眠锁</h4><p>有时xv6需要长时间保持锁。例如，文件系统（第8章）在磁盘上读写文件内容时保持文件锁定，这些磁盘操作可能需要几十毫秒。&#x3D;&#x3D;如果另一个进程想要获取自旋锁，那么长时间保持自旋锁会导致获取进程在自旋时浪费很长时间的CPU。自旋锁的另一个缺点是，一个进程在持有自旋锁的同时不能让出（yield）CPU，然而我们希望持有锁的进程等待磁盘I&#x2F;O的时候其他进程可以使用CPU。&#x3D;&#x3D;持有自旋锁时让步是非法的，因为如果第二个线程试图获取自旋锁，就可能导致死锁：因为<code>acquire</code>不会让出CPU，第二个线程的自旋可能会阻止第一个线程运行并释放锁。在持有锁时让步也违反了在持有自旋锁时中断必须关闭的要求。因此，我们想要一种锁，它在等待获取锁时让出CPU，并允许在持有锁时让步（以及中断）。</p>
<p><code>xv6以睡眠锁(sleep-locks)的形式提供了这样的锁。acquiresleep在等待的过程中让出CPU，使用的技术将在第 7 章解释。</code>在高层次上，sleep-lock有一个由spinlock保护的锁定字段，而 acquiresleep 对 sleep 的调用会原子性地让出 CPU 并释放spinlock。其结果是，在acquiresleep 等待时，其他线程可以执行。因为睡眠锁会使中断处于启用状态，所以不能在中断处理程序中使用睡眠锁。</p>
<p><code>因为acquiresleep可能会让出CPU，所以睡眠锁不能在spinlock临界区内使用（虽然spinlocks可以在睡眠锁临界区内使用）。</code>自旋锁最适合短的临界区，因为等待它们会浪费 CPU 时间；睡眠锁对长时间的操作很有效。</p>
<p><code>sleeplock.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Long-term locks for processes</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sleeplock</span> &#123;</span></span><br><span class="line">  uint locked;       <span class="comment">// Is the lock held?</span></span><br><span class="line">  <span class="comment">// 必须使用自旋锁保护，保证并发下的正确性</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lk</span>;</span> <span class="comment">// spinlock protecting this sleep lock</span></span><br><span class="line">  <span class="comment">// For debugging:</span></span><br><span class="line">  <span class="type">char</span> *name;        <span class="comment">// Name of lock.</span></span><br><span class="line">  <span class="type">int</span> pid;           <span class="comment">// Process holding lock</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>sleeplock.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Sleeping locks</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;riscv.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;defs.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;param.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;memlayout.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;spinlock.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;proc.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sleeplock.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">initsleeplock</span><span class="params">(<span class="keyword">struct</span> sleeplock *lk, <span class="type">char</span> *name)</span></span><br><span class="line">&#123;</span><br><span class="line">  initlock(&amp;lk-&gt;lk, <span class="string">&quot;sleep lock&quot;</span>);</span><br><span class="line">  lk-&gt;name = name;</span><br><span class="line">  lk-&gt;locked = <span class="number">0</span>;</span><br><span class="line">  lk-&gt;pid = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">acquiresleep</span><span class="params">(<span class="keyword">struct</span> sleeplock *lk)</span></span><br><span class="line">&#123;</span><br><span class="line">  acquire(&amp;lk-&gt;lk);</span><br><span class="line">  <span class="comment">// while循环消除了无效唤醒</span></span><br><span class="line">  <span class="keyword">while</span> (lk-&gt;locked) &#123;</span><br><span class="line">    sleep(lk, &amp;lk-&gt;lk);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 获得睡眠锁</span></span><br><span class="line">  lk-&gt;locked = <span class="number">1</span>;</span><br><span class="line">  lk-&gt;pid = myproc()-&gt;pid;</span><br><span class="line">  release(&amp;lk-&gt;lk);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">releasesleep</span><span class="params">(<span class="keyword">struct</span> sleeplock *lk)</span></span><br><span class="line">&#123;</span><br><span class="line">  acquire(&amp;lk-&gt;lk);</span><br><span class="line">  lk-&gt;locked = <span class="number">0</span>;</span><br><span class="line">  lk-&gt;pid = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 释放睡眠锁，唤醒可能睡眠的进程</span></span><br><span class="line">  wakeup(lk);</span><br><span class="line">  release(&amp;lk-&gt;lk);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">holdingsleep</span><span class="params">(<span class="keyword">struct</span> sleeplock *lk)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> r;  </span><br><span class="line">  acquire(&amp;lk-&gt;lk);</span><br><span class="line">  r = lk-&gt;locked &amp;&amp; (lk-&gt;pid == myproc()-&gt;pid);</span><br><span class="line">  release(&amp;lk-&gt;lk);</span><br><span class="line">  <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第七章：调度"><a href="#第七章：调度" class="headerlink" title="第七章：调度"></a>第七章：调度</h3><p>任何操作系统运行的进程数量都可能超过计算机的 CPU 数量，因此需要制定一个方案，在各进程之间分时共享 CPU。理想情况下，这种共享对用户进程是透明的。一种常见的方法是通过将进程复用到硬件 CPU 上，给每个进程提供它有自己的虚拟 CPU 的假象。本章解释xv6 如何实现这种复用。</p>
<h4 id="7-1关于复用"><a href="#7-1关于复用" class="headerlink" title="7.1关于复用"></a>7.1关于复用</h4><p>xv6 通过在两种情况下将 CPU 从一个进程切换到另一个进程来实现复用。<code>首先，xv6的sleep和wakeup机制会进行切换，这会发生在进程等待设备或管道I/O，或等待子进程退出，或在 sleep系统调用中等待。其次，xv6周期性地强制切换，以应对长时间的计算进程。</code>这种复用造成了每个进程都有自己的 CPU 的假象，就像 xv6 使用内存分配器和硬件页表造成每个进程都有自己的内存的假象一样。</p>
<p>实现复用会有一些挑战。&#x3D;&#x3D;首先，如何从一个进程切换到另一个进程？虽然上下文切换的想法很简单，但实现起来却很难。第二，如何对用户进程透明的强制切换？xv6 采用一般的方式，用定时器中断来驱动上下文切换。第三，许多 CPU 可能会在进程间并发切换，需要设计一个锁来避免竞争。第四，当进程退出时，必须释放进程的内存和其他资源，但它自己不能做到这一切，因为它不能释放自己的内核栈，同时又在使用内核栈。第五，多核机器的每个内核必须记住它正在执行的进程，这样系统调用就会修改相应进程的内核状态。最后，sleep 和 wakeup 允许一个进程放弃 CPU，并睡眠等待事件，并允许另一个进程唤醒第一个进程。需要注意一些竞争可能会使唤醒丢失。xv6 试图尽可能简单地解决这些问题，但尽管如此，写出来代码还是很棘手。&#x3D;&#x3D;</p>
<h4 id="7-2上下文切换"><a href="#7-2上下文切换" class="headerlink" title="7.2上下文切换"></a>7.2上下文切换</h4><p><img src="/../../../../../../imgs/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%BA%90%E7%A0%81%E7%BA%A7%E5%89%96%E6%9E%90/image-20221116200142968.png" alt="image-20221116200142968"></p>
<p>图 7.1 概述了从一个用户进程切换到另一个用户进程所涉及的步骤：用户内核转换（系统调用或中断）到旧进程的内核线程，context 切换到当前 CPU 的调度器线程，context 切换到新进程的内核线程，以及 trap 返回到用户级进程。xv6 调度器在每个 CPU 上有一个专门的线程(保存的寄存器和栈)，因为调度器在旧进程的内核栈上执行是不安全的：其他核心可能会唤醒进程并运行它，而且在两个不同的核心上使用相同的栈将是一场灾难。在本节中，我们将研究在内核线程和调度线程之间切换的机制。</p>
<p><code>从一个线程切换到另一个线程，需要保存旧线程的 CPU 寄存器，并恢复新线程之前保存的寄存器；栈指针和 pc 被保存和恢复，意味着 CPU 将切换栈和正在执行的代码。</code></p>
<p>函数 swtch 执行内核线程切换的保存和恢复。swtch 并不直接知道线程，它只是保存和恢复寄存器组，称为上下文(context)。<code>当一个进程要放弃 CPU 的时候，进程的内核线程会调用 swtch 保存自己的上下文并返回到调度器上下文。每个上下文都包含在一个结构体context中，它本身包含在进程的结构体 proc 或 CPU 的结构体 cpu 中。</code>swtch 有两个参数：struct context *old 和 struct context *new。它将当前的寄存器保存在old 中，从 new 中加载寄存器，然后返回。</p>
<p>让我们跟随一个进程通过 swtch 进入 scheduler。我们在第 4 章看到，在中断结束时，有一种情况是 usertrap 调用 yield。yield 又调用 sched，sched 调用 swtch 将当前上下文保存在 p-&gt;context 中 ， 并 切 换 到 之 前 保 存 在 cpu-&gt;scheduler 中 的 调 度 器 上 下 文。</p>
<p>swtch只保存 callee-saved 寄存器，caller-saved 寄存器由调用的C代码保存在堆栈上。swtch 知道 struct context 中每个寄存器字段的偏移量。它不保存 pc。相反，swtch 保存了 ra 寄存器，它保存了 swtch 应该返回的地址。现在，swtch从新的上下文中恢复寄存器，新的上下文中保存着前一次 swtch 所保存的寄存器值。当swtch 返回时，它返回到被恢复的 ra 寄存器所指向的指令，也就是新线程之前调用 swtch的指令。此外，它还会在新线程的栈上返回。</p>
<p><code>在我们的例子中，sched调用swtch切换到cpu-&gt;scheduler，即CPU的调度上下文。这个上下文已经被调度器对swtch的调用所保存。当我们跟踪的swtch返回时，它不是返回到sched而是返回到 scheduler，它的栈指针指向当前CPU的调度器栈。</code></p>
<h4 id="7-3调度核心代码"><a href="#7-3调度核心代码" class="headerlink" title="7.3调度核心代码"></a>7.3调度核心代码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Per-CPU process scheduler.</span></span><br><span class="line"><span class="comment">// Each CPU calls scheduler() after setting itself up.</span></span><br><span class="line"><span class="comment">// Scheduler never returns.  It loops, doing:</span></span><br><span class="line"><span class="comment">//  - choose a process to run.</span></span><br><span class="line"><span class="comment">//  - swtch to start running that process.</span></span><br><span class="line"><span class="comment">//  - eventually that process transfers control</span></span><br><span class="line"><span class="comment">//    via swtch back to the scheduler.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">scheduler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">cpu</span> *<span class="title">c</span> =</span> mycpu();</span><br><span class="line">  </span><br><span class="line">  c-&gt;proc = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">    <span class="comment">// Avoid deadlock by ensuring that devices can interrupt.</span></span><br><span class="line">    <span class="comment">// CPU核心通过设置SSTATUS寄存器（SSTATUS_SIE）开启设备中断</span></span><br><span class="line">    intr_on();</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> found = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(p = proc; p &lt; &amp;proc[NPROC]; p++) &#123;</span><br><span class="line">      acquire(&amp;p-&gt;lock);</span><br><span class="line">      <span class="keyword">if</span>(p-&gt;state == RUNNABLE) &#123;</span><br><span class="line">        <span class="comment">// Switch to chosen process.  It is the process&#x27;s job</span></span><br><span class="line">        <span class="comment">// to release its lock and then reacquire it</span></span><br><span class="line">        <span class="comment">// before jumping back to us.</span></span><br><span class="line">        p-&gt;state = RUNNING;</span><br><span class="line">        c-&gt;proc = p;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// A kernel page table per process 实验开始</span></span><br><span class="line">        w_satp(MAKE_SATP(p-&gt;kernelpt));</span><br><span class="line">        sfence_vma();</span><br><span class="line">        <span class="comment">// A kernel page table per process 实验结束</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 切换到选中的进程执行</span></span><br><span class="line">        swtch(&amp;c-&gt;context, &amp;p-&gt;context);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Process is done running for now.</span></span><br><span class="line">        <span class="comment">// It should have changed its p-&gt;state before coming back.</span></span><br><span class="line">        c-&gt;proc = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// A kernel page table per process 实验开始</span></span><br><span class="line">        w_satp(MAKE_SATP(kernel_pagetable));</span><br><span class="line">      	sfence_vma();</span><br><span class="line">        <span class="comment">// A kernel page table per process 实验结束</span></span><br><span class="line">        found = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 这一步很重要，每次通过shced()--&gt;scheduler()--&gt;swtch()执行，到达这里会释放之前保持的p-&gt;lock</span></span><br><span class="line">      <span class="comment">// 一个具体的例子就是sleep()沿着函数调用到达这里后释放了p-&gt;lock，wakeup()可以获得p-&gt;lock并唤醒p</span></span><br><span class="line">      release(&amp;p-&gt;lock);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(found == <span class="number">0</span>) &#123;</span><br><span class="line">      intr_on();</span><br><span class="line">      <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;wfi&quot;</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="7-4mycpu和myproc"><a href="#7-4mycpu和myproc" class="headerlink" title="7.4mycpu和myproc"></a>7.4mycpu和myproc</h4><p>xv6 经常需要一个指向当前进程 proc 的指针。在单核处理器上，可以用一个全局变量指向当前的 proc。这在多核机器上是行不通的，因为每个核都执行不同的进程。<code>解决这个问题的方法是利用每个核都有自己的一组寄存器的事实，我们可以使用其中的一个寄存器来帮助查找每个核的信息。</code></p>
<p>&#x3D;&#x3D;xv6 为每个CPU维护了一个 cpu 结构体，它记录了当前在该CPU上运行的进程(如果有的话)，为CPU的调度线程保存的寄存器，以及管理中断禁用所需的嵌套自旋锁的计数。&#x3D;&#x3D;函数 mycpu返回一个指向当前 CPU 结构体 cpu 的指针。<code>RISC-V对其CPU进行编号，给每个CPU一个 hartid。xv6确保每个CPU的hartid在内核中被存储在该CPU的tp寄存器中。</code>这使得 mycpu 可以使用 tp 对 cpu 结构体的数组进行索引，从而找到正确的 cpu。</p>
<p>&#x3D;&#x3D;确保一个CPU的tp始终保持CPU的hartid是有一点复杂的。&#x3D;&#x3D;mstart在CPU启动的早期设置tp寄存器，此时CPU处于机器模式。usertrapret将tp寄存器保存在trapframe页中，因为用户进程可能会修改tp寄存器。最后，当从用户空间进入内核时，uservec会恢复保存的tp。编译器保证永远不使用tp寄存器。如果RISC-V允许xv6直接读取当前的hartid会更方便，但只有机器模式下能够读取，不允许在监督者模式下使用。</p>
<p><code>cpuid和mycpu的返回值很容易错：如果定时器中断，导致线程让出CPU，然后转移到不同的CPU上，之前返回的值将不再正确。为了避免这个问题，xv6要求调用者禁用中断，只有在使用完返回的cpu结构后才启用中断。</code></p>
<p>&#x3D;&#x3D;myproc函数返回当前CPU上运行的进程的proc指针。myproc禁用中断，调用mycpu，从cpu中获取当前进程指针(c-&gt;proc)，然后启用中断。即使启用了中断，myproc的返回值也可以安全使用：如果定时器中断将调用进程移到了不同的CPU上，它的proc结构指针将保持不变。&#x3D;&#x3D;</p>
<h4 id="7-5sleep和wakeup机制"><a href="#7-5sleep和wakeup机制" class="headerlink" title="7.5sleep和wakeup机制"></a>7.5sleep和wakeup机制</h4><p>调度和锁有助于隐藏一个进程对另一个进程的存在，但到目前为止，我们还没有帮助进程进行有意交互的抽象。为解决这个问题已经发明了许多机制。xv6使用了一种称为<code>sleep</code>和<code>wakeup</code>的方法，它允许一个进程在等待事件时休眠，而另一个进程在事件发生后将其唤醒。睡眠和唤醒通常被称为序列协调（sequence coordination）或条件同步机制（conditional synchronization mechanisms）。</p>
<p>为了说明，让我们考虑一个称为<code>信号量（semaphore）</code>的同步机制，它可以协调生产者和消费者。信号量维护一个计数并提供两个操作。“V”操作（对于生产者）增加计数。“P”操作（对于使用者）等待计数为非零，然后递减并返回。如果只有一个生产者线程和一个消费者线程，并且它们在不同的CPU上执行，并且编译器没有进行过积极的优化，那么此实现将是正确的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">semaphore</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">    <span class="type">int</span> count;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">void</span> <span class="title function_">V</span><span class="params">(<span class="keyword">struct</span> semaphore *s)</span></span><br><span class="line">&#123;</span><br><span class="line">    acquire(&amp;s-&gt;lock);</span><br><span class="line">    s-&gt;count += <span class="number">1</span>;</span><br><span class="line">    release(&amp;s-&gt;lock);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">P</span><span class="params">(<span class="keyword">struct</span> semaphore *s)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (s-&gt;count == <span class="number">0</span>)</span><br><span class="line">    ;</span><br><span class="line">    acquire(&amp;s-&gt;lock);</span><br><span class="line">    s-&gt;count -= <span class="number">1</span>;</span><br><span class="line">    release(&amp;s-&gt;lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的实现代价昂贵。如果生产者很少采取行动，消费者将把大部分时间花在<code>while</code>循环中，希望得到非零计数。消费者的CPU可以找到比通过反复轮询<code>s-&gt;count</code>繁忙等待更有成效的工作。要避免繁忙等待，消费者需要一种方法来释放CPU，并且只有在<code>V</code>增加计数后才能恢复。</p>
<p>这是朝着这个方向迈出的一步，尽管我们将看到这是不够的。让我们想象一对调用，sleep和wakeup，工作流程如下。<code>sleep(chan)在任意值chan上睡眠，称为等待通道（wait channel）。sleep将调用进程置于睡眠状态，释放CPU用于其他工作。wakeup(chan)唤醒所有在chan上睡眠的进程（如果有），使其sleep调用返回。如果没有进程在chan上等待，则wakeup不执行任何操作。</code>我们可以将信号量实现更改为使用sleep和wakeup（更改的行添加了注释）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">V</span><span class="params">(<span class="keyword">struct</span> semaphore *s)</span></span><br><span class="line">&#123;</span><br><span class="line">    acquire(&amp;s-&gt;lock);</span><br><span class="line">    s-&gt;count += <span class="number">1</span>;</span><br><span class="line">    wakeup(s);</span><br><span class="line">    release(&amp;s-&gt;lock);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">P</span><span class="params">(<span class="keyword">struct</span> semaphore *s)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (s-&gt;count == <span class="number">0</span>)</span><br><span class="line">    	sleep(s);</span><br><span class="line">    acquire(&amp;s-&gt;lock);</span><br><span class="line">    s-&gt;count -= <span class="number">1</span>;</span><br><span class="line">    release(&amp;s-&gt;lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>P</code>现在放弃CPU而不是自旋，这很好。然而，事实证明，使用此接口设计<code>sleep</code>和<code>wakeup</code>而不遭受所谓的丢失唤醒（lost wake-up）问题并非易事。假设<code>P</code>在第9行发现<code>s-&gt;count==0</code>。当<code>P</code>在第9行和第10行之间时，<code>V</code>在另一个CPU上运行：它将<code>s-&gt;count</code>更改为非零，并调用<code>wakeup</code>，这样就不会发现进程处于休眠状态，因此不会执行任何操作。现在P继续在第10行执行：它调用<code>sleep</code>并进入睡眠。这会导致一个问题：<code>P</code>正在休眠，等待调用<code>V</code>，而<code>V</code>已经被调用。除非我们运气好，生产者再次呼叫<code>V</code>，否则消费者将永远等待，即使<code>count</code>为非零。</p>
<p>&#x3D;&#x3D;这个问题的根源是V在错误的时刻运行，违反了P仅在s-&gt;count&#x3D;0时才休眠的不变量。&#x3D;&#x3D;保护不变量的一种不正确的方法是将锁的获取（下面以黄色突出显示）移动到P中，以便其检查count和调用sleep是原子的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">V</span><span class="params">(<span class="keyword">struct</span> semaphore *s)</span></span><br><span class="line">&#123;</span><br><span class="line">    acquire(&amp;s-&gt;lock);</span><br><span class="line">    s-&gt;count += <span class="number">1</span>;</span><br><span class="line">    wakeup(s);</span><br><span class="line">    release(&amp;s-&gt;lock);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">P</span><span class="params">(<span class="keyword">struct</span> semaphore *s)</span></span><br><span class="line">&#123;</span><br><span class="line">    acquire(&amp;s-&gt;lock);</span><br><span class="line">    <span class="keyword">while</span> (s-&gt;count == <span class="number">0</span>)</span><br><span class="line">    	sleep(s);</span><br><span class="line">    s-&gt;count -= <span class="number">1</span>;</span><br><span class="line">    release(&amp;s-&gt;lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>人们可能希望这个版本的<code>P</code>能够避免丢失唤醒，因为锁阻止<code>V</code>在第10行和第11行之间执行。它确实这样做了，但它会导致死锁：<code>P</code>在睡眠时持有锁，因此<code>V</code>将永远阻塞等待锁。</p>
<p>我们将通过更改sleep的接口来修复前面的方案：<code>调用方必须将条件锁（condition lock）传递给sleep，以便在调用进程被标记为sleep并在睡眠通道上等待后sleep可以释放锁。如果有一个并发的V操作，锁将强制它在P将自己置于睡眠状态前一直等待，因此wakeup将找到睡眠的消费者并将其唤醒。一旦消费者再次醒来，sleep会在返回前重新获得锁。</code>我们新的正确的<code>sleep/wakeup</code>方案可用如下（更改以黄色突出显示）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">V</span><span class="params">(<span class="keyword">struct</span> semaphore *s)</span></span><br><span class="line">&#123;</span><br><span class="line">    acquire(&amp;s-&gt;lock);</span><br><span class="line">    s-&gt;count += <span class="number">1</span>;</span><br><span class="line">    wakeup(s);</span><br><span class="line">    release(&amp;s-&gt;lock);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">P</span><span class="params">(<span class="keyword">struct</span> semaphore *s)</span></span><br><span class="line">&#123;</span><br><span class="line">    acquire(&amp;s-&gt;lock);</span><br><span class="line">    <span class="keyword">while</span> (s-&gt;count == <span class="number">0</span>)</span><br><span class="line">    	sleep(s, &amp;s-&gt;lock);</span><br><span class="line">    s-&gt;count -= <span class="number">1</span>;</span><br><span class="line">    release(&amp;s-&gt;lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>P</code>持有<code>s-&gt;lock</code>的事实阻止<code>V</code>在<code>P</code>检查<code>s-&gt;count</code>和调用<code>sleep</code>之间试图唤醒它。然而请注意，我们需要<code>sleep</code>释放<code>s-&gt;lock</code>并使消费者进程进入睡眠状态的操作是原子的。</p>
<h4 id="7-6sleep和wakeup代码"><a href="#7-6sleep和wakeup代码" class="headerlink" title="7.6sleep和wakeup代码"></a>7.6sleep和wakeup代码</h4><p>让我们看看sleep和wakeup的实现。<code>其基本思想是让sleep将当前进程标记为SLEEPING，然后调用sched释放CPU；wakeup查找在给定等待通道上休眠的进程，并将其标记为RUNNABLE。sleep和wakeup的调用者可以使用任何相互间方便的数字作为通道。</code>&#x3D;&#x3D;xv6通常使用等待过程中涉及的内核数据结构的地址。&#x3D;&#x3D;</p>
<p><code>sleep</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Atomically release lock and sleep on chan.</span></span><br><span class="line"><span class="comment">// Reacquires lock when awakened.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">sleep</span><span class="params">(<span class="type">void</span> *chan, <span class="keyword">struct</span> spinlock *lk)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  <span class="comment">// Must acquire p-&gt;lock in order to</span></span><br><span class="line">  <span class="comment">// change p-&gt;state and then call sched.</span></span><br><span class="line">  <span class="comment">// Once we hold p-&gt;lock, we can be</span></span><br><span class="line">  <span class="comment">// guaranteed that we won&#x27;t miss any wakeup</span></span><br><span class="line">  <span class="comment">// (wakeup locks p-&gt;lock),</span></span><br><span class="line">  <span class="comment">// so it&#x27;s okay to release lk.</span></span><br><span class="line">  <span class="comment">// 修改进程状态和调用sched函数前，必须拿到p-&gt;lock</span></span><br><span class="line">  <span class="keyword">if</span>(lk != &amp;p-&gt;lock)&#123;  <span class="comment">//DOC: sleeplock0</span></span><br><span class="line">    acquire(&amp;p-&gt;lock);  <span class="comment">//DOC: sleeplock1</span></span><br><span class="line">    release(lk);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Go to sleep.</span></span><br><span class="line">  <span class="comment">// 进程休眠</span></span><br><span class="line">  p-&gt;chan = chan;</span><br><span class="line">  p-&gt;state = SLEEPING;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// 转去调度线程</span></span><br><span class="line">  sched();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Tidy up.</span></span><br><span class="line">  <span class="comment">// 进程被唤醒紧接着执行，重置chan休眠等待链</span></span><br><span class="line">  p-&gt;chan = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Reacquire original lock.</span></span><br><span class="line">  <span class="comment">// 唤醒后需要重新获得原来的lk</span></span><br><span class="line">  <span class="keyword">if</span>(lk != &amp;p-&gt;lock)&#123;</span><br><span class="line">    release(&amp;p-&gt;lock);</span><br><span class="line">    acquire(lk);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>wakeup</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Wake up all processes sleeping on chan.</span></span><br><span class="line"><span class="comment">// Must be called without any p-&gt;lock.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">wakeup</span><span class="params">(<span class="type">void</span> *chan)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(p = proc; p &lt; &amp;proc[NPROC]; p++) &#123;</span><br><span class="line">    acquire(&amp;p-&gt;lock);</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;state == SLEEPING &amp;&amp; p-&gt;chan == chan) &#123;</span><br><span class="line">      p-&gt;state = RUNNABLE;</span><br><span class="line">    &#125;</span><br><span class="line">    release(&amp;p-&gt;lock);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>sleep</code>获得<code>p-&gt;lock</code>。要进入睡眠的进程现在同时持有<code>p-&gt;lock</code>和<code>lk</code>。在调用者（示例中为<code>P</code>）中持有<code>lk</code>是必要的：它确保没有其他进程（在示例中指一个运行的<code>V</code>）可以启动<code>wakeup(chan)</code>调用。既然<code>sleep</code>持有<code>p-&gt;lock</code>，那么释放<code>lk</code>是安全的：其他进程可能会启动对<code>wakeup(chan)</code>的调用，但是<code>wakeup</code>将等待获取<code>p-&gt;lock</code>，因此将等待<code>sleep</code>把进程置于睡眠状态的完成，以防止<code>wakeup</code>错过<code>sleep</code>。</p>
<p><code>还有一个小问题：如果lk和p-&gt;lock是同一个锁，那么如果sleep试图获取p-&gt;lock就会自身死锁。</code>但是，如果调用sleep的进程已经持有p-&gt;lock，那么它不需要做更多的事情来避免错过并发的wakeup。当wait持有p-&gt;lock调用sleep时，就会出现这种情况。</p>
<p>&#x3D;&#x3D;由于sleep只持有p-&gt;lock而无其他，它可以通过记录睡眠通道、将进程状态更改为SLEEPING并调用sched将进程置于睡眠状态。&#x3D;&#x3D;过一会儿，我们就会明白为什么在进程被标记为SLEEPING之前不将p-&gt;lock释放（由scheduler）是至关重要的。</p>
<p>在某个时刻，一个进程将获取条件锁，设置睡眠者正在等待的条件，并调用<code>wakeup(chan)</code>。在持有状态锁时调用<code>wakeup</code>非常重要。<code>wakeup</code>遍历进程表。它获取它所检查的每个进程的<code>p-&gt;lock</code>，这既是因为它可能会操纵该进程的状态，也是因为<code>p-&gt;lock</code>确保<code>sleep</code>和<code>wakeup</code>不会彼此错过。当<code>wakeup</code>发现一个<code>SLEEPING</code>的进程且<code>chan</code>相匹配时，它会将该进程的状态更改为<code>RUNNABLE</code>。调度器下次运行时，将看到进程已准备好运行。</p>
<p>为什么<code>sleep</code>和<code>wakeup</code>的用锁规则能确保睡眠进程不会错过唤醒？休眠进程从检查条件之前的某处到标记为休眠之后的某处，要么持有条件锁，要么持有其自身的<code>p-&gt;lock</code>或同时持有两者。调用<code>wakeup</code>的进程在<code>wakeup</code>的循环中同时持有这两个锁。因此，要么唤醒器（waker）在消费者线程检查条件之前使条件为真；要么唤醒器的<code>wakeup</code>在睡眠线程标记为<code>SLEEPING</code>后对其进行严格检查。然后<code>wakeup</code>将看到睡眠进程并将其唤醒（除非有其他东西首先将其唤醒）。</p>
<p>有时，多个进程在同一个通道上睡眠；例如，多个进程读取同一个管道。一个单独的<code>wakeup</code>调用就能把他们全部唤醒。其中一个将首先运行并获取与<code>sleep</code>一同调用的锁，并且（在管道例子中）读取在管道中等待的任何数据。尽管被唤醒，其他进程将发现没有要读取的数据。从他们的角度来看，醒来是“虚假的”，他们必须再次睡眠。因此，在检查条件的循环中总是调用<code>sleep</code>。</p>
<p>&#x3D;&#x3D;如果两次使用sleep&#x2F;wakeup时意外选择了相同的通道，则不会造成任何伤害：它们将看到虚假的唤醒，但如上所述的循环将容忍此问题。sleep&#x2F;wakeup的魅力在于它既轻量级（不需要创建特殊的数据结构来充当睡眠通道），又提供了一层抽象（调用者不需要知道他们正在与哪个特定进程进行交互）。&#x3D;&#x3D;</p>
<h4 id="7-7管道代码"><a href="#7-7管道代码" class="headerlink" title="7.7管道代码"></a>7.7管道代码</h4><p><code>一个使用 sleep 和 wakeup 来同步生产者和消费者的更复杂的例子是 xv6 的管道实现。</code>我们在第 1 章看到了管道的接口：写入管道一端的字节被复制到内核缓冲区，然后可以从管道的另一端读取。未来的章节将研究管道如何支持文件描述符，但我们现在来看一下pipewrite 和 piperead 的实现吧。</p>
<p><code>每个管道由一个结构体 pipe 表示，它包含一个锁和一个数据缓冲区。nread 和 nwrite两个字段统计从缓冲区读取和写入的字节总数。缓冲区呈环形：buf[PIPESIZE-1]之后写入的下一个字节是 buf[0]。计数不呈环形。这个约定使得实现可以区分满缓冲区(nwrite =nread+PIPESIZE)和空缓冲区(nwrite = nread)，但这意味着对缓冲区的索引必须使用buf[nread % PIPESIZE]，而不是使用 buf[nread]。</code></p>
<p>假设对 piperead 和 pipewrite 的调用同时发生在两个不同的 CPU 上。pipewrite首先获取管道的锁，它保护了计数、数据和相关的不变式。然后，Piperead也试图获取这个锁，但是不会获取成功。它在 acquire中循环，等待锁的到来。当 piperead 等待时，pipewrite 会循环写，依次将每个字节添加到管道中。在这个循环中，可能会发生缓冲区被填满的情况。在这种情况下，pipewrite 调用 wakeup 来唤醒所有睡眠中的 reader 有数据在缓冲区中等待，然后在&amp;pi-&gt;nwrite 上 sleep，等待 reader 从缓冲区中取出一些字节。Sleep 函数内会释放 pi-&gt;lock，然后 pipwrite 进程睡眠。</p>
<p><code>pipe结构体</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PIPESIZE 512</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">  <span class="type">char</span> data[PIPESIZE];</span><br><span class="line">  uint nread;     <span class="comment">// number of bytes read</span></span><br><span class="line">  uint nwrite;    <span class="comment">// number of bytes written</span></span><br><span class="line">  <span class="type">int</span> readopen;   <span class="comment">// read fd is still open</span></span><br><span class="line">  <span class="type">int</span> writeopen;  <span class="comment">// write fd is still open</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>pipewrite</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">pipewrite</span><span class="params">(<span class="keyword">struct</span> pipe *pi, uint64 addr, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="type">char</span> ch;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">pr</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">  acquire(&amp;pi-&gt;lock);</span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">    <span class="comment">// 管道数据区满了，唤醒piperead进程并陷入休眠</span></span><br><span class="line">    <span class="keyword">while</span>(pi-&gt;nwrite == pi-&gt;nread + PIPESIZE)&#123;  <span class="comment">//DOC: pipewrite-full</span></span><br><span class="line">      <span class="keyword">if</span>(pi-&gt;readopen == <span class="number">0</span> || pr-&gt;killed)&#123;</span><br><span class="line">        release(&amp;pi-&gt;lock);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      wakeup(&amp;pi-&gt;nread);</span><br><span class="line">      sleep(&amp;pi-&gt;nwrite, &amp;pi-&gt;lock);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 数据写入到内核数据区中</span></span><br><span class="line">    <span class="keyword">if</span>(copyin(pr-&gt;pagetable, &amp;ch, addr + i, <span class="number">1</span>) == <span class="number">-1</span>)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    pi-&gt;data[pi-&gt;nwrite++ % PIPESIZE] = ch;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 已全部写入，唤醒读进程即可</span></span><br><span class="line">  wakeup(&amp;pi-&gt;nread);</span><br><span class="line">  release(&amp;pi-&gt;lock);</span><br><span class="line">  <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在pi-&gt;lock可用了，<code>piperead设法获取它并进入它的临界区：它发现pi-&gt;nread!=pi-&gt;nwrite (pipewrite进入睡眠状态是由于pi-&gt;nwrite == pi-&gt;nread+PIPESIZE)，所以它进入for循环，将数据从管道中复制出来，并按复制的字节数增加nread。现在又可写了，所以piperead在返回之前调用wakeup来唤醒在睡眠的writer。wakeup找到一个在&amp;pi-&gt;nwrite上睡眠的进程，这个进程正在运行 pipewrite，但在缓冲区填满时停止了。它将该进程标记为RUNNABLE。</code></p>
<p><code>piperead</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">piperead</span><span class="params">(<span class="keyword">struct</span> pipe *pi, uint64 addr, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">pr</span> =</span> myproc();</span><br><span class="line">  <span class="type">char</span> ch;</span><br><span class="line"></span><br><span class="line">  acquire(&amp;pi-&gt;lock);</span><br><span class="line">  <span class="comment">// 管道数据区为空，进程休眠等待write进程的唤醒</span></span><br><span class="line">  <span class="keyword">while</span>(pi-&gt;nread == pi-&gt;nwrite &amp;&amp; pi-&gt;writeopen)&#123;  <span class="comment">//DOC: pipe-empty</span></span><br><span class="line">    <span class="keyword">if</span>(pr-&gt;killed)&#123;</span><br><span class="line">      release(&amp;pi-&gt;lock);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    sleep(&amp;pi-&gt;nread, &amp;pi-&gt;lock); <span class="comment">//DOC: piperead-sleep</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 数据从管道数据区拷贝到用户数据区</span></span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++)&#123;  <span class="comment">//DOC: piperead-copy</span></span><br><span class="line">    <span class="keyword">if</span>(pi-&gt;nread == pi-&gt;nwrite)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    ch = pi-&gt;data[pi-&gt;nread++ % PIPESIZE];</span><br><span class="line">    <span class="keyword">if</span>(copyout(pr-&gt;pagetable, addr + i, &amp;ch, <span class="number">1</span>) == <span class="number">-1</span>)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 读取完毕，唤醒写进程继续写入即可</span></span><br><span class="line">  wakeup(&amp;pi-&gt;nwrite);  <span class="comment">//DOC: piperead-wakeup</span></span><br><span class="line">  release(&amp;pi-&gt;lock);</span><br><span class="line">  <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>管道代码对 reader 和 writer 使用单独的睡眠 chan（pi-&gt;nread 和 pi-&gt;nwrite）；这可能会使系统在有多个 reader 和 writer 等待同一个管道的情况下更有效率。管道代码在循环内 sleep，检查 sleep 条件；如果有多个 reader 和 writer，除了第一个被唤醒的进程外，其他进程都会看到条件仍然是假的，然后再次睡眠。</p>
<h4 id="7-8wait、exit和kill代码"><a href="#7-8wait、exit和kill代码" class="headerlink" title="7.8wait、exit和kill代码"></a>7.8wait、exit和kill代码</h4><p>sleep 和 wakeup 可以用于许多种需要等待的情况。在第 1 章中介绍的一个有趣的例子是，一个子进程的 exit 和其父进程的 wait 之间的交互。在子进程退出的时候，父进程可能已经在 wait 中睡眠了，也可能在做别的事情；在后一种情况下，后续的 wait 调用必须观察子进程的退出，也许是在它调用 exit 之后很久。<code>xv6在wait观察到子进程退出之前，记录子进程退出的方式是让exit将调用进程设置为ZOMBIE状态，在那里停留，直到父进程的wait注意到它，将子进程的状态改为UNUSED，复制子进程的退出状态，并将子进程的进程ID返回给父进程。</code>&#x3D;&#x3D;如果父进程比子进程先退出，父进程就把子进程交给 init 进程，而init进程则循环的调用wait；这样每个子进程都有一个“父进程”来清理。&#x3D;&#x3D;主要的实现挑战是父进程和子进程的 wait 和 exit，以及 exit 和 exit 之间可能出现竞争和死锁的情况。</p>
<p>wait 使用调用进程的 p-&gt;lock 作为条件锁，以避免唤醒丢失，它在开始时获取该锁。然后它扫描进程表。如果它发现一个处于 ZOMBIE 状态的子进程，它释放这个子进程的资源和它的 proc 结构，将子进程的退出状态复制到提供给 wait 的地址(如果它不是 0)，并返回子进程的 ID。<code>如果wait找到了子进程但没有一个退出，它调用sleep等待其中一个子进程退出，然后再次扫描。这里，在sleep中释放的条件锁是等待进程的p-&gt;lock，也就是上面提到的特殊情况。请注意，wait经常持有两个锁；</code>它在试图获取任何子锁之前，会先获取自己的锁；因此 xv6 的所有锁都必须遵守相同的锁顺序（父进程的锁，然后是子进程的锁），以避免死锁。&#96;</p>
<p>wait 会查看每个进程的 np-&gt;parent 来寻找它的子进程。它使用 np-&gt;parent 而不持有 np-&gt;lock，这违反了共享变量必须受锁保护的通常规则。但是 np 有可能是当前进程的祖先，在这种情况下，获取 np-&gt;lock 可能会导致死锁，因为这违反了上面提到的顺序。在这种情况下，在没有锁的情况下检查 np-&gt;parent 似乎是安全的；一个进程的父进程字段只有“父亲“改变，所以如果 np-&gt;parent&#x3D;&#x3D;p 为真，除非当前进程改变它，否则该值就不会改变。</p>
<p><code>wait</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Wait for a child process to exit and return its pid.</span></span><br><span class="line"><span class="comment">// Return -1 if this process has no children.</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">wait</span><span class="params">(uint64 addr)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">np</span>;</span></span><br><span class="line">  <span class="type">int</span> havekids, pid;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// hold p-&gt;lock for the whole time to avoid lost</span></span><br><span class="line">  <span class="comment">// wakeups from a child&#x27;s exit().</span></span><br><span class="line">  acquire(&amp;p-&gt;lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">    <span class="comment">// Scan through table looking for exited children.</span></span><br><span class="line">    havekids = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(np = proc; np &lt; &amp;proc[NPROC]; np++)&#123;</span><br><span class="line">      <span class="comment">// this code uses np-&gt;parent without holding np-&gt;lock.</span></span><br><span class="line">      <span class="comment">// acquiring the lock first would cause a deadlock,</span></span><br><span class="line">      <span class="comment">// since np might be an ancestor, and we already hold p-&gt;lock.</span></span><br><span class="line">      <span class="comment">// np可能是p的祖先进程，注意需要遵循“先父进程锁后子进程锁”的原则</span></span><br><span class="line">      <span class="keyword">if</span>(np-&gt;parent == p)&#123;</span><br><span class="line">        <span class="comment">// np-&gt;parent can&#x27;t change between the check and the acquire()</span></span><br><span class="line">        <span class="comment">// because only the parent changes it, and we&#x27;re the parent.</span></span><br><span class="line">        acquire(&amp;np-&gt;lock);</span><br><span class="line">        havekids = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 对于僵死的子进程需要释放其内存</span></span><br><span class="line">        <span class="keyword">if</span>(np-&gt;state == ZOMBIE)&#123;</span><br><span class="line">          <span class="comment">// Found one.</span></span><br><span class="line">          <span class="comment">// 子进程的进程ID</span></span><br><span class="line">          pid = np-&gt;pid;</span><br><span class="line">          <span class="comment">// 子进程的退出状态复制到addr地址处</span></span><br><span class="line">          <span class="keyword">if</span>(addr != <span class="number">0</span> &amp;&amp; copyout(p-&gt;pagetable, addr, (<span class="type">char</span> *)&amp;np-&gt;xstate,</span><br><span class="line">                                  <span class="keyword">sizeof</span>(np-&gt;xstate)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            release(&amp;np-&gt;lock);</span><br><span class="line">            release(&amp;p-&gt;lock);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 释放子进程内存</span></span><br><span class="line">          freeproc(np);</span><br><span class="line">          release(&amp;np-&gt;lock);</span><br><span class="line">          release(&amp;p-&gt;lock);</span><br><span class="line">          <span class="comment">// 返回子进程ID</span></span><br><span class="line">          <span class="keyword">return</span> pid;</span><br><span class="line">        &#125;</span><br><span class="line">        release(&amp;np-&gt;lock);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// No point waiting if we don&#x27;t have any children.</span></span><br><span class="line">    <span class="comment">// 没有子进程直接返回-1</span></span><br><span class="line">    <span class="keyword">if</span>(!havekids || p-&gt;killed)&#123;</span><br><span class="line">      release(&amp;p-&gt;lock);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Wait for a child to exit.</span></span><br><span class="line">    <span class="comment">// 等待子进程调用exit退出唤醒</span></span><br><span class="line">    sleep(p, &amp;p-&gt;lock);  <span class="comment">//DOC: wait-sleep</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Exit记录退出状态，释放一些资源，将所有子进程交给 init 进程，在父进程处于等待状态时唤醒它，将调用进程标记为zombie，并永久放弃 CPU。</code>&#x3D;&#x3D;退出的进程必须持有父进程的锁，同时将自己状态设置为 ZOMBIE 并唤醒父进程，因为父进程的锁是条件锁，可以防止在等待中丢失 wakeup。子进程也必须持有自己的 p-&gt;lock，否则父进程可能会看到它的状态为 ZOMBIE，并在它还在运行时释放它。&#x3D;&#x3D;</p>
<blockquote>
<p>锁的获取顺序对避免死锁很重要：因为 wait 在子锁之前获取父锁，所以 exit 必须使用相同的顺序。</p>
</blockquote>
<p>exit 调用了一个专门的唤醒函数 wakeup1，它只唤醒父进程，而且只有父进程在wait中睡眠的情况下才会去唤醒它。<code>在将自己的状态设置为ZOMBIE之前，唤醒父进程可能看起来并不正确，但这是安全的：尽管wakeup1可能会导致父进程运行，但wait中的循环不能检查子进程，直到子进程的p-&gt;lock被调度器释放为止，所以wait不能查看退出的进程，直到exit将其状态设置为ZOMBIE之后。</code></p>
<p><code>exit</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Exit the current process.  Does not return.</span></span><br><span class="line"><span class="comment">// An exited process remains in the zombie state</span></span><br><span class="line"><span class="comment">// until its parent calls wait().</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">exit</span><span class="params">(<span class="type">int</span> status)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  <span class="keyword">if</span>(p == initproc)</span><br><span class="line">    panic(<span class="string">&quot;init exiting&quot;</span>);</span><br><span class="line">  <span class="comment">// 关闭所有打开的文件</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> fd = <span class="number">0</span>; fd &lt; NOFILE; fd++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;ofile[fd])&#123;</span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">f</span> =</span> p-&gt;ofile[fd];</span><br><span class="line">      fileclose(f);</span><br><span class="line">      p-&gt;ofile[fd] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 减少对内存中inode的引用</span></span><br><span class="line">  begin_op();</span><br><span class="line">  iput(p-&gt;cwd);</span><br><span class="line">  end_op();</span><br><span class="line">  p-&gt;cwd = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// we might re-parent a child to init. we can&#x27;t be precise about</span></span><br><span class="line">  <span class="comment">// waking up init, since we can&#x27;t acquire its lock once we&#x27;ve</span></span><br><span class="line">  <span class="comment">// acquired any other proc lock. so wake up init whether that&#x27;s</span></span><br><span class="line">  <span class="comment">// necessary or not. init may miss this wakeup, but that seems</span></span><br><span class="line">  <span class="comment">// harmless.</span></span><br><span class="line">  acquire(&amp;initproc-&gt;lock);</span><br><span class="line">  wakeup1(initproc);</span><br><span class="line">  release(&amp;initproc-&gt;lock);</span><br><span class="line">  <span class="comment">// grab a copy of p-&gt;parent, to ensure that we unlock the same</span></span><br><span class="line">  <span class="comment">// parent we locked. in case our parent gives us away to init while</span></span><br><span class="line">  <span class="comment">// we&#x27;re waiting for the parent lock. we may then race with an</span></span><br><span class="line">  <span class="comment">// exiting parent, but the result will be a harmless spurious wakeup</span></span><br><span class="line">  <span class="comment">// to a dead or wrong process; proc structs are never re-allocated</span></span><br><span class="line">  <span class="comment">// as anything else.</span></span><br><span class="line">  acquire(&amp;p-&gt;lock);</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">original_parent</span> =</span> p-&gt;parent;</span><br><span class="line">  release(&amp;p-&gt;lock);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// we need the parent&#x27;s lock in order to wake it up from wait().</span></span><br><span class="line">  <span class="comment">// the parent-then-child rule says we have to lock it first.</span></span><br><span class="line">  acquire(&amp;original_parent-&gt;lock);</span><br><span class="line">  acquire(&amp;p-&gt;lock);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Give any children to init.</span></span><br><span class="line">  reparent(p);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Parent might be sleeping in wait().</span></span><br><span class="line">  wakeup1(original_parent);</span><br><span class="line"></span><br><span class="line">  p-&gt;xstate = status;</span><br><span class="line">  p-&gt;state = ZOMBIE;</span><br><span class="line"></span><br><span class="line">  release(&amp;original_parent-&gt;lock);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Jump into the scheduler, never to return.</span></span><br><span class="line">  sched();</span><br><span class="line">  panic(<span class="string">&quot;zombie exit&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>reparent</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Pass p&#x27;s abandoned children to init.</span></span><br><span class="line"><span class="comment">// Caller must hold p-&gt;lock.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">reparent</span><span class="params">(<span class="keyword">struct</span> proc *p)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">pp</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(pp = proc; pp &lt; &amp;proc[NPROC]; pp++)&#123;</span><br><span class="line">    <span class="comment">// this code uses pp-&gt;parent without holding pp-&gt;lock.</span></span><br><span class="line">    <span class="comment">// acquiring the lock first could cause a deadlock</span></span><br><span class="line">    <span class="comment">// if pp or a child of pp were also in exit()</span></span><br><span class="line">    <span class="comment">// and about to try to lock p.</span></span><br><span class="line">    <span class="keyword">if</span>(pp-&gt;parent == p)&#123;</span><br><span class="line">      <span class="comment">// pp-&gt;parent can&#x27;t change between the check and the acquire()</span></span><br><span class="line">      <span class="comment">// because only the parent changes it, and we&#x27;re the parent.</span></span><br><span class="line">      acquire(&amp;pp-&gt;lock);</span><br><span class="line">      pp-&gt;parent = initproc;</span><br><span class="line">      <span class="comment">// we should wake up init here, but that would require</span></span><br><span class="line">      <span class="comment">// initproc-&gt;lock, which would be a deadlock, since we hold</span></span><br><span class="line">      <span class="comment">// the lock on one of init&#x27;s children (pp). this is why</span></span><br><span class="line">      <span class="comment">// exit() always wakes init (before acquiring any locks).</span></span><br><span class="line">      release(&amp;pp-&gt;lock);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>exit 允许一个进程自行终止，而 kill则允许一个进程请求另一个进程终止。<code>如果让kill直接摧毁进程，那就太复杂了，因为相应进程可能在另一个CPU上执行，也许正处于更新内核数据结构的敏感序列中</code>。因此，kill的作用很小：它只是设置进程的p-&gt;killed，如果它在sleep，则wakeup它。最终，进程会进入或离开内核，这时如果p-&gt;killed被设置，usertrap中的代码会调用exit。如果进程在用户空间运行，它将很快通过进行系统调用或因为定时器（或其他设备）中断而进入内核。</p>
<p><code>如果进程处于睡眠状态，kill调用wakeup会使进程从睡眠中返回。这是潜在的危险，因为正在等待的条件可能不为真。然而，xv6 对sleep的调用总是被包裹在一个while循环中，在sleep返回后重新检测条件。</code>一些对 sleep 的调用也会在循环中检测 p-&gt;killed，如果设置了 p-&gt;killed，则离开当前活动。只有当这种离开是正确的时候才会这样做。例如，管道读写代码如果设置了 killed 标志就会返回；最终代码会返回到 trap，trap 会再次检查标志并退出。</p>
<p><code>一些xv6 sleep循环没有检查p-&gt;killed，因为代码处于多步骤系统调用的中间，而这个调用应该是原子的。</code>&#x3D;&#x3D;virtio 驱动就是一个例子：它没有检查 p-&gt;killed，因为磁盘操作可能是一系列写操作中的一个，而这些写操作都是为了让文件系统处于一个正确的状态而需要的。&#x3D;&#x3D;一个在等待磁盘 I&#x2F;O 时被kill的进程不会退出，直到它完成当前的系统调用和usertrap看到killed的标志。</p>
<p><code>kill</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Kill the process with the given pid.</span></span><br><span class="line"><span class="comment">// The victim won&#x27;t exit until it tries to return</span></span><br><span class="line"><span class="comment">// to user space (see usertrap() in trap.c).</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">kill</span><span class="params">(<span class="type">int</span> pid)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(p = proc; p &lt; &amp;proc[NPROC]; p++)&#123;</span><br><span class="line">    acquire(&amp;p-&gt;lock);</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;pid == pid)&#123;</span><br><span class="line">      p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span>(p-&gt;state == SLEEPING)&#123;</span><br><span class="line">        <span class="comment">// Wake process from sleep().</span></span><br><span class="line">        p-&gt;state = RUNNABLE;</span><br><span class="line">      &#125;</span><br><span class="line">      release(&amp;p-&gt;lock);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    release(&amp;p-&gt;lock);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第八章：文件系统"><a href="#第八章：文件系统" class="headerlink" title="第八章：文件系统"></a>第八章：文件系统</h3><p>文件系统的目的是<code>组织和存储数据</code>。文件系统通常支持用户和应用程序之间的数据共享，以及支持持久性，以便数据在重启后仍然可用。</p>
<p>xv6 文件系统提供了类 Unix 的文件、目录和路径名，并将其数据存储在virtio磁盘上以实现持久化。该文件系统解决了几个挑战：</p>
<ul>
<li>文件系统需要磁盘上的数据结构来表示命名目录和文件的树，记录保存每个文件内容的块的身份，并记录磁盘上哪些区域是空闲的。</li>
<li>文件系统必须支持崩溃恢复。也就是说，如果发生崩溃如电源故障，文件系统必须在重新启动后仍能正常工作。风险在于，崩溃可能会中断更新序列，并在磁盘上留下不一致的数据结构（例如，一个块既在文件中使用，又被标记为空闲）。</li>
<li>不同的进程可能并发在文件系统上运行，所以文件系统代码必须协调维护每一个临界区。</li>
<li>访问磁盘的速度比访问内存的速度要慢几个数量级，所以文件系统必须维护缓存，用于缓存常用块。</li>
</ul>
<h4 id="8-1概述"><a href="#8-1概述" class="headerlink" title="8.1概述"></a>8.1概述</h4><p><img src="/../../../../../../imgs/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%BA%90%E7%A0%81%E7%BA%A7%E5%89%96%E6%9E%90/image-20221117091925084.png" alt="image-20221117091925084"></p>
<p>&#x3D;&#x3D;xv6 文件系统的实现分为七层，如图 8.1 所示。磁盘层在virtio磁盘上读写块。Buffer缓存层缓存磁盘块，并同步访问它们，确保一个块只能同时被内核中的一个进程访问。日志层允许上层通过事务更新多个磁盘块，并确保在崩溃时，磁盘块是原子更新的（即全部更新或不更新）。inode层将一个文件都表示为一个inode，每个文件包含一个唯一的i-number和一些存放文件数据的块。目录层将实现了一种特殊的inode，被称为目录，其包含一个目录项序列，每个目录项由文件名称和i-number组成。路径名层提供了层次化的路径名，如&#x2F;usr&#x2F;rtm&#x2F;xv6&#x2F;fs.c，可以用递归查找解析他们。文件描述符层用文件系统接口抽象了许多 Unix 资源（如管道、设备、文件等），使程序员的生产力得到大大的提高。&#x3D;&#x3D;</p>
<p><img src="/../../../../../../imgs/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%BA%90%E7%A0%81%E7%BA%A7%E5%89%96%E6%9E%90/image-20221117092252966.png" alt="image-20221117092252966"></p>
<p>文件系统必须安排好磁盘存储inode和内容块的位置。为此，xv6 将磁盘分为几个部分，如图8.2所示。文件系统不使用块0（它存放boot sector）。<code>第1块称为superblock，它包含了文件系统的元数据（以块为单位的文件系统大小、数据块的数量、inode 的数量和日志中的块数）。从块2开始存放着日志，日志之后是inodes，每个块会包含多个inode。在这些块之后是位图块(bitmap)，记录哪些数据块在使用。其余的块是数据块，每个数据块要么在位图块中标记为空闲，要么持有文件或目录的内容。超级块由一个单独的程序 mkfs 写入，它建立了一个初始文件系统。</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// On-disk file system format.</span></span><br><span class="line"><span class="comment">// Both the kernel and user programs use this header file.</span></span><br><span class="line"><span class="comment">// 磁盘上的文件系统的格式和布局</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ROOTINO  1   <span class="comment">// root i-number</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BSIZE 1024  <span class="comment">// block size</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Disk layout:</span></span><br><span class="line"><span class="comment">// [ boot block | super block | log | inode blocks |</span></span><br><span class="line"><span class="comment">//                                          free bit map | data blocks]</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// mkfs computes the super block and builds an initial file system. The</span></span><br><span class="line"><span class="comment">// super block describes the disk layout:</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">superblock</span> &#123;</span></span><br><span class="line">  uint magic;        <span class="comment">// Must be FSMAGIC 魔数</span></span><br><span class="line">  uint size;         <span class="comment">// Size of file system image (blocks) 文件系统影像大小（块数）</span></span><br><span class="line">  uint nblocks;      <span class="comment">// Number of data blocks data块数</span></span><br><span class="line">  uint ninodes;      <span class="comment">// Number of inodes inode数</span></span><br><span class="line">  uint nlog;         <span class="comment">// Number of log blocks log块数</span></span><br><span class="line">  uint logstart;     <span class="comment">// Block number of first log block log起始块号</span></span><br><span class="line">  uint inodestart;   <span class="comment">// Block number of first inode block inode起始块号</span></span><br><span class="line">  uint bmapstart;    <span class="comment">// Block number of first free map block bmap起始块号</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FSMAGIC 0x10203040</span></span><br></pre></td></tr></table></figure>

<p>本章的其余部分将讨论每一层，从 buffer 缓存开始。低层使用选择合适抽象，可以方便更高层的设计。</p>
<h4 id="8-2Buffer缓存层"><a href="#8-2Buffer缓存层" class="headerlink" title="8.2Buffer缓存层"></a>8.2Buffer缓存层</h4><p><code>buffer缓存有两项工作。(1)同步访问磁盘块，以确保磁盘块在内存中只有一个buffer缓存，并且一次只有一个内核线程能使用该buffer缓存；(2)缓存使用较多的块，这样它们就不需要从慢速磁盘中重新读取。</code></p>
<p>buffer缓存的主要接口包括bread和bwrite，bread返回一个在内存中可以读取和修改的块副本 buf，bwrite将修改后的buffer写到磁盘上相应的块。内核线程在使用完一个buffer后，必须通过调用brelse释放它。<code>buffer缓存为每个buffer都设有sleeplock，以确保每次只有一个线程使用 buffer（从而使用相应的磁盘块）；bread返回的buffer会被锁定，而brelse释放锁。</code></p>
<p>我们再来看看 buffer 缓存。buffer 缓存有固定数量的buffer来存放磁盘块，这意味着如果文件系统需要一个尚未被缓存的块，buffer缓存必须回收一个当前存放其他块的buffer。<code>buffer缓存为新块寻找最近使用最少的 buffer（LRU机制）。因为最近使用最少的buffer 是最不可能被再次使用的 buffer。</code></p>
<p><code>buf.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">buf</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> valid;   <span class="comment">// has data been read from disk? 是否从磁盘读取了数据</span></span><br><span class="line">  <span class="type">int</span> disk;    <span class="comment">// does disk &quot;own&quot; buf? 缓冲区的内容已经被修改需要被重新写入磁盘</span></span><br><span class="line">  uint dev;    <span class="comment">// 设备号</span></span><br><span class="line">  uint blockno;<span class="comment">// 块号</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sleeplock</span> <span class="title">lock</span>;</span> <span class="comment">// 保证进程同步访问buf</span></span><br><span class="line">  uint refcnt; <span class="comment">// 引用计数</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">prev</span>;</span> <span class="comment">// LRU cache list</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">next</span>;</span> <span class="comment">// LRU cache list</span></span><br><span class="line">  uchar data[BSIZE];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>buffer 缓存是一个由 buffer 组成的双端链表。由函数 binit 用静态数组 buf 初始化这个链表， binit 在启动时由 main调用。访问 buffer 缓存是通过链表，而不是buf 数组。</p>
<p><code>binit</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> <span class="title">buf</span>[<span class="title">NBUF</span>];</span></span><br><span class="line">  <span class="comment">// Linked list of all buffers, through prev/next.</span></span><br><span class="line">  <span class="comment">// Sorted by how recently the buffer was used.</span></span><br><span class="line">  <span class="comment">// head.next is most recent, head.prev is least.</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> <span class="title">head</span>;</span><span class="comment">// bcache的缓存更新策略是LRU</span></span><br><span class="line">&#125; bcache;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">binit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">b</span>;</span></span><br><span class="line">  initlock(&amp;bcache.lock, <span class="string">&quot;bcache&quot;</span>);</span><br><span class="line">  <span class="comment">// 创建buffer的双端链表</span></span><br><span class="line">  bcache.head.prev = &amp;bcache.head;</span><br><span class="line">  bcache.head.next = &amp;bcache.head;</span><br><span class="line">  <span class="keyword">for</span>(b = bcache.buf; b &lt; bcache.buf+NBUF; b++)&#123;</span><br><span class="line">    b-&gt;next = bcache.head.next;</span><br><span class="line">    b-&gt;prev = &amp;bcache.head;</span><br><span class="line">    initsleeplock(&amp;b-&gt;lock, <span class="string">&quot;buffer&quot;</span>);</span><br><span class="line">    bcache.head.next-&gt;prev = b;</span><br><span class="line">    bcache.head.next = b;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&#x3D;&#x3D;buffer 有两个与之相关的状态字段。字段 valid 表示是否包含该块的副本（是否从磁盘读取了数据）。字段 disk 表示缓冲区的内容已经被修改需要被重新写入磁盘。&#x3D;&#x3D;</p>
<p>bget扫描 buffer 链表，寻找给定设备号和扇区号来查找缓冲区。如果存在，bget 就会获取该 buffer 的 sleeplock。然后 bget 返回被锁定的 buffer。</p>
<p>如果给定的扇区没有缓存的 buffer，bget 必须生成一个，可能会使用一个存放不同扇区的 buffer，它再次扫描 buffer 链表，寻找没有被使用的 buffer(b-&gt;refcnt &#x3D; 0)；任何这样的 buffer 都可以使用。bget 修改 buffer 元数据，记录新的设备号和扇区号，并获得其 sleeplock。<code>请注意，b-&gt;valid = 0可以确保bread从磁盘读取块数据，而不是错误地使用buffer之前的内容。</code></p>
<p>请注意，每个磁盘扇区最多只能有一个 buffer，以确保写操作对读取者可见，也因为文件系统需要使用 buffer 上的锁来进行同步。<code>bget 通过从第一次循环检查块是否被缓存，第二次循环来生成一个相应的 buffer（通过设置 dev、blockno 和 refcnt），在进行这两步操作时，需要一直持有 bcache.lock 。持有 bcache.lock 会保证上面两个循环在整体上是原子的。</code></p>
<p>bget 在 bcache.lock 保护的临界区之外获取 buffer 的 sleeplock 是安全的，因为非零的 b-&gt;refcnt 可以防止缓冲区被重新用于不同的磁盘块。sleeplock 保护的是块的缓冲内容的读写，而 bcache.lock 保护被缓存块的信息。</p>
<p>如果所有 buffer 都在使用，那么太多的进程同时在执行文件相关的系统调用，bget 就会 panic。一个更好的处理方式可能是睡眠，直到有 buffer 空闲，尽管这时有可能出现死锁。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Look through buffer cache for block on device dev.</span></span><br><span class="line"><span class="comment">// If not found, allocate a buffer.</span></span><br><span class="line"><span class="comment">// In either case, return locked buffer.</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> buf*</span><br><span class="line"><span class="title function_">bget</span><span class="params">(uint dev, uint blockno)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">b</span>;</span></span><br><span class="line"></span><br><span class="line">  acquire(&amp;bcache.lock);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Is the block already cached?</span></span><br><span class="line">  <span class="comment">// 查找的块之前已被缓存，从前往后</span></span><br><span class="line">  <span class="keyword">for</span>(b = bcache.head.next; b != &amp;bcache.head; b = b-&gt;next)&#123;</span><br><span class="line">    <span class="keyword">if</span>(b-&gt;dev == dev &amp;&amp; b-&gt;blockno == blockno)&#123;</span><br><span class="line">      b-&gt;refcnt++;</span><br><span class="line">      release(&amp;bcache.lock);</span><br><span class="line">      acquiresleep(&amp;b-&gt;lock);</span><br><span class="line">      <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Not cached.</span></span><br><span class="line">  <span class="comment">// Recycle the least recently used (LRU) unused buffer.</span></span><br><span class="line">  <span class="comment">// 利用LRU（链表尾部是最少使用的）依次查找直到找到一个未被使用的buf，从后往前</span></span><br><span class="line">  <span class="keyword">for</span>(b = bcache.head.prev; b != &amp;bcache.head; b = b-&gt;prev)&#123;</span><br><span class="line">    <span class="keyword">if</span>(b-&gt;refcnt == <span class="number">0</span>) &#123;</span><br><span class="line">      b-&gt;dev = dev;</span><br><span class="line">      b-&gt;blockno = blockno;</span><br><span class="line">      <span class="comment">// b-&gt;valid = 0 可以确保 bread 从磁盘读取块数据，而不是错误地使用 buffer 之前的内容</span></span><br><span class="line">      b-&gt;valid = <span class="number">0</span>;</span><br><span class="line">      b-&gt;refcnt = <span class="number">1</span>;</span><br><span class="line">      release(&amp;bcache.lock);</span><br><span class="line">      acquiresleep(&amp;b-&gt;lock);</span><br><span class="line">      <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  panic(<span class="string">&quot;bget: no buffers&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一旦 bread 读取了磁盘内容（如果需要的话）并将缓冲区返回给它的调用者，调用者就独占该buffer，可以读取或写入数据。如果调用者修改了 buffer，它必须在释放 buffer 之前调用 bwrite 将修改后的数据写入磁盘。bwrite调用 virtio_disk_rw 与磁盘硬件交互。</p>
<p><code>bread</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Return a locked buf with the contents of the indicated block.</span></span><br><span class="line"><span class="keyword">struct</span> buf*</span><br><span class="line"><span class="title function_">bread</span><span class="params">(uint dev, uint blockno)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">b</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 寻找目标缓存块</span></span><br><span class="line">  b = bget(dev, blockno);</span><br><span class="line">  <span class="comment">// 如果是新分配的buf(b-&gt;valid==0)，需要从磁盘上重新读取</span></span><br><span class="line">  <span class="keyword">if</span>(!b-&gt;valid) &#123;</span><br><span class="line">    virtio_disk_rw(b, <span class="number">0</span>);</span><br><span class="line">    b-&gt;valid = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>bwrite</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Write b&#x27;s contents to disk.  Must be locked.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">bwrite</span><span class="params">(<span class="keyword">struct</span> buf *b)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 如果调用者修改了 buffer，它必须在释放 buffer 之前调用 bwrite 将修改后的数据写入磁盘</span></span><br><span class="line">  <span class="keyword">if</span>(!holdingsleep(&amp;b-&gt;lock))</span><br><span class="line">    panic(<span class="string">&quot;bwrite&quot;</span>);</span><br><span class="line">  virtio_disk_rw(b, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当调用者处理完一个buffer后，必须调用brelse来释放它。(brelse这个名字是b-release的缩写，虽然很神秘，但值得学习，它起源于 Unix，在 BSD、Linux 和 Solaris 中也有使用。) brelse释放 sleeplock，并将该 buffer 移动到链表的头部。移动 buffer 会使链表按照 buffer 最近使用的时间（最近释放）排序，链表中的第一个buffer 是最近使用的，最后一个是最晚使用的。bget 中的两个循环利用了这一点，在最坏的情况下，获取已缓存 buffer 的扫描必须处理整个链表，由于数据局部性，先检查最近使用的缓冲区（从 bcache.head 开始，通过 next 指针）将减少扫描时间。扫描选取可使用 buffer的方法是通过从后向前扫描（通过 prev 指针）选取最近使用最少的缓冲区。</p>
<p><code>brelse</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Release a locked buffer.</span></span><br><span class="line"><span class="comment">// Move to the head of the most-recently-used list.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">brelse</span><span class="params">(<span class="keyword">struct</span> buf *b)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(!holdingsleep(&amp;b-&gt;lock))</span><br><span class="line">    panic(<span class="string">&quot;brelse&quot;</span>);</span><br><span class="line">  <span class="comment">// buf使用完毕可以释放持有的buf的sleep锁了</span></span><br><span class="line">  releasesleep(&amp;b-&gt;lock);</span><br><span class="line"></span><br><span class="line">  acquire(&amp;bcache.lock);</span><br><span class="line">  b-&gt;refcnt--;</span><br><span class="line">  <span class="comment">// buf没有进程使用，则把buf移至LRU链表表头（最近使用，可能后面很快就用到）</span></span><br><span class="line">  <span class="keyword">if</span> (b-&gt;refcnt == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// no one is waiting for it.</span></span><br><span class="line">    b-&gt;next-&gt;prev = b-&gt;prev;</span><br><span class="line">    b-&gt;prev-&gt;next = b-&gt;next;</span><br><span class="line">    b-&gt;next = bcache.head.next;</span><br><span class="line">    b-&gt;prev = &amp;bcache.head;</span><br><span class="line">    bcache.head.next-&gt;prev = b;</span><br><span class="line">    bcache.head.next = b;</span><br><span class="line">  &#125;</span><br><span class="line">  release(&amp;bcache.lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>有时候为了保证块缓存不会立即失效回收，使用bpin手动增加buf的引用计数，等到不需要再使用buf的时候使用bunpin减小buf的引用计数。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">bpin</span><span class="params">(<span class="keyword">struct</span> buf *b)</span> &#123;</span><br><span class="line">  acquire(&amp;bcache.lock);</span><br><span class="line">  b-&gt;refcnt++;</span><br><span class="line">  release(&amp;bcache.lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">bunpin</span><span class="params">(<span class="keyword">struct</span> buf *b)</span> &#123;</span><br><span class="line">  acquire(&amp;bcache.lock);</span><br><span class="line">  b-&gt;refcnt--;</span><br><span class="line">  release(&amp;bcache.lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="8-3Logging日志层"><a href="#8-3Logging日志层" class="headerlink" title="8.3Logging日志层"></a>8.3Logging日志层</h4><p>文件系统设计中最有趣的问题之一是崩溃恢复。这个问题的出现是因为许多文件系统操作涉及到对磁盘的多次写入，如果只执行了部分写操作，然后发生崩溃可能会使磁盘上的文件系统处于不一致的状态。例如，假设在文件截断（将文件的长度设置为零并释放其内容块）时发生崩溃。根据磁盘写入的顺序，可能会留下一个引用空闲内容块的 inode，也可能会留下一个已分配但没有被引用的内容块。</p>
<p>后面的这种情况相对来说好一点，但是如果一个 inode 指向被释放的块，很可能在重启后造成严重的问题。重启后，内核可能会将该块分配给另一个文件，现在我们有两个不同的文件无意中指向了同一个块。如果 xv6 支持多用户，这种情况可能是一个安全问题，因为旧文件的所有者能够读写新文件，即使该文件被另一个用户所拥有。</p>
<p><code>xv6通过简单的日志系统来解决文件系统操作过程中崩溃带来的问题。xv6的系统调用不直接写磁盘上的文件系统数据结构。相反，它将写入的数据记录在磁盘上的日志中。一旦系统调用记录了全部的写入数据，它就会在磁盘上写一个特殊的提交记录，表明该日志包含了一个完整的操作。这时，系统调用就会将日志中的写入数据写到磁盘上相应的位置。在执行完成后，系统调用将磁盘上的日志清除。</code></p>
<p>&#x3D;&#x3D;如果系统崩溃并重启，文件系统会在启动过程中恢复自己。如果日志被标记为包含一个完整的操作，那么恢复代码就会将写入的内容复制到它们在磁盘文件系统中的相应位置。如果日志未被标记为包含完整的操作，则恢复代码将忽略并清除该日志。&#x3D;&#x3D;</p>
<p>为什么 xv6 的日志系统可以解决文件系统操作过程中的崩溃问题？&#x3D;&#x3D;如果崩溃发生在操作提交之前，那么磁盘上的日志将不会被标记为完成，恢复代码将忽略它，磁盘的状态就像操作根本没有开始一样。如果崩溃发生在操作提交之后，那么恢复代码会重新执行写操作，可能会重复执行之前的写操作。不管是哪种情况，日志都会使写与崩溃为原子的，即恢复后，所有操作的写入内容，要么都在磁盘上，要么都不在。&#x3D;&#x3D;</p>
<p>:rabbit:日志的设计方案</p>
<p>日志驻留在超级块中指定的已知固定位置。它由一个头块（header block）和一系列更新块的副本（logged block）组成。<code>头块包含一个扇区号数组（每个logged block对应一个扇区号）以及日志块的计数。磁盘上的头块中的计数或者为零，表示日志中没有事务；或者为非零，表示日志包含一个完整的已提交事务，并具有指定数量的logged block。</code>在事务提交（commit）时xv6才向头块写入数据，在此之前不会写入，并在将logged blocks复制到文件系统后将计数设置为零。&#x3D;&#x3D;因此，事务中途崩溃将导致日志头块中的计数为零；提交后的崩溃将导致非零计数。&#x3D;&#x3D;</p>
<blockquote>
<p>注：logged block表示已经记录了操作信息的日志块，而log block仅表示日志块</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXOPBLOCKS  10  <span class="comment">// max # of blocks any FS op writes</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOGSIZE (MAXOPBLOCKS*3) <span class="comment">// max data blocks in on-disk log磁盘日志块最大数量</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Contents of the header block, used for both the on-disk header block</span></span><br><span class="line"><span class="comment">// and to keep track in memory of logged block# before commit.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">logheader</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line">  <span class="type">int</span> block[LOGSIZE];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">log</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">  <span class="type">int</span> start;</span><br><span class="line">  <span class="type">int</span> size;</span><br><span class="line">  <span class="type">int</span> outstanding; <span class="comment">// how many FS sys calls are executing.活跃的文件系统调用数，操作的磁盘日志块数默认最大是MAXOPBLOCKS，事务结束时实际写入日志块数就是确定的</span></span><br><span class="line">  <span class="type">int</span> committing;  <span class="comment">// in commit(), please wait.</span></span><br><span class="line">  <span class="type">int</span> dev;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">logheader</span> <span class="title">lh</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">log</span> <span class="title">log</span>;</span></span><br></pre></td></tr></table></figure>

<p>为了应对崩溃，每个系统调用都包含一个原子写序列。为了允许不同进程并发执行文件系统操作，日志系统可以将多个系统调用的写操作累积到一个事务中。<code>因此，一次提交可能涉及多个完整系统调用的写入。为了避免一个系统调用被分裂到不同的事务中，只有在没有文件系统相关的系统调用正在进行时，日志系统才会提交。</code></p>
<p>将几个事务一起提交的方法被称为组提交（group commit）。组提交可以减少磁盘操作的次数，因为它将提交的固定成本分摊在了多个操作上。组提交可以让文件系统同时执行更多的并发写，也可以让磁盘在一次磁盘轮转中把它们全部写入。xv6 的 virtio 驱动不支持这种批处理，但 xv6 的文件系统实现了这种方式。</p>
<p>&#x3D;&#x3D;xv6 在磁盘上划出固定的空间来存放日志。在一个事务中，系统调用所写的块总数必须适应这个空间的大小。&#x3D;&#x3D;这将导致两个后果：</p>
<p>1、<code>系统调用写入的日志大小必须小于日志空间的大小。</code>这对大多数系统调用来说都不是问题，但有两个系统调用可能会写很多块，write 和 unlink。大文件的 write 可能会写很多数据块和 bitmap 块，以及一个 inode 块；取消链接一个大文件可能会写很多 bitmap 块和一个 inode。xv6 的 write 系统调用将大的写操作分解成多个小的写操作，以适应在日志空间的大小，而 unlink 不会引起问题，因为 xv6 文件系统只使用一个位图块。</p>
<p>2、<code>日志空间有限的另一个后果是，日志系统只会在确定了系统调用的写操作可以适应剩余日志空间之后，才会开始执行该系统调用。</code></p>
<p>系统调用中一般用法如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">begin_op();</span><br><span class="line">...</span><br><span class="line">bp = bread(...);</span><br><span class="line">bp-&gt;data[...] = ...;</span><br><span class="line">log_write(bp);</span><br><span class="line">...</span><br><span class="line">end_op();</span><br></pre></td></tr></table></figure>

<p><code>begin_op会一直等到日志系统没有commiting，并且有足够的日志空间来容纳这次调用的写。</code>log.outstanding统计当前系统调用的数量，可以通过log.outstanding 乘以MAXOPBLOCKS来计算已使用的日志空间。&#x3D;&#x3D;自增 log.outstanding 既能预留空间，又能防止该系统调用期间进行提交。该代码假设每次系统调用最多写入MAXOPBLOCKS个块。&#x3D;&#x3D;</p>
<p><code>begin_op</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// called at the start of each FS system call.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">begin_op</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  acquire(&amp;<span class="built_in">log</span>.lock);</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="comment">// 会一直等到日志系统没有 commiting</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">log</span>.committing)&#123;</span><br><span class="line">      sleep(&amp;<span class="built_in">log</span>, &amp;<span class="built_in">log</span>.lock);</span><br><span class="line">    <span class="comment">// 并且有足够的日志空间来容纳这次调用的写，活跃中的文件系统使用的日志空间默认为最大值MAXOPBLOCKS，比较悲观和宽泛，实际可能比这要小得多</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">log</span>.lh.n + (<span class="built_in">log</span>.outstanding+<span class="number">1</span>)*MAXOPBLOCKS &gt; LOGSIZE)&#123;</span><br><span class="line">      <span class="comment">// this op might exhaust log space; wait for commit.</span></span><br><span class="line">      sleep(&amp;<span class="built_in">log</span>, &amp;<span class="built_in">log</span>.lock);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// log.outstanding 统计当前系统调用的数量 ，可以通过log.outstanding 乘以 MAXOPBLOCKS 来计算已使用的日志空间。</span></span><br><span class="line">      <span class="comment">// 自增log.outstanding 既预留空间，又能防止该系统调用期间进行提交。该代码假设每次系统调用最多写入MAXOPBLOCKS个块</span></span><br><span class="line">      <span class="built_in">log</span>.outstanding += <span class="number">1</span>;</span><br><span class="line">      release(&amp;<span class="built_in">log</span>.lock);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>log_write是 bwrite 的代理。它将扇区号记录在内存中，在磁盘上的日志中使用一个槽，并自增buffer.refcnt 防止该 buffer 被重用。</code>在提交之前，块必须留在缓存中，即该缓存的副本是修改的唯一记录；在提交之后才能将其写入磁盘上的位置；该次修改必须对其他读可见。 注意，当一个块在一个事务中被多次写入时，他们在日志中的槽是相同的。这种优化通常被称为 absorption(吸收)。例如，在一个事务中，包含多个文件的多个 inode 的磁盘块被写多次，这是常见的情况。<code>通过将几次磁盘写吸收为一次，文件系统可以节省日志空间，并且可以获得更好的性能，因为只有一份磁盘块的副本必须写入磁盘。</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Caller has modified b-&gt;data and is done with the buffer.</span></span><br><span class="line"><span class="comment">// Record the block number and pin in the cache by increasing refcnt.</span></span><br><span class="line"><span class="comment">// commit()/write_log() will do the disk write.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// log_write() replaces bwrite(); a typical use is:</span></span><br><span class="line"><span class="comment">//   bp = bread(...)</span></span><br><span class="line"><span class="comment">//   modify bp-&gt;data[]</span></span><br><span class="line"><span class="comment">//   log_write(bp)</span></span><br><span class="line"><span class="comment">//   brelse(bp)</span></span><br><span class="line"><span class="comment">// 它将扇区号记录在内存中，在磁盘上的日志中使用一个槽，并自增 buffer.refcnt 防止该 buffer 被重用。</span></span><br><span class="line"><span class="comment">// 在提交之前，块必须留在缓存中，即该缓存的副本是修改的唯一记录；在提交之后才能将其写入磁盘上的位置；</span></span><br><span class="line"><span class="comment">// 该次修改必须对其他读可见</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">log_write</span><span class="params">(<span class="keyword">struct</span> buf *b)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 本次事务写入数据过多</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">log</span>.lh.n &gt;= LOGSIZE || <span class="built_in">log</span>.lh.n &gt;= <span class="built_in">log</span>.size - <span class="number">1</span>)</span><br><span class="line">    panic(<span class="string">&quot;too big a transaction&quot;</span>);</span><br><span class="line">  <span class="comment">// 活跃的文件系统调用数&gt;=1</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">log</span>.outstanding &lt; <span class="number">1</span>)</span><br><span class="line">    panic(<span class="string">&quot;log_write outside of trans&quot;</span>);</span><br><span class="line"></span><br><span class="line">  acquire(&amp;<span class="built_in">log</span>.lock);</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="built_in">log</span>.lh.n; i++) &#123;</span><br><span class="line">    <span class="comment">// 注意，当一个块在一个事务中被多次写入时，他们在日志中的槽是相同的。这种优化通常被称为 absorption(吸收)</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">log</span>.lh.block[i] == b-&gt;blockno)   <span class="comment">// log absorbtion</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">log</span>.lh.block[i] = b-&gt;blockno;</span><br><span class="line">  <span class="comment">// 日志增加一个新块</span></span><br><span class="line">  <span class="keyword">if</span> (i == <span class="built_in">log</span>.lh.n) &#123;  <span class="comment">// Add new block to log?</span></span><br><span class="line">    <span class="comment">// 自增 buffer.refcnt 防止该 buffer 被重用</span></span><br><span class="line">    <span class="comment">// 在提交之前块必须留在缓存中，即该缓存的副本是修改的唯一记录；在提交之后才能将其写入磁盘上的位置</span></span><br><span class="line">    bpin(b);</span><br><span class="line">    <span class="built_in">log</span>.lh.n++;</span><br><span class="line">  &#125;</span><br><span class="line">  release(&amp;<span class="built_in">log</span>.lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>end_op首先递减 log.outstanding。如果计数为零，则通过调用commit()来提交当前事务。</p>
<blockquote>
<p>commit 分为四个阶段：</p>
<p>1、write_log()将事务中修改的每个块从 buffer 缓存中复制到磁盘上的日志槽中。</p>
<p>2、write_head()将 header 块写到磁盘上，就表明已提交，为提交点，写完日志后的崩溃，会导致在重启后重新执行日志。</p>
<p>3、install_trans从日志中读取每个块，并将其写到文件系统中对应的位置。</p>
<p>4、最后修改日志块计数为 0，并写入日志空间的 header 部分。这必须在下一个事务开始之前修改，这样崩溃就不会导致重启后的恢复使用这次的 header 和下次的日志块。</p>
</blockquote>
<p><code>end_op</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// called at the end of each FS system call.</span></span><br><span class="line"><span class="comment">// commits if this was the last outstanding operation.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">end_op</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> do_commit = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  acquire(&amp;<span class="built_in">log</span>.lock);</span><br><span class="line">  <span class="comment">// 文件系统调用结束，因此log.outstanding--</span></span><br><span class="line">  <span class="built_in">log</span>.outstanding -= <span class="number">1</span>;</span><br><span class="line">  <span class="comment">// 此时不可能是事务提交状态</span></span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">log</span>.committing)</span><br><span class="line">    panic(<span class="string">&quot;log.committing&quot;</span>);</span><br><span class="line">  <span class="comment">// 最后一个文件系统调用，允许事务提交</span></span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">log</span>.outstanding == <span class="number">0</span>)&#123;</span><br><span class="line">    do_commit = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">log</span>.committing = <span class="number">1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// begin_op() may be waiting for log space,</span></span><br><span class="line">    <span class="comment">// and decrementing log.outstanding has decreased</span></span><br><span class="line">    <span class="comment">// the amount of reserved space.</span></span><br><span class="line">    <span class="comment">// 此时事务还不能提交，尝试唤醒其他休眠的事务(因为预留空间不够而休眠)</span></span><br><span class="line">    wakeup(&amp;<span class="built_in">log</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  release(&amp;<span class="built_in">log</span>.lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(do_commit)&#123;</span><br><span class="line">    <span class="comment">// call commit w/o holding locks, since not allowed</span></span><br><span class="line">    <span class="comment">// to sleep with locks.</span></span><br><span class="line">    <span class="comment">// 提交事务，完成文件系统调用的整体原子操作</span></span><br><span class="line">    commit();</span><br><span class="line">    <span class="comment">// 重置log.committing=0</span></span><br><span class="line">    acquire(&amp;<span class="built_in">log</span>.lock);</span><br><span class="line">    <span class="built_in">log</span>.committing = <span class="number">0</span>;</span><br><span class="line">    wakeup(&amp;<span class="built_in">log</span>);</span><br><span class="line">    release(&amp;<span class="built_in">log</span>.lock);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>commit四部曲</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">commit</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">log</span>.lh.n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// write_log()将事务中修改的每个块从 buffer 缓存中复制到磁盘上的日志槽中。</span></span><br><span class="line">    write_log();     <span class="comment">// Write modified blocks from cache to log</span></span><br><span class="line">    <span class="comment">// write_head()将 header块写到磁盘上就表明已提交，为提交点，写完日志后的崩溃，会导致在重启后重新执行日志。</span></span><br><span class="line">    write_head();    <span class="comment">// Write header to disk -- the real commit</span></span><br><span class="line">    <span class="comment">// install_trans从日志中读取每个块，并将其写到文件系统中对应的位置。</span></span><br><span class="line">    install_trans(); <span class="comment">// Now install writes to home locations</span></span><br><span class="line">    <span class="comment">// 最后修改日志块计数为 0，并写入日志空间的 header部分。这必须在下一个事务开始之前修改，这样崩溃就不会导致重启后的恢复使用这次的 header 和下次的日志块</span></span><br><span class="line">    <span class="built_in">log</span>.lh.n = <span class="number">0</span>;</span><br><span class="line">    write_head();    <span class="comment">// Erase the transaction from the log</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>write_log</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Copy modified blocks from cache to log.</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">write_log</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> tail;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (tail = <span class="number">0</span>; tail &lt; <span class="built_in">log</span>.lh.n; tail++) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">to</span> =</span> bread(<span class="built_in">log</span>.dev, <span class="built_in">log</span>.start+tail+<span class="number">1</span>); <span class="comment">// log block</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">from</span> =</span> bread(<span class="built_in">log</span>.dev, <span class="built_in">log</span>.lh.block[tail]); <span class="comment">// cache block</span></span><br><span class="line">    memmove(to-&gt;data, from-&gt;data, BSIZE);</span><br><span class="line">    bwrite(to);  <span class="comment">// write the log</span></span><br><span class="line">    brelse(from);</span><br><span class="line">    brelse(to);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>需要注意一点：磁盘的日志区第一块是logheader使用的，后面才供事务的数据缓存使用。</p>
</blockquote>
<p><code>write_head</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Write in-memory log header to disk.</span></span><br><span class="line"><span class="comment">// This is the true point at which the</span></span><br><span class="line"><span class="comment">// current transaction commits.</span></span><br><span class="line"><span class="comment">// 内存中的日志头写入磁盘，真正的事务提交点</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">write_head</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">buf</span> =</span> bread(<span class="built_in">log</span>.dev, <span class="built_in">log</span>.start);</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">logheader</span> *<span class="title">hb</span> =</span> (<span class="keyword">struct</span> logheader *) (buf-&gt;data);</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  hb-&gt;n = <span class="built_in">log</span>.lh.n;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="built_in">log</span>.lh.n; i++) &#123;</span><br><span class="line">    hb-&gt;block[i] = <span class="built_in">log</span>.lh.block[i];</span><br><span class="line">  &#125;</span><br><span class="line">  bwrite(buf);</span><br><span class="line">  brelse(buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>install_trans</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Copy committed blocks from log to their home location</span></span><br><span class="line"><span class="comment">// 日志块中的数据写入磁盘相应正确的位置</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">install_trans</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> tail;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (tail = <span class="number">0</span>; tail &lt; <span class="built_in">log</span>.lh.n; tail++) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">lbuf</span> =</span> bread(<span class="built_in">log</span>.dev, <span class="built_in">log</span>.start+tail+<span class="number">1</span>); <span class="comment">// read log block</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">dbuf</span> =</span> bread(<span class="built_in">log</span>.dev, <span class="built_in">log</span>.lh.block[tail]); <span class="comment">// read dst</span></span><br><span class="line">    memmove(dbuf-&gt;data, lbuf-&gt;data, BSIZE);  <span class="comment">// copy block to dst</span></span><br><span class="line">    bwrite(dbuf);  <span class="comment">// write dst to disk</span></span><br><span class="line">    <span class="comment">// log_write()时曾经调用bpin(buf)保证缓冲区不会被重用，现在使用完buf可以回收释放了</span></span><br><span class="line">    bunpin(dbuf);</span><br><span class="line">    brelse(lbuf);</span><br><span class="line">    brelse(dbuf);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>recover_from_log是在initlog中调用的，而initlog是在第一个用户进程运行之前, 由fsinit调用的。它读取日志头，如果日志头显示日志中包含一个已提交的事务，则会像end_op那样执行日志。</code></p>
<p>一个使用了日志的例子是 filewrite。这个事务看起来像这样：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">begin_op();</span><br><span class="line">ilock(f-&gt;ip);</span><br><span class="line">r = writei(f-&gt;ip, ...);</span><br><span class="line">iunlock(f-&gt;ip);</span><br><span class="line">end_op();</span><br></pre></td></tr></table></figure>

<p><code>这段代码被包裹在一个循环中，它将大的写分解成每次只有几个扇区的单独事务，以避免溢出日志空间。</code>调用writei写入许多块作为这个事务的一部分：文件的 inode，一个或多个 bitmap 块，以及一些数据块。</p>
<p><code>initlog</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">initlog</span><span class="params">(<span class="type">int</span> dev, <span class="keyword">struct</span> superblock *sb)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 日志头占一块大小</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">sizeof</span>(<span class="keyword">struct</span> logheader) &gt;= BSIZE)</span><br><span class="line">    panic(<span class="string">&quot;initlog: too big logheader&quot;</span>);</span><br><span class="line"></span><br><span class="line">  initlock(&amp;<span class="built_in">log</span>.lock, <span class="string">&quot;log&quot;</span>);</span><br><span class="line">  <span class="built_in">log</span>.start = sb-&gt;logstart;</span><br><span class="line">  <span class="built_in">log</span>.size = sb-&gt;nlog;</span><br><span class="line">  <span class="built_in">log</span>.dev = dev;</span><br><span class="line">  <span class="comment">// 崩溃恢复</span></span><br><span class="line">  recover_from_log();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>recover_from_log</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 它读取日志头，如果日志头显示日志中包含一个已提交的事务，则会像 end_op 那样执行日志。</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">recover_from_log</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  read_head();</span><br><span class="line">  install_trans(); <span class="comment">// if committed, copy from log to disk</span></span><br><span class="line">  <span class="built_in">log</span>.lh.n = <span class="number">0</span>;</span><br><span class="line">  write_head(); <span class="comment">// clear the log</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>read_head</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Read the log header from disk into the in-memory log header</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">read_head</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">buf</span> =</span> bread(<span class="built_in">log</span>.dev, <span class="built_in">log</span>.start);</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">logheader</span> *<span class="title">lh</span> =</span> (<span class="keyword">struct</span> logheader *) (buf-&gt;data);</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="built_in">log</span>.lh.n = lh-&gt;n;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="built_in">log</span>.lh.n; i++) &#123;</span><br><span class="line">    <span class="built_in">log</span>.lh.block[i] = lh-&gt;block[i];</span><br><span class="line">  &#125;</span><br><span class="line">  brelse(buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="8-4块分配器"><a href="#8-4块分配器" class="headerlink" title="8.4块分配器"></a>8.4块分配器</h4><p><code>文件和目录存储在磁盘块中，必须从空闲池中分配，xv6的块分配器在磁盘上维护一个bitmap，每个块对应一个位。0表示对应的块是空闲的，1表示正在使用中。程序mkfs设置引导扇区、超级块、日志块、inode块和位图块对应的位。</code></p>
<p>块分配器提供了两个函数：balloc 申请一个新的磁盘块，bfree 释放一个块。balloc会有一个循环遍历每一个块，从块 0 开始，直到 sb.size，即文件系统中的块数。它寻找一个位为 0 的空闲块。如果 balloc 找到了这样一个块，它就会更新 bitmap 并返回该块。为了提高效率，这个循环被分成两部分。外循环读取 bitmap 的一个块，内循环检查块中的所有 BPB 位。如果两个进程同时试图分配一个块，可能会发生竞争，但buffer缓存只允许块同时被一个进程访问，这就避免了这种情况的发生。</p>
<p>bfree找到相应的 bitmap 块并清除相应的位。bread 和 brelse 暗含的独占性避免了显式锁定。</p>
<p><code>文件系统的初始化</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// File system implementation.  Five layers:</span></span><br><span class="line"><span class="comment">//   + Blocks: allocator for raw disk blocks.</span></span><br><span class="line"><span class="comment">//   + Log: crash recovery for multi-step updates.</span></span><br><span class="line"><span class="comment">//   + Files: inode allocator, reading, writing, metadata.</span></span><br><span class="line"><span class="comment">//   + Directories: inode with special contents (list of other inodes!)</span></span><br><span class="line"><span class="comment">//   + Names: paths like /usr/rtm/xv6/fs.c for convenient naming.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// This file contains the low-level file system manipulation</span></span><br><span class="line"><span class="comment">// routines.  The (higher-level) system call implementations</span></span><br><span class="line"><span class="comment">// are in sysfile.c.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// there should be one superblock per disk device, but we run with</span></span><br><span class="line"><span class="comment">// only one device</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">superblock</span> <span class="title">sb</span>;</span> </span><br><span class="line"><span class="comment">// Read the super block.</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">readsb</span><span class="params">(<span class="type">int</span> dev, <span class="keyword">struct</span> superblock *sb)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">bp</span>;</span></span><br><span class="line">  <span class="comment">// 块1是超级块</span></span><br><span class="line">  bp = bread(dev, <span class="number">1</span>);</span><br><span class="line">  memmove(sb, bp-&gt;data, <span class="keyword">sizeof</span>(*sb));</span><br><span class="line">  brelse(bp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Init fs</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">fsinit</span><span class="params">(<span class="type">int</span> dev)</span> &#123;</span><br><span class="line">  readsb(dev, &amp;sb);</span><br><span class="line">  <span class="keyword">if</span>(sb.magic != FSMAGIC)</span><br><span class="line">    panic(<span class="string">&quot;invalid file system&quot;</span>);</span><br><span class="line">  initlog(dev, &amp;sb);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>balloc</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Bitmap bits per block 每块的bmap比特数</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BPB           (BSIZE*8)</span></span><br><span class="line"><span class="comment">// Block of free map containing bit for block b 块b所在的bmap块号</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BBLOCK(b, sb) ((b)/BPB + sb.bmapstart)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Allocate a zeroed disk block.</span></span><br><span class="line"><span class="type">static</span> uint</span><br><span class="line"><span class="title function_">balloc</span><span class="params">(uint dev)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> b, bi, m;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">bp</span>;</span></span><br><span class="line"></span><br><span class="line">  bp = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(b = <span class="number">0</span>; b &lt; sb.size; b += BPB)&#123;</span><br><span class="line">    <span class="comment">// 外层循环遍历每一个bmap块</span></span><br><span class="line">    bp = bread(dev, BBLOCK(b, sb));</span><br><span class="line">    <span class="comment">// Bitmap上的每一个比特位表示一个数据块的状态</span></span><br><span class="line">    <span class="keyword">for</span>(bi = <span class="number">0</span>; bi &lt; BPB &amp;&amp; b + bi &lt; sb.size; bi++)&#123;</span><br><span class="line">      m = <span class="number">1</span> &lt;&lt; (bi % <span class="number">8</span>);</span><br><span class="line">      <span class="comment">// Bitmap中对应的bit位是0表示块空闲</span></span><br><span class="line">      <span class="keyword">if</span>((bp-&gt;data[bi/<span class="number">8</span>] &amp; m) == <span class="number">0</span>)&#123;  <span class="comment">// Is block free?</span></span><br><span class="line">        <span class="comment">// 块标记为已使用</span></span><br><span class="line">        bp-&gt;data[bi/<span class="number">8</span>] |= m;  <span class="comment">// Mark block in use.</span></span><br><span class="line">        log_write(bp);</span><br><span class="line">        brelse(bp);</span><br><span class="line">        bzero(dev, b + bi);</span><br><span class="line">        <span class="keyword">return</span> b + bi;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    brelse(bp);</span><br><span class="line">  &#125;</span><br><span class="line">  panic(<span class="string">&quot;balloc: out of blocks&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>bfree</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Free a disk block.</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">bfree</span><span class="params">(<span class="type">int</span> dev, uint b)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">bp</span>;</span></span><br><span class="line">  <span class="type">int</span> bi, m;</span><br><span class="line"></span><br><span class="line">  bp = bread(dev, BBLOCK(b, sb));</span><br><span class="line">  bi = b % BPB;</span><br><span class="line">  m = <span class="number">1</span> &lt;&lt; (bi % <span class="number">8</span>);</span><br><span class="line">  <span class="keyword">if</span>((bp-&gt;data[bi/<span class="number">8</span>] &amp; m) == <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;freeing free block&quot;</span>);</span><br><span class="line">  bp-&gt;data[bi/<span class="number">8</span>] &amp;= ~m;</span><br><span class="line">  log_write(bp);</span><br><span class="line">  brelse(bp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>bzero</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Zero a block.</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">bzero</span><span class="params">(<span class="type">int</span> dev, <span class="type">int</span> bno)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">bp</span>;</span></span><br><span class="line"></span><br><span class="line">  bp = bread(dev, bno);</span><br><span class="line">  <span class="built_in">memset</span>(bp-&gt;data, <span class="number">0</span>, BSIZE);</span><br><span class="line">  log_write(bp);</span><br><span class="line">  brelse(bp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="8-5Inode层"><a href="#8-5Inode层" class="headerlink" title="8.5Inode层"></a>8.5Inode层</h4><p>术语inode有两种相关的含义。<code>1、它可能指的是磁盘上的数据结构，其中包含了文件的大小和数据块号的列表；2、inode可能指的是内存中的inode，它包含了磁盘上inode的副本以及内核中需要的其他信息。</code></p>
<p>磁盘上的 inode 被放置磁盘的一个连续区域。每一个 inode 的大小都是一样的，所以，给定一个数字 n，很容易找到磁盘上的第 n 个 inode。事实上，这个数字 n，被称为 inode 号或 i-number，在实现中就是通过这个识别 inode 的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> BSIZE 1024  <span class="comment">// block size</span></span></span><br><span class="line"><span class="comment">// 一个文件关联的直接块数(12)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NDIRECT 12</span></span><br><span class="line"><span class="comment">// 一个文件关联的间接块数(1024/4=256)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NINDIRECT (BSIZE / sizeof(uint))</span></span><br><span class="line"><span class="comment">// 一个文件最大拥有的数据块数(12+256=268)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXFILE (NDIRECT + NINDIRECT)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// On-disk inode structure</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dinode</span> &#123;</span></span><br><span class="line">  <span class="type">short</span> type;           <span class="comment">// File type 文件类型：空闲/目录/文件/设备</span></span><br><span class="line">  <span class="type">short</span> major;          <span class="comment">// Major device number (T_DEVICE only) </span></span><br><span class="line">  <span class="type">short</span> minor;          <span class="comment">// Minor device number (T_DEVICE only) </span></span><br><span class="line">  <span class="comment">// 引用这个dinode的目录项数量，当nlink为0且inode的引用数也为0时就释放磁盘上的dinode及其数据块</span></span><br><span class="line">  <span class="type">short</span> nlink;          <span class="comment">// Number of links to inode in file system </span></span><br><span class="line">  uint size;            <span class="comment">// Size of file (bytes) 文件大小</span></span><br><span class="line">  <span class="comment">// addrs 数组记录了持有文件内容的磁盘块的块号</span></span><br><span class="line">  uint addrs[NDIRECT+<span class="number">1</span>];   <span class="comment">// Data block addresses </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&#x3D;&#x3D;结构体 dinode定义了磁盘上的inode。type字段区分了文件、目录和特殊文件(设备)。type为0表示该inode是空闲的。nlink字段统计引用这个inode的目录项的数量，当引用数为0时就释放磁盘上的inode及其数据块。size字段记录了文件中内容的字节数。addrs数组记录了持有文件内容的磁盘块的块号。&#x3D;&#x3D;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> major(dev)  ((dev) &gt;&gt; 16 &amp; 0xFFFF)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> minor(dev)  ((dev) &amp; 0xFFFF)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	mkdev(m,n)  ((uint)((m)&lt;&lt;16| (n)))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// in-memory copy of an inode</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode</span> &#123;</span></span><br><span class="line">  uint dev;           <span class="comment">// Device number 设备号</span></span><br><span class="line">  uint inum;          <span class="comment">// Inode number Inode编号</span></span><br><span class="line">  <span class="comment">// 指向 inode 的指针的数量，如果引用数量减少到零，icacahe就会考虑把它重新分配</span></span><br><span class="line">  <span class="type">int</span> ref;            <span class="comment">// Reference count</span></span><br><span class="line">  <span class="comment">// 保证了可以独占访问 inode 的其他字段（如文件长度）以及 inode的文件或目录内容块</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sleeplock</span> <span class="title">lock</span>;</span> <span class="comment">// protects everything below here</span></span><br><span class="line">  <span class="type">int</span> valid;          <span class="comment">// inode has been read from disk?</span></span><br><span class="line">  <span class="type">short</span> type;         <span class="comment">// copy of disk inode</span></span><br><span class="line">  <span class="type">short</span> major;</span><br><span class="line">  <span class="type">short</span> minor;</span><br><span class="line">  <span class="type">short</span> nlink;</span><br><span class="line">  uint size;</span><br><span class="line">  uint addrs[NDIRECT+<span class="number">1</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>内核将在使用的 inode 保存在内存中；结构体 inode 是磁盘 dinode 的拷贝。内核只在有指针指向inode 才会储存。<code>ref字段为指向inode的指针的数量，如果ref减少到零，内核就会从内存中丢弃这个inode。iget和iput函数引用和释放inode，并修改ref。</code>指向 inode 的指针可以来自文件描述符，当前工作目录，以及短暂的内核代码，如 exec。</p>
<p>在 xv6 的 inode 代码中，有四种锁或类似锁的机制。&#x3D;&#x3D;icache.lock 保证了一个inode在缓存只有一个副本，以及缓存 inode 的ref字段计数正确。每个内存中的inode都有一个包含sleeplock的锁字段，它保证了可以独占访问 inode 的其他字段（如文件长度）以及 inode的文件或目录内容块的。一个inode的ref如果大于0，则会使系统将该inode保留在缓存中，而不会重用该 inode。最后，每个inode都包含一个nlink字段(在磁盘上，缓存时会复制到内存中)，该字段统计链接该inode的目录项的数量；如果一个inode的链接数大于零，xv6不会释放它。&#x3D;&#x3D;</p>
<p>iget()返回的inode指针在调用iput()之前都是有效的；inode不会被删除，指针所引用的内存也不会被另一个inode重新使用。<code>iget()提供了对inode的非独占性访问，因此可以有许多指针指向同一个inode。文件系统代码中的许多部分都依赖于iget()的这种行为，既是为了保持对inode的长期引用(如打开的文件和当前目录)，也是为了防止竞争，同时避免在操作多个inode的代码中出现死锁(如路径名查找)。</code></p>
<p>iget在inode缓存中寻找一个带有所需设备号和inode号的active条目 (ip-&gt;ref &gt; 0)。如果它找到了，它就返回一个新的对该inode的引用。当iget扫描时，它会记录第一个空槽的位置 ，当它需要分配一个缓存条目时，它会使用这个空槽。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Find the inode with number inum on device dev</span></span><br><span class="line"><span class="comment">// and return the in-memory copy. Does not lock</span></span><br><span class="line"><span class="comment">// the inode and does not read it from disk.</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> inode*</span><br><span class="line"><span class="title function_">iget</span><span class="params">(uint dev, uint inum)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">ip</span>, *<span class="title">empty</span>;</span></span><br><span class="line">  <span class="comment">// 获得整个icache锁</span></span><br><span class="line">  acquire(&amp;icache.lock);</span><br><span class="line">  <span class="comment">// Is the inode already cached?</span></span><br><span class="line">  <span class="comment">// 如果inode已被缓存则直接返回，否则记录下icache中空闲项</span></span><br><span class="line">  empty = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(ip = &amp;icache.inode[<span class="number">0</span>]; ip &lt; &amp;icache.inode[NINODE]; ip++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(ip-&gt;ref &gt; <span class="number">0</span> &amp;&amp; ip-&gt;dev == dev &amp;&amp; ip-&gt;inum == inum)&#123;</span><br><span class="line">      ip-&gt;ref++;</span><br><span class="line">      release(&amp;icache.lock);</span><br><span class="line">      <span class="keyword">return</span> ip;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(empty == <span class="number">0</span> &amp;&amp; ip-&gt;ref == <span class="number">0</span>)    <span class="comment">// Remember empty slot.</span></span><br><span class="line">      empty = ip;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 回收一个icache项</span></span><br><span class="line">  <span class="keyword">if</span>(empty == <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;iget: no inodes&quot;</span>);</span><br><span class="line">  <span class="comment">// 使用icache的空闲项</span></span><br><span class="line">  ip = empty;</span><br><span class="line">  ip-&gt;dev = dev;</span><br><span class="line">  ip-&gt;inum = inum;</span><br><span class="line">  ip-&gt;ref = <span class="number">1</span>;</span><br><span class="line">  <span class="comment">// 空inode项必须从磁盘上读取内容</span></span><br><span class="line">  ip-&gt;valid = <span class="number">0</span>;</span><br><span class="line">  release(&amp;icache.lock);</span><br><span class="line">  <span class="keyword">return</span> ip;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>inode缓存只缓存被指针指向的inode。它的主要工作其实是同步多个进程的访问，缓存是次要的。</code>如果一个 inode 被频繁使用，如果不被 inode 缓存保存，buffer 缓存可能会把它保存在内存中。<code>inode缓存是write-through的，这意味着缓存的inode被修改，就必须立即用iupdate把它写入磁盘。</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="comment">// icache.lock 保证了一个 inode 在缓存只有一个副本，以及缓存 inode 的 ref 字段计数正确</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> <span class="title">inode</span>[<span class="title">NINODE</span>];</span></span><br><span class="line">&#125; icache;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">iinit</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  initlock(&amp;icache.lock, <span class="string">&quot;icache&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; NINODE; i++) &#123;</span><br><span class="line">    initsleeplock(&amp;icache.inode[i].lock, <span class="string">&quot;inode&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要创建一个新的 inode(例如，当创建一个文件时)，xv6 会调用 ialloc。ialloc 类似于 balloc：它遍历磁盘上的 inode ，寻找一个被标记为空闲的 inode。当它找到后，它会修改该 inode 的 type 字段来使用它，最后调用 iget  来从 inode 缓存中返回一个条目。&#x3D;&#x3D;由于一次只能有一个进程持有对 bp 的引用，所以 ialloc 可以正确执行。ialloc 可以确保其他进程不会同时看到 inode 是可用的并使用它。&#x3D;&#x3D;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Inodes per block. 一个块的inode数量</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IPB           (BSIZE / sizeof(struct dinode))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Allocate an inode on device dev.</span></span><br><span class="line"><span class="comment">// Mark it as allocated by giving it type type.</span></span><br><span class="line"><span class="comment">// Returns an unlocked but allocated and referenced inode.</span></span><br><span class="line"><span class="comment">// 分配设备(磁盘)上的一个dinode，类型标记为type</span></span><br><span class="line"><span class="keyword">struct</span> inode*</span><br><span class="line"><span class="title function_">ialloc</span><span class="params">(uint dev, <span class="type">short</span> type)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> inum;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">bp</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">dinode</span> *<span class="title">dip</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(inum = <span class="number">1</span>; inum &lt; sb.ninodes; inum++)&#123;</span><br><span class="line">    <span class="comment">// 由于一次只能有一个进程持有对 bp 的引用，所以 ialloc 可以正确执行。</span></span><br><span class="line">    <span class="comment">// ialloc 可以确保其他进程不会同时看到 inode 是可用的并使用它。</span></span><br><span class="line">    <span class="comment">// 第一次需要磁盘读，后面都是直接从块缓存中拿</span></span><br><span class="line">    bp = bread(dev, IBLOCK(inum, sb));</span><br><span class="line">    <span class="comment">// 具体的dinode</span></span><br><span class="line">    dip = (<span class="keyword">struct</span> dinode*)bp-&gt;data + inum%IPB;</span><br><span class="line">    <span class="comment">// 空闲的dinode分配使用</span></span><br><span class="line">    <span class="keyword">if</span>(dip-&gt;type == <span class="number">0</span>)&#123;  <span class="comment">// a free inode</span></span><br><span class="line">      <span class="built_in">memset</span>(dip, <span class="number">0</span>, <span class="keyword">sizeof</span>(*dip));</span><br><span class="line">      dip-&gt;type = type;</span><br><span class="line">      log_write(bp);   <span class="comment">// mark it allocated on the disk</span></span><br><span class="line">      brelse(bp);</span><br><span class="line">      <span class="keyword">return</span> iget(dev, inum);</span><br><span class="line">    &#125;</span><br><span class="line">    brelse(bp);</span><br><span class="line">  &#125;</span><br><span class="line">  panic(<span class="string">&quot;ialloc: no inodes&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>在读写inode的元数据或内容之前，代码必须使用ilock锁定它。</code>ilock使用sleeplock内部有一个睡眠锁来锁定。<code>一旦ilock锁定了inode，它就会根据自己的需要从磁盘（更有可能是inode缓存）读取inode。</code>函数 iunlock释放睡眠锁，这会唤醒正在等待该睡眠锁的进程。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Lock the given inode.</span></span><br><span class="line"><span class="comment">// Reads the inode from disk if necessary.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">ilock</span><span class="params">(<span class="keyword">struct</span> inode *ip)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">bp</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">dinode</span> *<span class="title">dip</span>;</span></span><br><span class="line">  <span class="comment">// 合法性检查</span></span><br><span class="line">  <span class="keyword">if</span>(ip == <span class="number">0</span> || ip-&gt;ref &lt; <span class="number">1</span>)</span><br><span class="line">    panic(<span class="string">&quot;ilock&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// inode加睡眠锁</span></span><br><span class="line">  acquiresleep(&amp;ip-&gt;lock);</span><br><span class="line">  <span class="comment">// inode无效需要从磁盘上重新读取</span></span><br><span class="line">  <span class="keyword">if</span>(ip-&gt;valid == <span class="number">0</span>)&#123;</span><br><span class="line">    bp = bread(ip-&gt;dev, IBLOCK(ip-&gt;inum, sb));</span><br><span class="line">    <span class="comment">// 磁盘上的相关数据结构是dinode</span></span><br><span class="line">    dip = (<span class="keyword">struct</span> dinode*)bp-&gt;data + ip-&gt;inum%IPB;</span><br><span class="line">    ip-&gt;type = dip-&gt;type;</span><br><span class="line">    ip-&gt;major = dip-&gt;major;</span><br><span class="line">    ip-&gt;minor = dip-&gt;minor;</span><br><span class="line">    ip-&gt;nlink = dip-&gt;nlink;</span><br><span class="line">    ip-&gt;size = dip-&gt;size;</span><br><span class="line">    memmove(ip-&gt;addrs, dip-&gt;addrs, <span class="keyword">sizeof</span>(ip-&gt;addrs));</span><br><span class="line">    brelse(bp);</span><br><span class="line">    <span class="comment">// valid有效位置一</span></span><br><span class="line">    ip-&gt;valid = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(ip-&gt;type == <span class="number">0</span>)</span><br><span class="line">      panic(<span class="string">&quot;ilock: no type&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Unlock the given inode.</span></span><br><span class="line"><span class="comment">// 给指定的inode解锁</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">iunlock</span><span class="params">(<span class="keyword">struct</span> inode *ip)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(ip == <span class="number">0</span> || !holdingsleep(&amp;ip-&gt;lock) || ip-&gt;ref &lt; <span class="number">1</span>)</span><br><span class="line">    panic(<span class="string">&quot;iunlock&quot;</span>);</span><br><span class="line"></span><br><span class="line">  releasesleep(&amp;ip-&gt;lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>iput通过递减引用次数释放指向inode的指针。如果递减后的引用数为0，inode缓存中就会释放掉该 inode在inode缓存中的槽位，该槽位就可以被其他inode使用。</code></p>
<p>&#x3D;&#x3D;如果 iput 发现没有指针指向该 inode，并且没有任何目录项链接该 inode（不在任何目录中出现），那么该 inode 和它的数据块必须被释放。Iput 调用 itrunc 将文件截断为零字节，释放数据块；将 inode 类型设置为 0（未分配）；并将 inode 写入磁盘。&#x3D;&#x3D;</p>
<blockquote>
<p>iput 在释放 inode 的锁定协议是值得我们仔细研究。一个危险是，一个并发线程可能会在 ilock 中等待使用这个 inode(例如，读取一个文件或列出一个目录)，但它没有意识到该inode 可能被释放掉了。这种情况是不会发生，因为该 inode 的没有被目录项链接且 ip-&gt;ref为 1，那么系统调用是没有这个指针的（如果有，ip-&gt;ref 应该为 2）。这一个引用是调用 iput 的线程所拥有的。的确，iput 会在其 icache.lock 锁定的临界区之外检查引用数是否为 1，但此时已知链接数为 0，所以没有线程会尝试获取新的引用。另一个主要的危险是，并发调用 ialloc 可能会使 iput 返回一个正在被释放的 inode。这种情况发生在 iupdate 写磁盘时ip-&gt;type&#x3D;0。这种竞争是正常的，分配 inode 的线程会等待获取 inode 的睡眠锁，然后再读取或写入 inode，但此时 iput 就结束了。</p>
</blockquote>
<p><code>iput</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Drop a reference to an in-memory inode.</span></span><br><span class="line"><span class="comment">// If that was the last reference, the inode cache entry can</span></span><br><span class="line"><span class="comment">// be recycled.</span></span><br><span class="line"><span class="comment">// If that was the last reference and the inode has no links</span></span><br><span class="line"><span class="comment">// to it, free the inode (and its content) on disk.</span></span><br><span class="line"><span class="comment">// All calls to iput() must be inside a transaction in</span></span><br><span class="line"><span class="comment">// case it has to free the inode.</span></span><br><span class="line"><span class="comment">// 撤销一个inode的ref引用</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">iput</span><span class="params">(<span class="keyword">struct</span> inode *ip)</span></span><br><span class="line">&#123;</span><br><span class="line">  acquire(&amp;icache.lock);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// inode has no links and no other references: truncate and free.</span></span><br><span class="line">  <span class="keyword">if</span>(ip-&gt;ref == <span class="number">1</span> &amp;&amp; ip-&gt;valid &amp;&amp; ip-&gt;nlink == <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">// ip-&gt;ref == 1 means no other process can have ip locked,</span></span><br><span class="line">    <span class="comment">// so this acquiresleep() won&#x27;t block (or deadlock).</span></span><br><span class="line">    acquiresleep(&amp;ip-&gt;lock);</span><br><span class="line">    release(&amp;icache.lock);</span><br><span class="line">    <span class="comment">// 调用 itrunc 将文件截断为零字节，释放数据块</span></span><br><span class="line">    itrunc(ip);</span><br><span class="line">    <span class="comment">// 将 inode 类型设置为 0（未分配），并将 inode 写入磁盘</span></span><br><span class="line">    ip-&gt;type = <span class="number">0</span>;</span><br><span class="line">    iupdate(ip);</span><br><span class="line">    ip-&gt;valid = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    releasesleep(&amp;ip-&gt;lock);</span><br><span class="line">    acquire(&amp;icache.lock);</span><br><span class="line">  &#125;</span><br><span class="line">  ip-&gt;ref--;</span><br><span class="line">  release(&amp;icache.lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>itrunc 释放文件的块，将 inode 的大小重置为零。itrunc首先释放直接块，然后释放间接块中指向的块，最后释放间接块本身。</p>
</blockquote>
<p><code>itrunc</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Truncate inode (discard contents).</span></span><br><span class="line"><span class="comment">// Caller must hold ip-&gt;lock.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">itrunc</span><span class="params">(<span class="keyword">struct</span> inode *ip)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i, j;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">bp</span>;</span></span><br><span class="line">  uint *a;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 释放文件的直接关联块</span></span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; NDIRECT; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(ip-&gt;addrs[i])&#123;</span><br><span class="line">      bfree(ip-&gt;dev, ip-&gt;addrs[i]);</span><br><span class="line">      ip-&gt;addrs[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 释放文件的间接关联块</span></span><br><span class="line">  <span class="keyword">if</span>(ip-&gt;addrs[NDIRECT])&#123;</span><br><span class="line">    bp = bread(ip-&gt;dev, ip-&gt;addrs[NDIRECT]);</span><br><span class="line">    a = (uint*)bp-&gt;data;</span><br><span class="line">    <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; NINDIRECT; j++)&#123;</span><br><span class="line">      <span class="comment">// 释放文件的间接关联块</span></span><br><span class="line">      <span class="keyword">if</span>(a[j])</span><br><span class="line">        bfree(ip-&gt;dev, a[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    brelse(bp);</span><br><span class="line">    <span class="comment">// 释放存放间接块号的块</span></span><br><span class="line">    bfree(ip-&gt;dev, ip-&gt;addrs[NDIRECT]);</span><br><span class="line">    ip-&gt;addrs[NDIRECT] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 文件截断后更新信息完毕，写回磁盘</span></span><br><span class="line">  ip-&gt;size = <span class="number">0</span>;</span><br><span class="line">  iupdate(ip);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>iupdate</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Copy a modified in-memory inode to disk.</span></span><br><span class="line"><span class="comment">// Must be called after every change to an ip-&gt;xxx field</span></span><br><span class="line"><span class="comment">// that lives on disk, since i-node cache is write-through.</span></span><br><span class="line"><span class="comment">// Caller must hold ip-&gt;lock.</span></span><br><span class="line"><span class="comment">// Inode缓存是直写的，修改了inode后需要写回磁盘上的dinode</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">iupdate</span><span class="params">(<span class="keyword">struct</span> inode *ip)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">bp</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">dinode</span> *<span class="title">dip</span>;</span></span><br><span class="line"></span><br><span class="line">  bp = bread(ip-&gt;dev, IBLOCK(ip-&gt;inum, sb));</span><br><span class="line">  dip = (<span class="keyword">struct</span> dinode*)bp-&gt;data + ip-&gt;inum%IPB;</span><br><span class="line">  dip-&gt;type = ip-&gt;type;</span><br><span class="line">  dip-&gt;major = ip-&gt;major;</span><br><span class="line">  dip-&gt;minor = ip-&gt;minor;</span><br><span class="line">  dip-&gt;nlink = ip-&gt;nlink;</span><br><span class="line">  dip-&gt;size = ip-&gt;size;</span><br><span class="line">  memmove(dip-&gt;addrs, ip-&gt;addrs, <span class="keyword">sizeof</span>(ip-&gt;addrs));</span><br><span class="line">  log_write(bp);</span><br><span class="line">  brelse(bp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>iput()会写磁盘。这意味着任何使用文件系统的系统调用都会写磁盘，因为系统调用可能是最后一个对文件有引用的调用。甚至像 read()这样看似只读的调用，最终也可能会调用iput()。这又意味着，即使是只读的系统调用，如果使用了文件系统，也必须用事务来包装。</p>
</blockquote>
<p>崩溃发生在 iput中是相当棘手的。<code>当文件的链接数降到零时，iput()不会立即截断一个文件，因为一些进程可能仍然在内存中持有对inode的引用：一个进程可能仍然在对文件进行读写，因为它成功地打开了inode。但是，如果崩溃发生在该文件的最后一个文件描述符释放时，那么该文件将被标记为已在磁盘上分配，但没有目录项指向它。</code></p>
<p>文件系统处理这种情况的方法有两种。简单的解决方法是，是在重启后的恢复时，文件系统会扫描整个文件系统，寻找那些被标记为已分配的文件，但没有指向它们的目录项。如果有这样的文件存在，那么就可以释放这些文件。</p>
<p>第二种解决方案不需要扫描文件系统。在这个解决方案中，文件系统在磁盘上（例如，在 superblock 中）记录链接数为 0 但引用数不为 0 的文件的 inode 的 inumber，文件系统在其引用计数达到 0 时删除该文件 ，同时它更新磁盘上的列表，从列表中删除该 inode。恢复时，文件系统会释放列表中的任何文件</p>
<p>&#x3D;&#x3D;xv6 没有实现这两种解决方案，这意味着 inode 可能会在磁盘上被标记分配，即使它们不再使用。这意味着随着时间的推移，xv6 可能会面临磁盘空间耗尽的风险。&#x3D;&#x3D;</p>
<p><img src="/../../../../../../imgs/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%BA%90%E7%A0%81%E7%BA%A7%E5%89%96%E6%9E%90/image-20221117163303777.png" alt="image-20221117163303777"></p>
<p>磁盘上的 inode，即 dinode 结构体，包含一个 size 和一个块号数组（见图 8.3）。inode数据可以在 dinode 的 addrs 数组中找到。开始的 NDIRECT 个数据块放置在数组中的前NDIRECT 个条目中，这些块被称为直接块。接下来的 NINDIRECT 个数据块并没有放置在inode中，而是被存放在叫做间接块的数据块中。addrs数组中的最后一个条目给出了放置间接块的地址。因此，一个文件的前12kB ( NDIRECT x BSIZE)字节可以从 inode 中列出的块中加载，而接下来的 256 kB ( NINDIRECT x BSIZE)字节只能在查阅间接块后才能取出。对于磁盘这是一种不错的表示方式，但对客户机就有点复杂了。<code>函数bmap是包装了这种表示方式的高层次函数以便于readi和writei可以更好的使用。bmap返回inode ip的第bn个数据块的磁盘块号。如果ip没有第bn个的数据块，bmap就会分配一个。</code></p>
<blockquote>
<p>最前面的NDIRECT个块储存在ip-&gt;addrs[0]~ip-&gt;addrs[NDIRECT-1]中，接下来的 NINDIRECT 个块放置在 ip-&gt;addrs[NDIRECT]指向的的间接块中。bmap 读取间接块，然后从块内的正确的位置读取一个块号如果块号超过了 NDIRECT+NINDIRECT，bmap 就会 panic；writei 会检查并防止这种情况。</p>
</blockquote>
<p><code>bmap</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Inode content</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The content (data) associated with each inode is stored</span></span><br><span class="line"><span class="comment">// in blocks on the disk. The first NDIRECT block numbers</span></span><br><span class="line"><span class="comment">// are listed in ip-&gt;addrs[].  The next NINDIRECT blocks are</span></span><br><span class="line"><span class="comment">// listed in block ip-&gt;addrs[NDIRECT].</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Return the disk block address of the nth block in inode ip.</span></span><br><span class="line"><span class="comment">// If there is no such block, bmap allocates one.</span></span><br><span class="line"><span class="type">static</span> uint</span><br><span class="line"><span class="title function_">bmap</span><span class="params">(<span class="keyword">struct</span> inode *ip, uint bn)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint addr, *a;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">bp</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(bn &lt; NDIRECT)&#123;</span><br><span class="line">    <span class="keyword">if</span>((addr = ip-&gt;addrs[bn]) == <span class="number">0</span>)</span><br><span class="line">      ip-&gt;addrs[bn] = addr = balloc(ip-&gt;dev);</span><br><span class="line">    <span class="keyword">return</span> addr;</span><br><span class="line">  &#125;</span><br><span class="line">  bn -= NDIRECT;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(bn &lt; NINDIRECT)&#123;</span><br><span class="line">    <span class="comment">// Load indirect block, allocating if necessary.</span></span><br><span class="line">    <span class="keyword">if</span>((addr = ip-&gt;addrs[NDIRECT]) == <span class="number">0</span>)</span><br><span class="line">      ip-&gt;addrs[NDIRECT] = addr = balloc(ip-&gt;dev);</span><br><span class="line">    bp = bread(ip-&gt;dev, addr);</span><br><span class="line">    a = (uint*)bp-&gt;data;</span><br><span class="line">    <span class="keyword">if</span>((addr = a[bn]) == <span class="number">0</span>)&#123;</span><br><span class="line">      a[bn] = addr = balloc(ip-&gt;dev);</span><br><span class="line">      log_write(bp);</span><br><span class="line">    &#125;</span><br><span class="line">    brelse(bp);</span><br><span class="line">    <span class="keyword">return</span> addr;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  panic(<span class="string">&quot;bmap: out of range&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>bmap 使 得 readi 和 writei 可以很容易地获取一个 inode 的数据。 readi首先要确定偏移量和计数没有超过文件末端。从文件超出末尾开始的读会返回一个错误，而从文件末尾开始或读取过程中超出末尾的读会不会返回错误，只是返回的字节数会少于请求的字节数。</p>
<p><code>readi</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Read data from inode.</span></span><br><span class="line"><span class="comment">// Caller must hold ip-&gt;lock.</span></span><br><span class="line"><span class="comment">// If user_dst==1, then dst is a user virtual address;</span></span><br><span class="line"><span class="comment">// otherwise, dst is a kernel address.</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">readi</span><span class="params">(<span class="keyword">struct</span> inode *ip, <span class="type">int</span> user_dst, uint64 dst, uint off, uint n)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint tot, m;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">bp</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 文件偏移量不能超过文件大小或者为负</span></span><br><span class="line">  <span class="keyword">if</span>(off &gt; ip-&gt;size || off + n &lt; off)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 不能读取超出文件大小的数据</span></span><br><span class="line">  <span class="keyword">if</span>(off + n &gt; ip-&gt;size)</span><br><span class="line">    n = ip-&gt;size - off;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 读取n字节的数据到dst地址处</span></span><br><span class="line">  <span class="keyword">for</span>(tot=<span class="number">0</span>; tot&lt;n; tot+=m, off+=m, dst+=m)&#123;</span><br><span class="line">    bp = bread(ip-&gt;dev, bmap(ip, off/BSIZE));</span><br><span class="line">    m = min(n - tot, BSIZE - off%BSIZE);</span><br><span class="line">    <span class="keyword">if</span>(either_copyout(user_dst, dst, bp-&gt;data + (off % BSIZE), m) == <span class="number">-1</span>) &#123;</span><br><span class="line">      brelse(bp);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    brelse(bp);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> tot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主循环会把文件中的每一个块的数据复制到 dst 中。writei与 readi 相同，但有2个不同：</p>
<ul>
<li>从文件末尾开始或越过文件末尾的写入会使文件增长，但不会超过文件的最大长度；</li>
<li>如果写使文件增长了，writi 必须更新它的大小。</li>
</ul>
<p><code>writei</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Write data to inode.</span></span><br><span class="line"><span class="comment">// Caller must hold ip-&gt;lock.</span></span><br><span class="line"><span class="comment">// If user_src==1, then src is a user virtual address;</span></span><br><span class="line"><span class="comment">// otherwise, src is a kernel address.</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">writei</span><span class="params">(<span class="keyword">struct</span> inode *ip, <span class="type">int</span> user_src, uint64 src, uint off, uint n)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint tot, m;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">bp</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 文件偏移量不能超过文件大小或者为负</span></span><br><span class="line">  <span class="keyword">if</span>(off &gt; ip-&gt;size || off + n &lt; off)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="comment">// 写入后文件大小不能超过允许的最大文件大小</span></span><br><span class="line">  <span class="keyword">if</span>(off + n &gt; MAXFILE*BSIZE)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 写入n字节的数据到off后面</span></span><br><span class="line">  <span class="keyword">for</span>(tot=<span class="number">0</span>; tot&lt;n; tot+=m, off+=m, src+=m)&#123;</span><br><span class="line">    bp = bread(ip-&gt;dev, bmap(ip, off/BSIZE));</span><br><span class="line">    m = min(n - tot, BSIZE - off%BSIZE);</span><br><span class="line">    <span class="keyword">if</span>(either_copyin(bp-&gt;data + (off % BSIZE), user_src, src, m) == <span class="number">-1</span>) &#123;</span><br><span class="line">      brelse(bp);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    log_write(bp);</span><br><span class="line">    brelse(bp);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(n &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(off &gt; ip-&gt;size)</span><br><span class="line">      ip-&gt;size = off;</span><br><span class="line">    <span class="comment">// write the i-node back to disk even if the size didn&#x27;t change</span></span><br><span class="line">    <span class="comment">// because the loop above might have called bmap() and added a new</span></span><br><span class="line">    <span class="comment">// block to ip-&gt;addrs[].</span></span><br><span class="line">    <span class="comment">// 更新后的inode信息写回磁盘</span></span><br><span class="line">    iupdate(ip);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>readi 和 writei 开始都会检查 ip-&gt;type &#x3D;&#x3D; T_DEV。这种情况处理的是数据不在文件系统中的特殊设备；我们将在文件描述符层中再讨论这种情况。</p>
</blockquote>
<p>函数 stati将 inode 元数据复制到 stat 结构体中，通过 stat 系统调用暴露给用户程序。</p>
<p><code>stat结构体</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> T_DIR     1   <span class="comment">// Directory</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> T_FILE    2   <span class="comment">// File</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> T_DEVICE  3   <span class="comment">// Device</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> dev;     <span class="comment">// File system&#x27;s disk device</span></span><br><span class="line">  uint ino;    <span class="comment">// Inode number</span></span><br><span class="line">  <span class="type">short</span> type;  <span class="comment">// Type of file</span></span><br><span class="line">  <span class="type">short</span> nlink; <span class="comment">// Number of links to file</span></span><br><span class="line">  uint64 size; <span class="comment">// Size of file in bytes</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>stati</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Copy stat information from inode.</span></span><br><span class="line"><span class="comment">// Caller must hold ip-&gt;lock.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">stati</span><span class="params">(<span class="keyword">struct</span> inode *ip, <span class="keyword">struct</span> stat *st)</span></span><br><span class="line">&#123;</span><br><span class="line">  st-&gt;dev = ip-&gt;dev;</span><br><span class="line">  st-&gt;ino = ip-&gt;inum;</span><br><span class="line">  st-&gt;type = ip-&gt;type;</span><br><span class="line">  st-&gt;nlink = ip-&gt;nlink;</span><br><span class="line">  st-&gt;size = ip-&gt;size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="8-6目录层"><a href="#8-6目录层" class="headerlink" title="8.6目录层"></a>8.6目录层</h4><p><code>目录的实现机制和文件很类似。它的inode类型是T_DIR，它的数据是一个目录项的序列。每个条目是一个结构体dirent，它包含一个名称和一个inode号。名称最多包含DIRSIZ(14)个字符，较短的名称以 NULL(0)结束。inode号为0的目录项是空闲的。</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Directory is a file containing a sequence of dirent structures.</span></span><br><span class="line"><span class="comment">// 目录名称的最大长度</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DIRSIZ 14</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// directory entry 目录项（inode编号+对应的文件名）</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> &#123;</span></span><br><span class="line">  ushort inum;</span><br><span class="line">  <span class="type">char</span> name[DIRSIZ];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>函数dirlookup在一个目录中搜索一个带有给定名称的条目。</code>如果找到了，它返回一个指向相应 inode 的指针，解锁该 inode，并将* poff 设置为目录中条目的字节偏移量，以便调用者编辑它。如果dirlookup 找到一个对应名称的条目，则更新*poff，并返回一个通过 iget 获得的未被锁定的 inode。<code>dirlookup是iget返回未锁定的inode的原因。调用者已经锁定了dp，所以如果查找的是 “.” ，当前目录的别名，在返回之前试图锁定inode，就会试图重新锁定dp而死锁。还有更复杂的死锁情况，涉及到多个进程和”..”父目录的别名,”.”不是唯一的问题。</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Look for a directory entry in a directory.</span></span><br><span class="line"><span class="comment">// If found, set *poff to byte offset of entry.</span></span><br><span class="line"><span class="keyword">struct</span> inode*</span><br><span class="line"><span class="title function_">dirlookup</span><span class="params">(<span class="keyword">struct</span> inode *dp, <span class="type">char</span> *name, uint *poff)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint off, inum;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> <span class="title">de</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// inode必须是目录类型</span></span><br><span class="line">  <span class="keyword">if</span>(dp-&gt;type != T_DIR)</span><br><span class="line">    panic(<span class="string">&quot;dirlookup not DIR&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 逐个查找比较目录的dirent序列</span></span><br><span class="line">  <span class="keyword">for</span>(off = <span class="number">0</span>; off &lt; dp-&gt;size; off += <span class="keyword">sizeof</span>(de))&#123;</span><br><span class="line">    <span class="comment">// 读取目录inode中的dirent</span></span><br><span class="line">    <span class="keyword">if</span>(readi(dp, <span class="number">0</span>, (uint64)&amp;de, off, <span class="keyword">sizeof</span>(de)) != <span class="keyword">sizeof</span>(de))</span><br><span class="line">      panic(<span class="string">&quot;dirlookup read&quot;</span>);</span><br><span class="line">    <span class="comment">// 目录项为空，跳过</span></span><br><span class="line">    <span class="keyword">if</span>(de.inum == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    <span class="comment">// 找到符合的目录项</span></span><br><span class="line">    <span class="keyword">if</span>(namecmp(name, de.name) == <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="comment">// entry matches path element</span></span><br><span class="line">      <span class="comment">// 将*poff 设置为目录中条目的字节偏移量</span></span><br><span class="line">      <span class="keyword">if</span>(poff)</span><br><span class="line">        *poff = off;</span><br><span class="line">      inum = de.inum;</span><br><span class="line">      <span class="comment">// 返回相应的inode</span></span><br><span class="line">      <span class="keyword">return</span> iget(dp-&gt;dev, inum);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>函数dirlink会在当前目录dp中创建一个新的目录项，通过给定的名称和inode号。</code>如果名称已经存在，dirlink 将返回一个错误。主循环读取目录项，寻找一个未使用的条目。当它找到一个时，它会提前跳出循环，并将 off 设置为该可用条目的偏移量。否则，循环结束时，将 off 设置为 dp-&gt;size。不管是哪种方式，dirlink 都会在偏移量 off 的位置添加一个新的条目到目录中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Write a new directory entry (name, inum) into the directory dp.</span></span><br><span class="line"><span class="comment">// 给目录增加一项dirent(name,inum)</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">dirlink</span><span class="params">(<span class="keyword">struct</span> inode *dp, <span class="type">char</span> *name, uint inum)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> off;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> <span class="title">de</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">ip</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Check that name is not present.</span></span><br><span class="line">  <span class="comment">// 新增的一项dirent的name必须是未存在的</span></span><br><span class="line">  <span class="keyword">if</span>((ip = dirlookup(dp, name, <span class="number">0</span>)) != <span class="number">0</span>)&#123;</span><br><span class="line">    iput(ip);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Look for an empty dirent.</span></span><br><span class="line">  <span class="comment">// 寻找一个空闲的dirent</span></span><br><span class="line">  <span class="keyword">for</span>(off = <span class="number">0</span>; off &lt; dp-&gt;size; off += <span class="keyword">sizeof</span>(de))&#123;</span><br><span class="line">    <span class="keyword">if</span>(readi(dp, <span class="number">0</span>, (uint64)&amp;de, off, <span class="keyword">sizeof</span>(de)) != <span class="keyword">sizeof</span>(de))</span><br><span class="line">      panic(<span class="string">&quot;dirlink read&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(de.inum == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// (name,inum)信息加入dirent</span></span><br><span class="line">  <span class="built_in">strncpy</span>(de.name, name, DIRSIZ);</span><br><span class="line">  de.inum = inum;</span><br><span class="line">  <span class="comment">// dirent写回inode</span></span><br><span class="line">  <span class="keyword">if</span>(writei(dp, <span class="number">0</span>, (uint64)&amp;de, off, <span class="keyword">sizeof</span>(de)) != <span class="keyword">sizeof</span>(de))</span><br><span class="line">    panic(<span class="string">&quot;dirlink&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="8-7路径命名层"><a href="#8-7路径命名层" class="headerlink" title="8.7路径命名层"></a>8.7路径命名层</h4><p>查找路径名会对每一个节点调用一次dirlookup。namei解析路径并返回相应的inode。函数 nameiparent是namei的一个变种：它返回相应inode的父目录inode，并将最后一个元素复制到 name中。这两个函数都通过调用namex来实现。</p>
<p>namex首先确定路径解析从哪里开始。如果路径以斜线开头，则从根目录开始解析；否则，从当前目录开始解析。然后它使用 skipelem 来遍历路径中的每个元素。循环的每次迭代都必须在当前 inode ip 中查找name。迭代的开始是锁定 ip 并检查它是否是一个目录。如果不是，查找就会失败。(锁定ip是必要的，不是因为ip-&gt;type可能会改变，而是因为在ilock运行前，不能保证ip-&gt;type已经从磁盘载入)。如果调用的是nameiparent，而且这是最后一个路径元素，按照之前nameiparent的定义，循环应该提前停止，最后一个路径元素已经被复制到name 中，所以namex只需要返回解锁的ip。最后，循环使用dirlookup查找路径元素，并通过设置ip &#x3D; next 为下一次迭代做准备。当循环遍历完路径元素时，它返回ip。</p>
<p><code>namex</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Look up and return the inode for a path name.</span></span><br><span class="line"><span class="comment">// If parent != 0, return the inode for the parent and copy the final</span></span><br><span class="line"><span class="comment">// path element into name, which must have room for DIRSIZ bytes.</span></span><br><span class="line"><span class="comment">// Must be called inside a transaction since it calls iput().</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> inode*</span><br><span class="line"><span class="title function_">namex</span><span class="params">(<span class="type">char</span> *path, <span class="type">int</span> nameiparent, <span class="type">char</span> *name)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">ip</span>, *<span class="title">next</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 路径以斜杠开头，则从根目录开始</span></span><br><span class="line">  <span class="keyword">if</span>(*path == <span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">    ip = iget(ROOTDEV, ROOTINO);</span><br><span class="line">  <span class="comment">// 否则，从当前目录开始</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    ip = idup(myproc()-&gt;cwd);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>((path = skipelem(path, name)) != <span class="number">0</span>)&#123;</span><br><span class="line">    ilock(ip);</span><br><span class="line">    <span class="comment">// 上级目录必须是T_DIR类型</span></span><br><span class="line">    <span class="keyword">if</span>(ip-&gt;type != T_DIR)&#123;</span><br><span class="line">      iunlockput(ip);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 到达路径最后一项，直接返回上级目录ip</span></span><br><span class="line">    <span class="keyword">if</span>(nameiparent &amp;&amp; *path == <span class="string">&#x27;\0&#x27;</span>)&#123;</span><br><span class="line">      <span class="comment">// Stop one level early.</span></span><br><span class="line">      iunlock(ip);</span><br><span class="line">      <span class="keyword">return</span> ip;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 在上级目录中查找名字为name的inode节点</span></span><br><span class="line">    <span class="keyword">if</span>((next = dirlookup(ip, name, <span class="number">0</span>)) == <span class="number">0</span>)&#123;</span><br><span class="line">      iunlockput(ip);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    iunlockput(ip);</span><br><span class="line">    ip = next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(nameiparent)&#123;</span><br><span class="line">    iput(ip);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ip;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>idup</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Increment reference count for ip.</span></span><br><span class="line"><span class="comment">// Returns ip to enable ip = idup(ip1) idiom.</span></span><br><span class="line"><span class="comment">// 增加inode的引用计数</span></span><br><span class="line"><span class="keyword">struct</span> inode*</span><br><span class="line"><span class="title function_">idup</span><span class="params">(<span class="keyword">struct</span> inode *ip)</span></span><br><span class="line">&#123;</span><br><span class="line">  acquire(&amp;icache.lock);</span><br><span class="line">  ip-&gt;ref++;</span><br><span class="line">  release(&amp;icache.lock);</span><br><span class="line">  <span class="keyword">return</span> ip;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>skipelem</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Copy the next path element from path into name.</span></span><br><span class="line"><span class="comment">// Return a pointer to the element following the copied one.</span></span><br><span class="line"><span class="comment">// The returned path has no leading slashes,</span></span><br><span class="line"><span class="comment">// so the caller can check *path==&#x27;\0&#x27; to see if the name is the last one.</span></span><br><span class="line"><span class="comment">// If no name to remove, return 0.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Examples:</span></span><br><span class="line"><span class="comment">//   skipelem(&quot;a/bb/c&quot;, name) = &quot;bb/c&quot;, setting name = &quot;a&quot;</span></span><br><span class="line"><span class="comment">//   skipelem(&quot;///a//bb&quot;, name) = &quot;bb&quot;, setting name = &quot;a&quot;</span></span><br><span class="line"><span class="comment">//   skipelem(&quot;a&quot;, name) = &quot;&quot;, setting name = &quot;a&quot;</span></span><br><span class="line"><span class="comment">//   skipelem(&quot;&quot;, name) = skipelem(&quot;////&quot;, name) = 0</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="type">static</span> <span class="type">char</span>*</span><br><span class="line"><span class="title function_">skipelem</span><span class="params">(<span class="type">char</span> *path, <span class="type">char</span> *name)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> *s;</span><br><span class="line">  <span class="type">int</span> len;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(*path == <span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">    path++;</span><br><span class="line">  <span class="keyword">if</span>(*path == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  s = path;</span><br><span class="line">  <span class="keyword">while</span>(*path != <span class="string">&#x27;/&#x27;</span> &amp;&amp; *path != <span class="number">0</span>)</span><br><span class="line">    path++;</span><br><span class="line">  len = path - s;</span><br><span class="line">  <span class="keyword">if</span>(len &gt;= DIRSIZ)</span><br><span class="line">    memmove(name, s, DIRSIZ);</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    memmove(name, s, len);</span><br><span class="line">    name[len] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span>(*path == <span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">    path++;</span><br><span class="line">  <span class="keyword">return</span> path;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>namei</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> inode*</span><br><span class="line"><span class="title function_">namei</span><span class="params">(<span class="type">char</span> *path)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> name[DIRSIZ];</span><br><span class="line">  <span class="keyword">return</span> namex(path, <span class="number">0</span>, name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>nameiparent</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> inode*</span><br><span class="line"><span class="title function_">nameiparent</span><span class="params">(<span class="type">char</span> *path, <span class="type">char</span> *name)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> namex(path, <span class="number">1</span>, name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>namex 可能需要很长的时间来完成：它可能会涉及几个磁盘操作，通过遍历路径名得到的目录的 inode 和目录块（如果它们不在 buffer 缓存中）。&#x3D;&#x3D;xv6 经过精心设计，如果一个内核线程对namex的调用在阻塞在磁盘I&#x2F;O上，另一个内核线程查找不同的路径名可以同时进行。namex分别锁定路径中的每个目录，这样不同目录的查找就可以并行进行。&#x3D;&#x3D;</p>
<p>这种并发性带来了一些挑战。例如，当一个内核线程在查找一个路径名时，另一个内核线程可能正在取消链接一个目录，这会改变目录数。一个潜在的风险是，可能一个查找线程正在搜索的目录可能已经被另一个内核线程删除了，而它的块已经被另一个目录或文件重用了。</p>
<p><code>xv6避免了这种竞争。例如，在namex中执行dirlookup时，查找线程会持有目录的锁，dirlookup 返回一个使用iget获得的inode。iget会增加inode的引用次数。只有从dirlookup收到inode后，namex才会释放目录上的锁。现在另一个线程可能会从目录中取消链接inode，但xv6还不会删除 inode，因为inode的引用数仍然大于零。</code></p>
<p>&#x3D;&#x3D;另一个风险是死锁。例如，当查找”. “时，next 指向的 inode 与 ip 相同。在释放对 ip 的锁之前锁定 next 会导致死锁。为了避免这种死锁，namex在获得对next的锁之前就会解锁目录。这里我们再次看到为什么iget和ilock之间的分离是很重要的。&#x3D;&#x3D;</p>
<h4 id="8-8文件描述符层"><a href="#8-8文件描述符层" class="headerlink" title="8.8文件描述符层"></a>8.8文件描述符层</h4><p>Unix 接口很酷的一点是：<code>Unix中的大部分资源都是以文件的形式来表示的，包括控制台、管道等设备，当然还有真实的文件。</code>文件描述符层就是实现这种统一性的一层。</p>
<p>xv6 给每个进程提供了自己的打开文件表，或者说文件描述符表，就像我们在第一章中看到的那样。每个打开的文件由一个结构体 file表示，它包装 inode 或管道，也包含一个 I&#x2F;O 偏移量。<code>每次调用open都会创建一个新的打开文件（一个新的结构体file），如果多个进程独立打开同一个文件，那么不同的file实例会有不同的I/O偏移量。</code>另一方面，一个打开的文件（同一个结构文件）可以在一个进程的文件表中出现多次，也可以在多个进程的文件表中出现。如果一个进程使用 open 打开文件，然后使用 dup 创建别名，或者使用fork 与子进程共享文件，就会出现这种情况。引用计数可以跟踪特定打开文件的引用数量。一个文件的打开方式可以为读，写，或者读写。通过 readable 和 writable 来指明。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">enum</span> &#123;</span> FD_NONE, FD_PIPE, FD_INODE, FD_DEVICE &#125; type;</span><br><span class="line">  <span class="type">int</span> ref; <span class="comment">// reference count</span></span><br><span class="line">  <span class="type">char</span> readable; <span class="comment">// 可读权限</span></span><br><span class="line">  <span class="type">char</span> writable; <span class="comment">// 可写权限</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">pipe</span> *<span class="title">pipe</span>;</span> <span class="comment">// FD_PIPE 指向的管道</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">ip</span>;</span>  <span class="comment">// FD_INODE and FD_DEVICE 指向的Inode</span></span><br><span class="line">  uint off;          <span class="comment">// FD_INODE 偏移量</span></span><br><span class="line">  <span class="type">short</span> major;       <span class="comment">// FD_DEVICE 主设备号</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// map major device number to device functions.</span></span><br><span class="line"><span class="comment">// 通过设备号映射设备读写函数</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">devsw</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> (*read)(<span class="type">int</span>, uint64, <span class="type">int</span>);</span><br><span class="line">  <span class="type">int</span> (*write)(<span class="type">int</span>, uint64, <span class="type">int</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">devsw</span> <span class="title">devsw</span>[];</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CONSOLE 1</span></span><br></pre></td></tr></table></figure>

<p>系统中所有打开的文件都保存在一个全局文件表中，即 ftable。文件表的功能有: 分配文件(filealloc)、创建重复引用(fileup)、释放引用(fileclose)、读写数据(fileeread和filewrite)。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设备读写函数结构(通过主设备号映射)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">devsw</span> <span class="title">devsw</span>[<span class="title">NDEV</span>];</span></span><br><span class="line"><span class="comment">// 文件表</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file</span> <span class="title">file</span>[<span class="title">NFILE</span>];</span></span><br><span class="line">&#125; ftable;</span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">fileinit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  initlock(&amp;ftable.lock, <span class="string">&quot;ftable&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>前三个函数应该比较熟悉了,就不过多的讨论。&#x3D;&#x3D;filealloc扫描文件表，寻找一个未引用的文件 (f-&gt;ref &#x3D;&#x3D; 0)，并返回一个新的引用；fileup增加引用计数；fileclose减少引用计数。当一个文件的引用数达到 0 时，fileclose会根据类型释放底层的管道或 inode。&#x3D;&#x3D;</p>
<p><code>filealloc</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Allocate a file structure.</span></span><br><span class="line"><span class="keyword">struct</span> file*</span><br><span class="line"><span class="title function_">filealloc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">f</span>;</span></span><br><span class="line"></span><br><span class="line">  acquire(&amp;ftable.lock);</span><br><span class="line">  <span class="keyword">for</span>(f = ftable.file; f &lt; ftable.file + NFILE; f++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(f-&gt;ref == <span class="number">0</span>)&#123;</span><br><span class="line">      f-&gt;ref = <span class="number">1</span>;</span><br><span class="line">      release(&amp;ftable.lock);</span><br><span class="line">      <span class="keyword">return</span> f;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  release(&amp;ftable.lock);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>filedup</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Increment ref count for file f.</span></span><br><span class="line"><span class="keyword">struct</span> file*</span><br><span class="line"><span class="title function_">filedup</span><span class="params">(<span class="keyword">struct</span> file *f)</span></span><br><span class="line">&#123;</span><br><span class="line">  acquire(&amp;ftable.lock);</span><br><span class="line">  <span class="keyword">if</span>(f-&gt;ref &lt; <span class="number">1</span>)</span><br><span class="line">    panic(<span class="string">&quot;filedup&quot;</span>);</span><br><span class="line">  f-&gt;ref++;</span><br><span class="line">  release(&amp;ftable.lock);</span><br><span class="line">  <span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>fileclose</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">/ Close file f.  (Decrement ref count, close when reaches <span class="number">0.</span>)</span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">fileclose</span><span class="params">(<span class="keyword">struct</span> file *f)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file</span> <span class="title">ff</span>;</span></span><br><span class="line"></span><br><span class="line">  acquire(&amp;ftable.lock);</span><br><span class="line">  <span class="keyword">if</span>(f-&gt;ref &lt; <span class="number">1</span>)</span><br><span class="line">    panic(<span class="string">&quot;fileclose&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span>(--f-&gt;ref &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    release(&amp;ftable.lock);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ff = *f;</span><br><span class="line">  <span class="comment">// ref==0表示文件空闲，type==FR_NONE</span></span><br><span class="line">  f-&gt;ref = <span class="number">0</span>;</span><br><span class="line">  f-&gt;type = FD_NONE;</span><br><span class="line">  release(&amp;ftable.lock);</span><br><span class="line">  <span class="comment">// 文件关闭inode信息写回磁盘</span></span><br><span class="line">  <span class="keyword">if</span>(ff.type == FD_PIPE)&#123;</span><br><span class="line">    pipeclose(ff.pipe, ff.writable);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>(ff.type == FD_INODE || ff.type == FD_DEVICE)&#123;</span><br><span class="line">    begin_op();</span><br><span class="line">    <span class="comment">// 文件关闭后需要撤销一个inode的ref引用</span></span><br><span class="line">    iput(ff.ip);</span><br><span class="line">    end_op();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>filestat</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Get metadata about file f.</span></span><br><span class="line"><span class="comment">// addr is a user virtual address, pointing to a struct stat.</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">filestat</span><span class="params">(<span class="keyword">struct</span> file *f, uint64 addr)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">st</span>;</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>(f-&gt;type == FD_INODE || f-&gt;type == FD_DEVICE)&#123;</span><br><span class="line">    ilock(f-&gt;ip);</span><br><span class="line">    stati(f-&gt;ip, &amp;st);</span><br><span class="line">    iunlock(f-&gt;ip);</span><br><span class="line">    <span class="keyword">if</span>(copyout(p-&gt;pagetable, addr, (<span class="type">char</span> *)&amp;st, <span class="keyword">sizeof</span>(st)) &lt; <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函 数 filestat 、 fileread 和 filewrite实现了对文件的统计 、读和写操作 。filestat只允许对 inodes进行操作，并调用stati。<code>fileread和filewrite首先检查打开模式是否允许该操作，然后再调用管道或inode的相关实现。如果文件代表一个inode，fileread和filewrite使用I/O偏移量作为本次操作的偏移量，然后前移偏移量。pipes没有偏移量的概念</code>。回想一下 inode的函数需要调用者处理锁的相关操作。inode 加锁附带了一个不错的作用，那就是读写偏移量是原子式更新的，这样多个进程写一个文件时，自己写的数据就不会被其他进程所覆盖，尽管他们的写入可能最终会交错进行。</p>
<p><code>fileread</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Read from file f.</span></span><br><span class="line"><span class="comment">// addr is a user virtual address.</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">fileread</span><span class="params">(<span class="keyword">struct</span> file *f, uint64 addr, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> r = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 检查文件读写权限</span></span><br><span class="line">  <span class="keyword">if</span>(f-&gt;readable == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="comment">// 根据文件类型选择不同的读取函数</span></span><br><span class="line">  <span class="keyword">if</span>(f-&gt;type == FD_PIPE)&#123;</span><br><span class="line">    r = piperead(f-&gt;pipe, addr, n);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>(f-&gt;type == FD_DEVICE)&#123;</span><br><span class="line">    <span class="keyword">if</span>(f-&gt;major &lt; <span class="number">0</span> || f-&gt;major &gt;= NDEV || !devsw[f-&gt;major].read)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    r = devsw[f-&gt;major].read(<span class="number">1</span>, addr, n);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>(f-&gt;type == FD_INODE)&#123;</span><br><span class="line">    ilock(f-&gt;ip);</span><br><span class="line">    <span class="keyword">if</span>((r = readi(f-&gt;ip, <span class="number">1</span>, addr, f-&gt;off, n)) &gt; <span class="number">0</span>)</span><br><span class="line">      f-&gt;off += r;</span><br><span class="line">    iunlock(f-&gt;ip);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    panic(<span class="string">&quot;fileread&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>filewrite</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Write to file f.</span></span><br><span class="line"><span class="comment">// addr is a user virtual address.</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">filewrite</span><span class="params">(<span class="keyword">struct</span> file *f, uint64 addr, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> r, ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 检查文件读写权限</span></span><br><span class="line">  <span class="keyword">if</span>(f-&gt;writable == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 根据文件类型选择不同的写入函数</span></span><br><span class="line">  <span class="keyword">if</span>(f-&gt;type == FD_PIPE)&#123;</span><br><span class="line">    ret = pipewrite(f-&gt;pipe, addr, n);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>(f-&gt;type == FD_DEVICE)&#123;</span><br><span class="line">    <span class="keyword">if</span>(f-&gt;major &lt; <span class="number">0</span> || f-&gt;major &gt;= NDEV || !devsw[f-&gt;major].write)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    ret = devsw[f-&gt;major].write(<span class="number">1</span>, addr, n);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>(f-&gt;type == FD_INODE)&#123;</span><br><span class="line">    <span class="comment">// write a few blocks at a time to avoid exceeding</span></span><br><span class="line">    <span class="comment">// the maximum log transaction size, including</span></span><br><span class="line">    <span class="comment">// i-node, indirect block, allocation blocks,</span></span><br><span class="line">    <span class="comment">// and 2 blocks of slop for non-aligned writes.</span></span><br><span class="line">    <span class="comment">// this really belongs lower down, since writei()</span></span><br><span class="line">    <span class="comment">// might be writing a device like the console.</span></span><br><span class="line">    <span class="type">int</span> max = ((MAXOPBLOCKS<span class="number">-1</span><span class="number">-1</span><span class="number">-2</span>) / <span class="number">2</span>) * BSIZE;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; n)&#123;</span><br><span class="line">      <span class="type">int</span> n1 = n - i;</span><br><span class="line">      <span class="keyword">if</span>(n1 &gt; max)</span><br><span class="line">        n1 = max;</span><br><span class="line"></span><br><span class="line">      begin_op();</span><br><span class="line">      ilock(f-&gt;ip);</span><br><span class="line">      <span class="keyword">if</span> ((r = writei(f-&gt;ip, <span class="number">1</span>, addr + i, f-&gt;off, n1)) &gt; <span class="number">0</span>)</span><br><span class="line">        f-&gt;off += r;</span><br><span class="line">      iunlock(f-&gt;ip);</span><br><span class="line">      end_op();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span>(r &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">if</span>(r != n1)</span><br><span class="line">        panic(<span class="string">&quot;short filewrite&quot;</span>);</span><br><span class="line">      i += r;</span><br><span class="line">    &#125;</span><br><span class="line">    ret = (i == n ? n : <span class="number">-1</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    panic(<span class="string">&quot;filewrite&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：fork的子进程与父进程共享file结构体，也就是说对于文件的修改导致的偏移量的变化，彼此都是可见的。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create a new process, copying the parent.</span></span><br><span class="line"><span class="comment">// Sets up child kernel stack to return as if from fork() system call.</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i, pid;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">np</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  <span class="comment">// Allocate process.</span></span><br><span class="line">  <span class="comment">// 分配一个进程</span></span><br><span class="line">  <span class="keyword">if</span>((np = allocproc()) == <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Copy user memory from parent to child.</span></span><br><span class="line">  <span class="comment">// 父进程的内存完整拷贝到子进程中</span></span><br><span class="line">  <span class="keyword">if</span>(uvmcopy(p-&gt;pagetable, np-&gt;pagetable, p-&gt;sz) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    freeproc(np);</span><br><span class="line">    release(&amp;np-&gt;lock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  np-&gt;sz = p-&gt;sz;</span><br><span class="line">  <span class="comment">// 保存父子关系</span></span><br><span class="line">  np-&gt;parent = p;</span><br><span class="line">  <span class="comment">// copy saved user registers.</span></span><br><span class="line">  <span class="comment">// 复制保存的用户寄存器信息（trapframe）</span></span><br><span class="line">  *(np-&gt;trapframe) = *(p-&gt;trapframe);</span><br><span class="line">  <span class="comment">// Cause fork to return 0 in the child.</span></span><br><span class="line">  <span class="comment">// a0寄存器是子进程的fork返回值</span></span><br><span class="line">  np-&gt;trapframe-&gt;a0 = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// increment reference counts on open file descriptors.</span></span><br><span class="line">  <span class="comment">// 增加打开的文件描述符的引用计数</span></span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; NOFILE; i++)</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;ofile[i])</span><br><span class="line">      np-&gt;ofile[i] = filedup(p-&gt;ofile[i]);</span><br><span class="line">  np-&gt;cwd = idup(p-&gt;cwd);</span><br><span class="line">  safestrcpy(np-&gt;name, p-&gt;name, <span class="keyword">sizeof</span>(p-&gt;name));</span><br><span class="line">  <span class="comment">// 子进程的进程ID</span></span><br><span class="line">  pid = np-&gt;pid;</span><br><span class="line">  <span class="comment">// 子进程可以调度执行</span></span><br><span class="line">  np-&gt;state = RUNNABLE;</span><br><span class="line">  release(&amp;np-&gt;lock);</span><br><span class="line">  <span class="keyword">return</span> pid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>allocproc分配空闲进程</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Look in the process table for an UNUSED proc.</span></span><br><span class="line"><span class="comment">// If found, initialize state required to run in the kernel,</span></span><br><span class="line"><span class="comment">// and return with p-&gt;lock held.</span></span><br><span class="line"><span class="comment">// If there are no free procs, or a memory allocation fails, return 0.</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> proc*</span><br><span class="line"><span class="title function_">allocproc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 从进程表中查找UNUSED状态的进程</span></span><br><span class="line">  <span class="keyword">for</span>(p = proc; p &lt; &amp;proc[NPROC]; p++) &#123;</span><br><span class="line">    acquire(&amp;p-&gt;lock);</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;state == UNUSED) &#123;</span><br><span class="line">      <span class="keyword">goto</span> found;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      release(&amp;p-&gt;lock);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">found:</span><br><span class="line">  <span class="comment">// 新创建的子进程需要分配新的pid</span></span><br><span class="line">  p-&gt;pid = allocpid();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Allocate a trapframe page.</span></span><br><span class="line">  <span class="comment">// 分配一个trapframe页</span></span><br><span class="line">  <span class="keyword">if</span>((p-&gt;trapframe = (<span class="keyword">struct</span> trapframe *)kalloc()) == <span class="number">0</span>)&#123;</span><br><span class="line">    release(&amp;p-&gt;lock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// An empty user page table.</span></span><br><span class="line">  <span class="comment">// 得到一个空闲用户页表</span></span><br><span class="line">  p-&gt;pagetable = proc_pagetable(p);</span><br><span class="line">  <span class="keyword">if</span>(p-&gt;pagetable == <span class="number">0</span>)&#123;</span><br><span class="line">    freeproc(p);</span><br><span class="line">    release(&amp;p-&gt;lock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Set up new context to start executing at forkret,</span></span><br><span class="line">  <span class="comment">// which returns to user space.</span></span><br><span class="line">  <span class="comment">// 建立新的上下文信息CTX，当内核调度线程选择该进程执行用户线程时从forkret开始执行</span></span><br><span class="line">  <span class="built_in">memset</span>(&amp;p-&gt;context, <span class="number">0</span>, <span class="keyword">sizeof</span>(p-&gt;context));</span><br><span class="line">  p-&gt;context.ra = (uint64)forkret;</span><br><span class="line">  p-&gt;context.sp = p-&gt;kstack + PGSIZE;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>forkret</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A fork child&#x27;s very first scheduling by scheduler()</span></span><br><span class="line"><span class="comment">// will swtch to forkret.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">forkret</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">static</span> <span class="type">int</span> first = <span class="number">1</span>;</span><br><span class="line">  <span class="comment">// Still holding p-&gt;lock from scheduler.</span></span><br><span class="line">  release(&amp;myproc()-&gt;lock);</span><br><span class="line">  <span class="keyword">if</span> (first) &#123;</span><br><span class="line">    <span class="comment">// File system initialization must be run in the context of a</span></span><br><span class="line">    <span class="comment">// regular process (e.g., because it calls sleep), and thus cannot</span></span><br><span class="line">    <span class="comment">// be run from main().</span></span><br><span class="line">    first = <span class="number">0</span>;</span><br><span class="line">    fsinit(ROOTDEV);</span><br><span class="line">  &#125;</span><br><span class="line">  usertrapret();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="8-9补充"><a href="#8-9补充" class="headerlink" title="8.9补充"></a>8.9补充</h4><p>实际操作系统中的 buffer 缓存要比 xv6 的复杂得多，但它有同样的两个目的：<code>缓存和同步访问磁盘</code>。<code>xv6的buffer缓存和V6是一样的，使用简单的最近最少使用（LRU）抛弃策略</code>；可以实现许多更复杂的策略，每种策略都对某些情况有好处，而对其它情况没有好处。<code>更高效的LRU 缓存不使用链表，而使用哈希表进行查找，使用堆进行LRU抛弃。现代的buffer缓存通常与虚拟内存系统集成在一起，以支持内存映射的文件。</code></p>
<p>xv6 的日志系统效率低下。提交不能与文件系统系统调用同时发生。系统会记录整个块，即使一个块中只有几个字节被改变。它执行同步的日志写入，一次写一个块，每一个块都可能需要整个磁盘旋转时间。真正的日志系统可以解决所有这些问题。</p>
<p><code>日志不是提供崩溃恢复的唯一方法。早期的文件系统在重启期间使用scavenger（例如UNIX fsck 程序）来检查每个文件和目录以及块和inode空闲列表，寻找并解决不一致的地方。</code>对于大型文件系统来说，清扫可能需要几个小时的时间，而且在某些情况下，这种方式要想获得的数据一致性，其系统调用必须是一致性的。从日志中恢复要快得多，而且在面对崩溃时，会导致系统调用是原子的。</p>
<p>xv6 使用了与早期 UNIX 相同的 inodes 和目录的基本磁盘布局；这个方案多年来任还在使用。BSD 的 UFS&#x2F;FFS 和 Linux 的 ext2&#x2F;ext3 使用基本相同的数据结构。<code>文件系统布局中最低效的部分是目录，在每次查找过程中需要对所有磁盘块进行线性扫描。</code>当目录只有几个磁盘块时，这是合理的，但对于持有许多文件的目录来说是昂贵的。微软 Windows 的 NTFS，Mac OS X 的 HFS，以及 Solaris 的 ZFS，<code>将一个目录在磁盘上实现了平衡树，用于查找块</code>。这很复杂，但可以保证目录查找的时间复杂度为 O（logn）。</p>
<p>xv6 对磁盘故障的处理很简单：如果磁盘操作失败，xv6 就会 panic。这是否合理取决于硬件：<code>如果一个操作系统位于特殊的硬件之上，这种硬件会使用冗余来掩盖故障，也许操作系统看到故障的频率很低，以至于直接panic是可以的。另一方面，使用普通磁盘的操作系统应该使用更加优雅的方式来处理异常，这样一个文件中一个块的丢失就不会影响文件系统其他部分的使用。</code></p>
<p>xv6 要求文件系统固定在磁盘设备上，而且大小不能改变。随着大型数据库和多媒体文件对存储要求越来越高，操作系统正在开发消除每个文件系统一个磁盘瓶颈的方法。<code>基本的方法是将许多磁盘组合成一个逻辑磁盘。硬件解决方案（如RAID）仍然是最流行的，但目前的趋势是尽可能地在软件中实现这种逻辑。</code>这些软件实现通常允许丰富的功能，如通过快速添加或删除磁盘来增长或缩小逻辑设备。当然，一个能够快速增长或收缩的存储层需要一个能够做到同样的文件系统：xv6 使用的固定大小的 inode 块阵列在这样的环境中不能很好地工作。将磁盘管理与文件系统分离可能是最简洁的设计，但也有文件系统将两者通过复杂的接口将他们耦合在一起，如 Sun 公司的 ZFS，将两者结合起来。</p>
<p>xv6 的文件系统缺乏现代文件系统的许多其他功能，例如，它缺乏对快照和增量备份的支持。</p>
<p><code>现代Unix系统允许用与磁盘存储相同的系统调用来访问许多种类的资源：命名管道、网络连接、远程访问的网络文件系统以及监视和控制接口，如/proc。</code>这些系统没有xv6在fileread和filewrite中的if语句，而是通常给每个打开的文件一个函数指针表，每个代表一个操作，调用函数指针来调用该inode的实现调用。网络文件系统和用户级文件系统提供了将这些调用变成网络RPC的函数，并在返回前等待响应。</p>
<h2 id="第二部分：XV6操作系统实验"><a href="#第二部分：XV6操作系统实验" class="headerlink" title="第二部分：XV6操作系统实验"></a>第二部分：XV6操作系统实验</h2><p>经过第一部分的学习我们已经基本掌握XV6的设计大致机制和思想，本部分的内容仅仅只是为了巩固所学以及扩展知识点，具体可以详见 <a target="_blank" rel="noopener" href="https://blog.miigon.net/categories/mit6-s081/">https://blog.miigon.net/categories/mit6-s081/</a></p>
<h3 id="Lab-1-Unix-utilities"><a href="#Lab-1-Unix-utilities" class="headerlink" title="Lab 1: Unix utilities"></a>Lab 1: Unix utilities</h3><p><code>实现几个unix实用工具，熟悉xv6的开发环境以及系统调用。</code></p>
<h4 id="1-1Boot-xv6-easy"><a href="#1-1Boot-xv6-easy" class="headerlink" title="1.1Boot xv6 (easy)"></a>1.1Boot xv6 (easy)</h4><p>准备环境，编译编译器、QEMU，克隆仓库，略过。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">clone</span> git://g.csail.mit.edu/xv6-labs-2020</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> xv6-labs-2020</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout util</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make qemu</span></span><br></pre></td></tr></table></figure>

<h4 id="1-2sleep-easy"><a href="#1-2sleep-easy" class="headerlink" title="1.2sleep (easy)"></a>1.2sleep (easy)</h4><blockquote>
<p>Implement the UNIX program sleep for xv6; your sleep should pause for a user-specified number of ticks. A tick is a notion of time defined by the xv6 kernel, namely the time between two interrupts from the timer chip. Your solution should be in the file user&#x2F;sleep.c.</p>
</blockquote>
<p>练手题，记得在 Makefile 中将 sleep 加入构建目标里。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sleep.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span> <span class="comment">// 必须以这个顺序 include，由于三个头文件有依赖关系</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span>(argc &lt; <span class="number">2</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;usage: sleep &lt;ticks&gt;\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	sleep(atoi(argv[<span class="number">1</span>]));</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">UPROGS=\</span><br><span class="line">	$U/_cat\</span><br><span class="line">	$U/_echo\</span><br><span class="line">	$U/_forktest\</span><br><span class="line">	$U/_grep\</span><br><span class="line">	$U/_init\</span><br><span class="line">	$U/_kill\</span><br><span class="line">	$U/_ln\</span><br><span class="line">	$U/_ls\</span><br><span class="line">	$U/_mkdir\</span><br><span class="line">	$U/_rm\</span><br><span class="line">	$U/_sh\</span><br><span class="line">	$U/_stressfs\</span><br><span class="line">	$U/_usertests\</span><br><span class="line">	$U/_grind\</span><br><span class="line">	$U/_wc\</span><br><span class="line">	$U/_zombie\</span><br><span class="line">	$U/_sleep\ .   <span class="comment"># here !!!</span></span><br></pre></td></tr></table></figure>

<h4 id="1-3pingpong-easy"><a href="#1-3pingpong-easy" class="headerlink" title="1.3pingpong (easy)"></a>1.3pingpong (easy)</h4><blockquote>
<p>Write a program that uses UNIX system calls to “ping-pong” a byte between two processes over a pair of pipes, one for each direction. The parent should send a byte to the child; the child should print “: received ping”, where is its process ID, write the byte on the pipe to the parent, and exit; the parent should read the byte from the child, print “: received pong”, and exit. Your solution should be in the file user&#x2F;pingpong.c.</p>
</blockquote>
<p>管道练手题，使用 fork() 复制本进程创建子进程，创建两个管道，分别用于父子之间两个方向的数据传输。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pingpong.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line">	<span class="comment">// 创建管道会得到一个长度为 2 的 int 数组</span></span><br><span class="line">	<span class="comment">// 其中 0 为用于从管道读取数据的文件描述符，1 为用于向管道写入数据的文件描述符</span></span><br><span class="line">	<span class="type">int</span> pp2c[<span class="number">2</span>], pc2p[<span class="number">2</span>];</span><br><span class="line">	pipe(pp2c); <span class="comment">// 创建用于 父进程 -&gt; 子进程 的管道</span></span><br><span class="line">	pipe(pc2p); <span class="comment">// 创建用于 子进程 -&gt; 父进程 的管道</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(fork() != <span class="number">0</span>) &#123; <span class="comment">// parent process</span></span><br><span class="line">		write(pp2c[<span class="number">1</span>], <span class="string">&quot;!&quot;</span>, <span class="number">1</span>); <span class="comment">// 1. 父进程首先向发出该字节</span></span><br><span class="line">		<span class="type">char</span> buf;</span><br><span class="line">		read(pc2p[<span class="number">0</span>], &amp;buf, <span class="number">1</span>); <span class="comment">// 2. 父进程发送完成后，开始等待子进程的回复</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d: received pong\n&quot;</span>, getpid()); <span class="comment">// 5. 子进程收到数据，read 返回，输出 pong</span></span><br><span class="line">		wait(<span class="number">0</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123; <span class="comment">// child process</span></span><br><span class="line">		<span class="type">char</span> buf;</span><br><span class="line">		read(pp2c[<span class="number">0</span>], &amp;buf, <span class="number">1</span>); <span class="comment">// 3. 子进程读取管道，收到父进程发送的字节数据</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d: received ping\n&quot;</span>, getpid());</span><br><span class="line">		write(pc2p[<span class="number">1</span>], &amp;buf, <span class="number">1</span>); <span class="comment">// 4. 子进程通过 子-&gt;父管道，将字节送回父进程</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注：序号只为方便理解，实际执行顺序由于两进程具体调度情况不定，不一定严格按照该顺序执行，但是结果相同。</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">$</span> pingpong</span><br><span class="line">4: received ping</span><br><span class="line">3: received pong</span><br><span class="line"><span class="built_in">$</span></span><br></pre></td></tr></table></figure>

<h4 id="1-4primes-moderate"><a href="#1-4primes-moderate" class="headerlink" title="1.4primes (moderate)"></a>1.4primes (moderate)</h4><blockquote>
<p>Write a concurrent version of prime sieve using pipes. This idea is due to Doug McIlroy, inventor of Unix pipes. The picture halfway down <a target="_blank" rel="noopener" href="http://swtch.com/~rsc/thread/">this page</a> and the surrounding text explain how to do it. Your solution should be in the file user&#x2F;primes.c.</p>
</blockquote>
<p>十分好玩的一道题hhhhh，使用多进程和管道，每一个进程作为一个 stage，筛掉某个素数的所有倍数。很巧妙的形式实现了多线程的筛法求素数。</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">主进程：生成 n ∈ [2,35] -&gt; 子进程1：筛掉所有 2 的倍数 -&gt; 子进程2：筛掉所有 3 的倍数 -&gt; 子进程3：筛掉所有 5 的倍数 -&gt; .....</span><br></pre></td></tr></table></figure>

<p>每一个 stage 以当前数集中最小的数字作为素数输出（每个 stage 中数集中最小的数一定是一个素数，因为它没有被任何比它小的数筛掉），并筛掉输入中该素数的所有倍数（必然不是素数），然后将剩下的数传递给下一 stage。最后会形成一条子进程链，而由于每一个进程都调用了 <code>wait(0);</code> 等待其子进程，所以会在最末端也就是最后一个 stage 完成的时候，沿着链条向上依次退出各个进程。</p>
<blockquote>
<p>素数筛法：将一组数feed到一个进程里，先print出最小的一个数，这是一个素数，然后用其他剩下的数依次尝试整除这个素数，如果可以整除，则将其drop，不能整除则将其feed到下一个进程中，直到最后打印出所有的素数。</p>
</blockquote>
<p><img src="/../../../../../../imgs/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%BA%90%E7%A0%81%E7%BA%A7%E5%89%96%E6%9E%90/image-20221118151758126.png" alt="image-20221118151758126"></p>
<p>注意最开始的父进程要等待所有子进程exit才能exit</p>
<p>解决思路：采用递归，每次先尝试从左pipe中读取一个数，如果读不到说明已经到达终点，exit，否则再创建一个右pipe并fork一个子进程，将筛选后的数feed进这个右pipe。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// primes.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 一次 sieve 调用是一个筛子阶段，会从 pleft 获取并输出一个素数 p，筛除 p 的所有倍数</span></span><br><span class="line"><span class="comment">// 同时创建下一 stage 的进程以及相应输入管道 pright，然后将剩下的数传到下一 stage 处理</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sieve</span><span class="params">(<span class="type">int</span> pleft[<span class="number">2</span>])</span> &#123; <span class="comment">// pleft 是来自该 stage 左端进程的输入管道</span></span><br><span class="line">	<span class="type">int</span> p;</span><br><span class="line">	read(pleft[<span class="number">0</span>], &amp;p, <span class="keyword">sizeof</span>(p)); <span class="comment">// 读第一个数，必然是素数</span></span><br><span class="line">	<span class="keyword">if</span>(p == <span class="number">-1</span>) &#123; <span class="comment">// 如果是哨兵 -1，则代表所有数字处理完毕，退出程序</span></span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;prime %d\n&quot;</span>, p);</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> pright[<span class="number">2</span>];</span><br><span class="line">	pipe(pright); <span class="comment">// 创建用于输出到下一 stage 的进程的输出管道 pright</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(fork() == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="comment">// 子进程 （下一个 stage）</span></span><br><span class="line">		close(pright[<span class="number">1</span>]); <span class="comment">// 子进程只需要对输入管道 pright 进行读，而不需要写，所以关掉子进程的输入管道写文件描述符，降低进程打开的文件描述符数量</span></span><br><span class="line">		close(pleft[<span class="number">0</span>]); <span class="comment">// 这里的 pleft 是*父进程*的输入管道，子进程用不到，关掉</span></span><br><span class="line">		sieve(pright); <span class="comment">// 子进程以父进程的输出管道作为输入，开始进行下一个 stage 的处理。</span></span><br><span class="line"></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// 父进程 （当前 stage）</span></span><br><span class="line">		close(pright[<span class="number">0</span>]); <span class="comment">// 同上，父进程只需要对子进程的输入管道进行写而不需要读，所以关掉父进程的读文件描述符</span></span><br><span class="line">		<span class="type">int</span> buf;</span><br><span class="line">		<span class="keyword">while</span>(read(pleft[<span class="number">0</span>], &amp;buf, <span class="keyword">sizeof</span>(buf)) &amp;&amp; buf != <span class="number">-1</span>) &#123; <span class="comment">// 从左端的进程读入数字</span></span><br><span class="line">			<span class="keyword">if</span>(buf % p != <span class="number">0</span>) &#123; <span class="comment">// 筛掉能被该进程筛掉的数字</span></span><br><span class="line">				write(pright[<span class="number">1</span>], &amp;buf, <span class="keyword">sizeof</span>(buf)); <span class="comment">// 将剩余的数字写到右端进程</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		buf = <span class="number">-1</span>;</span><br><span class="line">		write(pright[<span class="number">1</span>], &amp;buf, <span class="keyword">sizeof</span>(buf)); <span class="comment">// 补写最后的 -1，标示输入完成。</span></span><br><span class="line">		wait(<span class="number">0</span>); <span class="comment">// 等待该进程的子进程完成，也就是下一 stage</span></span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line">	<span class="comment">// 主进程</span></span><br><span class="line">	<span class="type">int</span> input_pipe[<span class="number">2</span>];</span><br><span class="line">	pipe(input_pipe); <span class="comment">// 准备好输入管道，输入 2 到 35 之间的所有整数。</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(fork() == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="comment">// 第一个 stage 的子进程</span></span><br><span class="line">		close(input_pipe[<span class="number">1</span>]); <span class="comment">// 子进程只需要读输入管道，而不需要写，关掉子进程的管道写文件描述符</span></span><br><span class="line">		sieve(input_pipe);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// 主进程</span></span><br><span class="line">		close(input_pipe[<span class="number">0</span>]); <span class="comment">// 同上</span></span><br><span class="line">		<span class="type">int</span> i;</span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">2</span>;i&lt;=<span class="number">35</span>;i++)&#123; <span class="comment">// 生成 [2, 35]，输入管道链最左端</span></span><br><span class="line">			write(input_pipe[<span class="number">1</span>], &amp;i, <span class="keyword">sizeof</span>(i));</span><br><span class="line">		&#125;</span><br><span class="line">		i = <span class="number">-1</span>;</span><br><span class="line">		write(input_pipe[<span class="number">1</span>], &amp;i, <span class="keyword">sizeof</span>(i)); <span class="comment">// 末尾输入 -1，用于标识输入完成</span></span><br><span class="line">	&#125;</span><br><span class="line">	wait(<span class="number">0</span>); <span class="comment">// 等待第一个 stage 完成。注意：这里无法等待子进程的子进程，只能等待直接子进程，无法等待间接子进程。在 sieve() 中会为每个 stage 再各自执行 wait(0)，形成等待链。</span></span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这一道的主要坑就是，stage 之间的管道 pleft 和 pright，要注意关闭不需要用到的文件描述符，否则跑到 n &#x3D; 13 的时候就会爆掉，出现读到全是 0 的情况。</p>
<p>这里的理由是，fork 会将父进程的所有文件描述符都复制到子进程里，而 xv6 每个进程能打开的文件描述符总数只有 16 个 （见 <code>defs.h</code> 中的 <code>NOFILE</code> 和 <code>proc.h</code> 中的 <code>struct file *ofile[NOFILE]; // Open files</code>）。</p>
<p>由于一个管道会同时打开一个输入文件和一个输出文件，所以一个管道就占用了 2 个文件描述符，并且复制的子进程还会复制父进程的描述符，于是跑到第六七层后，就会由于最末端的子进程出现 16 个文件描述符都被占满的情况，导致新管道创建失败。</p>
<p>解决方法有两部分：</p>
<ul>
<li>关闭管道的两个方向中不需要用到的方向的文件描述符（在具体进程中将管道变成只读&#x2F;只写）</li>
</ul>
<blockquote>
<p>原理：每个进程从左侧的读入管道中<strong>只需要读数据</strong>，并且<strong>只需要写数据</strong>到右侧的输出管道，所以可以把左侧管道的写描述符，以及右侧管道的读描述符关闭，而不会影响程序运行 这里注意文件描述符是进程独立的，在某个进程内关闭文件描述符，不会影响到其他进程!</p>
</blockquote>
<ul>
<li>子进程创建后，关闭父进程与祖父进程之间的文件描述符（因为子进程并不需要用到之前 stage 的管道）</li>
</ul>
<p><code>具体的操作在上面代码中有体现。（fork 后、执行操作前，close 掉不需要用掉的文件描述符）</code></p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">$</span> primes</span><br><span class="line">prime 2</span><br><span class="line">prime 3</span><br><span class="line">prime 5</span><br><span class="line">prime 7</span><br><span class="line">prime 11</span><br><span class="line">prime 13</span><br><span class="line">prime 17</span><br><span class="line">prime 19</span><br><span class="line">prime 23</span><br><span class="line">prime 29</span><br><span class="line">prime 31</span><br><span class="line"><span class="built_in">$</span></span><br></pre></td></tr></table></figure>

<h4 id="1-5find-moderate"><a href="#1-5find-moderate" class="headerlink" title="1.5find (moderate)"></a>1.5find (moderate)</h4><blockquote>
<p>Write a simple version of the UNIX find program: find all the files in a directory tree with a specific name. Your solution should be in the file user&#x2F;find.c.</p>
</blockquote>
<p>这里基本原理与 ls 相同，基本上可以从 ls.c 改造得到：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// find.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/fs.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">find</span><span class="params">(<span class="type">char</span> *path, <span class="type">char</span> *target)</span> &#123;</span><br><span class="line">	<span class="type">char</span> buf[<span class="number">512</span>], *p;</span><br><span class="line">	<span class="type">int</span> fd;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> <span class="title">de</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">st</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>((fd = open(path, <span class="number">0</span>)) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;find: cannot open %s\n&quot;</span>, path);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(fstat(fd, &amp;st) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;find: cannot stat %s\n&quot;</span>, path);</span><br><span class="line">		close(fd);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span>(st.type)&#123;</span><br><span class="line">	<span class="keyword">case</span> T_FILE:</span><br><span class="line">		<span class="comment">// 如果文件名结尾匹配 `/target`，则视为匹配</span></span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">strcmp</span>(path+<span class="built_in">strlen</span>(path)-<span class="built_in">strlen</span>(target), target) == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, path);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> T_DIR:</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">strlen</span>(path) + <span class="number">1</span> + DIRSIZ + <span class="number">1</span> &gt; <span class="keyword">sizeof</span> buf)&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;find: path too long\n&quot;</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">strcpy</span>(buf, path);</span><br><span class="line">		p = buf+<span class="built_in">strlen</span>(buf);</span><br><span class="line">		*p++ = <span class="string">&#x27;/&#x27;</span>;</span><br><span class="line">		<span class="keyword">while</span>(read(fd, &amp;de, <span class="keyword">sizeof</span>(de)) == <span class="keyword">sizeof</span>(de))&#123;</span><br><span class="line">			<span class="keyword">if</span>(de.inum == <span class="number">0</span>)</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			memmove(p, de.name, DIRSIZ);</span><br><span class="line">			p[DIRSIZ] = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">if</span>(stat(buf, &amp;st) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;find: cannot stat %s\n&quot;</span>, buf);</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 不要进入 `.` 和 `..`</span></span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">strcmp</span>(buf+<span class="built_in">strlen</span>(buf)<span class="number">-2</span>, <span class="string">&quot;/.&quot;</span>) != <span class="number">0</span> &amp;&amp; <span class="built_in">strcmp</span>(buf+<span class="built_in">strlen</span>(buf)<span class="number">-3</span>, <span class="string">&quot;/..&quot;</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">				find(buf, target); <span class="comment">// 递归查找</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	close(fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(argc &lt; <span class="number">3</span>)&#123;</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">char</span> target[<span class="number">512</span>];</span><br><span class="line">	target[<span class="number">0</span>] = <span class="string">&#x27;/&#x27;</span>; <span class="comment">// 为查找的文件名添加 / 在开头</span></span><br><span class="line">	<span class="built_in">strcpy</span>(target+<span class="number">1</span>, argv[<span class="number">2</span>]);</span><br><span class="line">	find(argv[<span class="number">1</span>], target);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">$</span> find . b</span><br><span class="line">    ./b</span><br><span class="line">    ./a/b</span><br></pre></td></tr></table></figure>

<h4 id="1-6xargs-moderate"><a href="#1-6xargs-moderate" class="headerlink" title="1.6xargs (moderate)"></a>1.6xargs (moderate)</h4><blockquote>
<p>Write a simple version of the UNIX xargs program: read lines from the standard input and run a command for each line, supplying the line as arguments to the command. Your solution should be in the file user&#x2F;xargs.c.</p>
</blockquote>
<p>编写 xargs 工具，从标准输入读入数据，将每一行当作参数，加入到传给 xargs 的程序名和参数后面作为额外参数，然后执行。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> hello too | xargs <span class="built_in">echo</span> <span class="built_in">bye</span></span></span><br><span class="line">bye hello too</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// xargs.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/fs.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 带参数列表，执行某个程序</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">run</span><span class="params">(<span class="type">char</span> *program, <span class="type">char</span> **args)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span>(fork() == <span class="number">0</span>) &#123; <span class="comment">// child exec</span></span><br><span class="line">		exec(program, args);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>; <span class="comment">// parent return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span>&#123;</span><br><span class="line">	<span class="type">char</span> buf[<span class="number">2048</span>]; <span class="comment">// 读入时使用的内存池</span></span><br><span class="line">	<span class="type">char</span> *p = buf, *last_p = buf; <span class="comment">// 当前参数的结束、开始指针</span></span><br><span class="line">	<span class="type">char</span> *argsbuf[<span class="number">128</span>]; <span class="comment">// 全部参数列表，字符串指针数组，包含 argv 传进来的参数和 stdin 读入的参数</span></span><br><span class="line">	<span class="type">char</span> **args = argsbuf; <span class="comment">// 指向 argsbuf 中第一个从 stdin 读入的参数</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;argc;i++) &#123;</span><br><span class="line">		<span class="comment">// 将 argv 提供的参数加入到最终的参数列表中</span></span><br><span class="line">		*args = argv[i];</span><br><span class="line">		args++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">char</span> **pa = args; <span class="comment">// 开始读入参数</span></span><br><span class="line">	<span class="keyword">while</span>(read(<span class="number">0</span>, p, <span class="number">1</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span>(*p == <span class="string">&#x27; &#x27;</span> || *p == <span class="string">&#x27;\n&#x27;</span>) &#123;</span><br><span class="line">			<span class="comment">// 读入一个参数完成（以空格分隔，如 `echo hello world`，则 hello 和 world 各为一个参数）</span></span><br><span class="line">			*p = <span class="string">&#x27;\0&#x27;</span>;	<span class="comment">// 将空格替换为 \0 分割开各个参数，这样可以直接使用内存池中的字符串作为参数字符串</span></span><br><span class="line">						<span class="comment">// 而不用额外开辟空间</span></span><br><span class="line">			*(pa++) = last_p;</span><br><span class="line">			last_p = p+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span>(*p == <span class="string">&#x27;\n&#x27;</span>) &#123;</span><br><span class="line">				<span class="comment">// 读入一行完成</span></span><br><span class="line">				*pa = <span class="number">0</span>; <span class="comment">// 参数列表末尾用 null 标识列表结束</span></span><br><span class="line">				run(argv[<span class="number">1</span>], argsbuf); <span class="comment">// 执行最后一行指令</span></span><br><span class="line">				pa = args; <span class="comment">// 重置读入参数指针，准备读入下一行</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		p++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(pa != args) &#123; <span class="comment">// 如果最后一行不是空行</span></span><br><span class="line">		<span class="comment">// 收尾最后一个参数</span></span><br><span class="line">		*p = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">		*(pa++) = last_p;</span><br><span class="line">		<span class="comment">// 收尾最后一行</span></span><br><span class="line">		*pa = <span class="number">0</span>; <span class="comment">// 参数列表末尾用 null 标识列表结束</span></span><br><span class="line">		<span class="comment">// 执行最后一行指令</span></span><br><span class="line">		run(argv[<span class="number">1</span>], argsbuf);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(wait(<span class="number">0</span>) != <span class="number">-1</span>) &#123;&#125;; <span class="comment">// 循环等待所有子进程完成，每一次 wait(0) 等待一个</span></span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Lab-2-System-calls"><a href="#Lab-2-System-calls" class="headerlink" title="Lab 2: System calls"></a>Lab 2: System calls</h3><blockquote>
<p>In this lab you will add some new system calls to xv6, which will help you understand how they work and will expose you to some of the internals of the xv6 kernel. You will add more system calls in later labs.</p>
</blockquote>
<p>对 xv6 添加一些新的系统调用，帮助加深对 xv6 内核的理解。</p>
<h4 id="2-1Tracing-moderate"><a href="#2-1Tracing-moderate" class="headerlink" title="2.1Tracing (moderate)"></a>2.1Tracing (moderate)</h4><p>准备环境，编译编译器、QEMU，克隆仓库，略过。</p>
<blockquote>
<p>In this assignment you will add a system call tracing feature that may help you when debugging later labs. You’ll create a new trace system call that will control tracing. It should take one argument, an integer “mask”, whose bits specify which system calls to trace. For example, to trace the fork system call, a program calls trace(1 « SYS_fork), where SYS_fork is a syscall number from kernel&#x2F;syscall.h. You have to modify the xv6 kernel to print out a line when each system call is about to return, if the system call’s number is set in the mask. The line should contain the process id, the name of the system call and the return value; you don’t need to print the system call arguments. The trace system call should enable tracing for the process that calls it and any children that it subsequently forks, but should not affect other processes.</p>
</blockquote>
<p>添加一个系统调用 trace 的功能，为每个进程设定一个位 mask，用 mask 中设定的位来指定要为哪些系统调用输出调试信息。</p>
<p>:pager:如何创建新系统调用</p>
<ol>
<li>首先在内核中合适的位置（取决于要实现的功能属于什么模块，理论上随便放都可以，只是主要起归类作用），实现我们的内核调用（在这里是 trace 调用）：</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/sysproc.c</span></span><br><span class="line"><span class="comment">// 这里着重理解如何添加系统调用，对于这个调用的具体代码细节在后面的部分分析</span></span><br><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_trace</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> mask;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(argint(<span class="number">0</span>, &amp;mask) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">myproc()-&gt;syscall_trace = mask;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里因为我们的系统调用会对进程进行操作，所以放在 sysproc.c 较为合适。</p>
<ol start="2">
<li>在 syscall.h 中加入新 system call 的序号：</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/syscall.h</span></span><br><span class="line"><span class="comment">// System call numbers</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_fork    1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_exit    2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_wait    3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_pipe    4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_read    5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_kill    6</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_exec    7</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_fstat   8</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_chdir   9</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_dup    10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_getpid 11</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_sbrk   12</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_sleep  13</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_uptime 14</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_open   15</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_write  16</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_mknod  17</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_unlink 18</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_link   19</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_mkdir  20</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_close  21</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_trace  22 <span class="comment">// here!!!!!</span></span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>用 extern 全局声明新的内核调用函数，并且在 syscalls 映射表中，加入从前面定义的编号到系统调用函数指针的映射</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/syscall.c </span></span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_chdir</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_close</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_dup</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_exec</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_exit</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_fork</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_fstat</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_getpid</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_kill</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_link</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_mkdir</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_mknod</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_open</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_pipe</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_read</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_sbrk</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_sleep</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_unlink</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_wait</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_write</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_uptime</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_trace</span><span class="params">(<span class="type">void</span>)</span>;   <span class="comment">// HERE</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="title function_">uint64</span> <span class="params">(*syscalls[])</span><span class="params">(<span class="type">void</span>)</span> = &#123;</span><br><span class="line">[SYS_fork]    sys_fork,</span><br><span class="line">[SYS_exit]    sys_exit,</span><br><span class="line">[SYS_wait]    sys_wait,</span><br><span class="line">[SYS_pipe]    sys_pipe,</span><br><span class="line">[SYS_read]    sys_read,</span><br><span class="line">[SYS_kill]    sys_kill,</span><br><span class="line">[SYS_exec]    sys_exec,</span><br><span class="line">[SYS_fstat]   sys_fstat,</span><br><span class="line">[SYS_chdir]   sys_chdir,</span><br><span class="line">[SYS_dup]     sys_dup,</span><br><span class="line">[SYS_getpid]  sys_getpid,</span><br><span class="line">[SYS_sbrk]    sys_sbrk,</span><br><span class="line">[SYS_sleep]   sys_sleep,</span><br><span class="line">[SYS_uptime]  sys_uptime,</span><br><span class="line">[SYS_open]    sys_open,</span><br><span class="line">[SYS_write]   sys_write,</span><br><span class="line">[SYS_mknod]   sys_mknod,</span><br><span class="line">[SYS_unlink]  sys_unlink,</span><br><span class="line">[SYS_link]    sys_link,</span><br><span class="line">[SYS_mkdir]   sys_mkdir,</span><br><span class="line">[SYS_close]   sys_close,</span><br><span class="line">[SYS_trace]   sys_trace,  <span class="comment">// AND HERE</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这里 <code>[SYS_trace] sys_trace</code> 是 C 语言数组的一个语法，表示以方括号内的值作为元素下标。比如 <code>int arr[] = &#123;[3] 2333, [6] 6666&#125;</code> 代表 arr 的下标 3 的元素为 2333，下标 6 的元素为 6666，其他元素填充 0 的数组。（该语法在 C++ 中已不可用）</p>
<ol start="4">
<li>在 usys.pl 中，加入用户态到内核态的跳板函数。</li>
</ol>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># user/usys.pl</span></span><br><span class="line"></span><br><span class="line">entry(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;exit&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;wait&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;pipe&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;write&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;close&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;kill&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;exec&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;mknod&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;unlink&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;fstat&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;link&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;mkdir&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;chdir&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;dup&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;getpid&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;sbrk&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;sleep&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;uptime&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;trace&quot;</span>);  <span class="comment"># HERE</span></span><br></pre></td></tr></table></figure>

<p>这个脚本在运行后会生成 usys.S 汇编文件，里面定义了每个 system call 的用户态跳板函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">trace:		# 定义用户态跳板函数</span><br><span class="line">li a7, SYS_trace	# 将系统调用 id 存入 a7 寄存器</span><br><span class="line">ecall				# ecall，调用 system call ，跳到内核态的统一系统调用处理函数 syscall()  (syscall.c)</span><br><span class="line">ret</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>在用户态的头文件加入定义，使得用户态程序可以找到这个跳板入口函数。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// user/user.h</span></span><br><span class="line"><span class="comment">// system calls</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">exit</span><span class="params">(<span class="type">int</span>)</span> __<span class="title function_">attribute__</span><span class="params">((<span class="keyword">noreturn</span>))</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">wait</span><span class="params">(<span class="type">int</span>*)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pipe</span><span class="params">(<span class="type">int</span>*)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span>, <span class="type">const</span> <span class="type">void</span>*, <span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">read</span><span class="params">(<span class="type">int</span>, <span class="type">void</span>*, <span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">close</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">kill</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">exec</span><span class="params">(<span class="type">char</span>*, <span class="type">char</span>**)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">open</span><span class="params">(<span class="type">const</span> <span class="type">char</span>*, <span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">mknod</span><span class="params">(<span class="type">const</span> <span class="type">char</span>*, <span class="type">short</span>, <span class="type">short</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">unlink</span><span class="params">(<span class="type">const</span> <span class="type">char</span>*)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">fstat</span><span class="params">(<span class="type">int</span> fd, <span class="keyword">struct</span> stat*)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">link</span><span class="params">(<span class="type">const</span> <span class="type">char</span>*, <span class="type">const</span> <span class="type">char</span>*)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">mkdir</span><span class="params">(<span class="type">const</span> <span class="type">char</span>*)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">chdir</span><span class="params">(<span class="type">const</span> <span class="type">char</span>*)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">dup</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">getpid</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">char</span>* <span class="title function_">sbrk</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sleep</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">uptime</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">trace</span><span class="params">(<span class="type">int</span>)</span>;		<span class="comment">// HERE</span></span><br></pre></td></tr></table></figure>

<h5 id="2-1-1系统调用全流程"><a href="#2-1-1系统调用全流程" class="headerlink" title="2.1.1系统调用全流程"></a>2.1.1系统调用全流程</h5><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">user/user.h:		用户态程序调用跳板函数 trace()</span><br><span class="line">user/usys.S:		跳板函数 trace() 使用 CPU 提供的 ecall 指令，调用到内核态</span><br><span class="line">kernel/syscall.c	到达内核态统一系统调用处理函数 syscall()，所有系统调用都会跳到这里来处理。</span><br><span class="line">kernel/syscall.c	syscall() 根据跳板传进来的系统调用编号，查询 syscalls[] 表，找到对应的内核函数并调用。</span><br><span class="line">kernel/sysproc.c	到达 sys<span class="built_in">_</span>trace() 函数，执行具体内核操作</span><br></pre></td></tr></table></figure>

<p><code>这么繁琐的调用流程的主要目的是实现用户态和内核态的良好隔离。</code></p>
<p>&#x3D;&#x3D;由于内核与用户进程的页表不同，寄存器也不互通，所以参数无法直接通过 C 语言参数的形式传过来，而是需要使用 argaddr、argint、argstr 等系列函数，从进程的 trapframe 中读取用户进程寄存器中的参数。同时由于页表不同，指针也不能直接互通访问（也就是内核不能直接对用户态传进来的指针进行解引用），而是需要使用 copyin、copyout 方法结合进程的页表，才能顺利找到用户态指针即逻辑地址对应的物理内存地址。&#x3D;&#x3D;</p>
<h5 id="2-1-2Tracing代码"><a href="#2-1-2Tracing代码" class="headerlink" title="2.1.2Tracing代码"></a>2.1.2Tracing代码</h5><p>首先在 proc.h 中修改 proc 结构的定义，添加 syscall_trace field，用 mask 的方式记录要 trace 的 system call。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/proc.h</span></span><br><span class="line"><span class="comment">// Per-process state</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// p-&gt;lock must be held when using these:</span></span><br><span class="line">  <span class="class"><span class="keyword">enum</span> <span class="title">procstate</span> <span class="title">state</span>;</span>        <span class="comment">// Process state</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">parent</span>;</span>         <span class="comment">// Parent process</span></span><br><span class="line">  <span class="type">void</span> *chan;                  <span class="comment">// If non-zero, sleeping on chan</span></span><br><span class="line">  <span class="type">int</span> killed;                  <span class="comment">// If non-zero, have been killed</span></span><br><span class="line">  <span class="type">int</span> xstate;                  <span class="comment">// Exit status to be returned to parent&#x27;s wait</span></span><br><span class="line">  <span class="type">int</span> pid;                     <span class="comment">// Process ID</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// these are private to the process, so p-&gt;lock need not be held.</span></span><br><span class="line">  uint64 kstack;               <span class="comment">// Virtual address of kernel stack</span></span><br><span class="line">  uint64 sz;                   <span class="comment">// Size of process memory (bytes)</span></span><br><span class="line">  <span class="type">pagetable_t</span> pagetable;       <span class="comment">// User page table</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> *<span class="title">trapframe</span>;</span> <span class="comment">// data page for trampoline.S</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">context</span> <span class="title">context</span>;</span>      <span class="comment">// swtch() here to run process</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">ofile</span>[<span class="title">NOFILE</span>];</span>  <span class="comment">// Open files</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">cwd</span>;</span>           <span class="comment">// Current directory</span></span><br><span class="line">  <span class="type">char</span> name[<span class="number">16</span>];               <span class="comment">// Process name (debugging)</span></span><br><span class="line">  uint64 syscall_trace;        <span class="comment">// Mask for syscall tracing (新添加的用于标识追踪哪些 system call 的 mask)</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在 proc.c 中，创建新进程的时候，为新添加的 syscall_trace 附上默认值 0（否则初始状态下可能会有垃圾数据）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/proc.c</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> proc*</span><br><span class="line"><span class="title function_">allocproc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  ......</span><br><span class="line">  <span class="built_in">memset</span>(&amp;p-&gt;context, <span class="number">0</span>, <span class="keyword">sizeof</span>(p-&gt;context));</span><br><span class="line">  p-&gt;context.ra = (uint64)forkret;</span><br><span class="line">  p-&gt;context.sp = p-&gt;kstack + PGSIZE;</span><br><span class="line"></span><br><span class="line">  p-&gt;syscall_trace = <span class="number">0</span>; <span class="comment">// (newly added) 为 syscall_trace 设置一个 0 的默认值</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 sysproc.c 中，实现 system call 的具体代码，也就是设置当前进程的 syscall_trace mask：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/sysproc.c</span></span><br><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_trace</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> mask;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(argint(<span class="number">0</span>, &amp;mask) &lt; <span class="number">0</span>) <span class="comment">// 通过读取进程的 trapframe，获得 mask 参数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  </span><br><span class="line">  myproc()-&gt;syscall_trace = mask; <span class="comment">// 设置调用进程的 syscall_trace mask</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改 fork 函数，使得子进程可以继承父进程的 syscall_trace mask：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/proc.c</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  ......</span><br><span class="line"></span><br><span class="line">  safestrcpy(np-&gt;name, p-&gt;name, <span class="keyword">sizeof</span>(p-&gt;name));</span><br><span class="line"></span><br><span class="line">  np-&gt;syscall_trace = p-&gt;syscall_trace; <span class="comment">// HERE!!! 子进程继承父进程的 syscall_trace</span></span><br><span class="line"></span><br><span class="line">  pid = np-&gt;pid;</span><br><span class="line">  np-&gt;state = RUNNABLE;</span><br><span class="line">  release(&amp;np-&gt;lock);</span><br><span class="line">  <span class="keyword">return</span> pid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据上方提到的系统调用的全流程，可以知道，所有的系统调用到达内核态后，都会进入到 syscall() 这个函数进行处理，所以要跟踪所有的内核函数，只需要在 syscall() 函数里埋点就行了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/syscall.c</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">syscall</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> num;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">  num = p-&gt;trapframe-&gt;a7;</span><br><span class="line">  <span class="keyword">if</span>(num &gt; <span class="number">0</span> &amp;&amp; num &lt; NELEM(syscalls) &amp;&amp; syscalls[num]) &#123; <span class="comment">// 如果系统调用编号有效</span></span><br><span class="line">    p-&gt;trapframe-&gt;a0 = syscalls[num](); <span class="comment">// 通过系统调用编号，获取系统调用处理函数的指针，调用并将返回值存到用户进程的 a0 寄存器中</span></span><br><span class="line">	<span class="comment">// 如果当前进程设置了对该编号系统调用的 trace，则打出 pid、系统调用名称和返回值。</span></span><br><span class="line">    <span class="keyword">if</span>((p-&gt;syscall_trace &gt;&gt; num) &amp; <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d: syscall %s -&gt; %d\n&quot;</span>,p-&gt;pid, syscall_names[num], p-&gt;trapframe-&gt;a0); <span class="comment">// syscall_names[num]: 从 syscall 编号到 syscall 名的映射表</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %s: unknown sys call %d\n&quot;</span>,</span><br><span class="line">            p-&gt;pid, p-&gt;name, num);</span><br><span class="line">    p-&gt;trapframe-&gt;a0 = <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面打出日志的过程还需要知道系统调用的名称字符串，在这里定义一个字符串数组进行映射：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/syscall.c</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *syscall_names[] = &#123;</span><br><span class="line">[SYS_fork]    <span class="string">&quot;fork&quot;</span>,</span><br><span class="line">[SYS_exit]    <span class="string">&quot;exit&quot;</span>,</span><br><span class="line">[SYS_wait]    <span class="string">&quot;wait&quot;</span>,</span><br><span class="line">[SYS_pipe]    <span class="string">&quot;pipe&quot;</span>,</span><br><span class="line">[SYS_read]    <span class="string">&quot;read&quot;</span>,</span><br><span class="line">[SYS_kill]    <span class="string">&quot;kill&quot;</span>,</span><br><span class="line">[SYS_exec]    <span class="string">&quot;exec&quot;</span>,</span><br><span class="line">[SYS_fstat]   <span class="string">&quot;fstat&quot;</span>,</span><br><span class="line">[SYS_chdir]   <span class="string">&quot;chdir&quot;</span>,</span><br><span class="line">[SYS_dup]     <span class="string">&quot;dup&quot;</span>,</span><br><span class="line">[SYS_getpid]  <span class="string">&quot;getpid&quot;</span>,</span><br><span class="line">[SYS_sbrk]    <span class="string">&quot;sbrk&quot;</span>,</span><br><span class="line">[SYS_sleep]   <span class="string">&quot;sleep&quot;</span>,</span><br><span class="line">[SYS_uptime]  <span class="string">&quot;uptime&quot;</span>,</span><br><span class="line">[SYS_open]    <span class="string">&quot;open&quot;</span>,</span><br><span class="line">[SYS_write]   <span class="string">&quot;write&quot;</span>,</span><br><span class="line">[SYS_mknod]   <span class="string">&quot;mknod&quot;</span>,</span><br><span class="line">[SYS_unlink]  <span class="string">&quot;unlink&quot;</span>,</span><br><span class="line">[SYS_link]    <span class="string">&quot;link&quot;</span>,</span><br><span class="line">[SYS_mkdir]   <span class="string">&quot;mkdir&quot;</span>,</span><br><span class="line">[SYS_close]   <span class="string">&quot;close&quot;</span>,</span><br><span class="line">[SYS_trace]   <span class="string">&quot;trace&quot;</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>编译执行：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">trace 32 grep hello README</span></span><br><span class="line">3: syscall read -&gt; 1023</span><br><span class="line">3: syscall read -&gt; 966</span><br><span class="line">3: syscall read -&gt; 70</span><br><span class="line">3: syscall read -&gt; 0</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash">$ trace 2147483647 grep hello README</span></span><br><span class="line">4: syscall trace -&gt; 0</span><br><span class="line">4: syscall exec -&gt; 3</span><br><span class="line">4: syscall open -&gt; 3</span><br><span class="line">4: syscall read -&gt; 1023</span><br><span class="line">4: syscall read -&gt; 966</span><br><span class="line">4: syscall read -&gt; 70</span><br><span class="line">4: syscall read -&gt; 0</span><br><span class="line">4: syscall close -&gt; 0</span><br><span class="line"><span class="meta prompt_">$</span></span><br></pre></td></tr></table></figure>

<p><code>成功追踪并打印出相应的系统调用。</code></p>
<h4 id="2-2Sysinfo-moderate"><a href="#2-2Sysinfo-moderate" class="headerlink" title="2.2Sysinfo (moderate)"></a>2.2Sysinfo (moderate)</h4><blockquote>
<p>In this assignment you will add a system call, sysinfo, that collects information about the running system. The system call takes one argument: a pointer to a struct sysinfo (see kernel&#x2F;sysinfo.h). The kernel should fill out the fields of this struct: the freemem field should be set to the number of bytes of free memory, and the nproc field should be set to the number of processes whose state is not UNUSED. We provide a test program sysinfotest; you pass this assignment if it prints “sysinfotest: OK”.</p>
</blockquote>
<p>添加一个系统调用，返回空闲的内存、以及已创建的进程数量。大多数步骤和上个实验是一样的，所以不再描述。唯一不同就是需要把结构体从内核内存拷贝到用户进程内存中。其他的难点可能就是在如何获取空闲内存和如何获取已创建进程上面了，因为涉及到了一些后面的知识。</p>
<h5 id="2-2-1获取空闲内存"><a href="#2-2-1获取空闲内存" class="headerlink" title="2.2.1获取空闲内存"></a>2.2.1获取空闲内存</h5><p>在内核的头文件中声明计算空闲内存的函数，因为是内存相关的，所以放在 kalloc、kfree 等函数的的声明之后。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/defs.h</span></span><br><span class="line"><span class="type">void</span>*           <span class="title function_">kalloc</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span>            <span class="title function_">kfree</span><span class="params">(<span class="type">void</span> *)</span>;</span><br><span class="line"><span class="type">void</span>            <span class="title function_">kinit</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">uint64 			<span class="title function_">count_free_mem</span><span class="params">(<span class="type">void</span>)</span>; <span class="comment">// here</span></span><br></pre></td></tr></table></figure>

<p>在 kalloc.c 中添加计算空闲内存的函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/kalloc.c</span></span><br><span class="line">uint64</span><br><span class="line"><span class="title function_">count_free_mem</span><span class="params">(<span class="type">void</span>)</span> <span class="comment">// added for counting free memory in bytes (lab2)</span></span><br><span class="line">&#123;</span><br><span class="line">  acquire(&amp;kmem.lock); <span class="comment">// 必须先锁内存管理结构，防止竞态条件出现</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 统计空闲页数，乘上页大小 PGSIZE 就是空闲的内存字节数</span></span><br><span class="line">  uint64 mem_bytes = <span class="number">0</span>;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span> =</span> kmem.freelist;</span><br><span class="line">  <span class="keyword">while</span>(r)&#123;</span><br><span class="line">    mem_bytes += PGSIZE;</span><br><span class="line">    r = r-&gt;next;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  release(&amp;kmem.lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> mem_bytes;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>xv6 中，空闲内存页的记录方式是，将空闲内存页本身直接用作链表节点，形成一个空闲页链表，每次需要分配，就把链表根部对应的页分配出去。每次需要回收，就把这个页作为新的根节点，把原来的 freelist 链表接到后面。注意这里是直接使用空闲页本身作为链表节点，所以不需要使用额外空间来存储空闲页链表，在 kalloc() 里也可以看到，分配内存的最后一个阶段，是直接将 freelist 的根节点的址（物理地址）返回出去了：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/kalloc.c</span></span><br><span class="line"><span class="comment">// Allocate one 4096-byte page of physical memory.</span></span><br><span class="line"><span class="comment">// Returns a pointer that the kernel can use.</span></span><br><span class="line"><span class="comment">// Returns 0 if the memory cannot be allocated.</span></span><br><span class="line"><span class="type">void</span> *</span><br><span class="line"><span class="title function_">kalloc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span>;</span></span><br><span class="line"></span><br><span class="line">  acquire(&amp;kmem.lock);</span><br><span class="line">  r = kmem.freelist; <span class="comment">// 获得空闲页链表的根节点</span></span><br><span class="line">  <span class="keyword">if</span>(r)</span><br><span class="line">    kmem.freelist = r-&gt;next;</span><br><span class="line">  release(&amp;kmem.lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(r)</span><br><span class="line">    <span class="built_in">memset</span>((<span class="type">char</span>*)r, <span class="number">5</span>, PGSIZE); <span class="comment">// fill with junk</span></span><br><span class="line">  <span class="keyword">return</span> (<span class="type">void</span>*)r; <span class="comment">// 把空闲页链表的根节点返回出去，作为内存页使用（长度是 4096）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&#x3D;&#x3D;常见的记录空闲页的方法有：空闲表法、空闲链表法、位示图法（位图法）、成组链接法。&#x3D;&#x3D;这里 xv6 采用的是<code>空闲链表法。</code></p>
<h5 id="2-2-2获取运行的进程数"><a href="#2-2-2获取运行的进程数" class="headerlink" title="2.2.2获取运行的进程数"></a>2.2.2获取运行的进程数</h5><p>同样在内核的头文件中添加函数声明：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/defs.h</span></span><br><span class="line">......</span><br><span class="line"><span class="type">void</span>            <span class="title function_">sleep</span><span class="params">(<span class="type">void</span>*, <span class="keyword">struct</span> spinlock*)</span>;</span><br><span class="line"><span class="type">void</span>            <span class="title function_">userinit</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">int</span>             <span class="title function_">wait</span><span class="params">(uint64)</span>;</span><br><span class="line"><span class="type">void</span>            <span class="title function_">wakeup</span><span class="params">(<span class="type">void</span>*)</span>;</span><br><span class="line"><span class="type">void</span>            <span class="title function_">yield</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">int</span>             <span class="title function_">either_copyout</span><span class="params">(<span class="type">int</span> user_dst, uint64 dst, <span class="type">void</span> *src, uint64 len)</span>;</span><br><span class="line"><span class="type">int</span>             <span class="title function_">either_copyin</span><span class="params">(<span class="type">void</span> *dst, <span class="type">int</span> user_src, uint64 src, uint64 len)</span>;</span><br><span class="line"><span class="type">void</span>            <span class="title function_">procdump</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">uint64			<span class="title function_">count_process</span><span class="params">(<span class="type">void</span>)</span>; <span class="comment">// here</span></span><br></pre></td></tr></table></figure>

<p>在 proc.c 中实现该函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">uint64</span><br><span class="line"><span class="title function_">count_process</span><span class="params">(<span class="type">void</span>)</span> &#123; <span class="comment">// added function for counting used process slots (lab2)</span></span><br><span class="line">  uint64 cnt = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">struct</span> proc *p = proc; p &lt; &amp;proc[NPROC]; p++) &#123;</span><br><span class="line">    <span class="comment">// acquire(&amp;p-&gt;lock);</span></span><br><span class="line">    <span class="comment">// 不需要锁进程 proc 结构，因为我们只需要读取进程列表，不需要写</span></span><br><span class="line">    <span class="keyword">if</span>(p-&gt;state != UNUSED) &#123; <span class="comment">// 不是 UNUSED 的进程位，就是已经分配的</span></span><br><span class="line">        cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-2-3实现-sysinfo-系统调用"><a href="#2-2-3实现-sysinfo-系统调用" class="headerlink" title="2.2.3实现 sysinfo 系统调用"></a>2.2.3实现 sysinfo 系统调用</h5><p>添加系统调用的流程与实验 1 类似，不再赘述。</p>
<p>这是具体系统信息函数的实现，其中调用了前面实现的 count_free_mem() 和 count_process()：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_sysinfo</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 从用户态读入一个指针，作为存放 sysinfo 结构的缓冲区</span></span><br><span class="line">  uint64 addr;</span><br><span class="line">  <span class="keyword">if</span>(argaddr(<span class="number">0</span>, &amp;addr) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sysinfo</span> <span class="title">sinfo</span>;</span></span><br><span class="line">  sinfo.freemem = count_free_mem(); <span class="comment">// kalloc.c</span></span><br><span class="line">  sinfo.nproc = count_process(); <span class="comment">// proc.c</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 使用 copyout，结合当前进程的页表，获得进程传进来的指针（逻辑地址）对应的物理地址</span></span><br><span class="line">  <span class="comment">// 然后将 &amp;sinfo 中的数据复制到该指针所指位置，供用户进程使用。</span></span><br><span class="line">  <span class="keyword">if</span>(copyout(myproc()-&gt;pagetable, addr, (<span class="type">char</span> *)&amp;sinfo, <span class="keyword">sizeof</span>(sinfo)) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 user.h 提供用户态入口：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// user.h</span></span><br><span class="line"><span class="type">char</span>* <span class="title function_">sbrk</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sleep</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">uptime</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">trace</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sysinfo</span>;</span> <span class="comment">// 这里要声明一下 sysinfo 结构，供用户态使用。</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sysinfo</span><span class="params">(<span class="keyword">struct</span> sysinfo *)</span>;</span><br></pre></td></tr></table></figure>

<p>编译运行：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sysinfotest</span></span><br><span class="line">sysinfotest: start</span><br><span class="line">sysinfotest: OK</span><br></pre></td></tr></table></figure>

<h3 id="Lab-3-Page-tables"><a href="#Lab-3-Page-tables" class="headerlink" title="Lab 3: Page tables"></a>Lab 3: Page tables</h3><blockquote>
<p>In this lab you will explore page tables and modify them to simplify the functions that copy data from user space to kernel space.</p>
</blockquote>
<p>探索页表，修改页表以简化从用户态拷贝数据到内核态的方法。</p>
<h4 id="3-1Print-a-page-table-easy"><a href="#3-1Print-a-page-table-easy" class="headerlink" title="3.1Print a page table (easy)"></a>3.1Print a page table (easy)</h4><blockquote>
<p>Define a function called vmprint(). It should take a pagetable_t argument, and print that pagetable in the format described below. Insert if(p-&gt;pid&#x3D;&#x3D;1) vmprint(p-&gt;pagetable) in exec.c just before the return argc, to print the first process’s page table. You receive full credit for this assignment if you pass the pte printout test of make grade.</p>
</blockquote>
<p>添加一个打印页表的内核函数，以如下格式打印出传进的页表，用于后面两个实验调试用：</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">page table 0x0000000087f6e000</span><br><span class="line">..0: pte 0x0000000021fda801 pa 0x0000000087f6a000</span><br><span class="line">.. ..0: pte 0x0000000021fda401 pa 0x0000000087f69000</span><br><span class="line">.. .. ..0: pte 0x0000000021fdac1f pa 0x0000000087f6b000</span><br><span class="line">.. .. ..1: pte 0x0000000021fda00f pa 0x0000000087f68000</span><br><span class="line">.. .. ..2: pte 0x0000000021fd9c1f pa 0x0000000087f67000</span><br><span class="line">..255: pte 0x0000000021fdb401 pa 0x0000000087f6d000</span><br><span class="line">.. ..511: pte 0x0000000021fdb001 pa 0x0000000087f6c000</span><br><span class="line">.. .. ..510: pte 0x0000000021fdd807 pa 0x0000000087f76000</span><br><span class="line">.. .. ..511: pte 0x0000000020001c0b pa 0x0000000080007000</span><br></pre></td></tr></table></figure>

<p>RISC-V 的逻辑地址寻址是采用<code>三级页表</code>的形式，9 bit 一级索引找到二级页表，9 bit 二级索引找到三级页表，9 bit 三级索引找到内存页，最低 12 bit 为页内偏移（即一个页 4096 bytes）。</p>
<p>本函数需要模拟如上的 CPU 查询页表的过程，对三级页表进行遍历，然后按照一定格式输出</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/defs.h</span></span><br><span class="line">......</span><br><span class="line"><span class="type">int</span>             <span class="title function_">copyout</span><span class="params">(<span class="type">pagetable_t</span>, uint64, <span class="type">char</span> *, uint64)</span>;</span><br><span class="line"><span class="type">int</span>             <span class="title function_">copyin</span><span class="params">(<span class="type">pagetable_t</span>, <span class="type">char</span> *, uint64, uint64)</span>;</span><br><span class="line"><span class="type">int</span>             <span class="title function_">copyinstr</span><span class="params">(<span class="type">pagetable_t</span>, <span class="type">char</span> *, uint64, uint64)</span>;</span><br><span class="line"><span class="type">int</span>             <span class="title function_">vmprint</span><span class="params">(<span class="type">pagetable_t</span> pagetable)</span>; <span class="comment">// 添加函数声明</span></span><br></pre></td></tr></table></figure>

<p>因为需要递归打印页表，而 xv6 已经有一个递归释放页表的函数 freewalk()，将其复制一份，并将释放部分代码改为打印即可：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/vm.c</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pgtblprint</span><span class="params">(<span class="type">pagetable_t</span> pagetable, <span class="type">int</span> depth)</span> &#123;</span><br><span class="line">  <span class="comment">// there are 2^9 = 512 PTEs in a page table.</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">512</span>; i++)&#123;</span><br><span class="line">    <span class="type">pte_t</span> pte = pagetable[i];</span><br><span class="line">    <span class="keyword">if</span>(pte &amp; PTE_V) &#123; <span class="comment">// 如果页表项有效</span></span><br><span class="line">      <span class="comment">// 按格式打印页表项</span></span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;..&quot;</span>);</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;depth;j++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; ..&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d: pte %p pa %p\n&quot;</span>, i, pte, PTE2PA(pte));</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果该节点不是叶节点，递归打印其子节点。</span></span><br><span class="line">      <span class="keyword">if</span>((pte &amp; (PTE_R|PTE_W|PTE_X)) == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">// this PTE points to a lower-level page table.</span></span><br><span class="line">        uint64 child = PTE2PA(pte);</span><br><span class="line">        pgtblprint((<span class="type">pagetable_t</span>)child,depth+<span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">vmprint</span><span class="params">(<span class="type">pagetable_t</span> pagetable)</span> &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;page table %p\n&quot;</span>, pagetable);</span><br><span class="line">  <span class="keyword">return</span> pgtblprint(pagetable, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// exec.c</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">exec</span><span class="params">(<span class="type">char</span> *path, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">  vmprint(p-&gt;pagetable); <span class="comment">// 按照实验要求，在 exec 返回之前打印一下页表。</span></span><br><span class="line">  <span class="keyword">return</span> argc; <span class="comment">// this ends up in a0, the first argument to main(argc, argv)</span></span><br><span class="line"></span><br><span class="line"> bad:</span><br><span class="line">  <span class="keyword">if</span>(pagetable)</span><br><span class="line">    proc_freepagetable(pagetable, sz);</span><br><span class="line">  <span class="keyword">if</span>(ip)&#123;</span><br><span class="line">    iunlockput(ip);</span><br><span class="line">    end_op();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-2A-kernel-page-table-per-process-hard"><a href="#3-2A-kernel-page-table-per-process-hard" class="headerlink" title="3.2A kernel page table per process (hard)"></a>3.2A kernel page table per process (hard)</h4><blockquote>
<p>Your first job is to modify the kernel so that every process uses its own copy of the kernel page table when executing in the kernel. Modify struct proc to maintain a kernel page table for each process, and modify the scheduler to switch kernel page tables when switching processes. For this step, each per-process kernel page table should be identical to the existing global kernel page table. You pass this part of the lab if usertests runs correctly.</p>
</blockquote>
<p>xv6 原本的设计是，用户进程在用户态使用各自的用户态页表，但是一旦进入内核态（例如使用了系统调用），则切换到内核页表（通过修改 satp 寄存器，trampoline.S）。然而这个内核页表是全局共享的，也就是全部进程进入内核态都共用同一个内核态页表：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vm.c</span></span><br><span class="line"><span class="type">pagetable_t</span> kernel_pagetable; <span class="comment">// 全局变量，共享的内核页表</span></span><br></pre></td></tr></table></figure>

<p>本 Lab 目标是让每一个进程进入内核态后，都能有自己的独立内核页表，为第三个实验做准备。</p>
<h5 id="3-2-1创建进程内核页表与内核栈"><a href="#3-2-1创建进程内核页表与内核栈" class="headerlink" title="3.2.1创建进程内核页表与内核栈"></a>3.2.1创建进程内核页表与内核栈</h5><p>首先在进程的结构体 proc 中，添加一个 kernelpgtbl，用于存储进程专享的内核态页表。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/proc.h</span></span><br><span class="line"><span class="comment">// Per-process state</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// p-&gt;lock must be held when using these:</span></span><br><span class="line">  <span class="class"><span class="keyword">enum</span> <span class="title">procstate</span> <span class="title">state</span>;</span>        <span class="comment">// Process state</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">parent</span>;</span>         <span class="comment">// Parent process</span></span><br><span class="line">  <span class="type">void</span> *chan;                  <span class="comment">// If non-zero, sleeping on chan</span></span><br><span class="line">  <span class="type">int</span> killed;                  <span class="comment">// If non-zero, have been killed</span></span><br><span class="line">  <span class="type">int</span> xstate;                  <span class="comment">// Exit status to be returned to parent&#x27;s wait</span></span><br><span class="line">  <span class="type">int</span> pid;                     <span class="comment">// Process ID</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// these are private to the process, so p-&gt;lock need not be held.</span></span><br><span class="line">  uint64 kstack;               <span class="comment">// Virtual address of kernel stack</span></span><br><span class="line">  uint64 sz;                   <span class="comment">// Size of process memory (bytes)</span></span><br><span class="line">  <span class="type">pagetable_t</span> pagetable;       <span class="comment">// User page table</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> *<span class="title">trapframe</span>;</span> <span class="comment">// data page for trampoline.S</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">context</span> <span class="title">context</span>;</span>      <span class="comment">// swtch() here to run process</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">ofile</span>[<span class="title">NOFILE</span>];</span>  <span class="comment">// Open files</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">cwd</span>;</span>           <span class="comment">// Current directory</span></span><br><span class="line">  <span class="type">char</span> name[<span class="number">16</span>];               <span class="comment">// Process name (debugging)</span></span><br><span class="line">  <span class="type">pagetable_t</span> kernelpgtbl;     <span class="comment">// Kernel page table （在 proc 中添加该 field）</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>接下来暴改 kvminit。内核需要依赖内核页表内一些固定的映射的存在才能正常工作，例如 UART 控制、硬盘界面、中断控制等。而 kvminit 原本只为全局内核页表 kernel_pagetable 添加这些映射。我们抽象出来一个可以为任何我们自己创建的内核页表添加这些映射的函数 kvm_map_pagetable()。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">kvm_map_pagetable</span><span class="params">(<span class="type">pagetable_t</span> pgtbl)</span> &#123;</span><br><span class="line">  <span class="comment">// 将各种内核需要的 direct mapping 添加到页表 pgtbl 中。</span></span><br><span class="line">  <span class="comment">// uart registers</span></span><br><span class="line">  kvmmap(pgtbl, UART0, UART0, PGSIZE, PTE_R | PTE_W);</span><br><span class="line">  <span class="comment">// virtio mmio disk interface</span></span><br><span class="line">  kvmmap(pgtbl, VIRTIO0, VIRTIO0, PGSIZE, PTE_R | PTE_W);</span><br><span class="line">  <span class="comment">// CLINT</span></span><br><span class="line">  kvmmap(pgtbl, CLINT, CLINT, <span class="number">0x10000</span>, PTE_R | PTE_W);</span><br><span class="line">  <span class="comment">// PLIC</span></span><br><span class="line">  kvmmap(pgtbl, PLIC, PLIC, <span class="number">0x400000</span>, PTE_R | PTE_W);</span><br><span class="line">  <span class="comment">// map kernel text executable and read-only.</span></span><br><span class="line">  kvmmap(pgtbl, KERNBASE, KERNBASE, (uint64)etext-KERNBASE, PTE_R | PTE_X);</span><br><span class="line">  <span class="comment">// map kernel data and the physical RAM we&#x27;ll make use of.</span></span><br><span class="line">  kvmmap(pgtbl, (uint64)etext, (uint64)etext, PHYSTOP-(uint64)etext, PTE_R | PTE_W);</span><br><span class="line">  <span class="comment">// map the trampoline for trap entry/exit to</span></span><br><span class="line">  <span class="comment">// the highest virtual address in the kernel.</span></span><br><span class="line">  kvmmap(pgtbl, TRAMPOLINE, (uint64)trampoline, PGSIZE, PTE_R | PTE_X);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">pagetable_t</span></span><br><span class="line"><span class="title function_">kvminit_newpgtbl</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">pagetable_t</span> pgtbl = (<span class="type">pagetable_t</span>) kalloc();</span><br><span class="line">  <span class="built_in">memset</span>(pgtbl, <span class="number">0</span>, PGSIZE);</span><br><span class="line"></span><br><span class="line">  kvm_map_pagetable(pgtbl);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> pgtbl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * create a direct-map page table for the kernel.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">kvminit</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  kernel_pagetable = kvminit_newpgtbl(); <span class="comment">// 仍然需要有全局的内核页表，用于内核 boot 过程，以及无进程在运行时使用。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将某个逻辑地址映射到某个物理地址（添加第一个参数 pgtbl）</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">kvmmap</span><span class="params">(<span class="type">pagetable_t</span> pgtbl, uint64 va, uint64 pa, uint64 sz, <span class="type">int</span> perm)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(mappages(pgtbl, va, sz, pa, perm) != <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;kvmmap&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// kvmpa 将内核逻辑地址转换为物理地址（添加第一个参数 kernelpgtbl）</span></span><br><span class="line">uint64</span><br><span class="line"><span class="title function_">kvmpa</span><span class="params">(<span class="type">pagetable_t</span> pgtbl, uint64 va)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint64 off = va % PGSIZE;</span><br><span class="line">  <span class="type">pte_t</span> *pte;</span><br><span class="line">  uint64 pa;</span><br><span class="line"></span><br><span class="line">  pte = walk(pgtbl, va, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span>(pte == <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;kvmpa&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span>((*pte &amp; PTE_V) == <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;kvmpa&quot;</span>);</span><br><span class="line">  pa = PTE2PA(*pte);</span><br><span class="line">  <span class="keyword">return</span> pa+off;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<p>现在可以创建进程间相互独立的内核页表了，但是还有一个东西需要处理：内核栈。 原本的 xv6 设计中，所有处于内核态的进程都共享同一个页表，即意味着共享同一个地址空间。由于 xv6 支持多核&#x2F;多进程调度，同一时间可能会有多个进程处于内核态，所以需要对所有处于内核态的进程创建其独立的内核态内的栈，也就是内核栈，供给其内核态代码执行过程。</p>
<p><code>xv6 在启动过程中，会在 procinit() 中为所有可能的 64 个进程位都预分配好内核栈 kstack，具体为在高地址空间里，每个进程使用一个页作为 kstack，并且两个不同 kstack 中间隔着一个无映射的 guard page 用于检测栈溢出错误。</code></p>
<p>在 xv6 原来的设计中，内核页表本来是只有一个的，所有进程共用，所以需要为不同进程创建多个内核栈，并 map 到不同位置（见 procinit() 和 KSTACK 宏）。而我们的新设计中，每一个进程都会有自己独立的内核页表，并且每个进程也只需要访问自己的内核栈，而不需要能够访问所有 64 个进程的内核栈。所以可以将所有进程的内核栈 map 到其<code>各自内核页表内的固定位置</code>（不同页表内的同一逻辑地址，指向不同物理内存）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// initialize the proc table at boot time.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">procinit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line">  </span><br><span class="line">  initlock(&amp;pid_lock, <span class="string">&quot;nextpid&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span>(p = proc; p &lt; &amp;proc[NPROC]; p++) &#123;</span><br><span class="line">      initlock(&amp;p-&gt;lock, <span class="string">&quot;proc&quot;</span>);</span><br><span class="line"><span class="comment">// 这里删除了为所有进程预分配内核栈的代码，变为创建进程的时候再创建内核栈，见 allocproc()</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  kvminithart();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然后，在创建进程的时候，为进程分配独立的内核页表，以及内核栈：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/proc.c</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> proc*</span><br><span class="line"><span class="title function_">allocproc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(p = proc; p &lt; &amp;proc[NPROC]; p++) &#123;</span><br><span class="line">    acquire(&amp;p-&gt;lock);</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;state == UNUSED) &#123;</span><br><span class="line">      <span class="keyword">goto</span> found;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      release(&amp;p-&gt;lock);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">found:</span><br><span class="line">  p-&gt;pid = allocpid();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Allocate a trapframe page.</span></span><br><span class="line">  <span class="keyword">if</span>((p-&gt;trapframe = (<span class="keyword">struct</span> trapframe *)kalloc()) == <span class="number">0</span>)&#123;</span><br><span class="line">    release(&amp;p-&gt;lock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// An empty user page table.</span></span><br><span class="line">  p-&gt;pagetable = proc_pagetable(p);</span><br><span class="line">  <span class="keyword">if</span>(p-&gt;pagetable == <span class="number">0</span>)&#123;</span><br><span class="line">    freeproc(p);</span><br><span class="line">    release(&amp;p-&gt;lock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">////// 新加部分 start //////</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 为新进程创建独立的内核页表，并将内核所需要的各种映射添加到新页表上</span></span><br><span class="line">  p-&gt;kernelpgtbl = kvminit_newpgtbl();</span><br><span class="line">  <span class="comment">// printf(&quot;kernel_pagetable: %p\n&quot;, p-&gt;kernelpgtbl);</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 分配一个物理页，作为新进程的内核栈使用</span></span><br><span class="line">  <span class="type">char</span> *pa = kalloc();</span><br><span class="line">  <span class="keyword">if</span>(pa == <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;kalloc&quot;</span>);</span><br><span class="line">  uint64 va = KSTACK((<span class="type">int</span>)<span class="number">0</span>); <span class="comment">// 将内核栈映射到固定的逻辑地址上</span></span><br><span class="line">  <span class="comment">// printf(&quot;map krnlstack va: %p to pa: %p\n&quot;, va, pa);</span></span><br><span class="line">  kvmmap(p-&gt;kernelpgtbl, va, (uint64)pa, PGSIZE, PTE_R | PTE_W);</span><br><span class="line">  p-&gt;kstack = va; <span class="comment">// 记录内核栈的逻辑地址，其实已经是固定的了，依然这样记录是为了避免需要修改其他部分 xv6 代码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">////// 新加部分 end //////</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Set up new context to start executing at forkret,</span></span><br><span class="line">  <span class="comment">// which returns to user space.</span></span><br><span class="line">  <span class="built_in">memset</span>(&amp;p-&gt;context, <span class="number">0</span>, <span class="keyword">sizeof</span>(p-&gt;context));</span><br><span class="line">  p-&gt;context.ra = (uint64)forkret;</span><br><span class="line">  p-&gt;context.sp = p-&gt;kstack + PGSIZE;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到这里进程独立的内核页表就创建完成了，但是目前只是创建而已，用户进程进入内核态后依然会使用全局共享的内核页表，因此还需要在 scheduler() 中进行相关修改。</p>
<h5 id="3-2-2切换到进程内核页表"><a href="#3-2-2切换到进程内核页表" class="headerlink" title="3.2.2切换到进程内核页表"></a>3.2.2切换到进程内核页表</h5><p>在调度器将 CPU 交给进程执行之前，切换到该进程对应的内核页表：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/proc.c</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">scheduler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">cpu</span> *<span class="title">c</span> =</span> mycpu();</span><br><span class="line">  </span><br><span class="line">  c-&gt;proc = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">    <span class="comment">// Avoid deadlock by ensuring that devices can interrupt.</span></span><br><span class="line">    intr_on();</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> found = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(p = proc; p &lt; &amp;proc[NPROC]; p++) &#123;</span><br><span class="line">      acquire(&amp;p-&gt;lock);</span><br><span class="line">      <span class="keyword">if</span>(p-&gt;state == RUNNABLE) &#123;</span><br><span class="line">        <span class="comment">// Switch to chosen process.  It is the process&#x27;s job</span></span><br><span class="line">        <span class="comment">// to release its lock and then reacquire it</span></span><br><span class="line">        <span class="comment">// before jumping back to us.</span></span><br><span class="line">        p-&gt;state = RUNNING;</span><br><span class="line">        c-&gt;proc = p;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 切换到进程独立的内核页表</span></span><br><span class="line">        w_satp(MAKE_SATP(p-&gt;kernelpgtbl));</span><br><span class="line">        sfence_vma(); <span class="comment">// 清除快表缓存</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 调度，执行进程</span></span><br><span class="line">        swtch(&amp;c-&gt;context, &amp;p-&gt;context);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 切换回全局内核页表</span></span><br><span class="line">        kvminithart();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Process is done running for now.</span></span><br><span class="line">        <span class="comment">// It should have changed its p-&gt;state before coming back.</span></span><br><span class="line">        c-&gt;proc = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        found = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      release(&amp;p-&gt;lock);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> !defined (LAB_FS)</span></span><br><span class="line">    <span class="keyword">if</span>(found == <span class="number">0</span>) &#123;</span><br><span class="line">      intr_on();</span><br><span class="line">      <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;wfi&quot;</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    ;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>到这里，每个进程执行的时候，就都会在内核态采用自己独立的内核页表了。</p>
<h5 id="3-2-3释放进程内核页表"><a href="#3-2-3释放进程内核页表" class="headerlink" title="3.2.3释放进程内核页表"></a>3.2.3释放进程内核页表</h5><p>最后需要做的事情就是在进程结束后，应该释放进程独享的页表以及内核栈，回收资源，否则会导致内存泄漏。</p>
<p>如果 usertests 在 reparent2 的时候出现了 <code>panic: kvmmap</code>，大概率是因为大量内存泄漏消耗完了内存，导致 kvmmap 分配页表项所需内存失败，这时候应该检查是否正确释放了每一处分配的内存，尤其是页表是否每个页表项都释放干净了。 </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// kernel/proc.c</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">freeproc</span><span class="params">(<span class="keyword">struct</span> proc *p)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(p-&gt;trapframe)</span><br><span class="line">    kfree((<span class="type">void</span>*)p-&gt;trapframe);</span><br><span class="line">  p-&gt;trapframe = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span>(p-&gt;pagetable)</span><br><span class="line">    proc_freepagetable(p-&gt;pagetable, p-&gt;sz);</span><br><span class="line">  p-&gt;pagetable = <span class="number">0</span>;</span><br><span class="line">  p-&gt;sz = <span class="number">0</span>;</span><br><span class="line">  p-&gt;pid = <span class="number">0</span>;</span><br><span class="line">  p-&gt;parent = <span class="number">0</span>;</span><br><span class="line">  p-&gt;name[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  p-&gt;chan = <span class="number">0</span>;</span><br><span class="line">  p-&gt;killed = <span class="number">0</span>;</span><br><span class="line">  p-&gt;xstate = <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 释放进程的内核栈</span></span><br><span class="line">  <span class="type">void</span> *kstack_pa = (<span class="type">void</span> *)kvmpa(p-&gt;kernelpgtbl, p-&gt;kstack);</span><br><span class="line">  <span class="comment">// printf(&quot;trace: free kstack %p\n&quot;, kstack_pa);</span></span><br><span class="line">  kfree(kstack_pa);</span><br><span class="line">  p-&gt;kstack = <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 注意：此处不能使用 proc_freepagetable，因为其不仅会释放页表本身，还会把页表内所有的叶节点对应的物理页也释放掉。</span></span><br><span class="line">  <span class="comment">// 这会导致内核运行所需要的关键物理页被释放，从而导致内核崩溃。</span></span><br><span class="line">  <span class="comment">// 这里使用 kfree(p-&gt;kernelpgtbl) 也是不足够的，因为这只释放了一级页表本身，而不释放二级以及三级页表所占用的空间。</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 递归释放进程独享的页表，释放页表本身所占用的空间，但**不释放页表指向的物理页**</span></span><br><span class="line">  kvm_free_kernelpgtbl(p-&gt;kernelpgtbl);</span><br><span class="line">  p-&gt;kernelpgtbl = <span class="number">0</span>;</span><br><span class="line">  p-&gt;state = UNUSED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>kvm_free_kernelpgtbl() 用于递归释放整个多级页表树，也是从 freewalk() 修改而来。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/vm.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归释放一个内核页表中的所有 mapping，但是不释放其指向的物理页</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">kvm_free_kernelpgtbl</span><span class="params">(<span class="type">pagetable_t</span> pagetable)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// there are 2^9 = 512 PTEs in a page table.</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">512</span>; i++)&#123;</span><br><span class="line">    <span class="type">pte_t</span> pte = pagetable[i];</span><br><span class="line">    uint64 child = PTE2PA(pte);</span><br><span class="line">    <span class="keyword">if</span>((pte &amp; PTE_V) &amp;&amp; (pte &amp; (PTE_R|PTE_W|PTE_X)) == <span class="number">0</span>)&#123; <span class="comment">// 如果该页表项指向更低一级的页表</span></span><br><span class="line">      <span class="comment">// 递归释放低一级页表及其页表项</span></span><br><span class="line">      kvm_free_kernelpgtbl((<span class="type">pagetable_t</span>)child);</span><br><span class="line">      pagetable[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  kfree((<span class="type">void</span>*)pagetable); <span class="comment">// 释放当前级别页表所占用空间</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里释放部分就实现完成了。</p>
<p>注意到我们的修改影响了其他代码： virtio 磁盘驱动 virtio_disk.c 中调用了 kvmpa() 用于将虚拟地址转换为物理地址，这一操作在我们修改后的版本中，需要传入进程的内核页表。对应修改即可。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// virtio_disk.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;proc.h&quot;</span> <span class="comment">// 添加头文件引入</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">virtio_disk_rw</span><span class="params">(<span class="keyword">struct</span> buf *b, <span class="type">int</span> write)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line">disk.desc[idx[<span class="number">0</span>]].addr = (uint64) kvmpa(myproc()-&gt;kernelpgtbl, (uint64) &amp;buf0); <span class="comment">// 调用 myproc()，获取进程内核页表</span></span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-3Simplify-copyin-x2F-copyinstr-hard"><a href="#3-3Simplify-copyin-x2F-copyinstr-hard" class="headerlink" title="3.3Simplify copyin&#x2F;copyinstr (hard)"></a>3.3Simplify copyin&#x2F;copyinstr (hard)</h4><blockquote>
<p>Replace the body of copyin in kernel&#x2F;vm.c with a call to copyin_new (defined in kernel&#x2F;vmcopyin.c); do the same for copyinstr and copyinstr_new. Add mappings for user addresses to each process’s kernel page table so that copyin_new and copyinstr_new work. You pass this assignment if usertests runs correctly and all the make grade tests pass.</p>
</blockquote>
<p>在上一个实验中，已经使得每一个进程都拥有独立的内核态页表了，这个实验的目标是，<code>在进程的内核态页表中维护一个用户态页表映射的副本，这样使得内核态也可以对用户态传进来的指针（逻辑地址）进行解引用。</code>这样做相比原来 copyin 的实现的优势是，&#x3D;&#x3D;原来的 copyin 是通过软件模拟访问页表的过程获取物理地址的，而在内核页表内维护映射副本的话，可以利用 CPU 的硬件寻址功能进行寻址，效率更高并且可以受快表加速。&#x3D;&#x3D;</p>
<blockquote>
<p>要实现这样的效果，我们需要在每一处内核对用户页表进行修改的时候，将同样的修改也同步应用在进程的内核页表上，使得两个页表的程序段（0 到 PLIC 段）地址空间的映射同步。</p>
</blockquote>
<h5 id="3-3-1准备页表映射转换的工具方法"><a href="#3-3-1准备页表映射转换的工具方法" class="headerlink" title="3.3.1准备页表映射转换的工具方法"></a>3.3.1准备页表映射转换的工具方法</h5><p>首先实现一些工具方法，多数是参考现有方法改造得来：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/vm.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 注：需要在 defs.h 中添加相应的函数声明，这里省略。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 src 页表的一部分页映射关系拷贝到 dst 页表中。</span></span><br><span class="line"><span class="comment">// 只拷贝页表项，不拷贝实际的物理页内存。</span></span><br><span class="line"><span class="comment">// 成功返回0，失败返回 -1</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">kvmcopymappings</span><span class="params">(<span class="type">pagetable_t</span> src, <span class="type">pagetable_t</span> dst, uint64 start, uint64 sz)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">pte_t</span> *pte;</span><br><span class="line">  uint64 pa, i;</span><br><span class="line">  uint flags;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// PGROUNDUP: prevent re-mapping already mapped pages (eg. when doing growproc)</span></span><br><span class="line">  <span class="keyword">for</span>(i = PGROUNDUP(start); i &lt; start + sz; i += PGSIZE)&#123;</span><br><span class="line">    <span class="keyword">if</span>((pte = walk(src, i, <span class="number">0</span>)) == <span class="number">0</span>)</span><br><span class="line">      panic(<span class="string">&quot;kvmcopymappings: pte should exist&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>((*pte &amp; PTE_V) == <span class="number">0</span>)</span><br><span class="line">      panic(<span class="string">&quot;kvmcopymappings: page not present&quot;</span>);</span><br><span class="line">    pa = PTE2PA(*pte);</span><br><span class="line">    <span class="comment">// `&amp; ~PTE_U` 表示将该页的权限设置为非用户页</span></span><br><span class="line">    <span class="comment">// 必须设置该权限，RISC-V 中内核是无法直接访问用户页的。</span></span><br><span class="line">    flags = PTE_FLAGS(*pte) &amp; ~PTE_U;</span><br><span class="line">    <span class="keyword">if</span>(mappages(dst, i, PGSIZE, pa, flags) != <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="keyword">goto</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"> err:</span><br><span class="line">  <span class="comment">// thanks @hdrkna for pointing out a mistake here.</span></span><br><span class="line">  <span class="comment">// original code incorrectly starts unmapping from 0 instead of PGROUNDUP(start)</span></span><br><span class="line">  uvmunmap(dst, PGROUNDUP(start), (i - PGROUNDUP(start)) / PGSIZE, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 与 uvmdealloc 功能类似，将程序内存从 oldsz 缩减到 newsz。但区别在于不释放实际内存</span></span><br><span class="line"><span class="comment">// 用于内核页表内程序内存映射与用户页表程序内存映射之间的同步</span></span><br><span class="line">uint64</span><br><span class="line"><span class="title function_">kvmdealloc</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 oldsz, uint64 newsz)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(newsz &gt;= oldsz)</span><br><span class="line">    <span class="keyword">return</span> oldsz;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(PGROUNDUP(newsz) &lt; PGROUNDUP(oldsz))&#123;</span><br><span class="line">    <span class="type">int</span> npages = (PGROUNDUP(oldsz) - PGROUNDUP(newsz)) / PGSIZE;</span><br><span class="line">    uvmunmap(pagetable, PGROUNDUP(newsz), npages, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> newsz;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>接下来，为映射程序内存做准备。实验中提示内核启动后，能够用于映射程序内存的地址范围是 [0,PLIC)，我们将把进程程序内存映射到其内核页表的这个范围内，<code>首先要确保这个范围没有和其他映射冲突。</code></p>
<p>查阅 xv6 book 可以看到，在 PLIC 之前还有一个 CLINT（核心本地中断器）的映射，该映射会与我们要 map 的程序内存冲突。<code>查阅 xv6 book 的 Chapter 5 以及 start.c 可以知道 CLINT 仅在内核启动的时候需要使用到，而用户进程在内核态中的操作并不需要使用到该映射。</code></p>
<p><img src="/../../../../../../imgs/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%BA%90%E7%A0%81%E7%BA%A7%E5%89%96%E6%9E%90/image-20221119142053545.png" alt="image-20221119142053545"></p>
<p><code>所以修改 kvm_map_pagetable()，去除 CLINT 的映射，这样进程内核页表就不会有 CLINT 与程序内存映射冲突的问题。但是由于全局内核页表也使用了 kvm_map_pagetable() 进行初始化，并且内核启动的时候需要 CLINT 映射存在，故在 kvminit() 中，另外单独给全局内核页表映射 CLINT。</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/vm.c</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">kvm_map_pagetable</span><span class="params">(<span class="type">pagetable_t</span> pgtbl)</span> &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// uart registers</span></span><br><span class="line">  kvmmap(pgtbl, UART0, UART0, PGSIZE, PTE_R | PTE_W);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// virtio mmio disk interface</span></span><br><span class="line">  kvmmap(pgtbl, VIRTIO0, VIRTIO0, PGSIZE, PTE_R | PTE_W);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// CLINT</span></span><br><span class="line">  <span class="comment">// kvmmap(pgtbl, CLINT, CLINT, 0x10000, PTE_R | PTE_W);</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// PLIC</span></span><br><span class="line">  kvmmap(pgtbl, PLIC, PLIC, <span class="number">0x400000</span>, PTE_R | PTE_W);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">kvminit</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  kernel_pagetable = kvminit_newpgtbl();</span><br><span class="line">  <span class="comment">// CLINT *is* however required during kernel boot up and</span></span><br><span class="line">  <span class="comment">// we should map it for the global kernel pagetable</span></span><br><span class="line">  kvmmap(kernel_pagetable, CLINT, CLINT, <span class="number">0x10000</span>, PTE_R | PTE_W);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同时在 exec 中加入检查，防止程序内存超过 PLIC：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"> <span class="type">int</span></span><br><span class="line"><span class="title function_">exec</span><span class="params">(<span class="type">char</span> *path, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Load program into memory.</span></span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>, off=elf.phoff; i&lt;elf.phnum; i++, off+=<span class="keyword">sizeof</span>(ph))&#123;</span><br><span class="line">    <span class="keyword">if</span>(readi(ip, <span class="number">0</span>, (uint64)&amp;ph, off, <span class="keyword">sizeof</span>(ph)) != <span class="keyword">sizeof</span>(ph))</span><br><span class="line">      <span class="keyword">goto</span> bad;</span><br><span class="line">    <span class="keyword">if</span>(ph.type != ELF_PROG_LOAD)</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">if</span>(ph.memsz &lt; ph.filesz)</span><br><span class="line">      <span class="keyword">goto</span> bad;</span><br><span class="line">    <span class="keyword">if</span>(ph.vaddr + ph.memsz &lt; ph.vaddr)</span><br><span class="line">      <span class="keyword">goto</span> bad;</span><br><span class="line">    uint64 sz1;</span><br><span class="line">    <span class="keyword">if</span>((sz1 = uvmalloc(pagetable, sz, ph.vaddr + ph.memsz)) == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">goto</span> bad;</span><br><span class="line">    <span class="keyword">if</span>(sz1 &gt;= PLIC) &#123; <span class="comment">// 添加检测，防止程序大小超过 PLIC</span></span><br><span class="line">      <span class="keyword">goto</span> bad;</span><br><span class="line">    &#125;</span><br><span class="line">    sz = sz1;</span><br><span class="line">    <span class="keyword">if</span>(ph.vaddr % PGSIZE != <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">goto</span> bad;</span><br><span class="line">    <span class="keyword">if</span>(loadseg(pagetable, ph.vaddr, ip, ph.off, ph.filesz) &lt; <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">goto</span> bad;</span><br><span class="line">  &#125;</span><br><span class="line">  iunlockput(ip);</span><br><span class="line">  end_op();</span><br><span class="line">  ip = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// .......</span></span><br></pre></td></tr></table></figure>

<h5 id="3-3-2同步映射用户页表和用户内核页表"><a href="#3-3-2同步映射用户页表和用户内核页表" class="headerlink" title="3.3.2同步映射用户页表和用户内核页表"></a>3.3.2同步映射用户页表和用户内核页表</h5><p>后面的步骤就是在每个修改到进程用户页表的位置，都将相应的修改同步到进程内核页表中。一共要修改：fork()、exec()、growproc()、userinit()。</p>
<p>fork()</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// kernel/proc.c</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Copy user memory from parent to child. （调用 kvmcopymappings，将新进程用户页表映射拷贝一份到新进程内核页表中）</span></span><br><span class="line">  <span class="keyword">if</span>(uvmcopy(p-&gt;pagetable, np-&gt;pagetable, p-&gt;sz) &lt; <span class="number">0</span> ||</span><br><span class="line">     kvmcopymappings(np-&gt;pagetable, np-&gt;kernelpgtbl, <span class="number">0</span>, p-&gt;sz) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    freeproc(np);</span><br><span class="line">    release(&amp;np-&gt;lock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  np-&gt;sz = p-&gt;sz;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>exec()</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// kernel/exec.c</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">exec</span><span class="params">(<span class="type">char</span> *path, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Save program name for debugging.</span></span><br><span class="line">  <span class="keyword">for</span>(last=s=path; *s; s++)</span><br><span class="line">    <span class="keyword">if</span>(*s == <span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">      last = s+<span class="number">1</span>;</span><br><span class="line">  safestrcpy(p-&gt;name, last, <span class="keyword">sizeof</span>(p-&gt;name));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 清除内核页表中对程序内存的旧映射，然后重新建立映射。</span></span><br><span class="line">  uvmunmap(p-&gt;kernelpgtbl, <span class="number">0</span>, PGROUNDUP(oldsz)/PGSIZE, <span class="number">0</span>);</span><br><span class="line">  kvmcopymappings(pagetable, p-&gt;kernelpgtbl, <span class="number">0</span>, sz);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// Commit to the user image.</span></span><br><span class="line">  oldpagetable = p-&gt;pagetable;</span><br><span class="line">  p-&gt;pagetable = pagetable;</span><br><span class="line">  p-&gt;sz = sz;</span><br><span class="line">  p-&gt;trapframe-&gt;epc = elf.entry;  <span class="comment">// initial program counter = main</span></span><br><span class="line">  p-&gt;trapframe-&gt;sp = sp; <span class="comment">// initial stack pointer</span></span><br><span class="line">  proc_freepagetable(oldpagetable, oldsz);</span><br><span class="line">  <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>growproc()</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/proc.c</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">growproc</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint sz;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">  sz = p-&gt;sz;</span><br><span class="line">  <span class="keyword">if</span>(n &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    uint64 newsz;</span><br><span class="line">    <span class="keyword">if</span>((newsz = uvmalloc(p-&gt;pagetable, sz, sz + n)) == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 内核页表中的映射同步扩大</span></span><br><span class="line">    <span class="keyword">if</span>(kvmcopymappings(p-&gt;pagetable, p-&gt;kernelpgtbl, sz, n) != <span class="number">0</span>) &#123;</span><br><span class="line">      uvmdealloc(p-&gt;pagetable, newsz, sz);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    sz = newsz;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>(n &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    uvmdealloc(p-&gt;pagetable, sz, sz + n);</span><br><span class="line">    <span class="comment">// 内核页表中的映射同步缩小</span></span><br><span class="line">    sz = kvmdealloc(p-&gt;kernelpgtbl, sz, sz + n);</span><br><span class="line">  &#125;</span><br><span class="line">  p-&gt;sz = sz;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>userinit()</p>
<p>对于 init 进程，由于不像其他进程，init 不是 fork 得来的，所以需要在 userinit 中也添加同步映射的代码。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/proc.c</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">userinit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// allocate one user page and copy init&#x27;s instructions</span></span><br><span class="line">  <span class="comment">// and data into it.</span></span><br><span class="line">  uvminit(p-&gt;pagetable, initcode, <span class="keyword">sizeof</span>(initcode));</span><br><span class="line">  p-&gt;sz = PGSIZE;</span><br><span class="line">  kvmcopymappings(p-&gt;pagetable, p-&gt;kernelpgtbl, <span class="number">0</span>, p-&gt;sz); <span class="comment">// 同步程序内存映射到进程内核页表中</span></span><br><span class="line">  <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到这里，两个页表的同步操作就都完成了。</p>
<h5 id="3-3-3替换-copyin、copyinstr-实现"><a href="#3-3-3替换-copyin、copyinstr-实现" class="headerlink" title="3.3.3替换 copyin、copyinstr 实现"></a>3.3.3替换 copyin、copyinstr 实现</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/vm.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明新函数原型</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">copyin_new</span><span class="params">(<span class="type">pagetable_t</span> pagetable, <span class="type">char</span> *dst, uint64 srcva, uint64 len)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">copyinstr_new</span><span class="params">(<span class="type">pagetable_t</span> pagetable, <span class="type">char</span> *dst, uint64 srcva, uint64 max)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 copyin、copyinstr 改为转发到新函数</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">copyin</span><span class="params">(<span class="type">pagetable_t</span> pagetable, <span class="type">char</span> *dst, uint64 srcva, uint64 len)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> copyin_new(pagetable, dst, srcva, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">copyinstr</span><span class="params">(<span class="type">pagetable_t</span> pagetable, <span class="type">char</span> *dst, uint64 srcva, uint64 max)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> copyinstr_new(pagetable, dst, srcva, max);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Lab-4-Traps"><a href="#Lab-4-Traps" class="headerlink" title="Lab 4: Traps"></a>Lab 4: Traps</h3><blockquote>
<p>This lab explores how system calls are implemented using traps. You will first do a warm-up exercises with stacks and then you will implement an example of user-level trap handling.</p>
</blockquote>
<p>探索 trap 实现系统调用的方式。</p>
<p>注意本部分主要内容其实都在lecture里（lecture 5、lecture 6），实验不是非常复杂但是以理解概念为重，trap机制、trampoline作用、函数calling convention、调用栈、特权模式、riscv汇编，这些即使都不知道可能依然能完成 lab。但是不代表这些不重要，相反这些才是主要内容，否则 lab 就算跑起来也只是盲狙，没有真正达到学习效果。</p>
<h4 id="4-1RISC-V-assembly-easy"><a href="#4-1RISC-V-assembly-easy" class="headerlink" title="4.1RISC-V assembly (easy)"></a>4.1RISC-V assembly (easy)</h4><p>It will be important to understand a bit of RISC-V assembly, which you were exposed to in 6.004. There is a file user&#x2F;call.c in your xv6 repo. make fs.img compiles it and also produces a readable assembly version of the program in user&#x2F;call.asm.</p>
<blockquote>
<p>Read the code in call.asm for the functions g, f, and main. The instruction manual for RISC-V is on the reference page. Here are some questions that you should answer (store the answers in a file answers-traps.txt)</p>
</blockquote>
<p>阅读 call.asm，以及 RISC-V 指令集教程，回答问题。（学习 RISC-V 汇编）</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">Q: Which registers contain arguments to functions? For example, which register holds 13 in main&#x27;s call to printf?</span><br><span class="line">A: a0-a7; a2;</span><br><span class="line"></span><br><span class="line">Q: Where is the call to function f in the assembly code for main? Where is the call to g? (Hint: the compiler may inline functions.)</span><br><span class="line">A: There is none. g(x) is inlined within f(x) and f(x) is further inlined into main()</span><br><span class="line"></span><br><span class="line">Q: At what address is the function printf located?</span><br><span class="line">A: 0x0000000000000628, main calls it with pc-relative addressing.</span><br><span class="line"></span><br><span class="line">Q: What value is in the register ra just after the jalr to printf in main?</span><br><span class="line">A: 0x0000000000000038, next line of assembly right after the jalr</span><br><span class="line"></span><br><span class="line">Q: Run the following code.</span><br><span class="line"></span><br><span class="line">	unsigned int i = 0x00646c72;</span><br><span class="line">	printf(&quot;H<span class="comment">%x Wo%s&quot;, 57616, &amp;i);      </span></span><br><span class="line"></span><br><span class="line">What is the output?</span><br><span class="line">If the RISC-V were instead big-endian what would you set i to in order to yield the same output?</span><br><span class="line">Would you need to change 57616 to a different value?</span><br><span class="line">A: &quot;He110 World&quot;; 0x726c6400; no, 57616 is 110 in hex regardless of endianness.</span><br><span class="line"></span><br><span class="line">Q: In the following code, what is going to be printed after &#x27;y=&#x27;? (note: the answer is not a specific value.) Why does this happen?</span><br><span class="line"></span><br><span class="line">	printf(&quot;x=<span class="comment">%d y=%d&quot;, 3);</span></span><br><span class="line"></span><br><span class="line">A: A random value depending on what codes there are right before the call.Because printf tried to read more arguments than supplied.</span><br><span class="line">The second argument `3` is passed in a1, and the register for the third argument, a2, is not set to any specific value before the</span><br><span class="line">call, and contains whatever there is before the call.</span><br></pre></td></tr></table></figure>

<p>简单翻译：</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">Q: 哪些寄存器存储了函数调用的参数？举个例子，main 调用 printf 的时候，13 被存在了哪个寄存器中？</span><br><span class="line">A: a0-a7; a2;</span><br><span class="line"></span><br><span class="line">Q: main 中调用函数 f 对应的汇编代码在哪？对 g 的调用呢？ (提示：编译器有可能会内链(inline)一些函数)</span><br><span class="line">A: 没有这样的代码。 g(x) 被内链到 f(x) 中，然后 f(x) 又被进一步内链到 main() 中</span><br><span class="line"></span><br><span class="line">Q: printf 函数所在的地址是？</span><br><span class="line">A: 0x0000000000000628, main 中使用 pc 相对寻址来计算得到这个地址。</span><br><span class="line"></span><br><span class="line">Q: 在 main 中 jalr 跳转到 printf 之后，ra 的值是什么？</span><br><span class="line">A: 0x0000000000000038, jalr 指令的下一条汇编指令的地址。</span><br><span class="line"></span><br><span class="line">Q: 运行下面的代码</span><br><span class="line"></span><br><span class="line">	unsigned int i = 0x00646c72;</span><br><span class="line">	printf(&quot;H<span class="comment">%x Wo%s&quot;, 57616, &amp;i);      </span></span><br><span class="line"></span><br><span class="line">输出是什么？</span><br><span class="line">如果 RISC-V 是大端序的，要实现同样的效果，需要将 i 设置为什么？需要将 57616 修改为别的值吗？</span><br><span class="line">A: &quot;He110 World&quot;; 0x726c6400; 不需要，57616 的十六进制是 110，无论端序（十六进制和内存中的表示不是同个概念）</span><br><span class="line"></span><br><span class="line">Q: 在下面的代码中，&#x27;y=&#x27; 之后会答应什么？ (note: 答案不是一个具体的值) 为什么?</span><br><span class="line"></span><br><span class="line">	printf(&quot;x=<span class="comment">%d y=%d&quot;, 3);</span></span><br><span class="line"></span><br><span class="line">A: 输出的是一个受调用前的代码影响的“随机”的值。因为 printf 尝试读的参数数量比提供的参数数量多。</span><br><span class="line">第二个参数 `3` 通过 a1 传递，而第三个参数对应的寄存器 a2 在调用前不会被设置为任何具体的值，而是会</span><br><span class="line">包含调用发生前的任何已经在里面的值。</span><br></pre></td></tr></table></figure>

<h4 id="4-2Backtrace-moderate"><a href="#4-2Backtrace-moderate" class="headerlink" title="4.2Backtrace (moderate)"></a>4.2Backtrace (moderate)</h4><p>For debugging it is often useful to have a backtrace: a list of the function calls on the stack above the point at which the error occurred.</p>
<blockquote>
<p>Implement a backtrace() function in kernel&#x2F;printf.c. Insert a call to this function in sys_sleep, and then run bttest, which calls sys_sleep. Your output should be as follows:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">backtrace: 0x0000000080002cda 0x0000000080002bb6 0x0000000080002898 </span><br></pre></td></tr></table></figure>

<p>After bttest exit qemu. In your terminal: the addresses may be slightly different but if you run addr2line -e kernel&#x2F;kernel (or riscv64-unknown-elf-addr2line -e kernel&#x2F;kernel) and cut-and-paste the above addresses as follows:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ addr2line -e kernel/kernel 0x0000000080002de2 0x0000000080002f4a 0x0000000080002bfc Ctrl-D </span><br></pre></td></tr></table></figure>

<p>You should see something like this:</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kernel/sysproc.c:74 kernel/syscall.c:224 kernel/trap.c:85</span><br></pre></td></tr></table></figure>
</blockquote>
<p>添加 backtrace 功能，打印出调用栈，用于调试。</p>
<p>在 defs.h 中添加声明</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// defs.h</span></span><br><span class="line"><span class="type">void</span>            <span class="title function_">printf</span><span class="params">(<span class="type">char</span>*, ...)</span>;</span><br><span class="line"><span class="type">void</span>            <span class="title function_">panic</span><span class="params">(<span class="type">char</span>*)</span> __<span class="title function_">attribute__</span><span class="params">((<span class="keyword">noreturn</span>))</span>;</span><br><span class="line"><span class="type">void</span>            <span class="title function_">printfinit</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span>            <span class="title function_">backtrace</span><span class="params">(<span class="type">void</span>)</span>; <span class="comment">// new</span></span><br></pre></td></tr></table></figure>

<p>在 riscv.h 中添加获取当前 fp（frame pointer）寄存器的方法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// riscv.h</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> uint64</span><br><span class="line"><span class="title function_">r_fp</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  uint64 x;</span><br><span class="line">  <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;mv %0, s0&quot;</span> : <span class="string">&quot;=r&quot;</span> (x))</span>;</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>fp 指向当前栈帧的开始地址，sp 指向当前栈帧的结束地址。 （栈从高地址往低地址生长，所以 fp 虽然是帧开始地址，但是地址比 sp 高）<br>栈帧中从高到低第一个 8 字节 <code>fp-8</code> 是 return address，也就是当前调用层应该返回到的地址。<br>栈帧中从高到低第二个 8 字节 <code>fp-16</code> 是 previous address，指向上一层栈帧的 fp 开始地址。<br>剩下的为保存的寄存器、局部变量等。一个栈帧的大小不固定，但是至少 16 字节。<br>在 xv6 中，使用一个页来存储栈，如果 fp 已经到达栈页的上界，则说明已经到达栈底。</p>
<p>查看 call.asm，可以看到，一个函数的函数体最开始首先会扩充一个栈帧给该层调用使用，在函数执行完毕后再回收，例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">g</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">   <span class="number">0</span>:	<span class="number">1141</span>                  addi  sp,sp,<span class="number">-16</span>  <span class="comment">// 扩张调用栈，得到一个 16 字节的栈帧</span></span><br><span class="line">   <span class="number">2</span>:	e422                  sd    s0,<span class="number">8</span>(sp)   <span class="comment">// 将返回地址存到栈帧的第一个 8 字节中</span></span><br><span class="line">   <span class="number">4</span>:	<span class="number">0800</span>                  addi  s0,sp,<span class="number">16</span></span><br><span class="line">  <span class="keyword">return</span> x+<span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line">   <span class="number">6</span>:	<span class="number">250</span>d                  addiw a0,a0,<span class="number">3</span></span><br><span class="line">   <span class="number">8</span>:	<span class="number">6422</span>                  ld    s0,<span class="number">8</span>(sp)   <span class="comment">// 从栈帧读出返回地址</span></span><br><span class="line">   a:	<span class="number">0141</span>                  addi  sp,sp,<span class="number">16</span>   <span class="comment">// 回收栈帧</span></span><br><span class="line">   c:	<span class="number">8082</span>                  ret              <span class="comment">// 返回</span></span><br></pre></td></tr></table></figure>

<p>注意栈的生长方向是从高地址到低地址，所以扩张是 -16，而回收是 +16。</p>
<p>实现 backtrace 函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// printf.c</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">backtrace</span><span class="params">()</span> &#123;</span><br><span class="line">  uint64 fp = r_fp();</span><br><span class="line">  <span class="keyword">while</span>(fp != PGROUNDUP(fp)) &#123; <span class="comment">// 如果已经到达栈底</span></span><br><span class="line">    uint64 ra = *(uint64*)(fp - <span class="number">8</span>); <span class="comment">// return address</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, ra);</span><br><span class="line">    fp = *(uint64*)(fp - <span class="number">16</span>); <span class="comment">// previous fp</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 sys_sleep 的开头调用一次 backtrace()</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sysproc.c</span></span><br><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_sleep</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line">  uint ticks0;</span><br><span class="line"></span><br><span class="line">  backtrace(); <span class="comment">// print stack backtrace.</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(argint(<span class="number">0</span>, &amp;n) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译运行：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">bttest</span></span><br><span class="line">0x0000000080002dea</span><br><span class="line">0x0000000080002cc4</span><br><span class="line">0x00000000800028d0</span><br></pre></td></tr></table></figure>

<h4 id="4-3Alarm-hard"><a href="#4-3Alarm-hard" class="headerlink" title="4.3Alarm (hard)"></a>4.3Alarm (hard)</h4><blockquote>
<p>In this exercise you’ll add a feature to xv6 that periodically alerts a process as it uses CPU time. This might be useful for compute-bound processes that want to limit how much CPU time they chew up, or for processes that want to compute but also want to take some periodic action. More generally, you’ll be implementing a primitive form of user-level interrupt&#x2F;fault handlers; you could use something similar to handle page faults in the application, for example. Your solution is correct if it passes alarmtest and usertests.</p>
</blockquote>
<p>按照如下原型添加系统调用 <code>sigalarm</code> 和 <code>sigreturn</code>（具体步骤不再赘述）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sigalarm</span><span class="params">(<span class="type">int</span> ticks, <span class="type">void</span> (*handler)())</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sigreturn</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>首先，在 proc 结构体的定义中，增加 alarm 相关字段：</p>
<ul>
<li>alarm_interval：时钟周期，0 为禁用</li>
<li>alarm_handler：时钟回调处理函数</li>
<li>alarm_ticks：下一次时钟响起前还剩下的 ticks 数</li>
<li>alarm_trapframe：时钟中断时刻的 trapframe，用于中断处理完成后恢复原程序的正常执行</li>
<li>alarm_goingoff：是否已经有一个时钟回调正在执行且还未返回（用于防止在 alarm_handler 中途闹钟到期再次调用 alarm_handler，导致 alarm_trapframe 被覆盖）</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> &#123;</span></span><br><span class="line">  <span class="comment">// ......</span></span><br><span class="line">  <span class="type">int</span> alarm_interval;          <span class="comment">// Alarm interval (0 for disabled)</span></span><br><span class="line">  <span class="type">void</span>(*alarm_handler)();      <span class="comment">// Alarm handler</span></span><br><span class="line">  <span class="type">int</span> alarm_ticks;             <span class="comment">// How many ticks left before next alarm goes off</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> *<span class="title">alarm_trapframe</span>;</span>  <span class="comment">// A copy of trapframe right before running alarm_handler</span></span><br><span class="line">  <span class="type">int</span> alarm_goingoff;          <span class="comment">// Is an alarm currently going off and hasn&#x27;t not yet returned? (prevent re-entrance of alarm_handler)</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>sigalarm 与 sigreturn 具体实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sysproc.c</span></span><br><span class="line">uint64 <span class="title function_">sys_sigalarm</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line">  uint64 fn;</span><br><span class="line">  <span class="keyword">if</span>(argint(<span class="number">0</span>, &amp;n) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">if</span>(argaddr(<span class="number">1</span>, &amp;fn) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> sigalarm(n, (<span class="type">void</span>(*)())(fn));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">uint64 <span class="title function_">sys_sigreturn</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> sigreturn();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// trap.c</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigalarm</span><span class="params">(<span class="type">int</span> ticks, <span class="type">void</span>(*handler)())</span> &#123;</span><br><span class="line">  <span class="comment">// 设置 myproc 中的相关属性</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  p-&gt;alarm_interval = ticks;</span><br><span class="line">  p-&gt;alarm_handler = handler;</span><br><span class="line">  p-&gt;alarm_ticks = ticks;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigreturn</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="comment">// 将 trapframe 恢复到时钟中断之前的状态，恢复原本正在执行的程序流</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  *p-&gt;trapframe = *p-&gt;alarm_trapframe;</span><br><span class="line">  p-&gt;alarm_goingoff = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 proc.c 中添加初始化与释放代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// proc.c</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> proc*</span><br><span class="line"><span class="title function_">allocproc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">found:</span><br><span class="line">  p-&gt;pid = allocpid();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Allocate a trapframe page.</span></span><br><span class="line">  <span class="keyword">if</span>((p-&gt;trapframe = (<span class="keyword">struct</span> trapframe *)kalloc()) == <span class="number">0</span>)&#123;</span><br><span class="line">    release(&amp;p-&gt;lock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Allocate a trapframe page for alarm_trapframe.</span></span><br><span class="line">  <span class="keyword">if</span>((p-&gt;alarm_trapframe = (<span class="keyword">struct</span> trapframe *)kalloc()) == <span class="number">0</span>)&#123;</span><br><span class="line">    release(&amp;p-&gt;lock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  p-&gt;alarm_interval = <span class="number">0</span>;</span><br><span class="line">  p-&gt;alarm_handler = <span class="number">0</span>;</span><br><span class="line">  p-&gt;alarm_ticks = <span class="number">0</span>;</span><br><span class="line">  p-&gt;alarm_goingoff = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">freeproc</span><span class="params">(<span class="keyword">struct</span> proc *p)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(p-&gt;alarm_trapframe)</span><br><span class="line">    kfree((<span class="type">void</span>*)p-&gt;alarm_trapframe);</span><br><span class="line">  p-&gt;alarm_trapframe = <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// ......</span></span><br><span class="line">  </span><br><span class="line">  p-&gt;alarm_interval = <span class="number">0</span>;</span><br><span class="line">  p-&gt;alarm_handler = <span class="number">0</span>;</span><br><span class="line">  p-&gt;alarm_ticks = <span class="number">0</span>;</span><br><span class="line">  p-&gt;alarm_goingoff = <span class="number">0</span>;</span><br><span class="line">  p-&gt;state = UNUSED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 usertrap() 函数中，实现时钟机制具体代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">usertrap</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> which_dev = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(p-&gt;killed)</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// give up the CPU if this is a timer interrupt.</span></span><br><span class="line">  <span class="comment">// if(which_dev == 2) &#123;</span></span><br><span class="line">  <span class="comment">//   yield();</span></span><br><span class="line">  <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// give up the CPU if this is a timer interrupt.</span></span><br><span class="line">  <span class="keyword">if</span>(which_dev == <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;alarm_interval != <span class="number">0</span>) &#123; <span class="comment">// 如果设定了时钟事件</span></span><br><span class="line">      <span class="keyword">if</span>(--p-&gt;alarm_ticks &lt;= <span class="number">0</span>) &#123; <span class="comment">// 时钟倒计时 -1 tick，如果已经到达或超过设定的 tick 数</span></span><br><span class="line">        <span class="keyword">if</span>(!p-&gt;alarm_goingoff) &#123; <span class="comment">// 确保没有时钟正在运行</span></span><br><span class="line">          p-&gt;alarm_ticks = p-&gt;alarm_interval;</span><br><span class="line">          <span class="comment">// jump to execute alarm_handler</span></span><br><span class="line">          *p-&gt;alarm_trapframe = *p-&gt;trapframe; <span class="comment">// backup trapframe</span></span><br><span class="line">          p-&gt;trapframe-&gt;epc = (uint64)p-&gt;alarm_handler;</span><br><span class="line">          p-&gt;alarm_goingoff = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果一个时钟到期的时候已经有一个时钟处理函数正在运行，则会推迟到原处理函数运行完成后的下一个 tick 才触发这次时钟</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    yield();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  usertrapret();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，在每次时钟中断的时候，如果进程有已经设置的时钟（<code>alarm_interval != 0</code>），则进行 alarm_ticks 倒数。当 alarm_ticks 倒数到小于等于 0 的时候，如果没有正在处理的时钟，则尝试触发时钟，将原本的程序流保存起来（<code>*alarm_trapframe = *trapframe</code>），然后通过修改 pc 寄存器的值，将程序流转跳到 alarm_handler 中，alarm_handler 执行完毕后再恢复原本的执行流（<code>*trapframe = *alarm_trapframe</code>）。这样从原本程序执行流的视角，就是不可感知的中断了。</p>
<p>编译运行：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">alarmtest</span></span><br><span class="line">test0 start</span><br><span class="line">.............alarm!</span><br><span class="line">test0 passed</span><br><span class="line">test1 start</span><br><span class="line">..alarm!</span><br><span class="line">..alarm!</span><br><span class="line">..alarm!</span><br><span class="line">..alarm!</span><br><span class="line">..alarm!</span><br><span class="line">..alarm!</span><br><span class="line">..alarm!</span><br><span class="line">.alarm!</span><br><span class="line">...alarm!</span><br><span class="line">..alarm!</span><br><span class="line">test1 passed</span><br><span class="line">test2 start</span><br><span class="line">..............alarm!</span><br><span class="line">test2 passed</span><br></pre></td></tr></table></figure>

<h3 id="Lab-5-Lazy-Page-Allocation"><a href="#Lab-5-Lazy-Page-Allocation" class="headerlink" title="Lab 5: Lazy Page Allocation"></a>Lab 5: Lazy Page Allocation</h3><blockquote>
<p>One of the many neat tricks an O&#x2F;S can play with page table hardware is lazy allocation of user-space heap memory. Xv6 applications ask the kernel for heap memory using the sbrk() system call. In the kernel we’ve given you, sbrk() allocates physical memory and maps it into the process’s virtual address space. It can take a long time for a kernel to allocate and map memory for a large request. Consider, for example, that a gigabyte consists of 262,144 4096-byte pages; that’s a huge number of allocations even if each is individually cheap. In addition, some programs allocate more memory than they actually use (e.g., to implement sparse arrays), or allocate memory well in advance of use. To allow sbrk() to complete more quickly in these cases, sophisticated kernels allocate user memory lazily. That is, sbrk() doesn’t allocate physical memory, but just remembers which user addresses are allocated and marks those addresses as invalid in the user page table. When the process first tries to use any given page of lazily-allocated memory, the CPU generates a page fault, which the kernel handles by allocating physical memory, zeroing it, and mapping it. You’ll add this lazy allocation feature to xv6 in this lab.</p>
</blockquote>
<p>实现一个内存页懒分配机制，在调用 sbrk() 的时候，不立即分配内存，而是只作记录。在访问到这一部分内存的时候才进行实际的物理内存分配。</p>
<p>首先修改 sys_sbrk，使其不再调用 growproc()，而是只修改 p-&gt;sz 的值而不分配物理内存。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/sysproc.c</span></span><br><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_sbrk</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> addr;</span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  <span class="keyword">if</span>(argint(<span class="number">0</span>, &amp;n) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  addr = p-&gt;sz;</span><br><span class="line">  <span class="keyword">if</span>(n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    uvmdealloc(p-&gt;pagetable, p-&gt;sz, p-&gt;sz+n); <span class="comment">// 如果是缩小空间，则马上释放</span></span><br><span class="line">  &#125;</span><br><span class="line">  p-&gt;sz += n; <span class="comment">// 懒分配</span></span><br><span class="line">  <span class="keyword">return</span> addr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改 usertrap 用户态 trap 处理函数，为缺页异常添加检测，如果为缺页异常（<code>(r_scause() == 13 || r_scause() == 15)</code>），且发生异常的地址是由于懒分配而没有映射的话，就为其分配物理内存，并在页表建立映射：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/trap.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// handle an interrupt, exception, or system call from user space.</span></span><br><span class="line"><span class="comment">// called from trampoline.S</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">usertrap</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">    syscall();</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>((which_dev = devintr()) != <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">// ok</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    uint64 va = r_stval();</span><br><span class="line">    <span class="keyword">if</span>((r_scause() == <span class="number">13</span> || r_scause() == <span class="number">15</span>) &amp;&amp; uvmshouldtouch(va))&#123; <span class="comment">// 缺页异常，并且发生异常的地址进行过懒分配</span></span><br><span class="line">      uvmlazytouch(va); <span class="comment">// 分配物理内存，并在页表创建映射</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果不是缺页异常，或者是在非懒加载地址上发生缺页异常，则抛出错误并杀死进程</span></span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;usertrap(): unexpected scause %p pid=%d\n&quot;</span>, r_scause(), p-&gt;pid);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;            sepc=%p stval=%p\n&quot;</span>, r_sepc(), r_stval());</span><br><span class="line">      p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>uvmlazytouch 函数负责分配实际的物理内存并建立映射。懒分配的内存页在被 touch 后就可以被使用了。uvmshouldtouch 用于检测一个虚拟地址是不是一个需要被 touch 的懒分配内存地址，具体检测的是：</p>
<ol>
<li>处于 <code>[0, p-&gt;sz)</code>地址范围之中（进程申请的内存范围）</li>
<li><code>不是栈的 guard page</code>（具体见 xv6 book，栈页的低一页故意留成不映射，作为哨兵用于捕捉 stack overflow 错误。懒分配不应该给这个地址分配物理页和建立映射，而应该直接抛出异常）</li>
<li><code>页表项不存在</code></li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/vm.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// touch a lazy-allocated page so it&#x27;s mapped to an actual physical page.</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">uvmlazytouch</span><span class="params">(uint64 va)</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  <span class="type">char</span> *mem = kalloc();</span><br><span class="line">  <span class="keyword">if</span>(mem == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// failed to allocate physical memory</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;lazy alloc: out of memory\n&quot;</span>);</span><br><span class="line">    p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">memset</span>(mem, <span class="number">0</span>, PGSIZE);</span><br><span class="line">    <span class="keyword">if</span>(mappages(p-&gt;pagetable, PGROUNDDOWN(va), PGSIZE, (uint64)mem, PTE_W|PTE_X|PTE_R|PTE_U) != <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;lazy alloc: failed to map page\n&quot;</span>);</span><br><span class="line">      kfree(mem);</span><br><span class="line">      p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// printf(&quot;lazy alloc: %p, p-&gt;sz: %p\n&quot;, PGROUNDDOWN(va), p-&gt;sz);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// whether a page is previously lazy-allocated and needed to be touched before use.</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">uvmshouldtouch</span><span class="params">(uint64 va)</span> &#123;</span><br><span class="line">  <span class="type">pte_t</span> *pte;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> va &lt; p-&gt;sz <span class="comment">// within size of memory for the process</span></span><br><span class="line">    &amp;&amp; PGROUNDDOWN(va) != r_sp() <span class="comment">// not accessing stack guard page (it shouldn&#x27;t be mapped)</span></span><br><span class="line">    &amp;&amp; (((pte = walk(p-&gt;pagetable, va, <span class="number">0</span>))==<span class="number">0</span>) || ((*pte &amp; PTE_V)==<span class="number">0</span>)); <span class="comment">// page table entry does not exist</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>由于懒分配的页，在刚分配的时候是没有对应的映射的，所以要把一些原本在遇到无映射地址时会 panic 的函数的行为改为直接忽略这样的地址。</code></p>
<p>uvmummap()：取消虚拟地址映射</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/vm.c</span></span><br><span class="line"><span class="comment">// 修改这个解决了 proc_freepagetable 时的 panic</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">uvmunmap</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 va, uint64 npages, <span class="type">int</span> do_free)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint64 a;</span><br><span class="line">  <span class="type">pte_t</span> *pte;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>((va % PGSIZE) != <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;uvmunmap: not aligned&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(a = va; a &lt; va + npages*PGSIZE; a += PGSIZE)&#123;</span><br><span class="line">    <span class="keyword">if</span>((pte = walk(pagetable, a, <span class="number">0</span>)) == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">continue</span>; <span class="comment">// 如果页表项不存在，跳过当前地址 （原本是直接panic）</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>((*pte &amp; PTE_V) == <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="keyword">continue</span>; <span class="comment">// 如果页表项不存在，跳过当前地址 （原本是直接panic）</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(PTE_FLAGS(*pte) == PTE_V)</span><br><span class="line">      panic(<span class="string">&quot;uvmunmap: not a leaf&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(do_free)&#123;</span><br><span class="line">      uint64 pa = PTE2PA(*pte);</span><br><span class="line">      kfree((<span class="type">void</span>*)pa);</span><br><span class="line">    &#125;</span><br><span class="line">    *pte = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>uvmcopy()：将父进程的页表以及内存拷贝到子进程</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/vm.c</span></span><br><span class="line"><span class="comment">// 修改这个解决了 fork 时的 panic</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">uvmcopy</span><span class="params">(<span class="type">pagetable_t</span> old, <span class="type">pagetable_t</span> new, uint64 sz)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">pte_t</span> *pte;</span><br><span class="line">  uint64 pa, i;</span><br><span class="line">  uint flags;</span><br><span class="line">  <span class="type">char</span> *mem;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; sz; i += PGSIZE)&#123;</span><br><span class="line">    <span class="keyword">if</span>((pte = walk(old, i, <span class="number">0</span>)) == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">continue</span>; <span class="comment">// 如果一个页不存在，则认为是懒加载的页，忽略即可</span></span><br><span class="line">    <span class="keyword">if</span>((*pte &amp; PTE_V) == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">continue</span>; <span class="comment">// 如果一个页不存在，则认为是懒加载的页，忽略即可</span></span><br><span class="line">    pa = PTE2PA(*pte);</span><br><span class="line">    flags = PTE_FLAGS(*pte);</span><br><span class="line">    <span class="keyword">if</span>((mem = kalloc()) == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">goto</span> err;</span><br><span class="line">    memmove(mem, (<span class="type">char</span>*)pa, PGSIZE);</span><br><span class="line">    <span class="keyword">if</span>(mappages(new, i, PGSIZE, (uint64)mem, flags) != <span class="number">0</span>)&#123;</span><br><span class="line">      kfree(mem);</span><br><span class="line">      <span class="keyword">goto</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"> err:</span><br><span class="line">  uvmunmap(new, <span class="number">0</span>, i / PGSIZE, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>copyin() 和 copyout()：内核&#x2F;用户态之间互相拷贝数据</p>
<p><code>由于这里可能会访问到懒分配但是还没实际分配的页，所以要加一个检测，确保 copy 之前，用户态地址对应的页都有被实际分配和映射。</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/vm.c</span></span><br><span class="line"><span class="comment">// 修改这个解决了 read/write 时的错误 (usertests 中的 sbrkarg 失败的问题)</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">copyout</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 dstva, <span class="type">char</span> *src, uint64 len)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint64 n, va0, pa0;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(uvmshouldtouch(dstva))</span><br><span class="line">    uvmlazytouch(dstva);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">copyin</span><span class="params">(<span class="type">pagetable_t</span> pagetable, <span class="type">char</span> *dst, uint64 srcva, uint64 len)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint64 n, va0, pa0;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(uvmshouldtouch(srcva))</span><br><span class="line">    uvmlazytouch(srcva);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此修改完成，在 xv6 中运行 lazytests 和 usertests 都应该能够成功了。如果在某一步出现了 remap 或者 leaf 之类的 panic，可能是由于页表项没有释放干净。可以从之前 pgtbl 实验中借用打印页表的函数 vmprint 的代码，并在可能有关的系统调用中打出，方便对页表进行调试。</p>
<blockquote>
<p>tip. 如果 usertests 某一步失败了，可以用 <code>usertests [测试名称]</code> 直接单独运行某个之前失败过的测试，例如 <code>usertests stacktest</code> 可以直接运行栈 guard page 的测试，而不用等待其他测试漫长的运行。</p>
</blockquote>
<h3 id="Lab-6-Copy-on-write-fork"><a href="#Lab-6-Copy-on-write-fork" class="headerlink" title="Lab 6: Copy-on-write fork"></a>Lab 6: Copy-on-write fork</h3><blockquote>
<p>COW fork() creates just a pagetable for the child, with PTEs for user memory pointing to the parent’s physical pages. COW fork() marks all the user PTEs in both parent and child as not writable. When either process tries to write one of these COW pages, the CPU will force a page fault. The kernel page-fault handler detects this case, allocates a page of physical memory for the faulting process, copies the original page into the new page, and modifies the relevant PTE in the faulting process to refer to the new page, this time with the PTE marked writeable. When the page fault handler returns, the user process will be able to write its copy of the page.</p>
<p>COW fork() makes freeing of the physical pages that implement user memory a little trickier. A given physical page may be referred to by multiple processes’ page tables, and should be freed only when the last reference disappears.</p>
</blockquote>
<p>实现 fork 懒复制机制，在进程 fork 后，不立刻复制内存页，而是将虚拟地址指向与父进程相同的物理地址。在父子任意一方尝试对内存页进行修改时，才对内存页进行复制。 物理内存页必须保证在所有引用都消失后才能被释放，这里需要有引用计数机制。</p>
<blockquote>
<p>为了便于区分，本文将只创建引用而不进行实际内存分配的页复制过程称为「懒复制」，将分配新的内存空间并将数据复制到其中的过程称为「实复制」</p>
</blockquote>
<h4 id="6-1fork时不立刻复制内存"><a href="#6-1fork时不立刻复制内存" class="headerlink" title="6.1fork时不立刻复制内存"></a>6.1fork时不立刻复制内存</h4><p>首先修改 uvmcopy()，在复制父进程的内存到子进程的时候，不立刻复制数据，而是建立指向原物理页的映射，<code>并将父子两端的页表项都设置为不可写</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/vm.c</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">uvmcopy</span><span class="params">(<span class="type">pagetable_t</span> old, <span class="type">pagetable_t</span> new, uint64 sz)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">pte_t</span> *pte;</span><br><span class="line">  uint64 pa, i;</span><br><span class="line">  uint flags;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; sz; i += PGSIZE)&#123;</span><br><span class="line">    <span class="keyword">if</span>((pte = walk(old, i, <span class="number">0</span>)) == <span class="number">0</span>)</span><br><span class="line">      panic(<span class="string">&quot;uvmcopy: pte should exist&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>((*pte &amp; PTE_V) == <span class="number">0</span>)</span><br><span class="line">      panic(<span class="string">&quot;uvmcopy: page not present&quot;</span>);</span><br><span class="line">    pa = PTE2PA(*pte);</span><br><span class="line">    <span class="comment">// 清除父进程的 PTE_W 标志位，设置 PTE_COW 标志位表示是一个懒复制页（多个进程引用同个物理页）</span></span><br><span class="line">    *pte = (*pte &amp; ~PTE_W) | PTE_COW;</span><br><span class="line">    flags = PTE_FLAGS(*pte);</span><br><span class="line">    <span class="comment">// 将父进程的物理页直接 map 到子进程 （懒复制）</span></span><br><span class="line">    <span class="comment">// 权限设置和父进程一致（不可写，PTE_COW）</span></span><br><span class="line">    <span class="keyword">if</span>(mappages(new, i, PGSIZE, (uint64)pa, flags) != <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="keyword">goto</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将物理页的引用次数增加 1</span></span><br><span class="line">    krefpage((<span class="type">void</span>*)pa);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"> err:</span><br><span class="line">  uvmunmap(new, <span class="number">0</span>, i / PGSIZE, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面用到了 PTE_COW 标志位，用于标示一个映射对应的物理页是否是懒复制页。这里 PTE_COW 需要在 riscv.h 中定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/riscv.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_V (1L &lt;&lt; 0) <span class="comment">// valid</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_R (1L &lt;&lt; 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_W (1L &lt;&lt; 2)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_X (1L &lt;&lt; 3)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_U (1L <span class="string">&lt;&lt; 4) // 1 -&gt;</span> user can access</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_COW (1L &lt;&lt; 8) <span class="comment">// 是否为懒复制页，使用页表项 flags 中保留的第 8 位表示</span></span></span><br><span class="line"><span class="comment">// （页表项 flags 中，第 8、9、10 位均为保留给操作系统使用的位，可以用作任意自定义用途）</span></span><br></pre></td></tr></table></figure>

<p>这样，fork 时就不会立刻复制内存，只会创建一个映射了。这时候如果尝试修改懒复制的页，会出现 page fault 被 usertrap() 捕获。接下来需要在 usertrap() 中捕捉这个 page fault，并在尝试修改页的时候，执行实复制操作。</p>
<h4 id="6-2捕获写操作并执行复制"><a href="#6-2捕获写操作并执行复制" class="headerlink" title="6.2捕获写操作并执行复制"></a>6.2捕获写操作并执行复制</h4><p>与 lazy allocation lab 类似，在 usertrap() 中添加对 page fault 的检测，并在当前访问的地址符合懒复制页条件时，对懒复制页进行实复制操作：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/trap.c</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">usertrap</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>((which_dev = devintr()) != <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">// ok</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>((r_scause() == <span class="number">13</span> || r_scause() == <span class="number">15</span>) &amp;&amp; uvmcheckcowpage(r_stval())) &#123; <span class="comment">// copy-on-write</span></span><br><span class="line">    <span class="keyword">if</span>(uvmcowcopy(r_stval()) == <span class="number">-1</span>)&#123; <span class="comment">// 如果内存不足，则杀死进程</span></span><br><span class="line">      p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;usertrap(): unexpected scause %p pid=%d\n&quot;</span>, r_scause(), p-&gt;pid);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;            sepc=%p stval=%p\n&quot;</span>, r_sepc(), r_stval());</span><br><span class="line">    p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>同时 copyout() 由于是软件访问页表，不会触发缺页异常，所以需要手动添加同样的监测代码（同 lab5），检测接收的页是否是一个懒复制页，若是，执行实复制操作</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/vm.c</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">copyout</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 dstva, <span class="type">char</span> *src, uint64 len)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint64 n, va0, pa0;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(uvmcheckcowpage(dstva))</span><br><span class="line">    uvmcowcopy(dstva);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现懒复制页的检测（<code>uvmcheckcowpage()</code>）与实复制（<code>uvmcowcopy()</code>）操作：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/vm.c</span></span><br><span class="line"><span class="comment">// 检查一个地址指向的页是否是懒复制页</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">uvmcheckcowpage</span><span class="params">(uint64 va)</span> &#123;</span><br><span class="line">  <span class="type">pte_t</span> *pte;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> va &lt; p-&gt;sz <span class="comment">// 在进程内存范围内</span></span><br><span class="line">    &amp;&amp; ((pte = walk(p-&gt;pagetable, va, <span class="number">0</span>))!=<span class="number">0</span>)</span><br><span class="line">    &amp;&amp; (*pte &amp; PTE_V) <span class="comment">// 页表项存在</span></span><br><span class="line">    &amp;&amp; (*pte &amp; PTE_COW); <span class="comment">// 页是一个懒复制页</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实复制一个懒复制页，并重新映射为可写</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">uvmcowcopy</span><span class="params">(uint64 va)</span> &#123;</span><br><span class="line">  <span class="type">pte_t</span> *pte;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>((pte = walk(p-&gt;pagetable, va, <span class="number">0</span>)) == <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;uvmcowcopy: walk&quot;</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 调用 kalloc.c 中的 kcopy_n_deref 方法，复制页</span></span><br><span class="line">  <span class="comment">// (如果懒复制页的引用已经为 1，则不需要重新分配和复制内存页，只需清除 PTE_COW 标记并标记 PTE_W 即可)</span></span><br><span class="line">  uint64 pa = PTE2PA(*pte);</span><br><span class="line">  uint64 new = (uint64)kcopy_n_deref((<span class="type">void</span>*)pa); <span class="comment">// 将一个懒复制的页引用变为一个实复制的页</span></span><br><span class="line">  <span class="keyword">if</span>(new == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 重新映射为可写，并清除 PTE_COW 标记</span></span><br><span class="line">  uint64 flags = (PTE_FLAGS(*pte) | PTE_W) &amp; ~PTE_COW;</span><br><span class="line">  uvmunmap(p-&gt;pagetable, PGROUNDDOWN(va), <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span>(mappages(p-&gt;pagetable, va, <span class="number">1</span>, new, flags) == <span class="number">-1</span>) &#123;</span><br><span class="line">    panic(<span class="string">&quot;uvmcowcopy: mappages&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到这里，就已经确定了大体的逻辑了：&#x3D;&#x3D;在 fork 的时候不复制数据只建立映射+标记，在进程尝试写入的时候进行实复制并重新映射为可写。&#x3D;&#x3D;</p>
<p><code>接下来，还需要做页的生命周期管理，确保在所有进程都不使用一个页时才将其释放</code></p>
<h4 id="6-3物理页生命周期以及引用计数"><a href="#6-3物理页生命周期以及引用计数" class="headerlink" title="6.3物理页生命周期以及引用计数"></a>6.3物理页生命周期以及引用计数</h4><p>在 kalloc.c 中，我们需要定义一系列的新函数，用于完成在支持懒复制的条件下的物理页生命周期管理。在原本的 xv6 实现中，一个物理页的生命周期内，可以支持以下操作：</p>
<ul>
<li>kalloc(): 分配物理页</li>
<li>kfree(): 释放回收物理页</li>
</ul>
<p>而在支持了懒分配后，由于一个物理页可能被多个进程（多个虚拟地址）引用，并且必须在最后一个引用消失后才可以释放回收该物理页，所以一个物理页的生命周期内，现在需要支持以下操作：</p>
<ul>
<li><code>kalloc(): 分配物理页，将其引用计数置为 1</code></li>
<li><code>krefpage(): 创建物理页的一个新引用，引用计数加 1</code></li>
<li><code>kcopy_n_deref(): 将物理页的一个引用实复制到一个新物理页上（引用计数为 1），返回得到的副本页；并将本物理页的引用计数减 1</code></li>
<li><code>kfree(): 释放物理页的一个引用，引用计数减 1；如果计数变为 0，则释放回收物理页</code></li>
</ul>
<blockquote>
<p>一个物理页 p 首先会被父进程使用 kalloc() 创建，fork 的时候，新创建的子进程会使用 krefpage() 声明自己对父进程物理页的引用。当尝试修改父进程或子进程中的页时，kcopy_n_deref() 负责将想要修改的页实复制到独立的副本，并记录解除旧的物理页的引用（引用计数减 1）。最后 kfree() 保证只有在所有的引用者都释放该物理页的引用时，才释放回收该物理页。</p>
</blockquote>
<p>这里首先定义一个数组 pageref[] 以及对应的宏，用于记录与获取某个物理页的引用计数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/kalloc.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于访问物理页引用计数数组</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PA2PGREF_ID(p) (((p)-KERNBASE)/PGSIZE)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PGREF_MAX_ENTRIES PA2PGREF_ID(PHYSTOP)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">pgreflock</span>;</span> <span class="comment">// 用于 pageref 数组的锁，防止竞态条件引起内存泄漏</span></span><br><span class="line"><span class="type">int</span> pageref[PGREF_MAX_ENTRIES]; <span class="comment">// 从 KERNBASE 开始到 PHYSTOP 之间的每个物理页的引用计数</span></span><br><span class="line"><span class="comment">// note:  reference counts are incremented on fork, not on mapping. this means that multiple mappings of the same physical page within a single process are only counted as one reference. this shouldn&#x27;t be a problem, though. as there&#x27;s no way for a user program to map a physical page twice within it&#x27;s address space in xv6.</span></span><br><span class="line"><span class="comment">// 通过物理地址获得引用计数</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PA2PGREF(p) pageref[PA2PGREF_ID((uint64)(p))]</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">kinit</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  initlock(&amp;kmem.lock, <span class="string">&quot;kmem&quot;</span>);</span><br><span class="line">  initlock(&amp;pgreflock, <span class="string">&quot;pgref&quot;</span>); <span class="comment">// 初始化锁</span></span><br><span class="line">  freerange(end, (<span class="type">void</span>*)PHYSTOP);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">kfree</span><span class="params">(<span class="type">void</span> *pa)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(((uint64)pa % PGSIZE) != <span class="number">0</span> || (<span class="type">char</span>*)pa &lt; end || (uint64)pa &gt;= PHYSTOP)</span><br><span class="line">    panic(<span class="string">&quot;kfree&quot;</span>);</span><br><span class="line"></span><br><span class="line">  acquire(&amp;pgreflock);</span><br><span class="line">  <span class="keyword">if</span>(--PA2PGREF(pa) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 当页面的引用计数小于等于 0 的时候，释放页面</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Fill with junk to catch dangling refs.</span></span><br><span class="line">    <span class="comment">// pa will be memset multiple times if race-condition occurred.</span></span><br><span class="line">    <span class="built_in">memset</span>(pa, <span class="number">1</span>, PGSIZE);</span><br><span class="line"></span><br><span class="line">    r = (<span class="keyword">struct</span> run*)pa;</span><br><span class="line"></span><br><span class="line">    acquire(&amp;kmem.lock);</span><br><span class="line">    r-&gt;next = kmem.freelist;</span><br><span class="line">    kmem.freelist = r;</span><br><span class="line">    release(&amp;kmem.lock);</span><br><span class="line">  &#125;</span><br><span class="line">  release(&amp;pgreflock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *</span><br><span class="line"><span class="title function_">kalloc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span>;</span></span><br><span class="line"></span><br><span class="line">  acquire(&amp;kmem.lock);</span><br><span class="line">  r = kmem.freelist;</span><br><span class="line">  <span class="keyword">if</span>(r)</span><br><span class="line">    kmem.freelist = r-&gt;next;</span><br><span class="line">  release(&amp;kmem.lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(r)&#123;</span><br><span class="line">    <span class="built_in">memset</span>((<span class="type">char</span>*)r, <span class="number">5</span>, PGSIZE); <span class="comment">// fill with junk</span></span><br><span class="line">    <span class="comment">// 新分配的物理页的引用计数为 1</span></span><br><span class="line">    <span class="comment">// (这里无需加锁)</span></span><br><span class="line">    PA2PGREF(r) = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> (<span class="type">void</span>*)r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Decrease reference to the page by one if it&#x27;s more than one, then</span></span><br><span class="line"><span class="comment">// allocate a new physical page and copy the page into it.</span></span><br><span class="line"><span class="comment">// (Effectively turing one reference into one copy.)</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// Do nothing and simply return pa when reference count is already</span></span><br><span class="line"><span class="comment">// less than or equal to 1.</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// 当引用已经小于等于 1 时，不创建和复制到新的物理页，而是直接返回该页本身</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">kcopy_n_deref</span><span class="params">(<span class="type">void</span> *pa)</span> &#123;</span><br><span class="line">  acquire(&amp;pgreflock);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 这一步很关键，当子进程先执行exec释放原来的物理页时此时父进程写pa地址处内容会触发COW，由于没有子进程引用pa，父进程不需要重新分配一块物理内容可以直接复用原来的物理页，并修改PTE权限</span></span><br><span class="line">  <span class="keyword">if</span>(PA2PGREF(pa) &lt;= <span class="number">1</span>) &#123; <span class="comment">// 只有 1 个引用，无需复制</span></span><br><span class="line">    release(&amp;pgreflock);</span><br><span class="line">    <span class="keyword">return</span> pa;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 分配新的内存页，并复制旧页中的数据到新页</span></span><br><span class="line">  uint64 newpa = (uint64)kalloc();</span><br><span class="line">  <span class="keyword">if</span>(newpa == <span class="number">0</span>) &#123;</span><br><span class="line">    release(&amp;pgreflock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// out of memory</span></span><br><span class="line">  &#125;</span><br><span class="line">  memmove((<span class="type">void</span>*)newpa, (<span class="type">void</span>*)pa, PGSIZE);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 旧页的引用减 1</span></span><br><span class="line">  PA2PGREF(pa)--;</span><br><span class="line"></span><br><span class="line">  release(&amp;pgreflock);</span><br><span class="line">  <span class="keyword">return</span> (<span class="type">void</span>*)newpa;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为 pa 的引用计数增加 1</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">krefpage</span><span class="params">(<span class="type">void</span> *pa)</span> &#123;</span><br><span class="line">  acquire(&amp;pgreflock);</span><br><span class="line">  PA2PGREF(pa)++;</span><br><span class="line">  release(&amp;pgreflock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里可以看到，为 pageref[] 数组定义了自旋锁 pgreflock，并且在除了 kalloc 的其他操作中，都使用了 <code>acquire(&amp;pgreflock);</code> 和 <code>release(&amp;pgreflock);</code> 获取和释放锁来保护操作的代码。这里的锁的作用是防止竞态条件（race-condition）下导致的内存泄漏。</p>
<p>举一个很常见的 fork() 后 exec() 的例子：</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">父进程: 分配物理页 p（p 引用计数 = 1）</span><br><span class="line">父进程: fork()（p 引用计数 = 2）</span><br><span class="line">父进程: 尝试修改 p，触发页异常</span><br><span class="line">父进程: 由于 p 引用计数大于 1，开始实复制 p（p 引用计数 = 2）</span><br><span class="line">--- 调度器切换到子进程</span><br><span class="line">子进程: exec() 替换进程影像，释放所有旧的页</span><br><span class="line">子进程: 尝试释放 p（引用计数减 1），子进程丢弃对 p 的引用（p 引用计数 = 1）</span><br><span class="line">--- 调度器切换到父进程</span><br><span class="line">父进程: （继续实复制p）创建新页 q，将 p 复制到 q，将 q 标记为可写并建立映射，在这过程中父进程丢弃对旧 p 的引用</span><br></pre></td></tr></table></figure>

<p><code>在这一个执行流过后，最终结果是物理页p并没有被释放回收，然而父进程和子进程都已经丢弃了对p的引用（页表中均没有指向p的页表项），这样一来p占用的内存就属于泄漏内存了，永远无法被回收。加了锁pgreflock之后，保证了这种情况不会出现。</code></p>
<p>&#x3D;&#x3D;注意 kalloc() 可以不用加锁，因为 kmem 的锁已经保证了同一个物理页不会同时被两个进程分配，并且在 kalloc() 返回前，其他操作 pageref() 的函数也不会被调用，因为没有任何其他进程能够在 kalloc() 返回前得到这个新页的地址。&#x3D;&#x3D;</p>
<h3 id="Lab-7-Multithreading"><a href="#Lab-7-Multithreading" class="headerlink" title="Lab 7: Multithreading"></a>Lab 7: Multithreading</h3><blockquote>
<p>This lab will familiarize you with multithreading. You will implement switching between threads in a user-level threads package, use multiple threads to speed up a program, and implement a barrier.</p>
</blockquote>
<p>实现一个用户态的线程库；尝试使用线程来为程序提速；并且尝试实现一个同步屏障。</p>
<h4 id="7-1Uthread-switching-between-threads-moderate"><a href="#7-1Uthread-switching-between-threads-moderate" class="headerlink" title="7.1Uthread: switching between threads (moderate)"></a>7.1Uthread: switching between threads (moderate)</h4><p>补全 uthread.c，完成用户态线程功能的实现。</p>
<p>这里的线程相比现代操作系统中的线程而言，更接近一些语言中的“协程”（coroutine）。原因是这里的“线程”是完全用户态实现的，多个线程也只能运行在一个 CPU 上，并且没有时钟中断来强制执行调度，需要线程函数本身在合适的时候主动 yield 释放 CPU。这样实现起来的线程并不对线程函数透明，所以比起操作系统的线程而言更接近 coroutine。</p>
<p>这个实验其实相当于在用户态重新实现一遍 xv6 kernel 中的 scheduler() 和 swtch() 的功能，所以大多数代码都是可以借鉴的。</p>
<p>uthread_switch.S 中需要实现上下文切换的代码，这里借鉴 swtch.S：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">// uthread_switch.S</span><br><span class="line">	.text</span><br><span class="line">	/*</span><br><span class="line">		 * save the old thread&#x27;s registers,</span><br><span class="line">		 * restore the new thread&#x27;s registers.</span><br><span class="line">		 */</span><br><span class="line">// void thread_switch(struct context *old, struct context *new);</span><br><span class="line">	.globl thread_switch</span><br><span class="line">thread_switch:</span><br><span class="line">	sd ra, 0(a0)</span><br><span class="line">	sd sp, 8(a0)</span><br><span class="line">	sd s0, 16(a0)</span><br><span class="line">	sd s1, 24(a0)</span><br><span class="line">	sd s2, 32(a0)</span><br><span class="line">	sd s3, 40(a0)</span><br><span class="line">	sd s4, 48(a0)</span><br><span class="line">	sd s5, 56(a0)</span><br><span class="line">	sd s6, 64(a0)</span><br><span class="line">	sd s7, 72(a0)</span><br><span class="line">	sd s8, 80(a0)</span><br><span class="line">	sd s9, 88(a0)</span><br><span class="line">	sd s10, 96(a0)</span><br><span class="line">	sd s11, 104(a0)</span><br><span class="line"></span><br><span class="line">	ld ra, 0(a1)</span><br><span class="line">	ld sp, 8(a1)</span><br><span class="line">	ld s0, 16(a1)</span><br><span class="line">	ld s1, 24(a1)</span><br><span class="line">	ld s2, 32(a1)</span><br><span class="line">	ld s3, 40(a1)</span><br><span class="line">	ld s4, 48(a1)</span><br><span class="line">	ld s5, 56(a1)</span><br><span class="line">	ld s6, 64(a1)</span><br><span class="line">	ld s7, 72(a1)</span><br><span class="line">	ld s8, 80(a1)</span><br><span class="line">	ld s9, 88(a1)</span><br><span class="line">	ld s10, 96(a1)</span><br><span class="line">	ld s11, 104(a1)</span><br><span class="line"></span><br><span class="line">	ret    /* return to ra */</span><br></pre></td></tr></table></figure>

<p>在调用本函数 uthread_switch() 的过程中，caller-saved registers 已经被调用者保存到栈帧中了，所以这里无需保存这一部分寄存器。</p>
<blockquote>
<p>引申：内核调度器无论是通过时钟中断进入（usertrap），还是线程自己主动放弃 CPU（sleep、exit），最终都会调用到 yield 进一步调用 swtch。 由于上下文切换永远都发生在函数调用的边界（swtch 调用的边界），恢复执行相当于是 swtch 的返回过程，会从堆栈中恢复 caller-saved 的寄存器， 所以用于保存上下文的 context 结构体只需保存 callee-saved 寄存器，以及 返回地址 ra、栈指针 sp 即可。恢复后执行到哪里是通过 ra 寄存器来决定的（swtch 末尾的 ret 转跳到 ra）</p>
<p>而 trapframe 则不同，一个中断可能在任何地方发生，不仅仅是函数调用边界，也有可能在函数执行中途，所以恢复的时候需要靠 pc 寄存器来定位。 并且由于切换位置不一定是函数调用边界，所以几乎所有的寄存器都要保存（无论 caller-saved 还是 callee-saved），才能保证正确的恢复执行。 这也是内核代码中 <code>struct trapframe</code> 中保存的寄存器比 <code>struct context</code> 多得多的原因。</p>
<p>另外一个，无论是程序主动 sleep，还是时钟中断，都是通过 trampoline 跳转到内核态 usertrap（保存 trapframe），然后再到达 swtch 保存上下文的。 恢复上下文都是恢复到 swtch 返回前（依然是内核态），然后返回跳转回 usertrap，再继续运行直到 usertrapret 跳转到 trampoline 读取 trapframe，并返回用户态。 也就是上下文恢复并不是直接恢复到用户态，而是恢复到内核态 swtch 刚执行完的状态。负责恢复用户态执行流的其实是 trampoline 以及 trapframe。</p>
</blockquote>
<p>从 proc.h 中借鉴一下 context 结构体，用于保存 ra、sp 以及 callee-saved registers：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// uthread.c</span></span><br><span class="line"><span class="comment">// Saved registers for thread context switches.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">context</span> &#123;</span></span><br><span class="line">  uint64 ra;</span><br><span class="line">  uint64 sp;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// callee-saved</span></span><br><span class="line">  uint64 s0;</span><br><span class="line">  uint64 s1;</span><br><span class="line">  uint64 s2;</span><br><span class="line">  uint64 s3;</span><br><span class="line">  uint64 s4;</span><br><span class="line">  uint64 s5;</span><br><span class="line">  uint64 s6;</span><br><span class="line">  uint64 s7;</span><br><span class="line">  uint64 s8;</span><br><span class="line">  uint64 s9;</span><br><span class="line">  uint64 s10;</span><br><span class="line">  uint64 s11;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">thread</span> &#123;</span></span><br><span class="line">  <span class="type">char</span>       <span class="built_in">stack</span>[STACK_SIZE]; <span class="comment">/* the thread&#x27;s stack */</span></span><br><span class="line">  <span class="type">int</span>        state;             <span class="comment">/* FREE, RUNNING, RUNNABLE */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">context</span> <span class="title">ctx</span>;</span> <span class="comment">// 在 thread 中添加 context 结构体</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">thread</span> <span class="title">all_thread</span>[<span class="title">MAX_THREAD</span>];</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">thread</span> *<span class="title">current_thread</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">thread_switch</span><span class="params">(<span class="keyword">struct</span> context* old, <span class="keyword">struct</span> context* new)</span>; <span class="comment">// 修改 thread_switch 函数声明</span></span><br></pre></td></tr></table></figure>

<p>在 thread_schedule 中调用 thread_switch 进行上下文切换：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// uthread.c</span></span><br><span class="line"><span class="type">void</span> </span><br><span class="line"><span class="title function_">thread_schedule</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (current_thread != next_thread) &#123;         <span class="comment">/* switch threads?  */</span></span><br><span class="line">    next_thread-&gt;state = RUNNING;</span><br><span class="line">    t = current_thread;</span><br><span class="line">    current_thread = next_thread;</span><br><span class="line">    thread_switch(&amp;t-&gt;ctx, &amp;next_thread-&gt;ctx); <span class="comment">// 切换线程</span></span><br><span class="line">  &#125; <span class="keyword">else</span></span><br><span class="line">    next_thread = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里有个小坑是要从 t 切换到 next_thread，不是从 current_thread 切换到 next_thread（因为前面有两句赋值，没错，我在这里眼瞎了卡了一下 QAQ）</p>
<p>再补齐 thread_create：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// uthread.c</span></span><br><span class="line"><span class="type">void</span> </span><br><span class="line"><span class="title function_">thread_create</span><span class="params">(<span class="type">void</span> (*func)())</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">thread</span> *<span class="title">t</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (t = all_thread; t &lt; all_thread + MAX_THREAD; t++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (t-&gt;state == FREE) <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  t-&gt;state = RUNNABLE;</span><br><span class="line">  t-&gt;ctx.ra = (uint64)func;       <span class="comment">// 返回地址</span></span><br><span class="line">  <span class="comment">// thread_switch 的结尾会返回到 ra，从而运行线程代码</span></span><br><span class="line">  t-&gt;ctx.sp = (uint64)&amp;t-&gt;<span class="built_in">stack</span> + (STACK_SIZE - <span class="number">1</span>);  <span class="comment">// 栈指针</span></span><br><span class="line">  <span class="comment">// 将线程的栈指针指向其独立的栈，注意到栈的生长是从高地址到低地址，所以</span></span><br><span class="line">  <span class="comment">// 要将 sp 设置为指向 stack 的最高地址</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>添加的部分为设置上下文中 ra 指向的地址为线程函数的地址，这样在第一次调度到该线程，执行到 thread_switch 中的 ret 之后就可以跳转到线程函数从而开始执行了。设置 sp 使得线程拥有自己独有的栈，也就是独立的执行流。</p>
<h4 id="7-2Using-threads-moderate"><a href="#7-2Using-threads-moderate" class="headerlink" title="7.2Using threads (moderate)"></a>7.2Using threads (moderate)</h4><p>分析并解决一个哈希表操作的例子内，由于 race-condition 导致的数据丢失的问题。</p>
<blockquote>
<p>Why are there missing keys with 2 threads, but not with 1 thread? Identify a sequence of events with 2 threads that can lead to a key being missing. Submit your sequence with a short explanation in answers-thread.txt</p>
</blockquote>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[假设键 k1、k2 属于同个 bucket]</span><br><span class="line"></span><br><span class="line">thread 1: 尝试设置 k1</span><br><span class="line">thread 1: 发现 k1 不存在，尝试在 bucket 末尾插入 k1</span><br><span class="line">--- scheduler 切换到 thread 2</span><br><span class="line">thread 2: 尝试设置 k2</span><br><span class="line">thread 2: 发现 k2 不存在，尝试在 bucket 末尾插入 k2</span><br><span class="line">thread 2: 分配 entry，在桶末尾插入 k2</span><br><span class="line">--- scheduler 切换回 thread 1</span><br><span class="line">thread 1: 分配 entry，没有意识到 k2 的存在，在其认为的 “桶末尾”（实际为 k2 所处位置）插入 k1</span><br><span class="line"></span><br><span class="line">[k1 被插入，但是由于被 k1 覆盖，k2 从桶中消失了，引发了键值丢失]</span><br></pre></td></tr></table></figure>

<p>首先先暂时忽略速度，为 put 和 get 操作加锁保证安全：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ph.c</span></span><br><span class="line"><span class="type">pthread_mutex_t</span> lock;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">pthread_t</span> *tha;</span><br><span class="line">  <span class="type">void</span> *value;</span><br><span class="line">  <span class="type">double</span> t1, t0;</span><br><span class="line">  </span><br><span class="line">  pthread_mutex_init(&amp;lock, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> </span><br><span class="line"><span class="type">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span></span><br><span class="line">&#123;</span><br><span class="line">   NBUCKET;</span><br><span class="line"></span><br><span class="line">  pthread_mutex_lock(&amp;lock);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">  pthread_mutex_unlock(&amp;lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> entry*</span><br><span class="line"><span class="title function_">get</span><span class="params">(<span class="type">int</span> key)</span></span><br><span class="line">&#123;</span><br><span class="line">  $ NBUCKET;</span><br><span class="line"></span><br><span class="line">  pthread_mutex_lock(&amp;lock);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">  pthread_mutex_unlock(&amp;lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>加完这个锁，就可以通过 ph_safe 测试了，编译执行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ ./ph 1</span><br><span class="line">100000 puts, 4.652 seconds, 21494 puts/second</span><br><span class="line">0: 0 keys missing</span><br><span class="line">100000 gets, 5.098 seconds, 19614 gets/second</span><br><span class="line">$ ./ph 2</span><br><span class="line">100000 puts, 5.224 seconds, 19142 puts/second</span><br><span class="line">0: 0 keys missing</span><br><span class="line">1: 0 keys missing</span><br><span class="line">200000 gets, 10.222 seconds, 19566 gets/second</span><br></pre></td></tr></table></figure>

<p>可以发现，多线程执行的版本也不会丢失 key 了，说明加锁成功防止了 race-condition 的出现。</p>
<p>但是仔细观察会发现，加锁后多线程的性能变得比单线程还要低了，虽然不会出现数据丢失，但是失去了多线程并行计算的意义：提升性能。</p>
<p>这里的原因是，我们为整个操作加上了互斥锁，意味着每一时刻只能有一个线程在操作哈希表，这里实际上等同于将哈希表的操作变回单线程了，又由于锁操作（加锁、解锁、锁竞争）是有开销的，所以性能甚至不如单线程版本。</p>
<p>这里的优化思路，也是多线程效率的一个常见的优化思路，就是降低锁的粒度。由于哈希表中，不同的 bucket 是互不影响的，一个 bucket 处于修改未完全的状态并不影响 put 和 get 对其他 bucket 的操作，所以实际上只需要确保两个线程不会同时操作同一个 bucket 即可，并不需要确保不会同时操作整个哈希表。</p>
<p>所以可以将加锁的粒度，从整个哈希表一个锁降低到每个 bucket 一个锁。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ph.c</span></span><br><span class="line"><span class="type">pthread_mutex_t</span> locks;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">pthread_t</span> *tha;</span><br><span class="line">  <span class="type">void</span> *value;</span><br><span class="line">  <span class="type">double</span> t1, t0;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;NBUCKET;i++) &#123;</span><br><span class="line">    pthread_mutex_init(&amp;locks[i], <span class="literal">NULL</span>); </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> </span><br><span class="line"><span class="type">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i = key % NBUCKET;</span><br><span class="line"></span><br><span class="line">  pthread_mutex_lock(&amp;locks[i]);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">  pthread_mutex_unlock(&amp;locks[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> entry*</span><br><span class="line"><span class="title function_">get</span><span class="params">(<span class="type">int</span> key)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i = key % NBUCKET;</span><br><span class="line"></span><br><span class="line">  pthread_mutex_lock(&amp;locks[i]);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">  pthread_mutex_unlock(&amp;locks[i]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这样修改后，编译执行：</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">$</span> ./ph 1</span><br><span class="line">100000 puts, 4.940 seconds, 20241 puts/second</span><br><span class="line">0: 0 keys missing</span><br><span class="line">100000 gets, 4.934 seconds, 20267 gets/second</span><br><span class="line"><span class="built_in">$</span> ./ph 2</span><br><span class="line">100000 puts, 3.489 seconds, 28658 puts/second</span><br><span class="line">0: 0 keys missing</span><br><span class="line">1: 0 keys missing</span><br><span class="line">200000 gets, 6.104 seconds, 32766 gets/second</span><br><span class="line"><span class="built_in">$</span> ./ph 4</span><br><span class="line">100000 puts, 1.881 seconds, 53169 puts/second</span><br><span class="line">0: 0 keys missing</span><br><span class="line">3: 0 keys missing</span><br><span class="line">2: 0 keys missing</span><br><span class="line">1: 0 keys missing</span><br><span class="line">400000 gets, 7.376 seconds, 54229 gets/second</span><br></pre></td></tr></table></figure>

<p>可以看到，多线程版本的性能有了显著提升（虽然由于锁开销，依然达不到理想的 <code>单线程速度 * 线程数</code> 那么快），并且依然没有 missing key。</p>
<p>此时再运行 grade，就可以通过 ph_fast 测试了。</p>
<h4 id="7-3Barrier-moderate"><a href="#7-3Barrier-moderate" class="headerlink" title="7.3Barrier (moderate)"></a>7.3Barrier (moderate)</h4><p>利用 pthread 提供的条件变量方法，实现同步屏障机制。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// barrier.c</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> </span><br><span class="line"><span class="title function_">barrier</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  pthread_mutex_lock(&amp;bstate.barrier_mutex);</span><br><span class="line">  <span class="keyword">if</span>(++bstate.nthread &lt; nthread) &#123;</span><br><span class="line">    pthread_cond_wait(&amp;bstate.barrier_cond, &amp;bstate.barrier_mutex);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    bstate.nthread = <span class="number">0</span>;</span><br><span class="line">    bstate.round++;</span><br><span class="line">    pthread_cond_broadcast(&amp;bstate.barrier_cond);</span><br><span class="line">  &#125;</span><br><span class="line">  pthread_mutex_unlock(&amp;bstate.barrier_mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>线程进入同步屏障 barrier 时，将已进入屏障的线程数量增加 1，然后再判断是否已经达到总线程数。如果未达到，则进入睡眠，等待其他线程。如果已经达到，则唤醒所有在 barrier 中等待的线程，所有线程继续执行；屏障轮数 + 1；</code></p>
<p>「将已进入屏障的线程数量增加 1，然后再判断是否已经达到总线程数」这一步并不是原子操作，并且这一步和后面的两种情况中的操作「睡眠」和「唤醒」之间也不是原子的，如果在这里发生 race-condition，则会导致出现 「lost wake-up 问题」（线程 1 即将睡眠前，线程 2 调用了唤醒，然后线程 1 才进入睡眠，导致线程 1 本该被唤醒而没被唤醒）</p>
<blockquote>
<p>解决方法是，「屏障的线程数量增加 1；判断是否已经达到总线程数；进入睡眠」这三步必须原子。所以使用一个互斥锁 barrier_mutex 来保护这一部分代码。pthread_cond_wait 会在进入睡眠的时候原子性的释放 barrier_mutex，从而允许后续线程进入 barrier，防止死锁。</p>
</blockquote>
<h3 id="Lab-8-Locks"><a href="#Lab-8-Locks" class="headerlink" title="Lab 8: Locks"></a>Lab 8: Locks</h3><p>重新设计代码以降低锁竞争，提高多核机器上系统的并行性。</p>
<h4 id="8-1Memory-allocator-moderate"><a href="#8-1Memory-allocator-moderate" class="headerlink" title="8.1Memory allocator (moderate)"></a>8.1Memory allocator (moderate)</h4><p>通过拆分 kmem 中的空闲内存链表，降低 kalloc 实现中的 kmem 锁竞争。</p>
<h5 id="8-1-1原理与分析"><a href="#8-1-1原理与分析" class="headerlink" title="8.1.1原理与分析"></a>8.1.1原理与分析</h5><p>kalloc 原本的实现中，使用 freelist 链表，将空闲物理页本身直接用作链表项（这样可以不使用额外空间）连接成一个链表，在分配的时候，将物理页从链表中移除，回收时将物理页放回链表中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/kalloc.c</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">freelist</span>;</span></span><br><span class="line">&#125; kmem;</span><br></pre></td></tr></table></figure>

<p>分配物理页的实现（原版）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/kalloc.c</span></span><br><span class="line"><span class="type">void</span> *</span><br><span class="line"><span class="title function_">kalloc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span>;</span></span><br><span class="line"></span><br><span class="line">  acquire(&amp;kmem.lock);</span><br><span class="line">  r = kmem.freelist; <span class="comment">// 取出一个物理页。页表项本身就是物理页。</span></span><br><span class="line">  <span class="keyword">if</span>(r)</span><br><span class="line">    kmem.freelist = r-&gt;next;</span><br><span class="line">  release(&amp;kmem.lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(r)</span><br><span class="line">    <span class="built_in">memset</span>((<span class="type">char</span>*)r, <span class="number">5</span>, PGSIZE); <span class="comment">// fill with junk</span></span><br><span class="line">  <span class="keyword">return</span> (<span class="type">void</span>*)r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里无论是分配物理页或释放物理页，都需要修改 freelist 链表。由于修改是多步操作，为了保持多线程一致性，必须加锁。但这样的设计也使得多线程无法并发申请内存，限制了并发效率。</p>
<p>证据是 kmem 锁上频繁的锁竞争：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kalloctest</span></span><br><span class="line">start test1</span><br><span class="line">test1 results:</span><br><span class="line">--- lock kmem/bcache stats</span><br><span class="line">lock: kmem: #fetch-and-add 83375 #acquire() 433015</span><br><span class="line">lock: bcache: #fetch-and-add 0 #acquire() 1260</span><br><span class="line">--- top 5 contended locks:</span><br><span class="line">lock: kmem: #fetch-and-add 83375 #acquire() 433015  // kmem 是整个系统中竞争最激烈的锁</span><br><span class="line">lock: proc: #fetch-and-add 23737 #acquire() 130718</span><br><span class="line">lock: virtio_disk: #fetch-and-add 11159 #acquire() 114</span><br><span class="line">lock: proc: #fetch-and-add 5937 #acquire() 130786</span><br><span class="line">lock: proc: #fetch-and-add 4080 #acquire() 130786</span><br><span class="line">tot= 83375</span><br><span class="line">test1 FAIL</span><br></pre></td></tr></table></figure>

<p>这里体现了一个先 profile 再进行优化的思路。如果一个大锁并不会引起明显的性能问题，有时候大锁就足够了。只有在万分确定性能热点是在该锁的时候才进行优化，「过早优化是万恶之源」。</p>
<p>这里解决性能热点的思路是「将共享资源变为不共享资源」。锁竞争优化一般有几个思路：</p>
<ul>
<li><code>只在必须共享的时候共享（对应为将资源从 CPU 共享拆分为每个 CPU 独立）</code></li>
<li><code>必须共享时，尽量减少在关键区中停留的时间（对应“大锁化小锁”，降低锁的粒度）</code></li>
</ul>
<blockquote>
<p>该 lab 的实验目标，即是为每个 CPU 分配独立的 freelist，这样多个 CPU 并发分配物理页就不再会互相排斥了，提高了并行性。</p>
</blockquote>
<p><code>但由于在一个 CPU freelist 中空闲页不足的情况下，仍需要从其他 CPU 的 freelist 中“偷”内存页，所以一个 CPU 的 freelist 并不是只会被其对应 CPU 访问，还可能在“偷”内存页的时候被其他 CPU 访问，故仍然需要使用单独的锁来保护每个 CPU 的 freelist。</code>但一个 CPU freelist 中空闲页不足的情况相对来说是比较稀有的，所以总体性能依然比单独 kmem 大锁要快。在最佳情况下，也就是没有发生跨 CPU “偷”页的情况下，这些小锁不会发生任何锁竞争。</p>
<h5 id="8-1-2代码实现"><a href="#8-1-2代码实现" class="headerlink" title="8.1.2代码实现"></a>8.1.2代码实现</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/kalloc.c</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">freelist</span>;</span></span><br><span class="line">&#125; kmem[NCPU]; <span class="comment">// 为每个 CPU 分配独立的 freelist，并用独立的锁保护它。</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *kmem_lock_names[] = &#123;</span><br><span class="line">  <span class="string">&quot;kmem_cpu_0&quot;</span>,</span><br><span class="line">  <span class="string">&quot;kmem_cpu_1&quot;</span>,</span><br><span class="line">  <span class="string">&quot;kmem_cpu_2&quot;</span>,</span><br><span class="line">  <span class="string">&quot;kmem_cpu_3&quot;</span>,</span><br><span class="line">  <span class="string">&quot;kmem_cpu_4&quot;</span>,</span><br><span class="line">  <span class="string">&quot;kmem_cpu_5&quot;</span>,</span><br><span class="line">  <span class="string">&quot;kmem_cpu_6&quot;</span>,</span><br><span class="line">  <span class="string">&quot;kmem_cpu_7&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">kinit</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;NCPU;i++) &#123; <span class="comment">// 初始化所有锁</span></span><br><span class="line">    initlock(&amp;kmem[i].lock, kmem_lock_names[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  freerange(end, (<span class="type">void</span>*)PHYSTOP);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/kalloc.c</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">kfree</span><span class="params">(<span class="type">void</span> *pa)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(((uint64)pa % PGSIZE) != <span class="number">0</span> || (<span class="type">char</span>*)pa &lt; end || (uint64)pa &gt;= PHYSTOP)</span><br><span class="line">    panic(<span class="string">&quot;kfree&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Fill with junk to catch dangling refs.</span></span><br><span class="line">  <span class="built_in">memset</span>(pa, <span class="number">1</span>, PGSIZE);</span><br><span class="line"></span><br><span class="line">  r = (<span class="keyword">struct</span> run*)pa;</span><br><span class="line"></span><br><span class="line">  push_off();</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> cpu = cpuid();</span><br><span class="line"></span><br><span class="line">  acquire(&amp;kmem[cpu].lock);</span><br><span class="line">  r-&gt;next = kmem[cpu].freelist;</span><br><span class="line">  kmem[cpu].freelist = r;</span><br><span class="line">  release(&amp;kmem[cpu].lock);</span><br><span class="line"></span><br><span class="line">  pop_off();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *</span><br><span class="line"><span class="title function_">kalloc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span>;</span></span><br><span class="line"></span><br><span class="line">  push_off();</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> cpu = cpuid();</span><br><span class="line"></span><br><span class="line">  acquire(&amp;kmem[cpu].lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(!kmem[cpu].freelist) &#123; <span class="comment">// no page left for this cpu</span></span><br><span class="line">    <span class="type">int</span> steal_left = <span class="number">64</span>; <span class="comment">// steal 64 pages from other cpu(s)</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;NCPU;i++) &#123;</span><br><span class="line">      <span class="keyword">if</span>(i == cpu) <span class="keyword">continue</span>; <span class="comment">// no self-robbery</span></span><br><span class="line">      acquire(&amp;kmem[i].lock);</span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">rr</span> =</span> kmem[i].freelist;</span><br><span class="line">      <span class="keyword">while</span>(rr &amp;&amp; steal_left) &#123;</span><br><span class="line">        kmem[i].freelist = rr-&gt;next;</span><br><span class="line">        rr-&gt;next = kmem[cpu].freelist;</span><br><span class="line">        kmem[cpu].freelist = rr;</span><br><span class="line">        rr = kmem[i].freelist;</span><br><span class="line">        steal_left--;</span><br><span class="line">      &#125;</span><br><span class="line">      release(&amp;kmem[i].lock);</span><br><span class="line">      <span class="keyword">if</span>(steal_left == <span class="number">0</span>) <span class="keyword">break</span>; <span class="comment">// done stealing</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  r = kmem[cpu].freelist;</span><br><span class="line">  <span class="keyword">if</span>(r)</span><br><span class="line">    kmem[cpu].freelist = r-&gt;next;</span><br><span class="line">  release(&amp;kmem[cpu].lock);</span><br><span class="line"></span><br><span class="line">  pop_off();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(r)</span><br><span class="line">    <span class="built_in">memset</span>((<span class="type">char</span>*)r, <span class="number">5</span>, PGSIZE); <span class="comment">// fill with junk</span></span><br><span class="line">  <span class="keyword">return</span> (<span class="type">void</span>*)r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里选择在内存页不足的时候，从其他的 CPU “偷” 64 个页，这里的数值是随意取的，<code>在现实场景中，最好进行测量后选取合适的数值，尽量使得“偷”页频率低。</code></p>
<blockquote>
<p>上述代码可能产生死锁（cpu_a 尝试偷 cpu_b，cpu_b 尝试偷 cpu_a）</p>
</blockquote>
<h3 id="Lab-9-File-Systems"><a href="#Lab-9-File-Systems" class="headerlink" title="Lab 9: File Systems"></a>Lab 9: File Systems</h3><p>为 xv6 的文件系统添加大文件以及符号链接支持。该 lab 难度较低。</p>
<h4 id="9-1Large-files-moderate"><a href="#9-1Large-files-moderate" class="headerlink" title="9.1Large files (moderate)"></a>9.1Large files (moderate)</h4><h5 id="9-1-1原理与分析"><a href="#9-1-1原理与分析" class="headerlink" title="9.1.1原理与分析"></a>9.1.1原理与分析</h5><p>与 FAT 文件系统类似，xv6 文件系统中的每一个 inode 结构体中，采用了<code>混合索引</code>的方式记录数据的所在具体盘块号。每个文件所占用的前 12 个盘块的盘块号是直接记录在 inode 中的（每个盘块 1024 字节），所以对于任何文件的前 12 KB 数据，都可以通过访问 inode 直接得到盘块号。这一部分称为直接记录盘块。</p>
<p>对于大于 12 个盘块的文件，大于 12 个盘块的部分，会分配一个额外的一级索引表（一盘块大小，1024Byte），用于存储这部分数据的所在盘块号。</p>
<p>由于一级索引表可以包含 BSIZE(1024) &#x2F; 4 &#x3D; 256 个盘块号，加上 inode 中的 12 个盘块号，一个文件最多可以使用 12+256 &#x3D; 268 个盘块，也就是 268KB。</p>
<p>inode 结构（含有 NDIRECT&#x3D;12 个直接记录盘块，还有一个一级索引盘块，后者又可额外包含 256 个盘块号）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/fs.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// note: NDIRECT=12</span></span><br><span class="line"><span class="comment">// On-disk inode structure</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dinode</span> &#123;</span></span><br><span class="line">  <span class="type">short</span> type;           <span class="comment">// File type</span></span><br><span class="line">  <span class="type">short</span> major;          <span class="comment">// Major device number (T_DEVICE only)</span></span><br><span class="line">  <span class="type">short</span> minor;          <span class="comment">// Minor device number (T_DEVICE only)</span></span><br><span class="line">  <span class="type">short</span> nlink;          <span class="comment">// Number of links to inode in file system</span></span><br><span class="line">  uint size;            <span class="comment">// Size of file (bytes)</span></span><br><span class="line">  uint addrs[NDIRECT+<span class="number">1</span>];   <span class="comment">// Data block addresses</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>本 lab 的目标是通过为混合索引机制添加二级索引页，来扩大能够支持的最大文件大小。</p>
<p><img src="/../../../../../../imgs/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%BA%90%E7%A0%81%E7%BA%A7%E5%89%96%E6%9E%90/image-20221119195251727.png" alt="image-20221119195251727"></p>
<p>本 lab 比较简单，主要前置是需要对文件系统的理解，确保充分理解 xv6 book 中的 file system 相关部分。</p>
<h5 id="9-1-2代码实现"><a href="#9-1-2代码实现" class="headerlink" title="9.1.2代码实现"></a>9.1.2代码实现</h5><p>首先修改 struct inode（内存中的 inode 副本结构体）以及 struct dinode（磁盘上的 inode 结构体），将 NDIRECT 直接索引的盘块号减少 1，腾出 inode 中的空间来存储二级索引的索引表盘块号。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/fs.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NDIRECT 11 <span class="comment">// 12 -&gt; 11</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NINDIRECT (BSIZE / sizeof(uint))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXFILE (NDIRECT + NINDIRECT + NINDIRECT * NINDIRECT)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// On-disk inode structure</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dinode</span> &#123;</span></span><br><span class="line">  <span class="type">short</span> type;           <span class="comment">// File type</span></span><br><span class="line">  <span class="type">short</span> major;          <span class="comment">// Major device number (T_DEVICE only)</span></span><br><span class="line">  <span class="type">short</span> minor;          <span class="comment">// Minor device number (T_DEVICE only)</span></span><br><span class="line">  <span class="type">short</span> nlink;          <span class="comment">// Number of links to inode in file system</span></span><br><span class="line">  uint size;            <span class="comment">// Size of file (bytes)</span></span><br><span class="line">  uint addrs[NDIRECT+<span class="number">2</span>];   <span class="comment">// Data block addresses (NDIRECT+1 -&gt; NDIRECT+2)</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/file.h</span></span><br><span class="line"><span class="comment">// in-memory copy of an inode</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode</span> &#123;</span></span><br><span class="line">  uint dev;           <span class="comment">// Device number</span></span><br><span class="line">  uint inum;          <span class="comment">// Inode number</span></span><br><span class="line">  <span class="type">int</span> ref;            <span class="comment">// Reference count</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sleeplock</span> <span class="title">lock</span>;</span> <span class="comment">// protects everything below here</span></span><br><span class="line">  <span class="type">int</span> valid;          <span class="comment">// inode has been read from disk?</span></span><br><span class="line"></span><br><span class="line">  <span class="type">short</span> type;         <span class="comment">// copy of disk inode</span></span><br><span class="line">  <span class="type">short</span> major;</span><br><span class="line">  <span class="type">short</span> minor;</span><br><span class="line">  <span class="type">short</span> nlink;</span><br><span class="line">  uint size;</span><br><span class="line">  uint addrs[NDIRECT+<span class="number">2</span>]; <span class="comment">// NDIRECT+1 -&gt; NDIRECT+2</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>修改 bmap（获取 inode 中第 bn 个块的块号）和 itrunc（释放该 inode 所使用的所有数据块），让其能够识别二级索引。（基本上和复制粘贴一致，只是在查出一级块号后，需将一级块中的数据读入，然后再次查询）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/fs.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Return the disk block address of the nth block in inode ip.</span></span><br><span class="line"><span class="comment">// If there is no such block, bmap allocates one.</span></span><br><span class="line"><span class="type">static</span> uint</span><br><span class="line"><span class="title function_">bmap</span><span class="params">(<span class="keyword">struct</span> inode *ip, uint bn)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint addr, *a;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">bp</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(bn &lt; NDIRECT)&#123;</span><br><span class="line">    <span class="keyword">if</span>((addr = ip-&gt;addrs[bn]) == <span class="number">0</span>)</span><br><span class="line">      ip-&gt;addrs[bn] = addr = balloc(ip-&gt;dev);</span><br><span class="line">    <span class="keyword">return</span> addr;</span><br><span class="line">  &#125;</span><br><span class="line">  bn -= NDIRECT;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(bn &lt; NINDIRECT)&#123; <span class="comment">// singly-indirect</span></span><br><span class="line">    <span class="comment">// Load indirect block, allocating if necessary.</span></span><br><span class="line">    <span class="keyword">if</span>((addr = ip-&gt;addrs[NDIRECT]) == <span class="number">0</span>)</span><br><span class="line">      ip-&gt;addrs[NDIRECT] = addr = balloc(ip-&gt;dev);</span><br><span class="line">    bp = bread(ip-&gt;dev, addr);</span><br><span class="line">    a = (uint*)bp-&gt;data;</span><br><span class="line">    <span class="keyword">if</span>((addr = a[bn]) == <span class="number">0</span>)&#123;</span><br><span class="line">      a[bn] = addr = balloc(ip-&gt;dev);</span><br><span class="line">      log_write(bp);</span><br><span class="line">    &#125;</span><br><span class="line">    brelse(bp);</span><br><span class="line">    <span class="keyword">return</span> addr;</span><br><span class="line">  &#125;</span><br><span class="line">  bn -= NINDIRECT;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(bn &lt; NINDIRECT * NINDIRECT) &#123; <span class="comment">// doubly-indirect</span></span><br><span class="line">    <span class="comment">// Load indirect block, allocating if necessary.</span></span><br><span class="line">    <span class="keyword">if</span>((addr = ip-&gt;addrs[NDIRECT+<span class="number">1</span>]) == <span class="number">0</span>)</span><br><span class="line">      ip-&gt;addrs[NDIRECT+<span class="number">1</span>] = addr = balloc(ip-&gt;dev);</span><br><span class="line">    bp = bread(ip-&gt;dev, addr);</span><br><span class="line">    a = (uint*)bp-&gt;data;</span><br><span class="line">    <span class="keyword">if</span>((addr = a[bn/NINDIRECT]) == <span class="number">0</span>)&#123;</span><br><span class="line">      a[bn/NINDIRECT] = addr = balloc(ip-&gt;dev);</span><br><span class="line">      log_write(bp);</span><br><span class="line">    &#125;</span><br><span class="line">    brelse(bp);</span><br><span class="line">    bn %= NINDIRECT;</span><br><span class="line">    bp = bread(ip-&gt;dev, addr);</span><br><span class="line">    a = (uint*)bp-&gt;data;</span><br><span class="line">    <span class="keyword">if</span>((addr = a[bn]) == <span class="number">0</span>)&#123;</span><br><span class="line">      a[bn] = addr = balloc(ip-&gt;dev);</span><br><span class="line">      log_write(bp);</span><br><span class="line">    &#125;</span><br><span class="line">    brelse(bp);</span><br><span class="line">    <span class="keyword">return</span> addr;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  panic(<span class="string">&quot;bmap: out of range&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Truncate inode (discard contents).</span></span><br><span class="line"><span class="comment">// Caller must hold ip-&gt;lock.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">itrunc</span><span class="params">(<span class="keyword">struct</span> inode *ip)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i, j;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">bp</span>;</span></span><br><span class="line">  uint *a;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; NDIRECT; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(ip-&gt;addrs[i])&#123;</span><br><span class="line">      bfree(ip-&gt;dev, ip-&gt;addrs[i]);</span><br><span class="line">      ip-&gt;addrs[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(ip-&gt;addrs[NDIRECT])&#123;</span><br><span class="line">    bp = bread(ip-&gt;dev, ip-&gt;addrs[NDIRECT]);</span><br><span class="line">    a = (uint*)bp-&gt;data;</span><br><span class="line">    <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; NINDIRECT; j++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(a[j])</span><br><span class="line">        bfree(ip-&gt;dev, a[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    brelse(bp);</span><br><span class="line">    bfree(ip-&gt;dev, ip-&gt;addrs[NDIRECT]);</span><br><span class="line">    ip-&gt;addrs[NDIRECT] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(ip-&gt;addrs[NDIRECT+<span class="number">1</span>])&#123;</span><br><span class="line">    bp = bread(ip-&gt;dev, ip-&gt;addrs[NDIRECT+<span class="number">1</span>]);</span><br><span class="line">    a = (uint*)bp-&gt;data;</span><br><span class="line">    <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; NINDIRECT; j++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(a[j]) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">bp2</span> =</span> bread(ip-&gt;dev, a[j]);</span><br><span class="line">        uint *a2 = (uint*)bp2-&gt;data;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt; NINDIRECT; k++)&#123;</span><br><span class="line">          <span class="keyword">if</span>(a2[k])</span><br><span class="line">            bfree(ip-&gt;dev, a2[k]);</span><br><span class="line">        &#125;</span><br><span class="line">        brelse(bp2);</span><br><span class="line">        bfree(ip-&gt;dev, a[j]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    brelse(bp);</span><br><span class="line">    bfree(ip-&gt;dev, ip-&gt;addrs[NDIRECT+<span class="number">1</span>]);</span><br><span class="line">    ip-&gt;addrs[NDIRECT + <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ip-&gt;size = <span class="number">0</span>;</span><br><span class="line">  iupdate(ip);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="9-2Symbolic-links-moderate"><a href="#9-2Symbolic-links-moderate" class="headerlink" title="9.2Symbolic links (moderate)"></a>9.2Symbolic links (moderate)</h4><p>实现符号链接机制。</p>
<h5 id="9-2-1原理与分析"><a href="#9-2-1原理与分析" class="headerlink" title="9.2.1原理与分析"></a>9.2.1原理与分析</h5><p><code>符号链接（软链接）是一类特殊的文件， 其包含有一条以绝对路径或者相对路径的形式指向其它文件或者目录的引用。</code>符号链接的操作是透明的：对符号链接文件进行读写的程序会表现得直接对目标文件进行操作。某些需要特别处理符号链接的程序（如备份程序）可能会识别并直接对其进行操作。</p>
<p>&#x3D;&#x3D;一个符号链接文件仅包含有一个文本字符串，其被操作系统解释为一条指向另一个文件或者目录的路径。它是一个独立文件，其存在并不依赖于目标文件。如果删除一个符号链接，它指向的目标文件不受影响。如果目标文件被移动、重命名或者删除，任何指向它的符号链接仍然存在，但是它们将会指向一个不复存在的文件。这种情况被有时被称为被遗弃。&#x3D;&#x3D;</p>
<h5 id="9-2-2代码实现"><a href="#9-2-2代码实现" class="headerlink" title="9.2.2代码实现"></a>9.2.2代码实现</h5><p>首先实现 symlink 系统调用，用于创建符号链接。 符号链接与普通的文件一样，需要占用 inode 块。这里使用 inode 中的第一个 direct-mapped 块（1024字节）来存储符号链接指向的文件。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/sysfile.c</span></span><br><span class="line"></span><br><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_symlink</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">ip</span>;</span></span><br><span class="line">  <span class="type">char</span> target[MAXPATH], path[MAXPATH];</span><br><span class="line">  <span class="keyword">if</span>(argstr(<span class="number">0</span>, target, MAXPATH) &lt; <span class="number">0</span> || argstr(<span class="number">1</span>, path, MAXPATH) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  begin_op();</span><br><span class="line"></span><br><span class="line">  ip = create(path, T_SYMLINK, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span>(ip == <span class="number">0</span>)&#123;</span><br><span class="line">    end_op();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// use the first data block to store target path.</span></span><br><span class="line">  <span class="keyword">if</span>(writei(ip, <span class="number">0</span>, (uint64)target, <span class="number">0</span>, <span class="built_in">strlen</span>(target)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    end_op();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  iunlockput(ip);</span><br><span class="line"></span><br><span class="line">  end_op();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 fcntl.h 中补齐 O_NOFOLLOW 的定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> O_RDONLY   0x000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> O_WRONLY   0x001</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> O_RDWR     0x002</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> O_CREATE   0x200</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> O_TRUNC    0x400</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> O_NOFOLLOW 0x800</span></span><br></pre></td></tr></table></figure>

<p>修改 sys_open，使其在遇到符号链接的时候，可以递归跟随符号链接，直到跟随到非符号链接的 inode 为止。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_open</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> path[MAXPATH];</span><br><span class="line">  <span class="type">int</span> fd, omode;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">f</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">ip</span>;</span></span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>((n = argstr(<span class="number">0</span>, path, MAXPATH)) &lt; <span class="number">0</span> || argint(<span class="number">1</span>, &amp;omode) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  begin_op();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(omode &amp; O_CREATE)&#123;</span><br><span class="line">    ip = create(path, T_FILE, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(ip == <span class="number">0</span>)&#123;</span><br><span class="line">      end_op();</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="type">int</span> symlink_depth = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123; <span class="comment">// recursively follow symlinks</span></span><br><span class="line">      <span class="keyword">if</span>((ip = namei(path)) == <span class="number">0</span>)&#123;</span><br><span class="line">        end_op();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      ilock(ip);</span><br><span class="line">      <span class="keyword">if</span>(ip-&gt;type == T_SYMLINK &amp;&amp; (omode &amp; O_NOFOLLOW) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(++symlink_depth &gt; <span class="number">10</span>) &#123;</span><br><span class="line">          <span class="comment">// too many layer of symlinks, might be a loop</span></span><br><span class="line">          iunlockput(ip);</span><br><span class="line">          end_op();</span><br><span class="line">          <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(readi(ip, <span class="number">0</span>, (uint64)path, <span class="number">0</span>, MAXPATH) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">          iunlockput(ip);</span><br><span class="line">          end_op();</span><br><span class="line">          <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        iunlockput(ip);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(ip-&gt;type == T_DIR &amp;&amp; omode != O_RDONLY)&#123;</span><br><span class="line">      iunlockput(ip);</span><br><span class="line">      end_op();</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// .......</span></span><br><span class="line"></span><br><span class="line">  iunlock(ip);</span><br><span class="line">  end_op();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> fd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Lab-10-Mmap"><a href="#Lab-10-Mmap" class="headerlink" title="Lab 10: Mmap"></a>Lab 10: Mmap</h3><p>这一个实验是要实现最基础的<code>mmap</code>功能。mmap即内存映射文件，将一个文件直接映射到内存当中，之后对文件的读写就可以直接通过对内存进行读写来进行，而对文件的同步则由操作系统来负责完成。使用<code>mmap</code>可以避免对文件大量<code>read</code>和<code>write</code>操作带来的内核缓冲区和用户缓冲区之间的频繁的数据拷贝。在Kafka消息队列等软件中借助<code>mmap</code>来实现<code>零拷贝（zero-copy）</code>。</p>
<h4 id="10-1原理与分析"><a href="#10-1原理与分析" class="headerlink" title="10.1原理与分析"></a>10.1原理与分析</h4><p><code>mmap</code> 函数的原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">mmap</span><span class="params">(<span class="type">void</span> *addr, <span class="type">size_t</span> length, <span class="type">int</span> prot, <span class="type">int</span> flags, <span class="type">int</span> fd, <span class="type">off_t</span> offset)</span>;</span><br></pre></td></tr></table></figure>

<p>下面介绍一下 <code>mmap</code> 函数的各个参数作用：</p>
<ul>
<li><p><code>addr</code>：指定映射的虚拟内存地址，可以设置为 NULL，让 Linux 内核自动选择合适的虚拟内存地址。</p>
</li>
<li><p><code>length</code>：映射的长度。</p>
</li>
<li><p><code>prot</code>：映射内存的保护模式，可选值如下：</p>
</li>
<li><ul>
<li><code>PROT_EXEC</code>：可以被执行。</li>
<li><code>PROT_READ</code>：可以被读取。</li>
<li><code>PROT_WRITE</code>：可以被写入。</li>
<li><code>PROT_NONE</code>：不可访问。</li>
</ul>
</li>
<li><p><code>flags</code>：指定映射的类型，常用的可选值如下：</p>
</li>
<li><ul>
<li><code>MAP_FIXED</code>：使用指定的起始虚拟内存地址进行映射。</li>
<li><code>MAP_SHARED</code>：与其它所有映射到这个文件的进程共享映射空间（可实现共享内存）。</li>
<li><code>MAP_PRIVATE</code>：建立一个写时复制（Copy on Write）的私有映射空间。</li>
<li><code>MAP_LOCKED</code>：锁定映射区的页面，从而防止页面被交换出内存。</li>
<li>…</li>
</ul>
</li>
<li><p><code>fd</code>：进行映射的文件句柄。</p>
</li>
<li><p><code>offset</code>：文件偏移量（从文件的何处开始映射）。</p>
</li>
</ul>
<h4 id="10-2代码实现"><a href="#10-2代码实现" class="headerlink" title="10.2代码实现"></a>10.2代码实现</h4><p>首先定义<code>vma</code>结构体用于保存内存映射信息，并在<code>proc</code>结构体中加入<code>struct vma *vma</code>指针：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> NVMA 16</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VMA_START (MAXVA / 2)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vma</span>&#123;</span></span><br><span class="line">  uint64 start;</span><br><span class="line">  uint64 end;</span><br><span class="line">  uint64 length; <span class="comment">// 0 means vma not used</span></span><br><span class="line">  uint64 off;</span><br><span class="line">  <span class="type">int</span> permission;</span><br><span class="line">  <span class="type">int</span> flags;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">vma</span> *<span class="title">next</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Per-process state</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> &#123;</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">vma</span> *<span class="title">vma</span>;</span></span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>之后实现对<code>vma</code>分配的代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vma</span> <span class="title">vma_list</span>[<span class="title">NVMA</span>];</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> vma* <span class="title function_">vma_alloc</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; NVMA; i++)&#123;</span><br><span class="line">    acquire(&amp;vma_list[i].lock);</span><br><span class="line">    <span class="keyword">if</span>(vma_list[i].length == <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> &amp;vma_list[i];</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      release(&amp;vma_list[i].lock);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  panic(<span class="string">&quot;no enough vma&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现<code>mmap</code>系统调用，这个函数主要就是申请一个<code>vma</code>，之后查找一块空闲内存，填入相关信息，将<code>vma</code>插入到进程的<code>vma</code>链表中去：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_mmap</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint64 addr;</span><br><span class="line">  <span class="type">int</span> length, prot, flags, fd, offset;</span><br><span class="line">  <span class="keyword">if</span>(argaddr(<span class="number">0</span>, &amp;addr) &lt; <span class="number">0</span> || argint(<span class="number">1</span>, &amp;length) &lt; <span class="number">0</span> || argint(<span class="number">2</span>, &amp;prot) &lt; <span class="number">0</span> || argint(<span class="number">3</span>, &amp;flags) &lt; <span class="number">0</span> || argint(<span class="number">4</span>, &amp;fd) &lt; <span class="number">0</span> || argint(<span class="number">5</span>, &amp;offset) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(addr != <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;mmap: addr not 0&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span>(offset != <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;mmap: offset not 0&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file</span>* <span class="title">f</span> =</span> p-&gt;ofile[fd];</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> pte_flag = PTE_U;</span><br><span class="line">  <span class="keyword">if</span> (prot &amp; PROT_WRITE) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!f-&gt;writable &amp;&amp; !(flags &amp; MAP_PRIVATE)) <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// map to a unwritable file with PROT_WRITE</span></span><br><span class="line">    pte_flag |= PTE_W;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (prot &amp; PROT_READ) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!f-&gt;readable) <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// map to a unreadable file with PROT_READ</span></span><br><span class="line">    pte_flag |= PTE_R;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">vma</span>* <span class="title">v</span> =</span> vma_alloc();</span><br><span class="line">  v-&gt;permission = pte_flag;</span><br><span class="line">  v-&gt;length = length;</span><br><span class="line">  v-&gt;off = offset;</span><br><span class="line">  v-&gt;file = myproc()-&gt;ofile[fd];</span><br><span class="line">  v-&gt;flags = flags;</span><br><span class="line">  filedup(f);</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">vma</span>* <span class="title">pv</span> =</span> p-&gt;vma;</span><br><span class="line">  <span class="keyword">if</span>(pv == <span class="number">0</span>)&#123;</span><br><span class="line">    v-&gt;start = VMA_START;</span><br><span class="line">    v-&gt;end = v-&gt;start + length;</span><br><span class="line">    p-&gt;vma = v;</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(pv-&gt;next) pv = pv-&gt;next;</span><br><span class="line">    v-&gt;start = PGROUNDUP(pv-&gt;end);</span><br><span class="line">    v-&gt;end = v-&gt;start + length;</span><br><span class="line">    pv-&gt;next = v;</span><br><span class="line">    v-&gt;next = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  addr = v-&gt;start;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;mmap: [%p, %p)\n&quot;</span>, addr, v-&gt;end);</span><br><span class="line"></span><br><span class="line">  release(&amp;v-&gt;lock);</span><br><span class="line">  <span class="keyword">return</span> addr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来就可以在<code>usertrap</code>中对缺页中断进行处理：查找进程的<code>vma</code>链表，判断该地址是否为映射地址，如果不是就说明出错，直接返回；如果在<code>vma</code>链表中，就可以申请并映射一个页面，之后根据<code>vma</code>从对应的文件中读取数据：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">mmap_handler</span><span class="params">(uint64 va, <span class="type">int</span> scause)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">vma</span>* <span class="title">v</span> =</span> p-&gt;vma;</span><br><span class="line">  <span class="keyword">while</span>(v != <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(va &gt;= v-&gt;start &amp;&amp; va &lt; v-&gt;end)&#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//printf(&quot;%p\n&quot;, v);</span></span><br><span class="line">    v = v-&gt;next;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(v == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// not mmap addr</span></span><br><span class="line">  <span class="keyword">if</span>(scause == <span class="number">13</span> &amp;&amp; !(v-&gt;permission &amp; PTE_R)) <span class="keyword">return</span> <span class="number">-2</span>; <span class="comment">// unreadable vma</span></span><br><span class="line">  <span class="keyword">if</span>(scause == <span class="number">15</span> &amp;&amp; !(v-&gt;permission &amp; PTE_W)) <span class="keyword">return</span> <span class="number">-3</span>; <span class="comment">// unwritable vma</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// load page from file</span></span><br><span class="line">  va = PGROUNDDOWN(va);</span><br><span class="line">  <span class="type">char</span>* mem = kalloc();</span><br><span class="line">  <span class="keyword">if</span> (mem == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-4</span>; <span class="comment">// kalloc failed</span></span><br><span class="line">  </span><br><span class="line">  <span class="built_in">memset</span>(mem, <span class="number">0</span>, PGSIZE);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(mappages(p-&gt;pagetable, va, PGSIZE, (uint64)mem, v-&gt;permission) != <span class="number">0</span>)&#123;</span><br><span class="line">    kfree(mem);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-5</span>; <span class="comment">// map page failed</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">f</span> =</span> v-&gt;file;</span><br><span class="line">  ilock(f-&gt;ip);</span><br><span class="line">  readi(f-&gt;ip, <span class="number">0</span>, (uint64)mem, v-&gt;off + va - v-&gt;start, PGSIZE);</span><br><span class="line">  iunlock(f-&gt;ip);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之后就是<code>munmap</code>的实现，同样先从链表中找到对应的<code>vma</code>结构体，之后根据三种不同情况（头部、尾部、整个）来写回并释放对应的页面并更新<code>vma</code>信息，如果整个区域都被释放就将<code>vma</code>和文件释放。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_munmap</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint64 addr;</span><br><span class="line">  <span class="type">int</span> length;</span><br><span class="line">  <span class="keyword">if</span>(argaddr(<span class="number">0</span>, &amp;addr) &lt; <span class="number">0</span> || argint(<span class="number">1</span>, &amp;length) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">vma</span> *<span class="title">v</span> =</span> p-&gt;vma;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">vma</span> *<span class="title">pre</span> =</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(v != <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(addr &gt;= v-&gt;start &amp;&amp; addr &lt; v-&gt;end) <span class="keyword">break</span>; <span class="comment">// found</span></span><br><span class="line">    pre = v;</span><br><span class="line">    v = v-&gt;next;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(v == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// not mapped</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;munmap: %p %d\n&quot;</span>, addr, length);</span><br><span class="line">  <span class="keyword">if</span>(addr != v-&gt;start &amp;&amp; addr + length != v-&gt;end) </span><br><span class="line">      panic(<span class="string">&quot;munmap middle of vma&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(addr == v-&gt;start)&#123;</span><br><span class="line">    writeback(v, addr, length);</span><br><span class="line">    <span class="comment">// length最后一页的后半部分需要保留，因此只需要 length / PGSIZE 个页被unmap</span></span><br><span class="line">    uvmunmap(p-&gt;pagetable, addr, length / PGSIZE, <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 关闭vma结构体的文件</span></span><br><span class="line">    <span class="keyword">if</span>(length == v-&gt;length)&#123;</span><br><span class="line">      <span class="comment">// 1、free all</span></span><br><span class="line">      fileclose(v-&gt;file);</span><br><span class="line">      <span class="keyword">if</span>(pre == <span class="number">0</span>)&#123;</span><br><span class="line">        p-&gt;vma = v-&gt;next; <span class="comment">// head</span></span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        pre-&gt;next = v-&gt;next;</span><br><span class="line">        v-&gt;next = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      acquire(&amp;v-&gt;lock);</span><br><span class="line">      v-&gt;length = <span class="number">0</span>;</span><br><span class="line">      release(&amp;v-&gt;lock);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="comment">// 2、free head</span></span><br><span class="line">      v-&gt;start += length;</span><br><span class="line">      v-&gt;off += length;</span><br><span class="line">      v-&gt;length -= length;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="comment">// 3、free tail</span></span><br><span class="line">    v-&gt;length -= length;</span><br><span class="line">    v-&gt;end -= length;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>写回函数先判断是否需要写回，当需要写回时就仿照<code>filewrite</code>的实现，将数据写回到对应的文件当中去，这里的实现是直接写回所有页面，但实际可以根据<code>PTE_D</code>来判断内存是否被写入，如果没有写入就不用写回：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">writeback</span><span class="params">(<span class="keyword">struct</span> vma* v, uint64 addr, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(!(v-&gt;permission &amp; PTE_W) || (v-&gt;flags &amp; MAP_PRIVATE)) <span class="comment">// no need to writeback</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>((addr % PGSIZE) != <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;unmap: not aligned&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;starting writeback: %p %d\n&quot;</span>, addr, n);</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file</span>* <span class="title">f</span> =</span> v-&gt;file;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> max = ((MAXOPBLOCKS<span class="number">-1</span><span class="number">-1</span><span class="number">-2</span>) / <span class="number">2</span>) * BSIZE;</span><br><span class="line">  <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(i &lt; n)&#123;</span><br><span class="line">    <span class="type">int</span> n1 = n - i;</span><br><span class="line">    <span class="keyword">if</span>(n1 &gt; max)</span><br><span class="line">      n1 = max;</span><br><span class="line"></span><br><span class="line">    begin_op();</span><br><span class="line">    ilock(f-&gt;ip);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p %d %d\n&quot;</span>,addr + i, v-&gt;off + v-&gt;start - addr, n1);</span><br><span class="line">    <span class="type">int</span> r = writei(f-&gt;ip, <span class="number">1</span>, addr + i, v-&gt;off + addr + i - v-&gt;start, n1);</span><br><span class="line">    iunlock(f-&gt;ip);</span><br><span class="line">    end_op();</span><br><span class="line">    i += r;</span><br><span class="line">    max -= r</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后就是在<code>fork</code>当中复制<code>vma</code>到子进程，在<code>exit</code>中当前进程的<code>vma</code>链表释放，在<code>exit</code>时要对页面进行写回：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  np-&gt;state = RUNNABLE;</span><br><span class="line"></span><br><span class="line">  np-&gt;vma = <span class="number">0</span>;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">vma</span> *<span class="title">pv</span> =</span> p-&gt;vma;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">vma</span> *<span class="title">pre</span> =</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(pv)&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vma</span> *<span class="title">vma</span> =</span> vma_alloc();</span><br><span class="line">    vma-&gt;start = pv-&gt;start;</span><br><span class="line">    vma-&gt;end = pv-&gt;end;</span><br><span class="line">    vma-&gt;off = pv-&gt;off;</span><br><span class="line">    vma-&gt;length = pv-&gt;length;</span><br><span class="line">    vma-&gt;permission = pv-&gt;permission;</span><br><span class="line">    vma-&gt;flags = pv-&gt;flags;</span><br><span class="line">    vma-&gt;file = pv-&gt;file;</span><br><span class="line">    filedup(vma-&gt;file);</span><br><span class="line">    vma-&gt;next = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(pre == <span class="number">0</span>)&#123;</span><br><span class="line">      np-&gt;vma = vma;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      pre-&gt;next = vma;</span><br><span class="line">    &#125;</span><br><span class="line">    pre = vma;</span><br><span class="line">    release(&amp;vma-&gt;lock);</span><br><span class="line">    pv = pv-&gt;next;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">exit</span><span class="params">(<span class="type">int</span> status)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(p == initproc)</span><br><span class="line">    panic(<span class="string">&quot;init exiting&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// munmap all mmap vma</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">vma</span>* <span class="title">v</span> =</span> p-&gt;vma;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">vma</span>* <span class="title">pv</span>;</span></span><br><span class="line">  <span class="keyword">while</span>(v)&#123;</span><br><span class="line">    writeback(v, v-&gt;start, v-&gt;length);</span><br><span class="line">    uvmunmap(p-&gt;pagetable, v-&gt;start, PGROUNDUP(v-&gt;length) / PGSIZE, <span class="number">1</span>);</span><br><span class="line">    fileclose(v-&gt;file);</span><br><span class="line">    pv = v-&gt;next;</span><br><span class="line">    acquire(&amp;v-&gt;lock);</span><br><span class="line">    v-&gt;next = <span class="number">0</span>;</span><br><span class="line">    v-&gt;length = <span class="number">0</span>;</span><br><span class="line">    release(&amp;v-&gt;lock);</span><br><span class="line">    v = pv;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Lab-11-Networking"><a href="#Lab-11-Networking" class="headerlink" title="Lab 11: Networking"></a>Lab 11: Networking</h3><p>熟悉系统驱动与外围设备的交互、内存映射寄存器与 DMA 数据传输，实现与 E1000 网卡交互的核心方法：transmit 与 recv。</p>
<p>本 lab 的难度主要在于阅读文档以及理解 CPU 与操作系统是如何与外围设备交互的。换言之，更重要的是理解概念以及 lab 已经写好的模版代码的作用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">e1000_transmit</span><span class="params">(<span class="keyword">struct</span> mbuf *m)</span></span><br><span class="line">&#123;</span><br><span class="line">  acquire(&amp;e1000_lock); <span class="comment">// 获取 E1000 的锁，防止多进程同时发送数据出现 race</span></span><br><span class="line"></span><br><span class="line">  uint32 ind = regs[E1000_TDT]; <span class="comment">// 下一个可用的 buffer 的下标</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tx_desc</span> *<span class="title">desc</span> =</span> &amp;tx_ring[ind]; <span class="comment">// 获取 buffer 的描述符，其中存储了关于该 buffer 的各种信息</span></span><br><span class="line">  <span class="comment">// 如果该 buffer 中的数据还未传输完，则代表我们已经将环形 buffer 列表全部用完，缓冲区不足，返回错误</span></span><br><span class="line">  <span class="keyword">if</span>(!(desc-&gt;status &amp; E1000_TXD_STAT_DD)) &#123;</span><br><span class="line">    release(&amp;e1000_lock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 如果该下标仍有之前发送完毕但未释放的 mbuf，则释放</span></span><br><span class="line">  <span class="keyword">if</span>(tx_mbufs[ind]) &#123;</span><br><span class="line">    mbuffree(tx_mbufs[ind]);</span><br><span class="line">    tx_mbufs[ind] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将要发送的 mbuf 的内存地址与长度填写到发送描述符中</span></span><br><span class="line">  desc-&gt;addr = (uint64)m-&gt;head;</span><br><span class="line">  desc-&gt;length = m-&gt;len;</span><br><span class="line">  <span class="comment">// 设置参数，EOP 表示该 buffer 含有一个完整的 packet</span></span><br><span class="line">  <span class="comment">// RS 告诉网卡在发送完成后，设置 status 中的 E1000_TXD_STAT_DD 位，表示发送完成。</span></span><br><span class="line">  desc-&gt;cmd = E1000_TXD_CMD_EOP | E1000_TXD_CMD_RS;</span><br><span class="line">  <span class="comment">// 保留新 mbuf 的指针，方便后续再次用到同一下标时释放。</span></span><br><span class="line">  tx_mbufs[ind] = m;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 环形缓冲区内下标增加一。</span></span><br><span class="line">  regs[E1000_TDT] = (regs[E1000_TDT] + <span class="number">1</span>) % TX_RING_SIZE;</span><br><span class="line">  </span><br><span class="line">  release(&amp;e1000_lock);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">e1000_recv</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>) &#123; <span class="comment">// 每次 recv 可能接收多个包</span></span><br><span class="line"></span><br><span class="line">    uint32 ind = (regs[E1000_RDT] + <span class="number">1</span>) % RX_RING_SIZE;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rx_desc</span> *<span class="title">desc</span> =</span> &amp;rx_ring[ind];</span><br><span class="line">    <span class="comment">// 如果需要接收的包都已经接收完毕，则退出</span></span><br><span class="line">    <span class="keyword">if</span>(!(desc-&gt;status &amp; E1000_RXD_STAT_DD)) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    rx_mbufs[ind]-&gt;len = desc-&gt;length;</span><br><span class="line">    </span><br><span class="line">    net_rx(rx_mbufs[ind]); <span class="comment">// 传递给上层网络栈。上层负责释放 mbuf</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配并设置新的 mbuf，供给下一次轮到该下标时使用</span></span><br><span class="line">    rx_mbufs[ind] = mbufalloc(<span class="number">0</span>); </span><br><span class="line">    desc-&gt;addr = (uint64)rx_mbufs[ind]-&gt;head;</span><br><span class="line">    desc-&gt;status = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    regs[E1000_RDT] = ind;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>操作系统想要发送数据的时候，将数据放入环形缓冲区数组 tx_ring 内，然后递增 E1000_TDT，网卡会自动将数据发出。当网卡收到数据的时候，网卡首先使用 direct memory access，将数据放入 rx_ring 环形缓冲区数组中，然后向 CPU 发起一个硬件中断，CPU 在收到中断后，直接读取 rx_ring 中的数据即可。</p>
<p>最后来个图片放松一下心情(bushi):stuffed_flatbread::stuffed_flatbread::stuffed_flatbread:</p>
<p><img src="C:\Users\lan\Pictures\壁纸\wallhaven-o5dj1p.jpg" alt="wallhaven-o5dj1p"></p>

  </div>
</article>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
        
          <li><a href="/">Home</a></li>
        
          <li><a href="/about/">About</a></li>
        
          <li><a href="/archives/">Writing</a></li>
        
          <li><a href="/tags/">Tag</a></li>
        
          <li><a target="_blank" rel="noopener" href="http://github.com/hulingF">Projects</a></li>
        
      </ul>
    </div>

    
    
      <div id="toc-footer" style="display: none">
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86%EF%BC%9AXV6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AE%80%E8%A6%81%E5%89%96%E6%9E%90"><span class="toc-number">1.</span> <span class="toc-text">第一部分：XV6操作系统简要剖析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E7%AB%A0%EF%BC%9A%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.1.</span> <span class="toc-text">第一章：操作系统接口</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%86%85%E5%AD%98"><span class="toc-number">1.1.1.</span> <span class="toc-text">1.1进程与内存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2I-x2F-O%E5%92%8C%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6"><span class="toc-number">1.1.2.</span> <span class="toc-text">1.2I&#x2F;O和文件描述符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3%E7%AE%A1%E9%81%93"><span class="toc-number">1.1.3.</span> <span class="toc-text">1.3管道</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.1.4.</span> <span class="toc-text">1.4文件系统</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0%EF%BC%9A%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BB%84%E7%BB%87"><span class="toc-number">1.2.</span> <span class="toc-text">第二章：操作系统组织</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1%E6%8A%BD%E8%B1%A1%E7%89%A9%E7%90%86%E8%B5%84%E6%BA%90"><span class="toc-number">1.2.1.</span> <span class="toc-text">2.1抽象物理资源</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2%E6%A8%A1%E5%BC%8F%E5%8F%98%E6%8D%A2%E4%B8%8E%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-number">1.2.2.</span> <span class="toc-text">2.2模式变换与系统调用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3%E5%86%85%E6%A0%B8%E7%BB%84%E7%BB%87"><span class="toc-number">1.2.3.</span> <span class="toc-text">2.3内核组织</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4xv6%E4%BB%A3%E7%A0%81%E7%BB%84%E7%BB%87%E5%BD%A2%E5%BC%8F"><span class="toc-number">1.2.4.</span> <span class="toc-text">2.4xv6代码组织形式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5%E8%BF%9B%E7%A8%8B%E6%A6%82%E8%BF%B0"><span class="toc-number">1.2.5.</span> <span class="toc-text">2.5进程概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-6xv6%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B"><span class="toc-number">1.2.6.</span> <span class="toc-text">2.6xv6启动流程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E7%AB%A0%EF%BC%9A%E9%A1%B5%E8%A1%A8"><span class="toc-number">1.3.</span> <span class="toc-text">第三章：页表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1%E5%88%86%E9%A1%B5%E7%A1%AC%E4%BB%B6"><span class="toc-number">1.3.1.</span> <span class="toc-text">3.1分页硬件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2%E5%86%85%E6%A0%B8%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4"><span class="toc-number">1.3.2.</span> <span class="toc-text">3.2内核地址空间</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3%E5%88%9B%E5%BB%BA%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4"><span class="toc-number">1.3.3.</span> <span class="toc-text">3.3创建地址空间</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D"><span class="toc-number">1.3.4.</span> <span class="toc-text">3.4物理内存分配</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-5%E8%BF%9B%E7%A8%8B%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4"><span class="toc-number">1.3.5.</span> <span class="toc-text">3.5进程地址空间</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-6sbrk%E8%A7%A3%E6%9E%90"><span class="toc-number">1.3.6.</span> <span class="toc-text">3.6sbrk解析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-7exec%E8%A7%A3%E6%9E%90"><span class="toc-number">1.3.7.</span> <span class="toc-text">3.7exec解析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E7%AB%A0%EF%BC%9A%E9%99%B7%E5%85%A5%E5%92%8C%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-number">1.4.</span> <span class="toc-text">第四章：陷入和系统调用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1RISC-V%E9%99%B7%E5%85%A5%E6%9C%BA%E5%88%B6"><span class="toc-number">1.4.1.</span> <span class="toc-text">4.1RISC-V陷入机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4%E7%9A%84%E9%99%B7%E5%85%A5"><span class="toc-number">1.4.2.</span> <span class="toc-text">4.2用户空间的陷入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%87%BD%E6%95%B0%E6%89%A7%E8%A1%8C"><span class="toc-number">1.4.3.</span> <span class="toc-text">4.3系统调用函数执行</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-4%E5%86%85%E6%A0%B8%E7%A9%BA%E9%97%B4%E7%9A%84%E9%99%B7%E5%85%A5"><span class="toc-number">1.4.4.</span> <span class="toc-text">4.4内核空间的陷入</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%BA%94%E7%AB%A0%EF%BC%9A%E4%B8%AD%E6%96%AD%E5%92%8C%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8"><span class="toc-number">1.5.</span> <span class="toc-text">第五章：中断和设备驱动</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1%E6%8E%A7%E5%88%B6%E5%8F%B0%E8%BE%93%E5%85%A5"><span class="toc-number">1.5.1.</span> <span class="toc-text">5.1控制台输入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2%E6%8E%A7%E5%88%B6%E5%8F%B0%E8%BE%93%E5%87%BA"><span class="toc-number">1.5.2.</span> <span class="toc-text">5.2控制台输出</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3%E8%AE%BE%E5%A4%87%E5%B9%B6%E5%8F%91"><span class="toc-number">1.5.3.</span> <span class="toc-text">5.3设备并发</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-4%E6%97%B6%E9%92%9F%E4%B8%AD%E6%96%AD"><span class="toc-number">1.5.4.</span> <span class="toc-text">5.4时钟中断</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-5%E8%A1%A5%E5%85%85"><span class="toc-number">1.5.5.</span> <span class="toc-text">5.5补充</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E5%85%AD%E7%AB%A0%EF%BC%9A%E9%94%81"><span class="toc-number">1.6.</span> <span class="toc-text">第六章：锁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-1%E7%AB%9E%E4%BA%89%E6%83%85%E5%86%B5"><span class="toc-number">1.6.1.</span> <span class="toc-text">6.1竞争情况</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2%E8%87%AA%E6%97%8B%E9%94%81"><span class="toc-number">1.6.2.</span> <span class="toc-text">6.2自旋锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-3%E9%94%81%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">1.6.3.</span> <span class="toc-text">6.3锁的使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-4%E6%AD%BB%E9%94%81%E5%92%8C%E9%94%81%E6%8E%92%E5%BA%8F"><span class="toc-number">1.6.4.</span> <span class="toc-text">6.4死锁和锁排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-5%E9%94%81%E5%92%8C%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F"><span class="toc-number">1.6.5.</span> <span class="toc-text">6.5锁和中断处理程序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-6%E6%8C%87%E4%BB%A4%E5%92%8C%E5%86%85%E5%AD%98%E6%8E%92%E5%BA%8F"><span class="toc-number">1.6.6.</span> <span class="toc-text">6.6指令和内存排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-7%E7%9D%A1%E7%9C%A0%E9%94%81"><span class="toc-number">1.6.7.</span> <span class="toc-text">6.7睡眠锁</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%83%E7%AB%A0%EF%BC%9A%E8%B0%83%E5%BA%A6"><span class="toc-number">1.7.</span> <span class="toc-text">第七章：调度</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7-1%E5%85%B3%E4%BA%8E%E5%A4%8D%E7%94%A8"><span class="toc-number">1.7.1.</span> <span class="toc-text">7.1关于复用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-2%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2"><span class="toc-number">1.7.2.</span> <span class="toc-text">7.2上下文切换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-3%E8%B0%83%E5%BA%A6%E6%A0%B8%E5%BF%83%E4%BB%A3%E7%A0%81"><span class="toc-number">1.7.3.</span> <span class="toc-text">7.3调度核心代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-4mycpu%E5%92%8Cmyproc"><span class="toc-number">1.7.4.</span> <span class="toc-text">7.4mycpu和myproc</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-5sleep%E5%92%8Cwakeup%E6%9C%BA%E5%88%B6"><span class="toc-number">1.7.5.</span> <span class="toc-text">7.5sleep和wakeup机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-6sleep%E5%92%8Cwakeup%E4%BB%A3%E7%A0%81"><span class="toc-number">1.7.6.</span> <span class="toc-text">7.6sleep和wakeup代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-7%E7%AE%A1%E9%81%93%E4%BB%A3%E7%A0%81"><span class="toc-number">1.7.7.</span> <span class="toc-text">7.7管道代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-8wait%E3%80%81exit%E5%92%8Ckill%E4%BB%A3%E7%A0%81"><span class="toc-number">1.7.8.</span> <span class="toc-text">7.8wait、exit和kill代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E5%85%AB%E7%AB%A0%EF%BC%9A%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.8.</span> <span class="toc-text">第八章：文件系统</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#8-1%E6%A6%82%E8%BF%B0"><span class="toc-number">1.8.1.</span> <span class="toc-text">8.1概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-2Buffer%E7%BC%93%E5%AD%98%E5%B1%82"><span class="toc-number">1.8.2.</span> <span class="toc-text">8.2Buffer缓存层</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-3Logging%E6%97%A5%E5%BF%97%E5%B1%82"><span class="toc-number">1.8.3.</span> <span class="toc-text">8.3Logging日志层</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-4%E5%9D%97%E5%88%86%E9%85%8D%E5%99%A8"><span class="toc-number">1.8.4.</span> <span class="toc-text">8.4块分配器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-5Inode%E5%B1%82"><span class="toc-number">1.8.5.</span> <span class="toc-text">8.5Inode层</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-6%E7%9B%AE%E5%BD%95%E5%B1%82"><span class="toc-number">1.8.6.</span> <span class="toc-text">8.6目录层</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-7%E8%B7%AF%E5%BE%84%E5%91%BD%E5%90%8D%E5%B1%82"><span class="toc-number">1.8.7.</span> <span class="toc-text">8.7路径命名层</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-8%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E5%B1%82"><span class="toc-number">1.8.8.</span> <span class="toc-text">8.8文件描述符层</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-9%E8%A1%A5%E5%85%85"><span class="toc-number">1.8.9.</span> <span class="toc-text">8.9补充</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86%EF%BC%9AXV6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C"><span class="toc-number">2.</span> <span class="toc-text">第二部分：XV6操作系统实验</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Lab-1-Unix-utilities"><span class="toc-number">2.1.</span> <span class="toc-text">Lab 1: Unix utilities</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1Boot-xv6-easy"><span class="toc-number">2.1.1.</span> <span class="toc-text">1.1Boot xv6 (easy)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2sleep-easy"><span class="toc-number">2.1.2.</span> <span class="toc-text">1.2sleep (easy)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3pingpong-easy"><span class="toc-number">2.1.3.</span> <span class="toc-text">1.3pingpong (easy)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4primes-moderate"><span class="toc-number">2.1.4.</span> <span class="toc-text">1.4primes (moderate)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-5find-moderate"><span class="toc-number">2.1.5.</span> <span class="toc-text">1.5find (moderate)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-6xargs-moderate"><span class="toc-number">2.1.6.</span> <span class="toc-text">1.6xargs (moderate)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Lab-2-System-calls"><span class="toc-number">2.2.</span> <span class="toc-text">Lab 2: System calls</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1Tracing-moderate"><span class="toc-number">2.2.1.</span> <span class="toc-text">2.1Tracing (moderate)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-1-1%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%85%A8%E6%B5%81%E7%A8%8B"><span class="toc-number">2.2.1.1.</span> <span class="toc-text">2.1.1系统调用全流程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-1-2Tracing%E4%BB%A3%E7%A0%81"><span class="toc-number">2.2.1.2.</span> <span class="toc-text">2.1.2Tracing代码</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2Sysinfo-moderate"><span class="toc-number">2.2.2.</span> <span class="toc-text">2.2Sysinfo (moderate)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-2-1%E8%8E%B7%E5%8F%96%E7%A9%BA%E9%97%B2%E5%86%85%E5%AD%98"><span class="toc-number">2.2.2.1.</span> <span class="toc-text">2.2.1获取空闲内存</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-2-2%E8%8E%B7%E5%8F%96%E8%BF%90%E8%A1%8C%E7%9A%84%E8%BF%9B%E7%A8%8B%E6%95%B0"><span class="toc-number">2.2.2.2.</span> <span class="toc-text">2.2.2获取运行的进程数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-2-3%E5%AE%9E%E7%8E%B0-sysinfo-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-number">2.2.2.3.</span> <span class="toc-text">2.2.3实现 sysinfo 系统调用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Lab-3-Page-tables"><span class="toc-number">2.3.</span> <span class="toc-text">Lab 3: Page tables</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1Print-a-page-table-easy"><span class="toc-number">2.3.1.</span> <span class="toc-text">3.1Print a page table (easy)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2A-kernel-page-table-per-process-hard"><span class="toc-number">2.3.2.</span> <span class="toc-text">3.2A kernel page table per process (hard)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3-2-1%E5%88%9B%E5%BB%BA%E8%BF%9B%E7%A8%8B%E5%86%85%E6%A0%B8%E9%A1%B5%E8%A1%A8%E4%B8%8E%E5%86%85%E6%A0%B8%E6%A0%88"><span class="toc-number">2.3.2.1.</span> <span class="toc-text">3.2.1创建进程内核页表与内核栈</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-2-2%E5%88%87%E6%8D%A2%E5%88%B0%E8%BF%9B%E7%A8%8B%E5%86%85%E6%A0%B8%E9%A1%B5%E8%A1%A8"><span class="toc-number">2.3.2.2.</span> <span class="toc-text">3.2.2切换到进程内核页表</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-2-3%E9%87%8A%E6%94%BE%E8%BF%9B%E7%A8%8B%E5%86%85%E6%A0%B8%E9%A1%B5%E8%A1%A8"><span class="toc-number">2.3.2.3.</span> <span class="toc-text">3.2.3释放进程内核页表</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3Simplify-copyin-x2F-copyinstr-hard"><span class="toc-number">2.3.3.</span> <span class="toc-text">3.3Simplify copyin&#x2F;copyinstr (hard)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3-3-1%E5%87%86%E5%A4%87%E9%A1%B5%E8%A1%A8%E6%98%A0%E5%B0%84%E8%BD%AC%E6%8D%A2%E7%9A%84%E5%B7%A5%E5%85%B7%E6%96%B9%E6%B3%95"><span class="toc-number">2.3.3.1.</span> <span class="toc-text">3.3.1准备页表映射转换的工具方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-3-2%E5%90%8C%E6%AD%A5%E6%98%A0%E5%B0%84%E7%94%A8%E6%88%B7%E9%A1%B5%E8%A1%A8%E5%92%8C%E7%94%A8%E6%88%B7%E5%86%85%E6%A0%B8%E9%A1%B5%E8%A1%A8"><span class="toc-number">2.3.3.2.</span> <span class="toc-text">3.3.2同步映射用户页表和用户内核页表</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-3-3%E6%9B%BF%E6%8D%A2-copyin%E3%80%81copyinstr-%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.3.3.3.</span> <span class="toc-text">3.3.3替换 copyin、copyinstr 实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Lab-4-Traps"><span class="toc-number">2.4.</span> <span class="toc-text">Lab 4: Traps</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1RISC-V-assembly-easy"><span class="toc-number">2.4.1.</span> <span class="toc-text">4.1RISC-V assembly (easy)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2Backtrace-moderate"><span class="toc-number">2.4.2.</span> <span class="toc-text">4.2Backtrace (moderate)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3Alarm-hard"><span class="toc-number">2.4.3.</span> <span class="toc-text">4.3Alarm (hard)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Lab-5-Lazy-Page-Allocation"><span class="toc-number">2.5.</span> <span class="toc-text">Lab 5: Lazy Page Allocation</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Lab-6-Copy-on-write-fork"><span class="toc-number">2.6.</span> <span class="toc-text">Lab 6: Copy-on-write fork</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-1fork%E6%97%B6%E4%B8%8D%E7%AB%8B%E5%88%BB%E5%A4%8D%E5%88%B6%E5%86%85%E5%AD%98"><span class="toc-number">2.6.1.</span> <span class="toc-text">6.1fork时不立刻复制内存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2%E6%8D%95%E8%8E%B7%E5%86%99%E6%93%8D%E4%BD%9C%E5%B9%B6%E6%89%A7%E8%A1%8C%E5%A4%8D%E5%88%B6"><span class="toc-number">2.6.2.</span> <span class="toc-text">6.2捕获写操作并执行复制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-3%E7%89%A9%E7%90%86%E9%A1%B5%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E4%BB%A5%E5%8F%8A%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0"><span class="toc-number">2.6.3.</span> <span class="toc-text">6.3物理页生命周期以及引用计数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Lab-7-Multithreading"><span class="toc-number">2.7.</span> <span class="toc-text">Lab 7: Multithreading</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7-1Uthread-switching-between-threads-moderate"><span class="toc-number">2.7.1.</span> <span class="toc-text">7.1Uthread: switching between threads (moderate)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-2Using-threads-moderate"><span class="toc-number">2.7.2.</span> <span class="toc-text">7.2Using threads (moderate)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-3Barrier-moderate"><span class="toc-number">2.7.3.</span> <span class="toc-text">7.3Barrier (moderate)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Lab-8-Locks"><span class="toc-number">2.8.</span> <span class="toc-text">Lab 8: Locks</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#8-1Memory-allocator-moderate"><span class="toc-number">2.8.1.</span> <span class="toc-text">8.1Memory allocator (moderate)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#8-1-1%E5%8E%9F%E7%90%86%E4%B8%8E%E5%88%86%E6%9E%90"><span class="toc-number">2.8.1.1.</span> <span class="toc-text">8.1.1原理与分析</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#8-1-2%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.8.1.2.</span> <span class="toc-text">8.1.2代码实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Lab-9-File-Systems"><span class="toc-number">2.9.</span> <span class="toc-text">Lab 9: File Systems</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#9-1Large-files-moderate"><span class="toc-number">2.9.1.</span> <span class="toc-text">9.1Large files (moderate)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#9-1-1%E5%8E%9F%E7%90%86%E4%B8%8E%E5%88%86%E6%9E%90"><span class="toc-number">2.9.1.1.</span> <span class="toc-text">9.1.1原理与分析</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#9-1-2%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.9.1.2.</span> <span class="toc-text">9.1.2代码实现</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-2Symbolic-links-moderate"><span class="toc-number">2.9.2.</span> <span class="toc-text">9.2Symbolic links (moderate)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#9-2-1%E5%8E%9F%E7%90%86%E4%B8%8E%E5%88%86%E6%9E%90"><span class="toc-number">2.9.2.1.</span> <span class="toc-text">9.2.1原理与分析</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#9-2-2%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.9.2.2.</span> <span class="toc-text">9.2.2代码实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Lab-10-Mmap"><span class="toc-number">2.10.</span> <span class="toc-text">Lab 10: Mmap</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#10-1%E5%8E%9F%E7%90%86%E4%B8%8E%E5%88%86%E6%9E%90"><span class="toc-number">2.10.1.</span> <span class="toc-text">10.1原理与分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-2%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.10.2.</span> <span class="toc-text">10.2代码实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Lab-11-Networking"><span class="toc-number">2.11.</span> <span class="toc-text">Lab 11: Networking</span></a></li></ol></li></ol>
      </div>
    

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://hulingf.github.io/2023/10/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%BA%90%E7%A0%81%E7%BA%A7%E5%89%96%E6%9E%90/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://hulingf.github.io/2023/10/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%BA%90%E7%A0%81%E7%BA%A7%E5%89%96%E6%9E%90/&text=操作系统源码级剖析"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://hulingf.github.io/2023/10/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%BA%90%E7%A0%81%E7%BA%A7%E5%89%96%E6%9E%90/&title=操作系统源码级剖析"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://hulingf.github.io/2023/10/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%BA%90%E7%A0%81%E7%BA%A7%E5%89%96%E6%9E%90/&is_video=false&description=操作系统源码级剖析"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=操作系统源码级剖析&body=Check out this article: https://hulingf.github.io/2023/10/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%BA%90%E7%A0%81%E7%BA%A7%E5%89%96%E6%9E%90/"><i class="fa-solid fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://hulingf.github.io/2023/10/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%BA%90%E7%A0%81%E7%BA%A7%E5%89%96%E6%9E%90/&title=操作系统源码级剖析"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://hulingf.github.io/2023/10/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%BA%90%E7%A0%81%E7%BA%A7%E5%89%96%E6%9E%90/&title=操作系统源码级剖析"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://hulingf.github.io/2023/10/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%BA%90%E7%A0%81%E7%BA%A7%E5%89%96%E6%9E%90/&title=操作系统源码级剖析"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://hulingf.github.io/2023/10/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%BA%90%E7%A0%81%E7%BA%A7%E5%89%96%E6%9E%90/&title=操作系统源码级剖析"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://hulingf.github.io/2023/10/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%BA%90%E7%A0%81%E7%BA%A7%E5%89%96%E6%9E%90/&name=操作系统源码级剖析&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://hulingf.github.io/2023/10/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%BA%90%E7%A0%81%E7%BA%A7%E5%89%96%E6%9E%90/&t=操作系统源码级剖析"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fa-solid fa-bars fa-lg" aria-hidden="true"></i> Menu</a>
        
          <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fa-solid fa-list fa-lg" aria-hidden="true"></i> TOC</a>
        
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fa-solid fa-share-alt fa-lg" aria-hidden="true"></i> Share</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2023
    hulingF
  </div>
  <div class="footer-right">
    <nav>
      <ul>
        <!--
       --><li><a href="/">Home</a></li><!--
     --><!--
       --><li><a href="/about/">About</a></li><!--
     --><!--
       --><li><a href="/archives/">Writing</a></li><!--
     --><!--
       --><li><a href="/tags/">Tag</a></li><!--
     --><!--
       --><li><a target="_blank" rel="noopener" href="http://github.com/hulingF">Projects</a></li><!--
     -->
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->



  <link rel="preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" crossorigin="anonymous" onload="this.onload=null;this.rel='stylesheet'"/>


    <!-- jquery -->

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" crossorigin="anonymous"></script>




<!-- clipboard -->

  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.7/clipboard.min.js" crossorigin="anonymous"></script>
  
  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"Copy to clipboard!\">";
    btn += '<i class="fa-regular fa-clone"></i>';
    btn += '</span>';
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "Copied!");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Disqus Comments -->

<!-- utterances Comments -->

</body>
</html>
