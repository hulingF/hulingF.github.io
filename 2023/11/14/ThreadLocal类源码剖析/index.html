<!DOCTYPE html>
<html lang=en>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5" />
    <meta name="description" content="ThreadLocal类源码剖析 本章主要参考梦想之家的原文附加上自己的理解过程：ThreadLocal源码深度解析 | wxweven 梦想之家  一、ThreadLocal类的简介该类提供线程本地变量，这些变量与其他正常对应变量的不同之处在于，访问一个ThreadLocal变量（通过其get或set方法）的每个线程都有其&#x3D;&#x3D;自己的、独立初始化的变量副本&#x3D;&amp;#x3D">
<meta property="og:type" content="article">
<meta property="og:title" content="ThreadLocal类源码剖析">
<meta property="og:url" content="https://hulingf.github.io/2023/11/14/ThreadLocal%E7%B1%BB%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/index.html">
<meta property="og:site_name" content="大军的秘密花园">
<meta property="og:description" content="ThreadLocal类源码剖析 本章主要参考梦想之家的原文附加上自己的理解过程：ThreadLocal源码深度解析 | wxweven 梦想之家  一、ThreadLocal类的简介该类提供线程本地变量，这些变量与其他正常对应变量的不同之处在于，访问一个ThreadLocal变量（通过其get或set方法）的每个线程都有其&#x3D;&#x3D;自己的、独立初始化的变量副本&#x3D;&amp;#x3D">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://hulingf.github.io/imgs/ThreadLocal%E7%B1%BB%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/QHAArF.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/ThreadLocal%E7%B1%BB%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/image-20231114195418794.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/ThreadLocal%E7%B1%BB%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/image-20231114215643893.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/ThreadLocal%E7%B1%BB%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/QHAtIA.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/ThreadLocal%E7%B1%BB%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/image-20231114235253187.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/ThreadLocal%E7%B1%BB%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/image-20231115012517958.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/ThreadLocal%E7%B1%BB%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/QHAArF.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/ThreadLocal%E7%B1%BB%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/QHABM8.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/ThreadLocal%E7%B1%BB%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/QHAyZQ.png">
<meta property="article:published_time" content="2023-11-14T11:51:30.757Z">
<meta property="article:modified_time" content="2024-02-23T03:17:28.359Z">
<meta property="article:author" content="hulingF">
<meta property="article:tag" content="并发编程">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://hulingf.github.io/imgs/ThreadLocal%E7%B1%BB%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/QHAArF.png">
    
    
      
        
          <link rel="shortcut icon" href="/images/favicon.ico">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
        
      
    
    <!-- title -->
    <title>ThreadLocal类源码剖析</title>
    <!-- async scripts -->
    <!-- Google Analytics -->


    <!-- Umami Analytics -->


    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
    <!-- rss -->
    
    
	<!-- mathjax -->
	
<meta name="generator" content="Hexo 6.3.0"></head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#" aria-label="Menu"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#" aria-label="Menu"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" aria-label="Top" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa-solid fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
        <!--
       --><li><a href="/">Home</a></li><!--
     --><!--
       --><li><a href="/about/">About</a></li><!--
     --><!--
       --><li><a href="/archives/">Writing</a></li><!--
     --><!--
       --><li><a href="/tags/">Tag</a></li><!--
     --><!--
       --><li><a target="_blank" rel="noopener" href="http://github.com/hulingF">Projects</a></li><!--
     -->
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" aria-label="Previous post" href="/2023/11/15/AtomicInteger%E7%B1%BB%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"><i class="fa-solid fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" aria-label="Next post" href="/2023/11/07/FutureTask%E7%B1%BB%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"><i class="fa-solid fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" aria-label="Back to top" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" aria-label="Share post" href="#"><i class="fa-solid fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://hulingf.github.io/2023/11/14/ThreadLocal%E7%B1%BB%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://hulingf.github.io/2023/11/14/ThreadLocal%E7%B1%BB%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/&text=ThreadLocal类源码剖析"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://hulingf.github.io/2023/11/14/ThreadLocal%E7%B1%BB%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/&title=ThreadLocal类源码剖析"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://hulingf.github.io/2023/11/14/ThreadLocal%E7%B1%BB%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/&is_video=false&description=ThreadLocal类源码剖析"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=ThreadLocal类源码剖析&body=Check out this article: https://hulingf.github.io/2023/11/14/ThreadLocal%E7%B1%BB%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"><i class="fa-solid fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://hulingf.github.io/2023/11/14/ThreadLocal%E7%B1%BB%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/&title=ThreadLocal类源码剖析"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://hulingf.github.io/2023/11/14/ThreadLocal%E7%B1%BB%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/&title=ThreadLocal类源码剖析"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://hulingf.github.io/2023/11/14/ThreadLocal%E7%B1%BB%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/&title=ThreadLocal类源码剖析"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://hulingf.github.io/2023/11/14/ThreadLocal%E7%B1%BB%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/&title=ThreadLocal类源码剖析"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://hulingf.github.io/2023/11/14/ThreadLocal%E7%B1%BB%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/&name=ThreadLocal类源码剖析&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://hulingf.github.io/2023/11/14/ThreadLocal%E7%B1%BB%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/&t=ThreadLocal类源码剖析"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    
    
      <div id="toc">
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#ThreadLocal%E7%B1%BB%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90"><span class="toc-number">1.</span> <span class="toc-text">ThreadLocal类源码剖析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81ThreadLocal%E7%B1%BB%E7%9A%84%E7%AE%80%E4%BB%8B"><span class="toc-number">1.1.</span> <span class="toc-text">一、ThreadLocal类的简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81ThreadLocal%E7%B1%BB%E7%9A%84%E6%9E%B6%E6%9E%84"><span class="toc-number">1.2.</span> <span class="toc-text">二、ThreadLocal类的架构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81ThreadLocal%E7%B1%BB%E7%9A%84%E5%B1%9E%E6%80%A7"><span class="toc-number">1.3.</span> <span class="toc-text">三、ThreadLocal类的属性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81ThreadLocal%E7%B1%BB%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="toc-number">1.4.</span> <span class="toc-text">四、ThreadLocal类的创建</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81ThreadLocal%E7%B1%BB%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">1.5.</span> <span class="toc-text">五、ThreadLocal类的方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-set%E6%96%B9%E6%B3%95"><span class="toc-number">1.5.1.</span> <span class="toc-text">1.set方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-get%E6%96%B9%E6%B3%95"><span class="toc-number">1.5.2.</span> <span class="toc-text">2.get方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-remove%E6%96%B9%E6%B3%95"><span class="toc-number">1.5.3.</span> <span class="toc-text">3.remove方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81ThreadLocalMap%E7%B1%BB%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">1.6.</span> <span class="toc-text">六、ThreadLocalMap类的原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-number">1.6.1.</span> <span class="toc-text">1.构造方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-set%E6%96%B9%E6%B3%95"><span class="toc-number">1.6.2.</span> <span class="toc-text">2.set方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-getEntry%E6%96%B9%E6%B3%95"><span class="toc-number">1.6.3.</span> <span class="toc-text">3.getEntry方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-remove%E6%96%B9%E6%B3%95"><span class="toc-number">1.6.4.</span> <span class="toc-text">4.remove方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-rehash%E6%96%B9%E6%B3%95"><span class="toc-number">1.6.5.</span> <span class="toc-text">5.rehash方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%E3%80%81ThreadLocal%E7%B1%BB%E7%9A%84%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F"><span class="toc-number">1.7.</span> <span class="toc-text">七、ThreadLocal类的内存泄漏</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">1.7.1.</span> <span class="toc-text">1.内存泄漏的原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E8%BF%87%E6%9C%9FEntry%E6%B8%85%E7%90%86%E5%8E%9F%E7%90%86"><span class="toc-number">1.7.2.</span> <span class="toc-text">2.过期Entry清理原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-remove%E6%96%B9%E6%B3%95-%E4%BD%BF%E7%94%A8expungeStaleEntry"><span class="toc-number">1.7.3.</span> <span class="toc-text">3.remove方法(使用expungeStaleEntry)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-set%E6%96%B9%E6%B3%95-%E4%BD%BF%E7%94%A8cleanSomeSlots%E5%92%8CreplaceStaleEntry"><span class="toc-number">1.7.4.</span> <span class="toc-text">4.set方法(使用cleanSomeSlots和replaceStaleEntry)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-getEntry%E6%96%B9%E6%B3%95-%E4%BD%BF%E7%94%A8expungeStaleEntry"><span class="toc-number">1.7.5.</span> <span class="toc-text">5.getEntry方法(使用expungeStaleEntry)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E6%80%BB%E7%BB%93"><span class="toc-number">1.7.6.</span> <span class="toc-text">6.内存泄漏总结</span></a></li></ol></li></ol></li></ol>
      </div>
    
  </span>
</div>

    
    <div class="content index py4 ">
        
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle p-name" itemprop="name headline">
        ThreadLocal类源码剖析
    </h1>



    <div class="meta">
      <span class="author p-author h-card" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span class="p-name" itemprop="name">hulingF</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2023-11-14T11:51:30.757Z" class="dt-published" itemprop="datePublished">2023-11-14</time>
        
      
    </div>


      

      
    <div class="article-tag">
        <i class="fa-solid fa-tag"></i>
        <a class="p-category" href="/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" rel="tag">并发编程</a>
    </div>


    </div>
  </header>
  

  <div class="content e-content" itemprop="articleBody">
    <h1 id="ThreadLocal类源码剖析"><a href="#ThreadLocal类源码剖析" class="headerlink" title="ThreadLocal类源码剖析"></a>ThreadLocal类源码剖析</h1><blockquote>
<p>本章主要参考梦想之家的原文附加上自己的理解过程：<a target="_blank" rel="noopener" href="http://wxweven.win/2018/03/11/ThreadLocal%E6%BA%90%E7%A0%81%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/">ThreadLocal源码深度解析 | wxweven 梦想之家</a></p>
</blockquote>
<h2 id="一、ThreadLocal类的简介"><a href="#一、ThreadLocal类的简介" class="headerlink" title="一、ThreadLocal类的简介"></a>一、ThreadLocal类的简介</h2><p>该类提供<code>线程本地</code>变量，这些变量与其他正常对应变量的不同之处在于，访问一个<code>ThreadLocal</code>变量（通过其<code>get</code>或<code>set</code>方法）的每个线程都有其&#x3D;&#x3D;自己的、独立初始化的变量副本&#x3D;&#x3D;。ThreadLocal实例通常是类中希望将状态与线程关联起来的私有静态字段例如用户ID或事务ID。举个例子，下面的类生成每个线程本地的唯一标识符。线程的ID在第一次调用threadId.get()时分配，并在后续调用中保持不变。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadId</span> &#123;</span><br><span class="line">    <span class="comment">// Atomic integer containing the next thread ID to be assigned</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">nextId</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Thread local variable containing each thread&#x27;s ID</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Integer&gt; threadId =</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;Integer&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span> <span class="keyword">protected</span> Integer <span class="title function_">initialValue</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> nextId.getAndIncrement();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Returns the current thread&#x27;s unique ID, assigning it if necessary</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> threadId.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当使用ThreadLocal维护变量时，ThreadLocal为每个使用该变量的线程提供独立的变量副本，所以每一个线程都可以独立地改变自己的副本，而不会影响其它线程所对应的副本。</p>
<h2 id="二、ThreadLocal类的架构"><a href="#二、ThreadLocal类的架构" class="headerlink" title="二、ThreadLocal类的架构"></a>二、ThreadLocal类的架构</h2><p><img src="/imgs/ThreadLocal%E7%B1%BB%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/QHAArF.png" alt="QHAArF.png"></p>
<p>ThreadLocal类的整体架构其实并不难理解，之前我们在Thread类的源码中曾经看到过两个字段<code>threadLocals</code>和<code>inheritableThreadLocals</code>，我们先暂时不用理会后一个，其实对<code>ThreadLocal</code>对象的<code>get</code>、<code>set</code>、<code>remove</code>都是针对当前线程即<code>Thread</code>对象的<code>ThreadLocalMap</code>类型的<code>threadLocals</code>字段。</p>
<p><img src="/imgs/ThreadLocal%E7%B1%BB%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/image-20231114195418794.png" alt="image-20231114195418794"></p>
<p>简洁的说，ThreadLocal类只是表面上所有线程都操作的对象，真正底层处理的都是线程私有的<code>threadLocals</code>字段，上面也说了这是一个<code>Map</code>结构，存储的是<code>ThreadLocal</code>到对应的<code>线程本地Value</code>的<code>映射对Entry</code>。</p>
<blockquote>
<p>也许你注意到了图1中的Entry对象的Key到ThreadLocal之间是一个虚线，这是因为Key本身是一个弱引用对象，当ThreadLocal对象没有外部强引用并且发生GC时，弱引用会被直接回收，此时Entry对象中的Key为null，我们称这种Entry是过期失效的。过期Entry的Value还是正常存在，因为一直存在着threadRef-&gt;thread-&gt;threadLocalMap-&gt;Entry-&gt;Value的强引用链关系，除非线程被销毁回收，不过实际项目中基本都是利用线程池技术实现线程复用，因此如果我们不人为干涉加以清理失效Entry，就会发生内存泄漏问题！所幸ThreadLocal本身就考虑到了内存泄漏问题并使用了两种清理手段：探索式清理和启发式清理！</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span> <span class="keyword">extends</span> <span class="title class_">WeakReference</span>&lt;ThreadLocal&lt;?&gt;&gt; &#123;</span><br><span class="line">    <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">    Object value;</span><br><span class="line"></span><br><span class="line">    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">        <span class="built_in">super</span>(k);</span><br><span class="line">        value = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="三、ThreadLocal类的属性"><a href="#三、ThreadLocal类的属性" class="headerlink" title="三、ThreadLocal类的属性"></a>三、ThreadLocal类的属性</h2><p>ThreadLocal类的属性就是<code>threadLocalHashCode</code>哈希码值用来计算其在ThreadLocalMap中哈希表数组的映射位置，为了使哈希分布更加均匀减少哈希冲突，ThreadLocal类自定义哈希码值<code>nextHashCode</code>，每创建一个ThreadLocal对象其哈希值就递增<code>HASH_INCREMENT</code>即<code>0x61c88647</code>，这其实是一个斐波那契数，至于为什么可以使哈希分布更加均匀就需要一定的数学基础了，这个不重点了解即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">threadLocalHashCode</span> <span class="operator">=</span> nextHashCode();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">AtomicInteger</span> <span class="variable">nextHashCode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();</span><br><span class="line"><span class="comment">// 黄金分割点：(√5 - 1) / 2 = 0.6180339887，Math.pow(2, 32) * 0.6180339887 = 0x61c88647</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">HASH_INCREMENT</span> <span class="operator">=</span> <span class="number">0x61c88647</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">nextHashCode</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> nextHashCode.getAndAdd(HASH_INCREMENT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="四、ThreadLocal类的创建"><a href="#四、ThreadLocal类的创建" class="headerlink" title="四、ThreadLocal类的创建"></a>四、ThreadLocal类的创建</h2><p>无参构造函数这种谁都懂的我就不专门贴出来了，一般我们都是建议创建ThreadLocal的同时并赋初始化值，可以通过ThreadLocal的子类化并重写<code>initialValue</code>函数实现，也可以通过ThreadLocal的静态方法<code>withInitial</code>实现(其实它也是上一种方法的具体化，代码中可以看出)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 该方法将在线程第一次使用get方法访问变量时被调用，除非该线程之前调用过set方法，在这种情况下，该线程将不会调用initialValue方法。</span></span><br><span class="line"><span class="comment">// 通常，每个线程最多调用此方法一次，但如果随后调用remove，然后调用get，则可能会再次调用该方法。</span></span><br><span class="line"><span class="comment">// 这个实现只是返回null，如果程序员希望线程本地变量具有非null的初始值，则必须对ThreadLocal进行子类化，并重写此方法。通常，将使用匿名内部类，开头的简介案例就是这么做的。</span></span><br><span class="line"><span class="keyword">protected</span> T <span class="title function_">initialValue</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建线程本地变量，变量的初始值是通过调用Supplier上的get方法来确定的</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;S&gt; ThreadLocal&lt;S&gt; <span class="title function_">withInitial</span><span class="params">(Supplier&lt;? extends S&gt; supplier)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SuppliedThreadLocal</span>&lt;&gt;(supplier);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 其实归根结底还是ThreadLocal的子类化并重写initialValue方法</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">SuppliedThreadLocal</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">ThreadLocal</span>&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Supplier&lt;? <span class="keyword">extends</span> <span class="title class_">T</span>&gt; supplier;</span><br><span class="line"></span><br><span class="line">    SuppliedThreadLocal(Supplier&lt;? <span class="keyword">extends</span> <span class="title class_">T</span>&gt; supplier) &#123;</span><br><span class="line">        <span class="built_in">this</span>.supplier = Objects.requireNonNull(supplier);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> T <span class="title function_">initialValue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> supplier.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="五、ThreadLocal类的方法"><a href="#五、ThreadLocal类的方法" class="headerlink" title="五、ThreadLocal类的方法"></a>五、ThreadLocal类的方法</h2><h3 id="1-set方法"><a href="#1-set方法" class="headerlink" title="1.set方法"></a>1.set方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T value)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.获得当前线程</span></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="comment">// 2.拿到当前线程对应的ThreadLocalMap</span></span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 3.针对ThreadLocalMap不为空的情况，直接加入或更新键值对Entry</span></span><br><span class="line">        map.set(<span class="built_in">this</span>, value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 4.针对ThreadLocalMap为空的情况，创建有效的Map并加入键值对Entry</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ThreadLocalMap <span class="title function_">getMap</span><span class="params">(Thread t)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取线程对象中的threadLocals字段</span></span><br><span class="line">    <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">createMap</span><span class="params">(Thread t, T firstValue)</span> &#123;</span><br><span class="line">    <span class="comment">// 创建新的有效Map并加入键值对Entry</span></span><br><span class="line">    t.threadLocals = <span class="keyword">new</span> <span class="title class_">ThreadLocalMap</span>(<span class="built_in">this</span>, firstValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>可以看出，当我们第一次调用ThreadLocal的set方法时会在Thread对象中创建一个新的ThreadLocalMap，并把键值对加入其中；后续调用set方法会直接操作ThreadLocalMap对象，最重要的还是ThreadLocalMap的<code>set</code>方法！</p>
</blockquote>
<h3 id="2-get方法"><a href="#2-get方法" class="headerlink" title="2.get方法"></a>2.get方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1.获取当前线程</span></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="comment">// 2.拿到当前线程对应的ThreadLocalMap</span></span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 3.根据ThreadLocal作为键拿到Map对象的键值对节点Entry</span></span><br><span class="line">        ThreadLocalMap.<span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> map.getEntry(<span class="built_in">this</span>);</span><br><span class="line">        <span class="comment">// 4.Map中存在该键值对，直接返回value值</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            <span class="type">T</span> <span class="variable">result</span> <span class="operator">=</span> (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 5.Map为空需要进行初始化操作，返回默认初始值</span></span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>可以看出，当我们第一次调用ThreadLocal的get方法时(之前没有任何set操作)会创建并初始化Thread对象中的ThreadLocalMap对象；后续调用get方法会直接操作ThreadLocalMap对象拿到对应的值，最重要的还是ThreadLocalMap的<code>getEntry</code>方法！</p>
</blockquote>
<p><img src="/imgs/ThreadLocal%E7%B1%BB%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/image-20231114215643893.png" alt="image-20231114215643893"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> T <span class="title function_">setInitialValue</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">T</span> <span class="variable">value</span> <span class="operator">=</span> initialValue();</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="literal">null</span>) &#123;</span><br><span class="line">        map.set(<span class="built_in">this</span>, value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        createMap(t, value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span> <span class="keyword">instanceof</span> TerminatingThreadLocal) &#123;</span><br><span class="line">        TerminatingThreadLocal.register((TerminatingThreadLocal&lt;?&gt;) <span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法就是set方法的一个<code>变种</code>，唯一的区别是：set方法中的value是传入的，而这个方法的value是调用<code>initialValue</code>方法获得的。</p>
<h3 id="3-remove方法"><a href="#3-remove方法" class="headerlink" title="3.remove方法"></a>3.remove方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1.拿到当前线程对应的ThreadLocalMap</span></span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">m</span> <span class="operator">=</span> getMap(Thread.currentThread());</span><br><span class="line">    <span class="keyword">if</span> (m != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 2.根据Key从ThreadLocalMap中删除指定的键值对</span></span><br><span class="line">        m.remove(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>remove方法删除此线程本地变量的当前值。如果当前线程随后读取此线程本地变量，则将通过调用其initialValue方法重新初始化其值，除非当前线程在此期间设置了其值。这可能会导致当前线程中多次调用initialValue方法。</p>
</blockquote>
<h2 id="六、ThreadLocalMap类的原理"><a href="#六、ThreadLocalMap类的原理" class="headerlink" title="六、ThreadLocalMap类的原理"></a>六、ThreadLocalMap类的原理</h2><p>在详细讲解ThreadLocalMap之前，我们先要了解ThreadLocalMap的<code>Hash冲突处理</code>，因为这是整个ThreadLocalMap最核心的地方，理解了这个，ThreadLocalMap其他的内容也就比较好理解了。</p>
<p>首先我们回顾下Java中的HashMap，我们知道HashMap的实现方式是数组+链表+红黑树，其中数组用于Hash桶定位，链表用于解决Hash冲突，红黑树用于加快查找速度。ThreadLocalMap，本质上来讲也是一个Map，也用到了Hash算法，那么它在实现上与HashMap有什么区别呢？这里先把结论给出来：</p>
<blockquote>
<p>Hash冲突的处理方式不一样，HashMap使用<code>链地址法</code>来解决Hash冲突，而ThreadLocalMap使用<code>开放地址法</code>来解决Hash冲突。</p>
</blockquote>
<p>每一个ThreadLocal对象都有一个<code>threadLocalHashCode</code>哈希值字段，在将ThreadLocal对象及其对应的Value放入ThreadLocalMap中时，需要现根据<code>threadLocalHashCode</code>哈希值对哈希表数组长度取模(因为数组长度是2的幂次方，因此可以通过threadLocalHashCode&amp;(length-1))找到数组中的槽位，然后构造出一个键值对Entry放入该槽位中。</p>
<p>尽管<code>threadLocalHashCode</code>哈希值映射后的分布相对均匀，但仍然无法避免<code>哈希冲突</code>的问题，此时采用<code>开发地址法</code>依次往后探查直到遇到空槽位存入。当然，ThreadLocalMap的这个过程中还有很多其他细节，如遇到Key相同的直接更新，遇到过期Entry需要清理。下图ThreadLocalA、ThreadLocalB、ThreadLocalC发生哈希冲突的情况图：</p>
<p><img src="/imgs/ThreadLocal%E7%B1%BB%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/QHAtIA.png" alt="QHAtIA.png"></p>
<h3 id="1-构造方法"><a href="#1-构造方法" class="headerlink" title="1.构造方法"></a>1.构造方法</h3><p>在前面分析ThreadLocal的set方法中，我们知道，如果当前Thread对应的ThreadLocalMap为null，则会调用createMap方法创建ThreadLocalMap：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">createMap</span><span class="params">(Thread t, T firstValue)</span> &#123;</span><br><span class="line">    t.threadLocals = <span class="keyword">new</span> <span class="title class_">ThreadLocalMap</span>(<span class="built_in">this</span>, firstValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>即调用了ThreadLocalMap的构造函数，我们来看看构造函数源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;</span><br><span class="line">    <span class="comment">// 1.数组默认初始长度是16</span></span><br><span class="line">    table = <span class="keyword">new</span> <span class="title class_">Entry</span>[INITIAL_CAPACITY];</span><br><span class="line">    <span class="comment">// 2.根据键的哈希值计算对应的槽位</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 3.存入初始的键值对</span></span><br><span class="line">    table[i] = <span class="keyword">new</span> <span class="title class_">Entry</span>(firstKey, firstValue);</span><br><span class="line">    <span class="comment">// 4.ThreadLocalMap的大小初始化为1</span></span><br><span class="line">    size = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 设置调整大小阈值，以在最坏的情况下保持2/3的负载系数</span></span><br><span class="line">    setThreshold(INITIAL_CAPACITY);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setThreshold</span><span class="params">(<span class="type">int</span> len)</span> &#123;</span><br><span class="line">    threshold = len * <span class="number">2</span> / <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们多提两个小函数，后面会用到这里先看一下，功能也很简单就是<code>向前</code>或<code>向后</code>移动，看成循环数组。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">nextIndex</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> ((i + <span class="number">1</span> &lt; len) ? i + <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">prevIndex</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> ((i - <span class="number">1</span> &gt;= <span class="number">0</span>) ? i - <span class="number">1</span> : len - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-set方法"><a href="#2-set方法" class="headerlink" title="2.set方法"></a>2.set方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We don&#x27;t use a fast path as with get() because it is at</span></span><br><span class="line">    <span class="comment">// least as common to use set() to create new entries as</span></span><br><span class="line">    <span class="comment">// it is to replace existing ones, in which case, a fast</span></span><br><span class="line">    <span class="comment">// path would fail more often than not.</span></span><br><span class="line"></span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> tab.length;</span><br><span class="line">    <span class="comment">// 1.定位Hash槽位位置</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 2. 从当前槽位位置往后遍历</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> tab[i]; e != <span class="literal">null</span>; e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">			</span><br><span class="line">        <span class="comment">// 3. 如果key相同，直接替换掉原来的value</span></span><br><span class="line">        <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">            e.value = value;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">		</span><br><span class="line">        <span class="comment">// 4. 如果当前槽位对应的key为null，特殊处理：清除并替换过期Entry</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="literal">null</span>) &#123;</span><br><span class="line">            replaceStaleEntry(key, value, i);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 5.找到没有使用的槽位即null，将传入的Entry放入该槽位中</span></span><br><span class="line">    tab[i] = <span class="keyword">new</span> <span class="title class_">Entry</span>(key, value);</span><br><span class="line">    <span class="comment">// 6.增加ThreadLocalMap的Entry个数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">sz</span> <span class="operator">=</span> ++size;</span><br><span class="line">    <span class="comment">// 7.没有清理出可用的槽位而且容量超过扩容阈值，重新Hash</span></span><br><span class="line">    <span class="keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class="line">        rehash();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>详细过程已经在源码中附加了注释，其中的『注释4』和『注释7』是跟ThreadLocal的内存泄露相关的，我们将在『ThreadLocal类的内存泄露』章节介绍到。</p>
</blockquote>
<h3 id="3-getEntry方法"><a href="#3-getEntry方法" class="headerlink" title="3.getEntry方法"></a>3.getEntry方法</h3><p><img src="/imgs/ThreadLocal%E7%B1%BB%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/image-20231114235253187.png" alt="image-20231114235253187"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Entry <span class="title function_">getEntry</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 定位Hash桶槽位位置</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> key.threadLocalHashCode &amp; (table.length - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 2. 获取当前槽位位置的Entry</span></span><br><span class="line">    <span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> table[i];</span><br><span class="line">    <span class="comment">// 3.如果Entry不为null且key相同，说明Hash命中，返回对应的值即可</span></span><br><span class="line">    <span class="keyword">if</span> (e != <span class="literal">null</span> &amp;&amp; e.get() == key)</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    <span class="comment">// 4.未命中，特殊处理</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> getEntryAfterMiss(key, i, e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>get方法的作用，也无需多说，跟HashMap的get方法一样，根据key去找value。同样，考虑到Hash冲突，会有未直接命中的情况，需要做特殊处理，即调用getEntryAfterMiss方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Entry <span class="title function_">getEntryAfterMiss</span><span class="params">(ThreadLocal&lt;?&gt; key, <span class="type">int</span> i, Entry e)</span> &#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> tab.length;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1.从当前位置往下找，这个原因在Hash冲突处理章节已经介绍过：</span></span><br><span class="line">    <span class="comment">// 插入时，如果当前位置已经有元素，则往下找一个位置，看是否为null，如此反复，直到找到一个为null的位置，把Entry放入该位置;</span></span><br><span class="line">    <span class="comment">// 所以，查找的时候，也是一样的逻辑，如果根据key算出来的Hash值位置上，不是当前Entry，那么就顺着数组往下找;</span></span><br><span class="line">    <span class="keyword">while</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">        <span class="comment">// 2.如果key相同，说明找到，直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (k == key)</span><br><span class="line">            <span class="keyword">return</span> e;</span><br><span class="line">        <span class="comment">// 3.如果当前位置key为null，特殊处理：清除过期Entry</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="literal">null</span>)</span><br><span class="line">            expungeStaleEntry(i);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 4.继续找数组的下一个位置</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            i = nextIndex(i, len);</span><br><span class="line">        e = tab[i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 5.最后还是没有找到，返回null</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>同样，这里需要特别注意的是『注释3』：当前数组位置key为null的情况，也是跟内存泄露相关的，『ThreadLocal类的内存泄露』章节会介绍到。</p>
</blockquote>
<h3 id="4-remove方法"><a href="#4-remove方法" class="headerlink" title="4.remove方法"></a>4.remove方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> &#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> tab.length;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1.定位Hash槽位位置</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2.遍历找出key对应的Entry</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> tab[i]; e != <span class="literal">null</span>; e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e.get() == key) &#123;</span><br><span class="line">            <span class="comment">// 3.找到对应的Entry后，清理该Entry的弱引用</span></span><br><span class="line">            e.clear();</span><br><span class="line">            <span class="comment">// 4.特殊处理：清除过期Entry</span></span><br><span class="line">            expungeStaleEntry(i);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>emove方法，根据key去删除map中的元素，这一过程中的特殊处理，也是跟内存泄露相关，会在『ThreadLocal类的内存泄露』章节介绍。</p>
</blockquote>
<h3 id="5-rehash方法"><a href="#5-rehash方法" class="headerlink" title="5.rehash方法"></a>5.rehash方法</h3><p><img src="/imgs/ThreadLocal%E7%B1%BB%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/image-20231115012517958.png" alt="image-20231115012517958"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">rehash</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1.清除所有的过期Entry</span></span><br><span class="line">    expungeStaleEntries();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Use lower threshold for doubling to avoid hysteresis</span></span><br><span class="line">    <span class="keyword">if</span> (size &gt;= threshold - threshold / <span class="number">4</span>)</span><br><span class="line">        <span class="comment">// 2.如果数组容量依然不够只能扩容</span></span><br><span class="line">        resize();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>expungeStaleEntries</code>的源代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">expungeStaleEntries</span><span class="params">()</span> &#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> tab.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; len; j++) &#123;</span><br><span class="line">        <span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> tab[j];</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span> &amp;&amp; e.get() == <span class="literal">null</span>)</span><br><span class="line">            expungeStaleEntry(j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>resize</code>的源代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">resize</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1.扩容两倍大小</span></span><br><span class="line">    Entry[] oldTab = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">oldLen</span> <span class="operator">=</span> oldTab.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">newLen</span> <span class="operator">=</span> oldLen * <span class="number">2</span>;</span><br><span class="line">    Entry[] newTab = <span class="keyword">new</span> <span class="title class_">Entry</span>[newLen];</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Entry e : oldTab) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">            ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">            <span class="keyword">if</span> (k == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 2.过期Entry可以忽略不用拷贝过去</span></span><br><span class="line">                e.value = <span class="literal">null</span>; <span class="comment">// Help the GC</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 3.正常Entry需要重新计算合适的槽位位置</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> k.threadLocalHashCode &amp; (newLen - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">while</span> (newTab[h] != <span class="literal">null</span>)</span><br><span class="line">                    h = nextIndex(h, newLen);</span><br><span class="line">                newTab[h] = e;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 4.设置大小阈值和Entry个数</span></span><br><span class="line">    setThreshold(newLen);</span><br><span class="line">    size = count;</span><br><span class="line">    table = newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>rehash的逻辑比较简单，我们就不详细介绍了，其实就是把哈希表中的原数组元素拷贝到扩容后的新数组，注意这个过程中不考虑过期Entry，并且正常Entry需要重新计算放置的槽位位置。</p>
</blockquote>
<h2 id="七、ThreadLocal类的内存泄漏"><a href="#七、ThreadLocal类的内存泄漏" class="headerlink" title="七、ThreadLocal类的内存泄漏"></a>七、ThreadLocal类的内存泄漏</h2><h3 id="1-内存泄漏的原理"><a href="#1-内存泄漏的原理" class="headerlink" title="1.内存泄漏的原理"></a>1.内存泄漏的原理</h3><p>我们再回过头来看看ThreadLocal的底层实现：</p>
<p><img src="/imgs/ThreadLocal%E7%B1%BB%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/QHAArF.png" alt="QHAArF.png"></p>
<p>在ThreadLocal的生命周期中，都存在这些引用，如下图实线代表强引用，虚线代表弱引用。</p>
<p><img src="/imgs/ThreadLocal%E7%B1%BB%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/QHABM8.png" alt="QHABM8.png"></p>
<p>ThreadLocal的实现是这样的：&#x3D;&#x3D;每个Thread维护一个ThreadLocalMap映射表，这个映射表的key是ThreadLocal实例本身，value是真正需要存储的Object。&#x3D;&#x3D;也就是说ThreadLocal本身并不存储值，它只是作为一个key来让线程从ThreadLocalMap获取value。值得注意的是图中的虚线，表示ThreadLocalMap是使用ThreadLocal的<code>弱引用</code>作为key的，弱引用的对象在GC时会被回收。</p>
<p>ThreadLocalMap使用ThreadLocal的弱引用作为key，如果一个ThreadLocal没有<code>外部强引用</code>来引用它，那么系统GC的时候，这个ThreadLocal势必会被<code>回收</code>，这样一来，ThreadLocalMap中就会出现key为null的<code>过期Entry</code>，就没有办法访问这些key为null的过期Entry的value，如果当前线程再迟迟不结束的话（典型情况就是线程池方式，线程并真正不结束，只是归还到线程池中），这些key为null的Entry的value就会一直存在一条强引用链：</p>
<blockquote>
<p>Thread Ref -&gt; Thread -&gt; ThreaLocalMap -&gt; Entry -&gt; Value</p>
</blockquote>
<p>导致value永远无法回收，造成内存泄漏。</p>
<blockquote>
<p>在ThreadLocalMap的set、getEntry、remove方法中，都提到了『特殊处理』，这个『特殊处理』就是为了解决内存泄露问题，它会清理掉不再被使用的过期Entry对象。</p>
</blockquote>
<h3 id="2-过期Entry清理原理"><a href="#2-过期Entry清理原理" class="headerlink" title="2.过期Entry清理原理"></a>2.过期Entry清理原理</h3><p>ThreadLocalMap特殊的Hash冲突处理方式，导致了：</p>
<blockquote>
<p>清理ThreadLocalMap时候要保证将一个index指向的Slot清理之后，需要连带着将挨着该index的非空Slot内的ThreadLocal对象全部Rehash一遍。</p>
</blockquote>
<p><strong>因为这些Slot内存储的ThreadLocal对象和index指向的Slot内存储的ThreadLocal对象<code>可能</code>都Hash到了同一个ThreadLocalMap内的Slot，如果把开头Slot清理后面的不去Rehash就无法找到他们了，这一过程详见『ThreadLocalMap类的原理』。</strong></p>
<p>JDK源码中，执行清理ThreadLocalMap的操作的有三个地方：</p>
<ul>
<li>主动调用ThreadLocalMap内的remove时执行expungeStaleEntry</li>
<li>set值到ThreadLocalMap时调用replaceStaleEntry和cleanSomeSlots</li>
<li>getEntry时如果发现key找不到会执行expungeStaleEntry</li>
</ul>
<h3 id="3-remove方法-使用expungeStaleEntry"><a href="#3-remove方法-使用expungeStaleEntry" class="headerlink" title="3.remove方法(使用expungeStaleEntry)"></a>3.remove方法(使用expungeStaleEntry)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> &#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> tab.length;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1.定位Hash槽位位置</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2.遍历找出key对应的Entry</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> tab[i]; e != <span class="literal">null</span>; e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e.get() == key) &#123;</span><br><span class="line">            <span class="comment">// 3.找到对应的Entry后，清理该Entry的弱引用</span></span><br><span class="line">            e.clear();</span><br><span class="line">            <span class="comment">// 4.特殊处理：清除过期Entry</span></span><br><span class="line">            expungeStaleEntry(i);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中的清理工作就是在<code>expungeStaleEntry</code>方法中执行的。我们来看看这个神秘的<code>expungeStaleEntry</code>方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">expungeStaleEntry</span><span class="params">(<span class="type">int</span> staleSlot)</span> &#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> tab.length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.清理当前槽位的Entry</span></span><br><span class="line">    tab[staleSlot].value = <span class="literal">null</span>;</span><br><span class="line">    tab[staleSlot] = <span class="literal">null</span>;</span><br><span class="line">    size--;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Rehash until we encounter null</span></span><br><span class="line">    Entry e;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 从当前位置开始往下遍历，直到找到为null的slot</span></span><br><span class="line">    <span class="keyword">for</span> (i = nextIndex(staleSlot, len); (e = tab[i]) != <span class="literal">null</span>; i = nextIndex(i, len)) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">        <span class="comment">// 3.key为null，该Entry已经无法被访问，顺带着清除该过期Entry</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="literal">null</span>) &#123;</span><br><span class="line">            e.value = <span class="literal">null</span>;</span><br><span class="line">            tab[i] = <span class="literal">null</span>;</span><br><span class="line">            size--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 4.key不为null，需要rehash，原因在『过期Entry清理原理』小节讲过</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> k.threadLocalHashCode &amp; (len - <span class="number">1</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 5.如果h==i，说明当前ThreadLocal与清理开始的ThreadLocal不是同一个run，不需要处理</span></span><br><span class="line">            <span class="keyword">if</span> (h != i) &#123;</span><br><span class="line">                tab[i] = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Unlike Knuth 6.4 Algorithm R, we must scan until</span></span><br><span class="line">                <span class="comment">// null because multiple entries could have been stale.</span></span><br><span class="line">                <span class="comment">// 6.从哈希映射基槽位开始依次往后找到一个空槽位，即开放地址法</span></span><br><span class="line">                <span class="keyword">while</span> (tab[h] != <span class="literal">null</span>)</span><br><span class="line">                    h = nextIndex(h, len);</span><br><span class="line">                tab[h] = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">// 7.返回连续非空槽位区间即run范围随后的空槽位位置</span></span><br><span class="line">   <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>expungeStaleEntry的工作是传入一个Slot的index，将该index指向的Slot清理，并且将该index之后同一个run范围内的所有Slot都检查一遍，发现Slot指向的ThreadLocal被GC则也清理该Slot，没被GC就将该ThreadLocal对象重新rehash到ThreadLocalMap的其它合适Slot上。最终会返回目标index所在run范围的终点序号，也即一个run末尾的空Slot的index值。</p>
</blockquote>
<p>这就是ThreadLocalMap中的第一种清理手段：<code>探索式清理</code>！</p>
<h3 id="4-set方法-使用cleanSomeSlots和replaceStaleEntry"><a href="#4-set方法-使用cleanSomeSlots和replaceStaleEntry" class="headerlink" title="4.set方法(使用cleanSomeSlots和replaceStaleEntry)"></a>4.set方法(使用cleanSomeSlots和replaceStaleEntry)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We don&#x27;t use a fast path as with get() because it is at</span></span><br><span class="line">    <span class="comment">// least as common to use set() to create new entries as</span></span><br><span class="line">    <span class="comment">// it is to replace existing ones, in which case, a fast</span></span><br><span class="line">    <span class="comment">// path would fail more often than not.</span></span><br><span class="line"></span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> tab.length;</span><br><span class="line">    <span class="comment">// 1.定位Hash槽位位置</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 2. 从当前槽位位置往后遍历</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> tab[i]; e != <span class="literal">null</span>; e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">			</span><br><span class="line">        <span class="comment">// 3. 如果key相同，替换掉原来的value</span></span><br><span class="line">        <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">            e.value = value;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">		</span><br><span class="line">        <span class="comment">// 4. 如果当前槽位对应的key为null，特殊处理：替换并清除过期Entry</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="literal">null</span>) &#123;</span><br><span class="line">            replaceStaleEntry(key, value, i);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 5.找到没有使用的槽位即null，将传入的Entry放入该槽位中</span></span><br><span class="line">    tab[i] = <span class="keyword">new</span> <span class="title class_">Entry</span>(key, value);</span><br><span class="line">    <span class="comment">// 6.增加ThreadLocalMap的Entry个数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">sz</span> <span class="operator">=</span> ++size;</span><br><span class="line">    <span class="comment">// 7.没有清理出可用的槽位而且容量超过阈值，重新Hash</span></span><br><span class="line">    <span class="keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class="line">        rehash();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>set操作是传入一个ThreadLocal对象和其绑定的value，将这个ThreadLocal和value存入ThreadLocalMap中。存的时候也是需要先对ThreadLocal对象做Hash找到其在ThreadLocalMap中的Slot，如果Slot被占用，会有三种情况：</p>
<ul>
<li><p>Slot内存储的ThreadLocal对象就是当前待存储的ThreadLocal对象，此时只需要用新Value替换原来的Value就结束了；</p>
</li>
<li><p>Slot内存储的ThreadLocal不是当前待存储的ThreadLocal对象，并且之前存的ThreadLocal对象已经被GC掉，Slot内过期Entry的WeakReference读取后返回空，这种情况下需要将原来的过期Entry清理并建立新的Entry指向这个新的ThreadLocal对象，存入当前的Slot。这个替换过程使用的是 <code>replaceStaleEntry</code> 方法；</p>
</li>
<li><p>如果不是上面两种情况，则需要继续查看紧挨着的Slot直到遇到空Slot。找到空Slot说明我们找到一个空位置，则创建全新的Entry指向当前ThreadLocal对象，存入这个找到的空Slot；</p>
</li>
</ul>
<p>如果是上面第三种情况，添加完新的 Entry 之后，还会执行一次 <code>cleanSomeSlots</code> 方法，源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">cleanSomeSlots</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">removed</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> tab.length;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        i = nextIndex(i, len);</span><br><span class="line">        <span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> tab[i];</span><br><span class="line">        <span class="comment">// 1. 清理当前已经失效的Entry</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span> &amp;&amp; e.get() == <span class="literal">null</span>) &#123;</span><br><span class="line">            n = len;</span><br><span class="line">            removed = <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">// 2. 清理过期Entry，前文讲过</span></span><br><span class="line">            i = expungeStaleEntry(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> ( (n &gt;&gt;&gt;= <span class="number">1</span>) != <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> removed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在当前新添加的Entry所在Slot之后，连续的找logN个Slot，判断这些Slot内存储的Entry是否指向一个已经被GC的ThreadLocal对象，是的话就对这个Slot执行 <code>expungeStaleEntry</code>做清理。它执行对数次扫描，作为<code>不扫描（快速但保留垃圾）</code>和<code>与元素数量成正比的扫描(这将找到所有垃圾，但会导致某些插入花费O(n)时间)</code>次数之间的平衡。</p>
</blockquote>
<p>这就是ThreadLocalMap中的第二种清理手段：<code>启发式清理</code>！</p>
<p>对于上面第二种情况中使用的 <code>replaceStaleEntry</code> 其实现还比较复杂，拿下图来说：</p>
<p><img src="/imgs/ThreadLocal%E7%B1%BB%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/QHAyZQ.png" alt="QHAyZQ.png"></p>
<p>假设当前要set的是ThreadLocalB，并且ThreadLocalA、B、C在这个ThreadLocalMap都具有相同的Hash值，从而都Hash到同一个Slot即现在ThreadLocalA所在的Slot。也正因为碰撞所以ThreadLocalB、C都是紧挨着ThreadLocalA存储的。3号位Slot指向null表示它本来是存一个ThreadLocal对象的，但这个对象被GC了，所以按照上面对set方法的描述，再次set ThreadLocalB的时候发现3号位是null就会执行<code>replaceStaleEntry</code>，希望将3号位replace为ThreadLocalB并绑定上最新的Value。</p>
<p>但是因为我们只检查到3号位，我们只能确认2、3两个位置没有ThreadLocalB对象，但ThreadLocalB对象可能存在于3号位之后的Slot中，所以直接将ThreadLocalB存入3号位是不行的，需要从3号位向后遍历着查找一下看看3号位之后还有没有ThreadLocalB对象了，如上图所示3号位之后还确实是有ThreadLocalB对象，并且因为发现3号位原来的ThreadLocal对象已经被 GC，所以replaceStaleEntry需要将4号位的ThreadLocalB挪到3号位，并且将该ThreadLocalB对象绑定上新的Value。交换之后4号位我们知道是需要被清理的，所以会调用<code>expungeStaleEntry</code>将该位置的Slot清理，并且将4号位之后的Slot都进行rehash。</p>
<p>当前面expungeStaleEntry执行之后，还是会调用cleanSomeSlots来探测当前run之后，也即6号位Slot之后logN个Slot看看有没有被GC掉的ThreadLocal，有的话就用expungeStaleEntry做清理。</p>
<p>需要注意的是如果在4号位找到ThreadLocalB，则4号位之后是不可能再有ThreadLocalB的，所以找到4号位做完交换和更新Value之后不需要从4号位再往后找有没有ThreadLocalB了。</p>
<p>除了上面说的这一大堆之外，replaceStaleEntry实际还会检查同一个run内3号位之前的Slot，看看这些Slot的ThreadLocal对象有没有被GC掉，虽然这些Slot在replaceStaleEntry执行之前，在set方法内已经检查过一次。从replaceStaleEntry内注释来看主要原因是想避免连续的rehash。我个人推测，主要是因为set操作三种情况中，最耗时的就是第二种需要执行replaceStaleEntry的情况，无论是直接找到被更新的ThreadLocal对象直接更新绑定的Value还是在一个run内没有发现被GC的ThreadLocal对象直接将新的ThreadLocal存在一个run的末尾的空Slot内，耗时都是比较小的，而需要执行replaceStaleEntry时因为清理一个Slot需要将后续所有Slot全部Rehash所以耗时最大，所以要尽可能的避免replaceStaleEntry的执行。而GC是任意时刻都可能执行的，虽然set操作内检查过上图2位，但是GC过后可能2号位的ThreadLocalA也被GC掉了，所以再次检查一下能更好的避免replaceStaleEntry的执行。</p>
<p>如果发现3号位之前有ThreadLocal对象被GC，则在替换完3号位后，会直接从3号位之前这个被GC的ThreadLocal对象所在Slot开始，完整的执行一遍expungeStaleEntry，全部执行完后相当于是从expungeStaleEntry执行开始的Slot到一个run的末尾所有被GC掉的ThreadLocal都会被清理。</p>
<p>replaceStaleEntry方法源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">replaceStaleEntry</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value,</span></span><br><span class="line"><span class="params">                               <span class="type">int</span> staleSlot)</span> &#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> tab.length;</span><br><span class="line">    Entry e;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Back up to check for prior stale entry in current run.</span></span><br><span class="line">    <span class="comment">// We clean out whole runs at a time to avoid continual</span></span><br><span class="line">    <span class="comment">// incremental rehashing due to garbage collector freeing</span></span><br><span class="line">    <span class="comment">// up refs in bunches (i.e., whenever the collector runs).</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">slotToExpunge</span> <span class="operator">=</span> staleSlot;</span><br><span class="line">    <span class="comment">// 1.向前找到可能的过期Entry</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> prevIndex(staleSlot, len);</span><br><span class="line">         (e = tab[i]) != <span class="literal">null</span>;</span><br><span class="line">         i = prevIndex(i, len))</span><br><span class="line">        <span class="keyword">if</span> (e.get() == <span class="literal">null</span>)</span><br><span class="line">            slotToExpunge = i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Find either the key or trailing null slot of run, whichever</span></span><br><span class="line">    <span class="comment">// occurs first</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> nextIndex(staleSlot, len);</span><br><span class="line">         (e = tab[i]) != <span class="literal">null</span>;</span><br><span class="line">         i = nextIndex(i, len)) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If we find key, then we need to swap it</span></span><br><span class="line">        <span class="comment">// with the stale entry to maintain hash table order.</span></span><br><span class="line">        <span class="comment">// The newly stale slot, or any other stale slot</span></span><br><span class="line">        <span class="comment">// encountered above it, can then be sent to expungeStaleEntry</span></span><br><span class="line">        <span class="comment">// to remove or rehash all of the other entries in run.</span></span><br><span class="line">        <span class="comment">// 2. 向后找到key相同的Entry</span></span><br><span class="line">        <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">            <span class="comment">// 3.更新并替换该Entry，当前槽位置为过期Entry</span></span><br><span class="line">            e.value = value;</span><br><span class="line">            tab[i] = tab[staleSlot];</span><br><span class="line">            tab[staleSlot] = e;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Start expunge at preceding stale entry if it exists</span></span><br><span class="line">            <span class="keyword">if</span> (slotToExpunge == staleSlot)</span><br><span class="line">                slotToExpunge = i;</span><br><span class="line">            <span class="comment">// 4.清理过期Entry</span></span><br><span class="line">            cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If we didn&#x27;t find stale entry on backward scan, the</span></span><br><span class="line">        <span class="comment">// first stale entry seen while scanning for key is the</span></span><br><span class="line">        <span class="comment">// first still present in the run.</span></span><br><span class="line">        <span class="comment">// 5.如果前面没有过期Entry，则记录传入的staleSlot过期Entry位置后的第一个过期Entry位置</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="literal">null</span> &amp;&amp; slotToExpunge == staleSlot)</span><br><span class="line">            slotToExpunge = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6.没有key相同的Entry，直接把过期Entry更换为新的Entry，符合开放地址规则</span></span><br><span class="line">    tab[staleSlot].value = <span class="literal">null</span>;</span><br><span class="line">    tab[staleSlot] = <span class="keyword">new</span> <span class="title class_">Entry</span>(key, value);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If there are any other stale entries in run, expunge them</span></span><br><span class="line">    <span class="comment">// 7.清理过期Entry</span></span><br><span class="line">    <span class="keyword">if</span> (slotToExpunge != staleSlot)</span><br><span class="line">        cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-getEntry方法-使用expungeStaleEntry"><a href="#5-getEntry方法-使用expungeStaleEntry" class="headerlink" title="5.getEntry方法(使用expungeStaleEntry)"></a>5.getEntry方法(使用expungeStaleEntry)</h3><p>ThreadLocalMap的getEntry方法，在未直接命中时，会调用getEntryAfterMiss，该方法也会做一次清理：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Entry <span class="title function_">getEntryAfterMiss</span><span class="params">(ThreadLocal&lt;?&gt; key, <span class="type">int</span> i, Entry e)</span> &#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> tab.length;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1.从当前位置往下找，这个原因在Hash冲突处理章节已经介绍过：</span></span><br><span class="line">    <span class="comment">// 插入时，如果当前位置已经有元素，则往下找一个位置，看是否为null，如此反复，直到找到一个为null的位置，把Entry放入该位置;</span></span><br><span class="line">    <span class="comment">// 所以，查找的时候，也是一样的逻辑，如果根据key算出来的Hash值位置上，不是当前Entry，那么就顺着数组往下找;</span></span><br><span class="line">    <span class="keyword">while</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">        <span class="comment">// 2.如果key相同，说明找到，直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (k == key)</span><br><span class="line">            <span class="keyword">return</span> e;</span><br><span class="line">        <span class="comment">// 3.如果当前位置key为null，特殊处理：清除过期Entry</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="literal">null</span>)</span><br><span class="line">            expungeStaleEntry(i);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 4.继续找数组的下一个位置</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            i = nextIndex(i, len);</span><br><span class="line">        e = tab[i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 5.最后还是没有找到，返回null</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在key为null时，会调用expungeStaleEntry方法进行清理，前文已经分析过expungeStaleEntry过程，不再赘述。</p>
<h3 id="6-内存泄漏总结"><a href="#6-内存泄漏总结" class="headerlink" title="6.内存泄漏总结"></a>6.内存泄漏总结</h3><p>大多数情况下，使用ThreadLocal不会产生内存泄露问题，因为在后续的set、get过程中，ThreadLocal会自动进行内存清理。</p>
<p>ThreadLocal自动清理机制需要依赖于用户调用ThreadLocalMap下的set和getEntry两个方法，即ThreadLocal的set、get方法，如果一个ThreadLocal对象已经被GC，用户不再向同一个Thread绑定新的ThreadLocal对象，也再不读取Thread上的其它ThreadLocal对象，就无法触发ThreadLocalMap的set和getEntry方法，导致ThreadLocal内存储的Value对象永久驻留内存。</p>
<p>&#x3D;&#x3D;所以即使ThreadLocal有自动内存清理机制，依然建议使用remove方法来手动清理内存。使用完ThreadLocal变量后，手动remove是个非常好的习惯！&#x3D;&#x3D;</p>

  </div>
</article>

    <div class="blog-post-comments">
        <div id="disqus_thread">
            <noscript>Please enable JavaScript to view the comments.</noscript>
        </div>
    </div>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
        
          <li><a href="/">Home</a></li>
        
          <li><a href="/about/">About</a></li>
        
          <li><a href="/archives/">Writing</a></li>
        
          <li><a href="/tags/">Tag</a></li>
        
          <li><a target="_blank" rel="noopener" href="http://github.com/hulingF">Projects</a></li>
        
      </ul>
    </div>

    
    
      <div id="toc-footer" style="display: none">
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#ThreadLocal%E7%B1%BB%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90"><span class="toc-number">1.</span> <span class="toc-text">ThreadLocal类源码剖析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81ThreadLocal%E7%B1%BB%E7%9A%84%E7%AE%80%E4%BB%8B"><span class="toc-number">1.1.</span> <span class="toc-text">一、ThreadLocal类的简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81ThreadLocal%E7%B1%BB%E7%9A%84%E6%9E%B6%E6%9E%84"><span class="toc-number">1.2.</span> <span class="toc-text">二、ThreadLocal类的架构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81ThreadLocal%E7%B1%BB%E7%9A%84%E5%B1%9E%E6%80%A7"><span class="toc-number">1.3.</span> <span class="toc-text">三、ThreadLocal类的属性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81ThreadLocal%E7%B1%BB%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="toc-number">1.4.</span> <span class="toc-text">四、ThreadLocal类的创建</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81ThreadLocal%E7%B1%BB%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">1.5.</span> <span class="toc-text">五、ThreadLocal类的方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-set%E6%96%B9%E6%B3%95"><span class="toc-number">1.5.1.</span> <span class="toc-text">1.set方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-get%E6%96%B9%E6%B3%95"><span class="toc-number">1.5.2.</span> <span class="toc-text">2.get方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-remove%E6%96%B9%E6%B3%95"><span class="toc-number">1.5.3.</span> <span class="toc-text">3.remove方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81ThreadLocalMap%E7%B1%BB%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">1.6.</span> <span class="toc-text">六、ThreadLocalMap类的原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-number">1.6.1.</span> <span class="toc-text">1.构造方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-set%E6%96%B9%E6%B3%95"><span class="toc-number">1.6.2.</span> <span class="toc-text">2.set方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-getEntry%E6%96%B9%E6%B3%95"><span class="toc-number">1.6.3.</span> <span class="toc-text">3.getEntry方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-remove%E6%96%B9%E6%B3%95"><span class="toc-number">1.6.4.</span> <span class="toc-text">4.remove方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-rehash%E6%96%B9%E6%B3%95"><span class="toc-number">1.6.5.</span> <span class="toc-text">5.rehash方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%E3%80%81ThreadLocal%E7%B1%BB%E7%9A%84%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F"><span class="toc-number">1.7.</span> <span class="toc-text">七、ThreadLocal类的内存泄漏</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">1.7.1.</span> <span class="toc-text">1.内存泄漏的原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E8%BF%87%E6%9C%9FEntry%E6%B8%85%E7%90%86%E5%8E%9F%E7%90%86"><span class="toc-number">1.7.2.</span> <span class="toc-text">2.过期Entry清理原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-remove%E6%96%B9%E6%B3%95-%E4%BD%BF%E7%94%A8expungeStaleEntry"><span class="toc-number">1.7.3.</span> <span class="toc-text">3.remove方法(使用expungeStaleEntry)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-set%E6%96%B9%E6%B3%95-%E4%BD%BF%E7%94%A8cleanSomeSlots%E5%92%8CreplaceStaleEntry"><span class="toc-number">1.7.4.</span> <span class="toc-text">4.set方法(使用cleanSomeSlots和replaceStaleEntry)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-getEntry%E6%96%B9%E6%B3%95-%E4%BD%BF%E7%94%A8expungeStaleEntry"><span class="toc-number">1.7.5.</span> <span class="toc-text">5.getEntry方法(使用expungeStaleEntry)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E6%80%BB%E7%BB%93"><span class="toc-number">1.7.6.</span> <span class="toc-text">6.内存泄漏总结</span></a></li></ol></li></ol></li></ol>
      </div>
    

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://hulingf.github.io/2023/11/14/ThreadLocal%E7%B1%BB%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://hulingf.github.io/2023/11/14/ThreadLocal%E7%B1%BB%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/&text=ThreadLocal类源码剖析"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://hulingf.github.io/2023/11/14/ThreadLocal%E7%B1%BB%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/&title=ThreadLocal类源码剖析"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://hulingf.github.io/2023/11/14/ThreadLocal%E7%B1%BB%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/&is_video=false&description=ThreadLocal类源码剖析"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=ThreadLocal类源码剖析&body=Check out this article: https://hulingf.github.io/2023/11/14/ThreadLocal%E7%B1%BB%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"><i class="fa-solid fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://hulingf.github.io/2023/11/14/ThreadLocal%E7%B1%BB%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/&title=ThreadLocal类源码剖析"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://hulingf.github.io/2023/11/14/ThreadLocal%E7%B1%BB%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/&title=ThreadLocal类源码剖析"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://hulingf.github.io/2023/11/14/ThreadLocal%E7%B1%BB%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/&title=ThreadLocal类源码剖析"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://hulingf.github.io/2023/11/14/ThreadLocal%E7%B1%BB%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/&title=ThreadLocal类源码剖析"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://hulingf.github.io/2023/11/14/ThreadLocal%E7%B1%BB%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/&name=ThreadLocal类源码剖析&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://hulingf.github.io/2023/11/14/ThreadLocal%E7%B1%BB%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/&t=ThreadLocal类源码剖析"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fa-solid fa-bars fa-lg" aria-hidden="true"></i> Menu</a>
        
          <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fa-solid fa-list fa-lg" aria-hidden="true"></i> TOC</a>
        
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fa-solid fa-share-alt fa-lg" aria-hidden="true"></i> Share</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2024
    hulingF
  </div>
  <div class="footer-right">
    <nav>
      <ul>
        <!--
       --><li><a href="/">Home</a></li><!--
     --><!--
       --><li><a href="/about/">About</a></li><!--
     --><!--
       --><li><a href="/archives/">Writing</a></li><!--
     --><!--
       --><li><a href="/tags/">Tag</a></li><!--
     --><!--
       --><li><a target="_blank" rel="noopener" href="http://github.com/hulingF">Projects</a></li><!--
     -->
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->



  <link rel="preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" crossorigin="anonymous" onload="this.onload=null;this.rel='stylesheet'"/>


    <!-- jquery -->

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" crossorigin="anonymous"></script>




<!-- clipboard -->

  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.7/clipboard.min.js" crossorigin="anonymous"></script>
  
  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"Copy to clipboard!\">";
    btn += '<i class="fa-regular fa-clone"></i>';
    btn += '</span>';
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "Copied!");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Disqus Comments -->

    <script type="text/javascript">
        var disqus_shortname = 'hulingF';

        (function(){
            var dsq = document.createElement('script');
            dsq.type = 'text/javascript';
            dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        }());
    </script>

<!-- utterances Comments -->

</body>
</html>
