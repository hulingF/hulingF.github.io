<!DOCTYPE html>
<html lang=en>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5" />
    <meta name="description" content="从ReentrantLock类看AQS的原理及实践(上篇)一、学习AQS的前置知识大名鼎鼎的AQS抽象队列同步器是JUC并发包下许多同步组件的基础框架，它的设计可以说考虑了方方面面的需求显得尤为复杂，从ReentrantLock的lock方法来看AQS，线程因为无法获取锁进入同步队列阻塞等待所使用的就是LockSupport的part方法，这也是我们要说的第一个前置知识。 1.LockSuppor">
<meta property="og:type" content="article">
<meta property="og:title" content="从ReentrantLock类看AQS的原理及实践(上篇)">
<meta property="og:url" content="https://hulingf.github.io/2023/11/17/%E4%BB%8EReentrantLock%E7%B1%BB%E7%9C%8BAQS%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E8%B7%B5(%E4%B8%8A%E7%AF%87)/index.html">
<meta property="og:site_name" content="大军的秘密花园">
<meta property="og:description" content="从ReentrantLock类看AQS的原理及实践(上篇)一、学习AQS的前置知识大名鼎鼎的AQS抽象队列同步器是JUC并发包下许多同步组件的基础框架，它的设计可以说考虑了方方面面的需求显得尤为复杂，从ReentrantLock的lock方法来看AQS，线程因为无法获取锁进入同步队列阻塞等待所使用的就是LockSupport的part方法，这也是我们要说的第一个前置知识。 1.LockSuppor">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://hulingf.github.io/imgs/%E4%BB%8EReentrantLock%E7%B1%BB%E7%9C%8BAQS%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E8%B7%B5(%E4%B8%8A%E7%AF%87)/fc14a34cdcf9ec2dfdc58a17d7d131a54504e4fd.png@670w_!web-note.webp">
<meta property="og:image" content="https://hulingf.github.io/imgs/%E4%BB%8EReentrantLock%E7%B1%BB%E7%9C%8BAQS%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E8%B7%B5(%E4%B8%8A%E7%AF%87)/a41d79c1d94ae81f7b5a011be9b0f7bf41bd5ecc.png@670w_!web-note.webp">
<meta property="og:image" content="https://hulingf.github.io/imgs/%E4%BB%8EReentrantLock%E7%B1%BB%E7%9C%8BAQS%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E8%B7%B5(%E4%B8%8A%E7%AF%87)/7f9d49c534c5e9a8a56a2efe469c465eeb13d94c.png@670w_!web-note.webp">
<meta property="og:image" content="https://hulingf.github.io/imgs/%E4%BB%8EReentrantLock%E7%B1%BB%E7%9C%8BAQS%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E8%B7%B5(%E4%B8%8A%E7%AF%87)/image-20231118213227293.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/%E4%BB%8EReentrantLock%E7%B1%BB%E7%9C%8BAQS%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E8%B7%B5(%E4%B8%8A%E7%AF%87)/412d294ff5535bbcddc0d979b2a339e6102264.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/%E4%BB%8EReentrantLock%E7%B1%BB%E7%9C%8BAQS%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E8%B7%B5(%E4%B8%8A%E7%AF%87)/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI1MTc4MzUz,size_16,color_FFFFFF,t_70.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/%E4%BB%8EReentrantLock%E7%B1%BB%E7%9C%8BAQS%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E8%B7%B5(%E4%B8%8A%E7%AF%87)/image-20231117111109191.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/%E4%BB%8EReentrantLock%E7%B1%BB%E7%9C%8BAQS%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E8%B7%B5(%E4%B8%8A%E7%AF%87)/image-20231117120915463.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/%E4%BB%8EReentrantLock%E7%B1%BB%E7%9C%8BAQS%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E8%B7%B5(%E4%B8%8A%E7%AF%87)/image-20231117122019379.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/%E4%BB%8EReentrantLock%E7%B1%BB%E7%9C%8BAQS%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E8%B7%B5(%E4%B8%8A%E7%AF%87)/image-20231117122652255.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/%E4%BB%8EReentrantLock%E7%B1%BB%E7%9C%8BAQS%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E8%B7%B5(%E4%B8%8A%E7%AF%87)/image-20231117155101378.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/%E4%BB%8EReentrantLock%E7%B1%BB%E7%9C%8BAQS%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E8%B7%B5(%E4%B8%8A%E7%AF%87)/82077ccf14127a87b77cefd1ccf562d3253591.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/%E4%BB%8EReentrantLock%E7%B1%BB%E7%9C%8BAQS%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E8%B7%B5(%E4%B8%8A%E7%AF%87)/d2f7f7fffdc30d85d17b44266c3ab05323338.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/%E4%BB%8EReentrantLock%E7%B1%BB%E7%9C%8BAQS%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E8%B7%B5(%E4%B8%8A%E7%AF%87)/7132e4cef44c26f62835b197b239147b18062.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/%E4%BB%8EReentrantLock%E7%B1%BB%E7%9C%8BAQS%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E8%B7%B5(%E4%B8%8A%E7%AF%87)/960271cf2b5c8a185eed23e98b72c75538637.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/%E4%BB%8EReentrantLock%E7%B1%BB%E7%9C%8BAQS%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E8%B7%B5(%E4%B8%8A%E7%AF%87)/image-20231117161623954.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/%E4%BB%8EReentrantLock%E7%B1%BB%E7%9C%8BAQS%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E8%B7%B5(%E4%B8%8A%E7%AF%87)/27605d483e8935da683a93be015713f331378.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/%E4%BB%8EReentrantLock%E7%B1%BB%E7%9C%8BAQS%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E8%B7%B5(%E4%B8%8A%E7%AF%87)/3f1e1a44f5b7d77000ba4f9476189b2e32806.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/%E4%BB%8EReentrantLock%E7%B1%BB%E7%9C%8BAQS%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E8%B7%B5(%E4%B8%8A%E7%AF%87)/image-20231117170552419.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/%E4%BB%8EReentrantLock%E7%B1%BB%E7%9C%8BAQS%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E8%B7%B5(%E4%B8%8A%E7%AF%87)/image-20231118204104012.png">
<meta property="article:published_time" content="2023-11-17T02:03:48.559Z">
<meta property="article:modified_time" content="2023-11-23T07:31:09.839Z">
<meta property="article:author" content="hulingF">
<meta property="article:tag" content="并发编程">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://hulingf.github.io/imgs/%E4%BB%8EReentrantLock%E7%B1%BB%E7%9C%8BAQS%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E8%B7%B5(%E4%B8%8A%E7%AF%87)/fc14a34cdcf9ec2dfdc58a17d7d131a54504e4fd.png@670w_!web-note.webp">
    
    
      
        
          <link rel="shortcut icon" href="/images/favicon.ico">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
        
      
    
    <!-- title -->
    <title>从ReentrantLock类看AQS的原理及实践(上篇)</title>
    <!-- async scripts -->
    <!-- Google Analytics -->


    <!-- Umami Analytics -->


    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
    <!-- rss -->
    
    
	<!-- mathjax -->
	
<meta name="generator" content="Hexo 6.3.0"></head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#" aria-label="Menu"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#" aria-label="Menu"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" aria-label="Top" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa-solid fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
        <!--
       --><li><a href="/">Home</a></li><!--
     --><!--
       --><li><a href="/about/">About</a></li><!--
     --><!--
       --><li><a href="/archives/">Writing</a></li><!--
     --><!--
       --><li><a href="/tags/">Tag</a></li><!--
     --><!--
       --><li><a target="_blank" rel="noopener" href="http://github.com/hulingF">Projects</a></li><!--
     -->
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" aria-label="Previous post" href="/2023/11/18/CountDownLatch%E7%B1%BB%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"><i class="fa-solid fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" aria-label="Next post" href="/2023/11/15/LongAdder%E7%B1%BB%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"><i class="fa-solid fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" aria-label="Back to top" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" aria-label="Share post" href="#"><i class="fa-solid fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://hulingf.github.io/2023/11/17/%E4%BB%8EReentrantLock%E7%B1%BB%E7%9C%8BAQS%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E8%B7%B5(%E4%B8%8A%E7%AF%87)/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://hulingf.github.io/2023/11/17/%E4%BB%8EReentrantLock%E7%B1%BB%E7%9C%8BAQS%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E8%B7%B5(%E4%B8%8A%E7%AF%87)/&text=从ReentrantLock类看AQS的原理及实践(上篇)"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://hulingf.github.io/2023/11/17/%E4%BB%8EReentrantLock%E7%B1%BB%E7%9C%8BAQS%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E8%B7%B5(%E4%B8%8A%E7%AF%87)/&title=从ReentrantLock类看AQS的原理及实践(上篇)"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://hulingf.github.io/2023/11/17/%E4%BB%8EReentrantLock%E7%B1%BB%E7%9C%8BAQS%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E8%B7%B5(%E4%B8%8A%E7%AF%87)/&is_video=false&description=从ReentrantLock类看AQS的原理及实践(上篇)"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=从ReentrantLock类看AQS的原理及实践(上篇)&body=Check out this article: https://hulingf.github.io/2023/11/17/%E4%BB%8EReentrantLock%E7%B1%BB%E7%9C%8BAQS%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E8%B7%B5(%E4%B8%8A%E7%AF%87)/"><i class="fa-solid fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://hulingf.github.io/2023/11/17/%E4%BB%8EReentrantLock%E7%B1%BB%E7%9C%8BAQS%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E8%B7%B5(%E4%B8%8A%E7%AF%87)/&title=从ReentrantLock类看AQS的原理及实践(上篇)"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://hulingf.github.io/2023/11/17/%E4%BB%8EReentrantLock%E7%B1%BB%E7%9C%8BAQS%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E8%B7%B5(%E4%B8%8A%E7%AF%87)/&title=从ReentrantLock类看AQS的原理及实践(上篇)"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://hulingf.github.io/2023/11/17/%E4%BB%8EReentrantLock%E7%B1%BB%E7%9C%8BAQS%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E8%B7%B5(%E4%B8%8A%E7%AF%87)/&title=从ReentrantLock类看AQS的原理及实践(上篇)"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://hulingf.github.io/2023/11/17/%E4%BB%8EReentrantLock%E7%B1%BB%E7%9C%8BAQS%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E8%B7%B5(%E4%B8%8A%E7%AF%87)/&title=从ReentrantLock类看AQS的原理及实践(上篇)"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://hulingf.github.io/2023/11/17/%E4%BB%8EReentrantLock%E7%B1%BB%E7%9C%8BAQS%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E8%B7%B5(%E4%B8%8A%E7%AF%87)/&name=从ReentrantLock类看AQS的原理及实践(上篇)&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://hulingf.github.io/2023/11/17/%E4%BB%8EReentrantLock%E7%B1%BB%E7%9C%8BAQS%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E8%B7%B5(%E4%B8%8A%E7%AF%87)/&t=从ReentrantLock类看AQS的原理及实践(上篇)"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    
    
      <div id="toc">
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%8EReentrantLock%E7%B1%BB%E7%9C%8BAQS%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E8%B7%B5-%E4%B8%8A%E7%AF%87"><span class="toc-number">1.</span> <span class="toc-text">从ReentrantLock类看AQS的原理及实践(上篇)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E5%AD%A6%E4%B9%A0AQS%E7%9A%84%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86"><span class="toc-number">1.1.</span> <span class="toc-text">一、学习AQS的前置知识</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-LockSupport%E5%B7%A5%E5%85%B7%E7%B1%BB"><span class="toc-number">1.1.1.</span> <span class="toc-text">1.LockSupport工具类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Java%E4%B8%AD%E6%96%AD%E6%9C%BA%E5%88%B6"><span class="toc-number">1.1.2.</span> <span class="toc-text">2.Java中断机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%A8%A1%E6%9D%BF%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.1.3.</span> <span class="toc-text">3.模板设计模式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81ReentrantLock%E7%B1%BB%E7%9A%84%E7%AE%80%E4%BB%8B"><span class="toc-number">1.2.</span> <span class="toc-text">二、ReentrantLock类的简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81ReentrantLock%E7%B1%BB%E7%9A%84%E7%BB%93%E6%9E%84"><span class="toc-number">1.3.</span> <span class="toc-text">三、ReentrantLock类的结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-ReentrantLock%E7%B1%BB%E7%9A%84%E6%80%BB%E4%BD%93%E6%9E%B6%E6%9E%84"><span class="toc-number">1.3.1.</span> <span class="toc-text">1.ReentrantLock类的总体架构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Lock%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.3.2.</span> <span class="toc-text">2.Lock接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-Sync%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">1.3.3.</span> <span class="toc-text">3.Sync内部类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81AQS%E7%9A%84%E9%87%8D%E7%82%B9%E5%8E%9F%E7%90%86"><span class="toc-number">1.4.</span> <span class="toc-text">三、AQS的重点原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-AQS%E7%9A%84%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0"><span class="toc-number">1.4.1.</span> <span class="toc-text">1.AQS的原理概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-AQS%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">1.4.2.</span> <span class="toc-text">2.AQS的数据结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-AQS%E9%87%8D%E8%A6%81%E6%96%B9%E6%B3%95%E4%B8%8EReentrantLock%E7%9A%84%E5%85%B3%E8%81%94"><span class="toc-number">1.4.3.</span> <span class="toc-text">3.AQS重要方法与ReentrantLock的关联</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-AQS%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">1.4.4.</span> <span class="toc-text">4.AQS的应用场景</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81ReentrantLock%E7%B1%BB%E7%9A%84%E5%8A%A0%E9%94%81%E6%B5%81%E7%A8%8B"><span class="toc-number">1.5.</span> <span class="toc-text">四、ReentrantLock类的加锁流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81ReentrantLock%E7%B1%BB%E7%9A%84%E8%A7%A3%E9%94%81%E6%B5%81%E7%A8%8B"><span class="toc-number">1.6.</span> <span class="toc-text">五、ReentrantLock类的解锁流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81ReentrantLock%E7%B1%BB%E7%9A%84%E5%85%B6%E4%BB%96%E6%96%B9%E6%B3%95"><span class="toc-number">1.7.</span> <span class="toc-text">六、ReentrantLock类的其他方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-lockInterruptibly"><span class="toc-number">1.7.1.</span> <span class="toc-text">1.lockInterruptibly</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-tryLock"><span class="toc-number">1.7.2.</span> <span class="toc-text">2.tryLock</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-tryLock%E8%B6%85%E6%97%B6%E7%89%88%E6%9C%AC"><span class="toc-number">1.7.3.</span> <span class="toc-text">3.tryLock超时版本</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E8%87%AA%E5%AE%9A%E4%B9%89%E5%90%8C%E6%AD%A5%E5%B7%A5%E5%85%B7"><span class="toc-number">1.8.</span> <span class="toc-text">七、自定义同步工具</span></a></li></ol></li></ol>
      </div>
    
  </span>
</div>

    
    <div class="content index py4 ">
        
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle p-name" itemprop="name headline">
        从ReentrantLock类看AQS的原理及实践(上篇)
    </h1>



    <div class="meta">
      <span class="author p-author h-card" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span class="p-name" itemprop="name">hulingF</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2023-11-17T02:03:48.559Z" class="dt-published" itemprop="datePublished">2023-11-17</time>
        
      
    </div>


      

      
    <div class="article-tag">
        <i class="fa-solid fa-tag"></i>
        <a class="p-category" href="/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" rel="tag">并发编程</a>
    </div>


    </div>
  </header>
  

  <div class="content e-content" itemprop="articleBody">
    <h1 id="从ReentrantLock类看AQS的原理及实践-上篇"><a href="#从ReentrantLock类看AQS的原理及实践-上篇" class="headerlink" title="从ReentrantLock类看AQS的原理及实践(上篇)"></a>从ReentrantLock类看AQS的原理及实践(上篇)</h1><h2 id="一、学习AQS的前置知识"><a href="#一、学习AQS的前置知识" class="headerlink" title="一、学习AQS的前置知识"></a>一、学习AQS的前置知识</h2><p>大名鼎鼎的AQS抽象队列同步器是JUC并发包下许多同步组件的基础框架，它的设计可以说考虑了方方面面的需求显得尤为复杂，从ReentrantLock的lock方法来看AQS，线程因为无法获取锁进入同步队列阻塞等待所使用的就是LockSupport的part方法，这也是我们要说的第一个前置知识。</p>
<h3 id="1-LockSupport工具类"><a href="#1-LockSupport工具类" class="headerlink" title="1.LockSupport工具类"></a>1.LockSupport工具类</h3><p>LockSupport是一个工具类，提供了基本的<code>线程阻塞</code>和<code>唤醒</code>功能（相较于wait、notify、notifyAll可以做到<code>精准唤醒</code>指定的线程），它是创建锁和其他同步组件的基础工具，内部是使用<code>sun.misc.Unsafe</code>类实现的。LockSupport和使用它的线程都会关联一个许可permmit，park方法表示消耗一个许可，调用park方法时，如果许可可用则park方法返回，如果没有许可则一直阻塞直到许可可用。unpark方法表示增加一个许可，<code>多次调用并不会积累许可</code>，因为许可数最大值为1。当然这里所讲的permit在LockSupport的代码当中没有体现，需要到HotSpot的源码当中查看，以下为截图供查看：</p>
<p>1、&#x2F;share&#x2F;vm&#x2F;runtime&#x2F;park.hpp中许可的定义字段_counter</p>
<p><img src="/../../../../../../imgs/%E4%BB%8EReentrantLock%E7%B1%BB%E7%9C%8BAQS%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E8%B7%B5(%E4%B8%8A%E7%AF%87)/fc14a34cdcf9ec2dfdc58a17d7d131a54504e4fd.png@670w_!web-note.webp" alt="img"></p>
<p>2、park()的实现(部分截图)【os&#x2F;bsd&#x2F;vm&#x2F;os_bsd.cpp】</p>
<p><img src="/../../../../../../imgs/%E4%BB%8EReentrantLock%E7%B1%BB%E7%9C%8BAQS%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E8%B7%B5(%E4%B8%8A%E7%AF%87)/a41d79c1d94ae81f7b5a011be9b0f7bf41bd5ecc.png@670w_!web-note.webp" alt="img"></p>
<p>3、unpark()实现(部分截图)【os&#x2F;bsd&#x2F;vm&#x2F;os_bsd.cpp】</p>
<p><img src="/../../../../../../imgs/%E4%BB%8EReentrantLock%E7%B1%BB%E7%9C%8BAQS%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E8%B7%B5(%E4%B8%8A%E7%AF%87)/7f9d49c534c5e9a8a56a2efe469c465eeb13d94c.png@670w_!web-note.webp" alt="img"></p>
<h3 id="2-Java中断机制"><a href="#2-Java中断机制" class="headerlink" title="2.Java中断机制"></a>2.Java中断机制</h3><p><img src="/../../../../../../imgs/%E4%BB%8EReentrantLock%E7%B1%BB%E7%9C%8BAQS%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E8%B7%B5(%E4%B8%8A%E7%AF%87)/image-20231118213227293.png" alt="image-20231118213227293"></p>
<p>注意：线程调用LockSupport的part方法会进入WAITING状态，如果此时对该线程调用interrupt方法，线程会立即苏醒恢复。</p>
<h3 id="3-模板设计模式"><a href="#3-模板设计模式" class="headerlink" title="3.模板设计模式"></a>3.模板设计模式</h3><h2 id="二、ReentrantLock类的简介"><a href="#二、ReentrantLock类的简介" class="headerlink" title="二、ReentrantLock类的简介"></a>二、ReentrantLock类的简介</h2><p>ReentrantLock类是<code>可重入互斥锁</code>，与使用同步方法和语句访问的<code>隐式监视器锁</code>具有相同的基本行为和语义，但具有扩展功能。ReentrantLock由最后一次成功锁定但尚未解锁的线程拥有，当锁不被另一个线程拥有时，调用锁的线程将返回并成功获取锁。如果当前线程已经拥有锁，该lock方法将立即返回，这可以使用<code>isHeldByCurrentThread</code>和<code>getHoldCount</code>方法进行检查。<br>此类的构造函数接受可选的公平参数，当设置为 true 时，在争用情况下，锁倾向于授予<code>等待时间最长</code>的线程访问权限（即同步队列的队头虚节点的下一个节点），否则该锁不保证任何特定的访问顺序。使用由许多线程访问的公平锁的程序可能会显示比使用默认设置的程序更低的总体吞吐量（即更慢，<code>通常慢得多</code>），但在获取锁的时间上具有较小的差异并<code>保证不会出现饥饿</code>。 但请注意，锁的公平性并不能保证线程调度的公平性。因此，使用公平锁的许多线程之一可能会连续多次获得公平锁，而其他活动线程没有进展并且当前没有持有该锁。另请注意，不定时的 tryLock() 方法不遵守公平性设置，如果锁可用，即使其他线程正在等待也会成功。</p>
<blockquote>
<p>关于公平与非公平的额外说明：</p>
<p>在AQS持有锁的线程释放锁以后，可能来竞争锁的线程有两种类型，<strong>一种就是在同步队列中线程</strong>，准确的说就是队列中第一个等待的线程，因为只有它才有争抢锁的资格(FIFO规则)。<strong>另外一种想要争抢锁的线程就是队列外的线程</strong>,也就是没有排队的线程。如果释放的锁可以被这些没有排队的线程优先抢到的话，那对于排队的线程来说就是<strong>非公平的，</strong>如果我们优先队列中的线程获取到锁的话，那对于他们就是<strong>公平的。说到底就是允不允许争抢锁的时候插队，当然这里的插队，是指插在队头！允许插队就是不公平的，不允许就是公平的。</strong></p>
</blockquote>
<p>为了帮助大家更好地理解ReentrantLock的特性，我们先将ReentrantLock跟常用的Synchronized进行比较，其特性如下（蓝色部分为本篇文章主要剖析的点）：</p>
<p><img src="/../../../../../../imgs/%E4%BB%8EReentrantLock%E7%B1%BB%E7%9C%8BAQS%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E8%B7%B5(%E4%B8%8A%E7%AF%87)/412d294ff5535bbcddc0d979b2a339e6102264.png" alt="img"></p>
<h2 id="三、ReentrantLock类的结构"><a href="#三、ReentrantLock类的结构" class="headerlink" title="三、ReentrantLock类的结构"></a>三、ReentrantLock类的结构</h2><h3 id="1-ReentrantLock类的总体架构"><a href="#1-ReentrantLock类的总体架构" class="headerlink" title="1.ReentrantLock类的总体架构"></a>1.ReentrantLock类的总体架构</h3><p><img src="/../../../../../../imgs/%E4%BB%8EReentrantLock%E7%B1%BB%E7%9C%8BAQS%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E8%B7%B5(%E4%B8%8A%E7%AF%87)/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI1MTc4MzUz,size_16,color_FFFFFF,t_70.png" alt="img"></p>
<p>借鉴网上的一张ReentrantLock类的结构图，可以看出ReentrantLock首先继承了<code>Lock</code>接口并实现了其中的6个方法，其次ReentrantLock包含了一个内部类对象<code>sync</code>是AQS的实现类<code>Sync</code>，根据构造函数的公平参数<code>sync</code>可以<code>Sync</code>的两个实现子类<code>FairSync</code>或<code>NonfairSync</code>之一。</p>
<h3 id="2-Lock接口"><a href="#2-Lock接口" class="headerlink" title="2.Lock接口"></a>2.Lock接口</h3><p>我们先来看一下Lock接口的信息：</p>
<p><img src="/../../../../../../imgs/%E4%BB%8EReentrantLock%E7%B1%BB%E7%9C%8BAQS%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E8%B7%B5(%E4%B8%8A%E7%AF%87)/image-20231117111109191.png" alt="image-20231117111109191"></p>
<p>Lock实现提供了比使用synchronized方法和语句更广泛的锁定操作。它们允许<code>更灵活的结构</code>，可能具有完全不同的属性，并且可能支持<code>多个关联的Condition对象</code>。锁是控制多个线程对共享资源的访问的工具。通常，锁提供对共享资源的独占访问：一次只有一个线程可以获取锁，并且对共享资源的所有访问都需要首先获取锁。但是，某些锁可能允许对共享资源的并发访问，例如ReadWriteLock的读锁。使用synchronized方法或语句提供对与每个对象关联的隐式监视器锁的访问，但强制所有锁获取和释放以块结构方式发生：当获取多个锁时，必须以相反的顺序释放它们，并且所有锁都必须在获取它们的同一词法范围内释放。</p>
<p>虽然synchronized方法和语句的作用域机制使使用监视器锁进行编程变得更加容易，并且有助于避免许多涉及锁的常见编程错误，但有时您需要以更灵活的方式使用锁。例如，一些遍历并发访问数据结构的算法需要使用<code>hand-over-hand</code>或<code>chain locking</code>：获取节点A的锁，然后获取节点B的锁，然后释放A并获取 C，然后释放B并获得D等。Lock接口的实现允许在不同范围内获取和释放锁，并允许以任何顺序获取和释放多个锁，从而允许使用此类技术。随着灵活性的增加，责任也随之增加。块结构锁定的缺失消除了synchronized方法和语句中发生的锁的自动释放。在大多数情况下，应该使用以下习惯用法：</p>
<p><img src="/../../../../../../imgs/%E4%BB%8EReentrantLock%E7%B1%BB%E7%9C%8BAQS%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E8%B7%B5(%E4%B8%8A%E7%AF%87)/image-20231117120915463.png" alt="image-20231117120915463"></p>
<p>当加锁和解锁发生在不同的作用域时，必须注意确保持有锁时执行的所有代码都受到<code>try-finally</code>或<code>try-catch</code>的保护，以确保在必要时释放锁。&#x3D;&#x3D;Lock实现通过提供非阻塞尝试获取锁 (tryLock())、尝试获取可中断锁 (lockInterruptically) 以及尝试获取可以超时的锁(tryLock(long, TimeUnit))，从而提供了使用同步方法和语句的附加功能。&#x3D;&#x3D;<br>Lock类还可以提供与隐式监视器锁完全不同的行为和语义，例如<code>保证顺序</code>、<code>不可重入使用</code>或<code>死锁检测</code>。如果实现提供了此类专门的语义，那么该实现必须<code>记录</code>这些语义。请注意， Lock实例只是普通对象，它们本身可以用作synchronized语句中的目标对象，获取Lock实例的监视器锁与调用该实例的任何lock方法没有指定的关系。<u>为了避免混淆，建议您永远不要以这种方式使用Lock实例，除非在它们自己的实现中。</u></p>
<p>锁获取的三种形式（可中断、不可中断和定时）在性能特征、顺序保证或其他实现质量方面可能有所不同。此外，中断正在进行的锁获取的能力在给定的Lock类中可能不可用。因此，Lock实现不需要为所有三种形式的锁获取定义完全相同的保证或语义，也不需要支持正在进行的锁获取的中断。<code>需要一个实现来清楚地记录每种锁定方法提供的语义和保证。</code>它还必须遵守此接口中定义的中断语义，以支持锁获取的中断：要么完全中断，要么仅在方法入口处中断。由于中断通常意味着取消，并且对中断的检查通常不频繁，因此实现可以优先响应中断而不是正常方法返回。</p>
<p><img src="/../../../../../../imgs/%E4%BB%8EReentrantLock%E7%B1%BB%E7%9C%8BAQS%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E8%B7%B5(%E4%B8%8A%E7%AF%87)/image-20231117122019379.png" alt="image-20231117122019379"></p>
<p>ReentrantLock作为Lock接口的实现类，实现了Lock接口定义的所有方法，并且都是委托给内部的<code>sync</code>对象实现，以lock方法为例，其余方法都是同理：</p>
<p><img src="/../../../../../../imgs/%E4%BB%8EReentrantLock%E7%B1%BB%E7%9C%8BAQS%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E8%B7%B5(%E4%B8%8A%E7%AF%87)/image-20231117122652255.png" alt="image-20231117122652255"></p>
<h3 id="3-Sync内部类"><a href="#3-Sync内部类" class="headerlink" title="3.Sync内部类"></a>3.Sync内部类</h3><p>本篇不会涉及到AQS的条件队列，因此为了便于理解不相关的方法不会贴出，这里我们也只是简单的解释其中出现的方法，后面设计到ReentrantLock的加锁和解锁流程时涉及到的会展开详细解释：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Sync</span> <span class="keyword">extends</span> <span class="title class_">AbstractQueuedSynchronizer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">5179523762034025860L</span>;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 由于ReentrantLock有公平和非公平两种模式，因此lock方法需要留给FairSync和NonfairSync单独实现</span></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 有趣的是Sync已经帮我们实现好了非公平加锁的核心逻辑，NonfairSync继承Sync后实现lock方法后只需直接调用</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">nonfairTryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                setExclusiveOwnerThread(current);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c + acquires;</span><br><span class="line">            <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">            setState(nextc);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解锁的逻辑无论公平还是非公平模式都是一致的，Sync直接定义好了</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span> releases)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState() - releases;</span><br><span class="line">        <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">free</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">            free = <span class="literal">true</span>;</span><br><span class="line">            setExclusiveOwnerThread(<span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        setState(c);</span><br><span class="line">        <span class="keyword">return</span> free;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查当前线程是否是独占锁的持有者</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">isHeldExclusively</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// While we must in general read state before owner,</span></span><br><span class="line">        <span class="comment">// we don&#x27;t need to do so to check if current thread is owner</span></span><br><span class="line">        <span class="keyword">return</span> getExclusiveOwnerThread() == Thread.currentThread();</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 获取ReentrantLock独占锁的持有者线程</span></span><br><span class="line">    <span class="keyword">final</span> Thread <span class="title function_">getOwner</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getState() == <span class="number">0</span> ? <span class="literal">null</span> : getExclusiveOwnerThread();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前线程锁重入的次数</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getHoldCount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> isHeldExclusively() ? getState() : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查锁是否已经被占用</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">isLocked</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getState() != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/../../../../../../imgs/%E4%BB%8EReentrantLock%E7%B1%BB%E7%9C%8BAQS%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E8%B7%B5(%E4%B8%8A%E7%AF%87)/image-20231117155101378.png" alt="image-20231117155101378"></p>
<blockquote>
<p>为什么nonfairTryAcquire方法是在Sync类中定义的而不是NonfairSync类定义的呢？其实是因为ReentrantLock类提供给开发者的tryLock方法需要使用到nonfairTryAcquire方法，无论是公平模式还是非公平模式下的ReentrantLock都是如此，因此作者选择将nonfairTryAcquire方法放入NonfairSync和FairSync的父类Sync中实现，这一点后面也会看到。</p>
</blockquote>
<p>当然，ReentrantLock所依靠的真正实现类其实还是<code>Sync</code>的两个实现类<code>FairSync</code>和<code>NonfairSync</code>，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">NonfairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">7316153563782823691L</span>;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 非公平加锁，外来的线程可以直接插队竞争锁</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">            setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">FairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">3000897897090466540L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 公平加锁，符合FIFO队列的顺序加锁特点</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">                compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                setExclusiveOwnerThread(current);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c + acquires;</span><br><span class="line">            <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">            setState(nextc);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="三、AQS的重点原理"><a href="#三、AQS的重点原理" class="headerlink" title="三、AQS的重点原理"></a>三、AQS的重点原理</h2><p>看了这么多，最终还是需要AQS框架的介入，首先，我们通过下面的架构图来整体了解一下AQS框架：</p>
<p><img src="/../../../../../../imgs/%E4%BB%8EReentrantLock%E7%B1%BB%E7%9C%8BAQS%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E8%B7%B5(%E4%B8%8A%E7%AF%87)/82077ccf14127a87b77cefd1ccf562d3253591.png" alt="img"></p>
<ul>
<li>上图中有颜色的为Method，无颜色的为Attribution。</li>
<li>总的来说，AQS框架共分为五层，自上而下由浅入深，从AQS对外暴露的API到底层基础数据。</li>
<li>当有自定义同步器接入时，只需<code>重写第一层所需要的部分方法</code>即可，不需要关注底层具体的实现流程。当自定义同步器进行加锁或者解锁操作时，先经过第一层的API进入AQS内部方法，然后经过第二层进行锁的获取，接着对于获取锁失败的流程，进入第三层和第四层的等待队列处理，而这些处理方式均依赖于第五层的基础数据提供层。</li>
</ul>
<p>下面我们会从整体到细节，从流程到方法逐一剖析AQS框架，主要分析过程如下：</p>
<p><img src="/../../../../../../imgs/%E4%BB%8EReentrantLock%E7%B1%BB%E7%9C%8BAQS%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E8%B7%B5(%E4%B8%8A%E7%AF%87)/d2f7f7fffdc30d85d17b44266c3ab05323338.png" alt="img"></p>
<h3 id="1-AQS的原理概述"><a href="#1-AQS的原理概述" class="headerlink" title="1.AQS的原理概述"></a>1.AQS的原理概述</h3><p>AQS核心思想是，如果被请求的共享资源空闲，那么就将当前请求资源的线程设置为有效的工作线程，将共享资源设置为锁定状态；如果共享资源被占用，就需要一定的阻塞等待唤醒机制来保证锁分配。这个机制主要用的是CLH队列的变体实现的，将暂时获取不到锁的线程加入到队列中。</p>
<p>CLH：Craig、Landin and Hagersten队列，是单向链表，AQS中的队列是CLH变体的虚拟双向队列（FIFO），AQS是通过将每条请求共享资源的线程封装成一个节点来实现锁的分配。</p>
<p><img src="/../../../../../../imgs/%E4%BB%8EReentrantLock%E7%B1%BB%E7%9C%8BAQS%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E8%B7%B5(%E4%B8%8A%E7%AF%87)/7132e4cef44c26f62835b197b239147b18062.png" alt="img"></p>
<p>AQS使用一个volatile的int类型的成员变量state来表示同步状态，通过内置的FIFO队列来完成资源获取的排队工作，通过CAS完成对state值的修改。</p>
<h3 id="2-AQS的数据结构"><a href="#2-AQS的数据结构" class="headerlink" title="2.AQS的数据结构"></a>2.AQS的数据结构</h3><p>先来看下AQS中最基本的数据结构——Node，Node即为上面CLH变体队列中的节点。</p>
<p><img src="/../../../../../../imgs/%E4%BB%8EReentrantLock%E7%B1%BB%E7%9C%8BAQS%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E8%B7%B5(%E4%B8%8A%E7%AF%87)/960271cf2b5c8a185eed23e98b72c75538637.png" alt="img"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="comment">// 共享锁的标记</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">SHARED</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">    <span class="comment">// 独占锁的标记</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">EXCLUSIVE</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 表明节点因为超时或中断而取消</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CANCELLED</span> <span class="operator">=</span>  <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 表明后继节点需要被唤醒</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SIGNAL</span>    <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 条件队列中才会使用到</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CONDITION</span> <span class="operator">=</span> -<span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 共享锁模式下才会使用到</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">PROPAGATE</span> <span class="operator">=</span> -<span class="number">3</span>;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 同步队列中节点的当前状态，初始化为0</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">int</span> waitStatus;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 前驱节点</span></span><br><span class="line">    <span class="keyword">volatile</span> Node prev;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 后继节点</span></span><br><span class="line">    <span class="keyword">volatile</span> Node next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 入队等待的线程</span></span><br><span class="line">    <span class="keyword">volatile</span> Thread thread;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 双重作用，既可以指示链接的下一个Condition节点，又可以表示锁的两种模式：SHARED或EXCLUSIVE</span></span><br><span class="line">    Node nextWaiter;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">isShared</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> nextWaiter == SHARED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Node <span class="title function_">predecessor</span><span class="params">()</span> <span class="keyword">throws</span> NullPointerException &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> prev;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node() &#123;    <span class="comment">// Used to establish initial head or SHARED marker</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node(Thread thread, Node mode) &#123;     <span class="comment">// Used by addWaiter</span></span><br><span class="line">        <span class="built_in">this</span>.nextWaiter = mode;</span><br><span class="line">        <span class="built_in">this</span>.thread = thread;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node(Thread thread, <span class="type">int</span> waitStatus) &#123; <span class="comment">// Used by Condition</span></span><br><span class="line">        <span class="built_in">this</span>.waitStatus = waitStatus;</span><br><span class="line">        <span class="built_in">this</span>.thread = thread;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在了解数据结构后，接下来了解一下AQS的同步状态——State。AQS中维护了一个名为state的字段，意为同步状态，是由Volatile修饰的，用于展示当前临界资源的获锁情况。</p>
<p><img src="/../../../../../../imgs/%E4%BB%8EReentrantLock%E7%B1%BB%E7%9C%8BAQS%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E8%B7%B5(%E4%B8%8A%E7%AF%87)/image-20231117161623954.png" alt="image-20231117161623954"></p>
<p>这几个方法都是final修饰的，说明子类中无法重写它们。我们可以通过修改state字段表示的同步状态来实现多线程的独占模式和共享模式（加锁过程）。</p>
<p><img src="/../../../../../../imgs/%E4%BB%8EReentrantLock%E7%B1%BB%E7%9C%8BAQS%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E8%B7%B5(%E4%B8%8A%E7%AF%87)/27605d483e8935da683a93be015713f331378.png" alt="img"></p>
<p><img src="/../../../../../../imgs/%E4%BB%8EReentrantLock%E7%B1%BB%E7%9C%8BAQS%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E8%B7%B5(%E4%B8%8A%E7%AF%87)/3f1e1a44f5b7d77000ba4f9476189b2e32806.png" alt="img"></p>
<p>对于我们自定义的同步工具，需要自定义获取同步状态和释放状态的方式，也就是AQS架构图中的第一层：API层。</p>
<h3 id="3-AQS重要方法与ReentrantLock的关联"><a href="#3-AQS重要方法与ReentrantLock的关联" class="headerlink" title="3.AQS重要方法与ReentrantLock的关联"></a>3.AQS重要方法与ReentrantLock的关联</h3><p>从架构图中可以得知，AQS提供了大量用于自定义同步器实现的Protected方法。自定义同步器实现的相关方法也只是为了通过修改state字段来实现多线程的独占模式或者共享模式。自定义同步器需要实现以下方法（ReentrantLock需要实现的方法如下，并不是全部）：</p>
<table>
<thead>
<tr>
<th align="left">方法名</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">protected boolean isHeldExclusively()</td>
<td align="left">该线程是否正在独占资源。只有用到Condition才需要去实现它。</td>
</tr>
<tr>
<td align="left">protected boolean tryAcquire(int arg)</td>
<td align="left">独占方式。arg为获取锁的次数，尝试获取资源，成功则返回True，失败则返回False。</td>
</tr>
<tr>
<td align="left">protected boolean tryRelease(int arg)</td>
<td align="left">独占方式。arg为释放锁的次数，尝试释放资源，成功则返回True，失败则返回False。</td>
</tr>
<tr>
<td align="left">protected int tryAcquireShared(int arg)</td>
<td align="left">共享方式。arg为获取锁的次数，尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</td>
</tr>
<tr>
<td align="left">protected boolean tryReleaseShared(int arg)</td>
<td align="left">共享方式。arg为释放锁的次数，尝试释放资源，如果释放后允许唤醒后续等待结点返回True，否则返回False。</td>
</tr>
</tbody></table>
<p>一般来说，自定义同步器要么是独占方式，要么是共享方式，它们也只需实现tryAcquire-tryRelease、tryAcquireShared-tryReleaseShared中的一种即可。AQS也支持自定义同步器同时实现独占和共享两种方式，如ReentrantReadWriteLock。ReentrantLock是独占锁，所以实现了tryAcquire-tryRelease。</p>
<h3 id="4-AQS的应用场景"><a href="#4-AQS的应用场景" class="headerlink" title="4.AQS的应用场景"></a>4.AQS的应用场景</h3><p>除了上边ReentrantLock的可重入性的应用，AQS作为并发编程的框架，为很多其他同步工具提供了良好的解决方案。下面列出了JUC中的几种同步工具，大体介绍一下AQS的应用场景：</p>
<table>
<thead>
<tr>
<th align="left">同步工具</th>
<th align="left">同步工具与AQS的关联</th>
</tr>
</thead>
<tbody><tr>
<td align="left">ReentrantLock</td>
<td align="left">使用AQS保存锁重复持有的次数。当一个线程获取锁时，ReentrantLock记录当前获得锁的线程标识，用于检测是否重复获取，以及错误线程试图解锁操作时异常情况的处理。</td>
</tr>
<tr>
<td align="left">Semaphore</td>
<td align="left">使用AQS同步状态来保存信号量的当前计数。tryRelease会增加计数，acquireShared会减少计数。</td>
</tr>
<tr>
<td align="left">CountDownLatch</td>
<td align="left">使用AQS同步状态来表示计数。计数为0时，所有的Acquire操作（CountDownLatch的await方法）才可以通过。</td>
</tr>
<tr>
<td align="left">ReentrantReadWriteLock</td>
<td align="left">使用AQS同步状态中的16位保存写锁持有的次数，剩下的16位用于保存读锁的持有次数。</td>
</tr>
<tr>
<td align="left">ThreadPoolExecutor</td>
<td align="left">Worker利用AQS同步状态实现对独占线程变量的设置（tryAcquire和tryRelease）。</td>
</tr>
</tbody></table>
<h2 id="四、ReentrantLock类的加锁流程"><a href="#四、ReentrantLock类的加锁流程" class="headerlink" title="四、ReentrantLock类的加锁流程"></a>四、ReentrantLock类的加锁流程</h2><p>我们以非公平锁为例，全流程讲解整个加锁的过程，首先我们先看加锁的入口函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">    sync.lock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以说，ReentrantLock的加锁是委托给内部的<code>sync</code>对象完成的，以非公平的<code>NonFairSync</code>为例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 新的线程直接尝试CAS获取锁，可以完成插队加锁</span></span><br><span class="line">    <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">        <span class="comment">// 加锁成功后设置独占锁的持有者线程为当前线程</span></span><br><span class="line">        setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 加锁失败后的流程</span></span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当第一个线程请求加锁时发现当前state值为0，锁还没有被占用，于是调用compareAndSetState加锁成功，开始处理后续业务逻辑；当然这是理想情况，如果此时恰好第二个线程提前抢占了锁，则本次compareAndSetState加锁失败，就会进入acquire方法寻求解决方案，让我们走进acquire的世界吧：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个AQS中的acquire方法中先后出现了四个函数，首先会调用子类(本节中就是<code>NonfairSync</code>)重写的<code>tryAcquire</code>方法，也许你会疑惑为什么在AQS中为什么不把tryAcquire方法定义为抽象方法而是保护方法，原因就是保证实现类可以根据自己的需求重写特定的方法实现功能逻辑，例如ReentrantLock中的<code>NonfairSync</code>只需要实现<code>tryAcquire</code>和<code>tryRelease</code>方法即可，其余的像<code>tryAcquireShared</code>、<code>tryReleaseShared</code>等方法根本不需要：</p>
<p><img src="/../../../../../../imgs/%E4%BB%8EReentrantLock%E7%B1%BB%E7%9C%8BAQS%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E8%B7%B5(%E4%B8%8A%E7%AF%87)/image-20231117170552419.png" alt="image-20231117170552419"></p>
<p>回到正题中，让我们看看<code>NonfairSync</code>的<code>tryAcquire</code>方法的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">nonfairTryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">    <span class="comment">// 此刻发现锁已经被释放了，可以进行竞争抢占</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 加锁成功后还是设置独占锁的持有者线程为当前线程，并返回true表示加锁成功</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 上一步竞争抢占锁失败或者锁一直被占用着，进一步判断是不是持有锁线程的重入加锁</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="comment">// ReentrantLock锁可重入</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c + acquires;</span><br><span class="line">        <span class="comment">// ReentrantLock锁有递归次数限制，不能超过整型表示的最大正数2^31^-1</span></span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">        <span class="comment">// 线程已经持有锁，不需要通过CAS方法修改state</span></span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回false表示加锁失败</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看到tryAcquire内部其实还是调用了父类<code>Sync</code>就定义好的<code>nonfairTryAcquire</code>方法，整个tryAcquire做的事情就是检查一下独占锁有没有被释放，如果锁被释放了就进行竞争抢占，否则判断是不是重入加锁，如果都不是表明当前线程可能只能进入同步队列等待了。</p>
<p>针对tryAcquire加锁成功acquire方法的判断逻辑就已经结束了，下面我们进一步查看tryAcquire加锁失败即返回false的后续操作，首当其冲的就是addWaiter方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Node <span class="title function_">addWaiter</span><span class="params">(Node mode)</span> &#123;</span><br><span class="line">    <span class="comment">// 把线程封装到Node节点中，其中mode在这里是独占模式Node.EXCLUSIVE</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(Thread.currentThread(), mode);</span><br><span class="line">    <span class="comment">// Try the fast path of enq; backup to full enq on failure</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">pred</span> <span class="operator">=</span> tail;</span><br><span class="line">    <span class="comment">// 尾节点不为空，表明同步队列已经初始化具有虚头节点，直接插入队尾即可</span></span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="literal">null</span>) &#123;</span><br><span class="line">        node.prev = pred;</span><br><span class="line">        <span class="comment">// CAS修改队尾指针成功，可能会因为并发线程修改队尾指针导致本次CAS失败，这种情况需要交给后续enq保证节点入队</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 负责同步队列的初始化和保证节点入队尾</span></span><br><span class="line">    enq(node);</span><br><span class="line">    <span class="comment">// 返回插入的新节点</span></span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Node <span class="title function_">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> &#123;</span><br><span class="line">    <span class="comment">// 自旋很重要！</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail;</span><br><span class="line">        <span class="comment">// 初始化同步队列</span></span><br><span class="line">        <span class="keyword">if</span> (t == <span class="literal">null</span>) &#123; </span><br><span class="line">            <span class="comment">// CAS修改队头指针为虚节点，可能会因为并发线程进入enq方法初始化队列而CAS失败，但是自旋保证了即使发生这种情况也会使节点正确入队尾</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> <span class="title class_">Node</span>()))</span><br><span class="line">                <span class="comment">// 初始化的状态是队头、队尾指针都指向虚节点</span></span><br><span class="line">                tail = head;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 新节点插入队尾</span></span><br><span class="line">            node.prev = t;</span><br><span class="line">            <span class="comment">// CAS修改队尾指针为新节点，可能会因为并发线程插入队尾导致CAS失败，但是自旋保证了即使发生这种情况也会使节点正确入队尾</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                t.next = node;</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此，总的来说<code>addWaiter</code>方法保证了同步队列的初始化和节点入队尾的并发安全性。</p>
<p>接着，既然节点已经插入同步队列的尾部了，那么后续的阻塞等待逻辑怎么完成的呢，这就需要我们再一次查看<code>acquireQueued</code>方法的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="comment">// 是否获取到锁的标记，默认为true表示没有获取到锁</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 加锁过程中是否中断的标记，ReentrantLock的lock方法并不处理中断，仅仅记录中断标记</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 自旋很重要！</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">// 新插入节点的前驱节点</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();</span><br><span class="line">            <span class="comment">// 只有虚节点的后一个节点(即第一个有效节点，符合FIFO规则)才有资格竞争锁</span></span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                <span class="comment">// 新插入的节点加锁成功的话，虚节点后移一位变成当前持有锁的</span></span><br><span class="line">                setHead(node);</span><br><span class="line">                <span class="comment">// help GC</span></span><br><span class="line">                p.next = <span class="literal">null</span>; </span><br><span class="line">                <span class="comment">// 修改标记为false表示获取到锁</span></span><br><span class="line">                failed = <span class="literal">false</span>;</span><br><span class="line">                <span class="comment">// 返回中断标记</span></span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 新插入的节点不是第一个有效节点，或者虽然是第一个有效节点但是尝试加锁失败</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                <span class="comment">// 如果阻塞等待期间当前线程被中断了，修改中断标记为true</span></span><br><span class="line">                interrupted = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            <span class="comment">// 发生异常，取消正在获取锁的线程节点</span></span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码告诉我们只有队头节点(虚节点的后一个节点)才有资格去竞争锁，这也符合AQS的FIFO同步队列的规则定义，有的同学可能会认为调用ReentrantLock的lock方法加锁失败会就会立即去同步队列阻塞等待，这其实是错误的观点，不是每个节点都有资格竞争锁的，而且第一个有效头节点也不会立刻就阻塞等待而是会再次尝试加锁多次，实在获取不到锁才会阻塞等待。</p>
<p>下面我们去看一下acquireQueued中获取不到锁处理流程的第一个函数<code>shouldParkAfterFailedAcquire</code>，顾名思义就是在加锁失败后判断是否应该阻塞等待的逻辑函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> &#123;</span><br><span class="line">    <span class="comment">// 前置节点的状态</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> pred.waitStatus;</span><br><span class="line">    <span class="comment">// 前置节点状态为SIGNAL，表示前置节点可以负责后继节点的唤醒工作，当前节点可以安心阻塞等待了，返回true</span></span><br><span class="line">    <span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * This node has already set status asking a release</span></span><br><span class="line"><span class="comment">         * to signal it, so it can safely park.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 前置节点的状态为CANCELLED，移除前面所有无效的Cancelled节点，我们本节用不到</span></span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Predecessor was cancelled. Skip over predecessors and</span></span><br><span class="line"><span class="comment">         * indicate retry.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            node.prev = pred = pred.prev;</span><br><span class="line">        &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">        pred.next = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * waitStatus must be 0 or PROPAGATE.  Indicate that we</span></span><br><span class="line"><span class="comment">         * need a signal, but don&#x27;t park yet.  Caller will need to</span></span><br><span class="line"><span class="comment">         * retry to make sure it cannot acquire before parking.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">// 节点的默认状态为0，通过CAS修改前置节点状态为SIGNAL</span></span><br><span class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 除了前置节点状态为SIGNAL这种情况外，其余都返回false表示当前节点不应该阻塞，需要再次尝试</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一开始节点的默认状态都是0，因此<code>shouldParkAfterFailedAcquire</code>会修改前置节点状态为<code>SIGNAL</code>，然后再次自旋重试加锁(针对有效头节点)，如果还是没有获取到锁则再次进入<code>shouldParkAfterFailedAcquire</code>方法并返回true表示当前节点可以阻塞了，随即调用后续的<code>parkAndCheckInterrupt</code>方法阻塞当前线程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">parkAndCheckInterrupt</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 当前线程阻塞等待后续解锁唤醒，也可能会被中断唤醒(我们这里可以理解为虚假唤醒，因为原则上ReentrantLock不响应中断)，唤醒后需要去竞争加锁，可能会被外来线程插队(这就是非公平锁的特点)</span></span><br><span class="line">    LockSupport.park(<span class="built_in">this</span>);</span><br><span class="line">    <span class="comment">// 唤醒后返回当前线程阻塞等待期间是否被中断的标识，会清除线程的中断位</span></span><br><span class="line">    <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到这里，<code>acquire</code>方法内的前三个主要函数都已经讲解完毕，我们再次回顾该方法的逻辑：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同步队列的第一个有效节点被唤醒并成功加锁后，返回阻塞等待期间是否被中断的标识，如果确实被中断过，此时调用<code>selfInterrupt</code>方法设置当前线程的中断位，因此可以看出，ReentrantLock的lock方法确实不处理中断：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">selfInterrupt</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 设置中断位</span></span><br><span class="line">    Thread.currentThread().interrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="五、ReentrantLock类的解锁流程"><a href="#五、ReentrantLock类的解锁流程" class="headerlink" title="五、ReentrantLock类的解锁流程"></a>五、ReentrantLock类的解锁流程</h2><p>讲完ReentrantLock的加锁流程，下面我们看一下ReentrantLock的解锁流程，首先看一下解锁的入口函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">    sync.release(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以说，ReentrantLock的解锁也是委托给内部的<code>sync</code>对象完成的，以非公平的<code>NonFairSync</code>为例(其实解锁对于公平或非公平模型都是一样的操作)：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">release</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="comment">// 尝试[完全]释放锁成功后的情况，这里的完全指的是重入锁全部释放</span></span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="comment">// 同步队列头的虚节点状态是SIGNAL，可以唤醒其后继节点</span></span><br><span class="line">        <span class="keyword">if</span> (h != <span class="literal">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先解锁的第一个方法就是<code>tryRelease</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span> releases)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState() - releases;</span><br><span class="line">    <span class="comment">// 只有持有锁的线程才能释放锁，否则抛出IllegalMonitorStateException，跟synchronized相似</span></span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line">    <span class="comment">// 完全释放锁的标记，默认false表示没有完全释放锁</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">free</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 重入次数归零表明已经完全释放锁</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 修改标记位true表示完全释放锁</span></span><br><span class="line">        free = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 独占锁的持有者线程置为空</span></span><br><span class="line">        setExclusiveOwnerThread(<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 持有锁的线程修改state值不需要使用CAS操作</span></span><br><span class="line">    setState(c);</span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于完全释放锁后唤醒同步队列中等待的第一个节点，<code>unparkSuccessor</code>给出了操作逻辑：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">unparkSuccessor</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">    <span class="comment">// 把虚节点的状态重置为0，让其退出唤醒后继节点的工作，这个操作成不成功都无所谓</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> node.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line">	   <span class="comment">// 虚节点的后继节点，也就是我们需要唤醒的节点</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">s</span> <span class="operator">=</span> node.next;</span><br><span class="line">    <span class="comment">// 从前往后找非取消节点存在可能无法完整遍历同步队列的问题，因为addWaiter方法中新节点入队的CAS操作与设置上一次尾节点的next引用不是原子性的，可能同步队列还没有来得及建立最后面节点之间的next指向，因此只能使用从后往前的遍历方式！</span></span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        s = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail; t != <span class="literal">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 唤醒后继节点</span></span><br><span class="line">    <span class="keyword">if</span> (s != <span class="literal">null</span>)</span><br><span class="line">        LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="六、ReentrantLock类的其他方法"><a href="#六、ReentrantLock类的其他方法" class="headerlink" title="六、ReentrantLock类的其他方法"></a>六、ReentrantLock类的其他方法</h2><h3 id="1-lockInterruptibly"><a href="#1-lockInterruptibly" class="headerlink" title="1.lockInterruptibly"></a>1.lockInterruptibly</h3><p>该方法不同于lock方法不响应等待阻塞过程中的中断，而是一旦等待过程中发现线程中断就抛出中断异常InterruptedException，用的时机很少。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    sync.acquireInterruptibly(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/../../../../../../imgs/从ReentrantLock类看AQS的原理及实践(上篇)/image-20231118204104012.png" alt="image-20231118204104012" style="zoom:67%;" />

<h3 id="2-tryLock"><a href="#2-tryLock" class="headerlink" title="2.tryLock"></a>2.tryLock</h3><p>该方法不同于lock方法会一直阻塞等待获取锁，而是去尝试获取锁，如果拿不到锁也无所谓返回false即可，后续业务逻辑会自行决定如何处理，这也是为了避免我们的业务系统因为迟迟获取不到锁而发生严重阻塞，导致大量请求的堆积甚至系统发生崩溃。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> sync.nonfairTryAcquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-tryLock超时版本"><a href="#3-tryLock超时版本" class="headerlink" title="3.tryLock超时版本"></a>3.tryLock超时版本</h3><p>该方法相对于tryLock原方式增加了超时等待限制，如果获取不到锁会先等待一定时间，如果超时后还拿不到锁就返回false，增加了tryLock调用的灵活性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(<span class="type">long</span> timeout, TimeUnit unit)</span></span><br><span class="line">    <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">return</span> sync.tryAcquireNanos(<span class="number">1</span>, unit.toNanos(timeout));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquireNanos</span><span class="params">(<span class="type">int</span> arg, <span class="type">long</span> nanosTimeout)</span></span><br><span class="line">    <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="comment">// 进入方法时检查当前线程是否被中断，如果是的话抛出InterruptedException</span></span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">    <span class="comment">// 尝试获取锁，如果没有获取到就调用超时版本的doAcquireNanos方法</span></span><br><span class="line">    <span class="keyword">return</span> tryAcquire(arg) ||</span><br><span class="line">        doAcquireNanos(arg, nanosTimeout);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">doAcquireNanos</span><span class="params">(<span class="type">int</span> arg, <span class="type">long</span> nanosTimeout)</span></span><br><span class="line">    <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="comment">// 等待时间小于等于零，直接返回false表示没有拿到锁</span></span><br><span class="line">    <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0L</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 计算超时时刻</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">long</span> <span class="variable">deadline</span> <span class="operator">=</span> System.nanoTime() + nanosTimeout;</span><br><span class="line">    <span class="comment">// 下面的代码逻辑与前面的tryLock方法中的一样</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> addWaiter(Node.EXCLUSIVE);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="literal">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 计算剩余等待时间</span></span><br><span class="line">            nanosTimeout = deadline - System.nanoTime();</span><br><span class="line">            <span class="comment">// 超时时刻已到，返回false表示没有拿到锁</span></span><br><span class="line">            <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0L</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">// 调用LockSupport的超时阻塞方法，注意如果剩余阻塞等待时间还不到spinForTimeoutThreshold，那么选择自旋可能程序效率更高，因为线程状态切换也需要一定开销(操作系统调度线程从用户态到内核态需要一定时钟周期)</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                nanosTimeout &gt; spinForTimeoutThreshold)</span><br><span class="line">                LockSupport.parkNanos(<span class="built_in">this</span>, nanosTimeout);</span><br><span class="line">            <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="七、自定义同步工具"><a href="#七、自定义同步工具" class="headerlink" title="七、自定义同步工具"></a>七、自定义同步工具</h2><p>了解AQS基本原理以后，按照上面所说的AQS知识点，自己实现一个同步工具。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LeeLock</span>  &#123;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 不可重入的非阻塞独占锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Sync</span> <span class="keyword">extends</span> <span class="title class_">AbstractQueuedSynchronizer</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span> <span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> compareAndSetState(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span> <span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">            setState(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">isHeldExclusively</span> <span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> getState() == <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="type">Sync</span> <span class="variable">sync</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Sync</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span> <span class="params">()</span> &#123;</span><br><span class="line">        sync.acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span> <span class="params">()</span> &#123;</span><br><span class="line">        sync.release(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LeeMain</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">LeeLock</span> <span class="variable">leeLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LeeLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span> <span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">runnable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span> <span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    leeLock.lock();</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">                        count++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    leeLock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(runnable);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(runnable);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        thread1.join();</span><br><span class="line">        thread2.join();</span><br><span class="line">        System.out.println(count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码每次运行结果都会是20000。通过简单的几行代码就能实现同步功能，这就是AQS的强大之处。</p>

  </div>
</article>

    <div class="blog-post-comments">
        <div id="disqus_thread">
            <noscript>Please enable JavaScript to view the comments.</noscript>
        </div>
    </div>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
        
          <li><a href="/">Home</a></li>
        
          <li><a href="/about/">About</a></li>
        
          <li><a href="/archives/">Writing</a></li>
        
          <li><a href="/tags/">Tag</a></li>
        
          <li><a target="_blank" rel="noopener" href="http://github.com/hulingF">Projects</a></li>
        
      </ul>
    </div>

    
    
      <div id="toc-footer" style="display: none">
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%8EReentrantLock%E7%B1%BB%E7%9C%8BAQS%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E8%B7%B5-%E4%B8%8A%E7%AF%87"><span class="toc-number">1.</span> <span class="toc-text">从ReentrantLock类看AQS的原理及实践(上篇)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E5%AD%A6%E4%B9%A0AQS%E7%9A%84%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86"><span class="toc-number">1.1.</span> <span class="toc-text">一、学习AQS的前置知识</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-LockSupport%E5%B7%A5%E5%85%B7%E7%B1%BB"><span class="toc-number">1.1.1.</span> <span class="toc-text">1.LockSupport工具类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Java%E4%B8%AD%E6%96%AD%E6%9C%BA%E5%88%B6"><span class="toc-number">1.1.2.</span> <span class="toc-text">2.Java中断机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%A8%A1%E6%9D%BF%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.1.3.</span> <span class="toc-text">3.模板设计模式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81ReentrantLock%E7%B1%BB%E7%9A%84%E7%AE%80%E4%BB%8B"><span class="toc-number">1.2.</span> <span class="toc-text">二、ReentrantLock类的简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81ReentrantLock%E7%B1%BB%E7%9A%84%E7%BB%93%E6%9E%84"><span class="toc-number">1.3.</span> <span class="toc-text">三、ReentrantLock类的结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-ReentrantLock%E7%B1%BB%E7%9A%84%E6%80%BB%E4%BD%93%E6%9E%B6%E6%9E%84"><span class="toc-number">1.3.1.</span> <span class="toc-text">1.ReentrantLock类的总体架构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Lock%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.3.2.</span> <span class="toc-text">2.Lock接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-Sync%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">1.3.3.</span> <span class="toc-text">3.Sync内部类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81AQS%E7%9A%84%E9%87%8D%E7%82%B9%E5%8E%9F%E7%90%86"><span class="toc-number">1.4.</span> <span class="toc-text">三、AQS的重点原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-AQS%E7%9A%84%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0"><span class="toc-number">1.4.1.</span> <span class="toc-text">1.AQS的原理概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-AQS%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">1.4.2.</span> <span class="toc-text">2.AQS的数据结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-AQS%E9%87%8D%E8%A6%81%E6%96%B9%E6%B3%95%E4%B8%8EReentrantLock%E7%9A%84%E5%85%B3%E8%81%94"><span class="toc-number">1.4.3.</span> <span class="toc-text">3.AQS重要方法与ReentrantLock的关联</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-AQS%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">1.4.4.</span> <span class="toc-text">4.AQS的应用场景</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81ReentrantLock%E7%B1%BB%E7%9A%84%E5%8A%A0%E9%94%81%E6%B5%81%E7%A8%8B"><span class="toc-number">1.5.</span> <span class="toc-text">四、ReentrantLock类的加锁流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81ReentrantLock%E7%B1%BB%E7%9A%84%E8%A7%A3%E9%94%81%E6%B5%81%E7%A8%8B"><span class="toc-number">1.6.</span> <span class="toc-text">五、ReentrantLock类的解锁流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81ReentrantLock%E7%B1%BB%E7%9A%84%E5%85%B6%E4%BB%96%E6%96%B9%E6%B3%95"><span class="toc-number">1.7.</span> <span class="toc-text">六、ReentrantLock类的其他方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-lockInterruptibly"><span class="toc-number">1.7.1.</span> <span class="toc-text">1.lockInterruptibly</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-tryLock"><span class="toc-number">1.7.2.</span> <span class="toc-text">2.tryLock</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-tryLock%E8%B6%85%E6%97%B6%E7%89%88%E6%9C%AC"><span class="toc-number">1.7.3.</span> <span class="toc-text">3.tryLock超时版本</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E8%87%AA%E5%AE%9A%E4%B9%89%E5%90%8C%E6%AD%A5%E5%B7%A5%E5%85%B7"><span class="toc-number">1.8.</span> <span class="toc-text">七、自定义同步工具</span></a></li></ol></li></ol>
      </div>
    

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://hulingf.github.io/2023/11/17/%E4%BB%8EReentrantLock%E7%B1%BB%E7%9C%8BAQS%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E8%B7%B5(%E4%B8%8A%E7%AF%87)/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://hulingf.github.io/2023/11/17/%E4%BB%8EReentrantLock%E7%B1%BB%E7%9C%8BAQS%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E8%B7%B5(%E4%B8%8A%E7%AF%87)/&text=从ReentrantLock类看AQS的原理及实践(上篇)"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://hulingf.github.io/2023/11/17/%E4%BB%8EReentrantLock%E7%B1%BB%E7%9C%8BAQS%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E8%B7%B5(%E4%B8%8A%E7%AF%87)/&title=从ReentrantLock类看AQS的原理及实践(上篇)"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://hulingf.github.io/2023/11/17/%E4%BB%8EReentrantLock%E7%B1%BB%E7%9C%8BAQS%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E8%B7%B5(%E4%B8%8A%E7%AF%87)/&is_video=false&description=从ReentrantLock类看AQS的原理及实践(上篇)"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=从ReentrantLock类看AQS的原理及实践(上篇)&body=Check out this article: https://hulingf.github.io/2023/11/17/%E4%BB%8EReentrantLock%E7%B1%BB%E7%9C%8BAQS%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E8%B7%B5(%E4%B8%8A%E7%AF%87)/"><i class="fa-solid fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://hulingf.github.io/2023/11/17/%E4%BB%8EReentrantLock%E7%B1%BB%E7%9C%8BAQS%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E8%B7%B5(%E4%B8%8A%E7%AF%87)/&title=从ReentrantLock类看AQS的原理及实践(上篇)"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://hulingf.github.io/2023/11/17/%E4%BB%8EReentrantLock%E7%B1%BB%E7%9C%8BAQS%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E8%B7%B5(%E4%B8%8A%E7%AF%87)/&title=从ReentrantLock类看AQS的原理及实践(上篇)"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://hulingf.github.io/2023/11/17/%E4%BB%8EReentrantLock%E7%B1%BB%E7%9C%8BAQS%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E8%B7%B5(%E4%B8%8A%E7%AF%87)/&title=从ReentrantLock类看AQS的原理及实践(上篇)"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://hulingf.github.io/2023/11/17/%E4%BB%8EReentrantLock%E7%B1%BB%E7%9C%8BAQS%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E8%B7%B5(%E4%B8%8A%E7%AF%87)/&title=从ReentrantLock类看AQS的原理及实践(上篇)"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://hulingf.github.io/2023/11/17/%E4%BB%8EReentrantLock%E7%B1%BB%E7%9C%8BAQS%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E8%B7%B5(%E4%B8%8A%E7%AF%87)/&name=从ReentrantLock类看AQS的原理及实践(上篇)&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://hulingf.github.io/2023/11/17/%E4%BB%8EReentrantLock%E7%B1%BB%E7%9C%8BAQS%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E8%B7%B5(%E4%B8%8A%E7%AF%87)/&t=从ReentrantLock类看AQS的原理及实践(上篇)"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fa-solid fa-bars fa-lg" aria-hidden="true"></i> Menu</a>
        
          <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fa-solid fa-list fa-lg" aria-hidden="true"></i> TOC</a>
        
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fa-solid fa-share-alt fa-lg" aria-hidden="true"></i> Share</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2023
    hulingF
  </div>
  <div class="footer-right">
    <nav>
      <ul>
        <!--
       --><li><a href="/">Home</a></li><!--
     --><!--
       --><li><a href="/about/">About</a></li><!--
     --><!--
       --><li><a href="/archives/">Writing</a></li><!--
     --><!--
       --><li><a href="/tags/">Tag</a></li><!--
     --><!--
       --><li><a target="_blank" rel="noopener" href="http://github.com/hulingF">Projects</a></li><!--
     -->
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->



  <link rel="preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" crossorigin="anonymous" onload="this.onload=null;this.rel='stylesheet'"/>


    <!-- jquery -->

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" crossorigin="anonymous"></script>




<!-- clipboard -->

  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.7/clipboard.min.js" crossorigin="anonymous"></script>
  
  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"Copy to clipboard!\">";
    btn += '<i class="fa-regular fa-clone"></i>';
    btn += '</span>';
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "Copied!");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Disqus Comments -->

    <script type="text/javascript">
        var disqus_shortname = 'hulingF';

        (function(){
            var dsq = document.createElement('script');
            dsq.type = 'text/javascript';
            dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        }());
    </script>

<!-- utterances Comments -->

</body>
</html>
