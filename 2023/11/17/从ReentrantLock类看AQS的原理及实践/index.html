<!DOCTYPE html>
<html lang=en>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5" />
    <meta name="description" content="从ReentrantLock类看AQS的原理及实践一、学习AQS的前置知识大名鼎鼎的AQS抽象队列同步器是JUC并发包下许多同步组件的基础框架，它的设计可以说考虑了方方面面的需求显得尤为复杂，从ReentrantLock的lock方法来看AQS，线程因为无法获取锁进入同步队列阻塞等待所使用的就是LockSupport的part方法，这也是我们要说的第一个前置知识。 1.LockSupport工具类">
<meta property="og:type" content="article">
<meta property="og:title" content="从ReentrantLock类看AQS的原理及实践">
<meta property="og:url" content="https://hulingf.github.io/2023/11/17/%E4%BB%8EReentrantLock%E7%B1%BB%E7%9C%8BAQS%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E8%B7%B5/index.html">
<meta property="og:site_name" content="大军的秘密花园">
<meta property="og:description" content="从ReentrantLock类看AQS的原理及实践一、学习AQS的前置知识大名鼎鼎的AQS抽象队列同步器是JUC并发包下许多同步组件的基础框架，它的设计可以说考虑了方方面面的需求显得尤为复杂，从ReentrantLock的lock方法来看AQS，线程因为无法获取锁进入同步队列阻塞等待所使用的就是LockSupport的part方法，这也是我们要说的第一个前置知识。 1.LockSupport工具类">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://hulingf.github.io/imgs/%E4%BB%8EReentrantLock%E7%B1%BB%E7%9C%8BAQS%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E8%B7%B5(%E4%B8%8A%E7%AF%87)/image-20240905220638103.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/%E4%BB%8EReentrantLock%E7%B1%BB%E7%9C%8BAQS%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E8%B7%B5(%E4%B8%8A%E7%AF%87)/fc14a34cdcf9ec2dfdc58a17d7d131a54504e4fd.png@670w_!web-note.webp">
<meta property="og:image" content="https://hulingf.github.io/imgs/%E4%BB%8EReentrantLock%E7%B1%BB%E7%9C%8BAQS%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E8%B7%B5(%E4%B8%8A%E7%AF%87)/a41d79c1d94ae81f7b5a011be9b0f7bf41bd5ecc.png@670w_!web-note.webp">
<meta property="og:image" content="https://hulingf.github.io/imgs/%E4%BB%8EReentrantLock%E7%B1%BB%E7%9C%8BAQS%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E8%B7%B5(%E4%B8%8A%E7%AF%87)/7f9d49c534c5e9a8a56a2efe469c465eeb13d94c.png@670w_!web-note.webp">
<meta property="og:image" content="https://hulingf.github.io/imgs/%E4%BB%8EReentrantLock%E7%B1%BB%E7%9C%8BAQS%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E8%B7%B5(%E4%B8%8A%E7%AF%87)/image-20240905221052742.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/%E4%BB%8EReentrantLock%E7%B1%BB%E7%9C%8BAQS%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E8%B7%B5(%E4%B8%8A%E7%AF%87)/image-20231118213227293.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/%E4%BB%8EReentrantLock%E7%B1%BB%E7%9C%8BAQS%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E8%B7%B5(%E4%B8%8A%E7%AF%87)/412d294ff5535bbcddc0d979b2a339e6102264.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/%E4%BB%8EReentrantLock%E7%B1%BB%E7%9C%8BAQS%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E8%B7%B5(%E4%B8%8A%E7%AF%87)/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI1MTc4MzUz,size_16,color_FFFFFF,t_70.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/%E4%BB%8EReentrantLock%E7%B1%BB%E7%9C%8BAQS%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E8%B7%B5(%E4%B8%8A%E7%AF%87)/image-20231117111109191.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/%E4%BB%8EReentrantLock%E7%B1%BB%E7%9C%8BAQS%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E8%B7%B5(%E4%B8%8A%E7%AF%87)/image-20231117120915463.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/%E4%BB%8EReentrantLock%E7%B1%BB%E7%9C%8BAQS%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E8%B7%B5(%E4%B8%8A%E7%AF%87)/image-20231117122652255.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/%E4%BB%8EReentrantLock%E7%B1%BB%E7%9C%8BAQS%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E8%B7%B5(%E4%B8%8A%E7%AF%87)/image-20231117155101378.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/%E4%BB%8EReentrantLock%E7%B1%BB%E7%9C%8BAQS%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E8%B7%B5(%E4%B8%8A%E7%AF%87)/image-20240829162839826.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/%E4%BB%8EReentrantLock%E7%B1%BB%E7%9C%8BAQS%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E8%B7%B5(%E4%B8%8A%E7%AF%87)/82077ccf14127a87b77cefd1ccf562d3253591.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/%E4%BB%8EReentrantLock%E7%B1%BB%E7%9C%8BAQS%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E8%B7%B5(%E4%B8%8A%E7%AF%87)/d2f7f7fffdc30d85d17b44266c3ab05323338.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/%E4%BB%8EReentrantLock%E7%B1%BB%E7%9C%8BAQS%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E8%B7%B5(%E4%B8%8A%E7%AF%87)/7132e4cef44c26f62835b197b239147b18062.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/%E4%BB%8EReentrantLock%E7%B1%BB%E7%9C%8BAQS%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E8%B7%B5(%E4%B8%8A%E7%AF%87)/960271cf2b5c8a185eed23e98b72c75538637.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/%E4%BB%8EReentrantLock%E7%B1%BB%E7%9C%8BAQS%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E8%B7%B5(%E4%B8%8A%E7%AF%87)/image-20231117161623954.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/%E4%BB%8EReentrantLock%E7%B1%BB%E7%9C%8BAQS%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E8%B7%B5(%E4%B8%8A%E7%AF%87)/27605d483e8935da683a93be015713f331378.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/%E4%BB%8EReentrantLock%E7%B1%BB%E7%9C%8BAQS%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E8%B7%B5(%E4%B8%8A%E7%AF%87)/3f1e1a44f5b7d77000ba4f9476189b2e32806.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/%E4%BB%8EReentrantLock%E7%B1%BB%E7%9C%8BAQS%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E8%B7%B5(%E4%B8%8A%E7%AF%87)/image-20231117170552419.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/%E4%BB%8EReentrantLock%E7%B1%BB%E7%9C%8BAQS%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E8%B7%B5(%E4%B8%8A%E7%AF%87)/image-20231118204104012.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/%E4%BB%8EReentrantLock%E7%B1%BB%E7%9C%8BAQS%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E8%B7%B5(%E4%B8%8A%E7%AF%87)/image-20240905222014198.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/%E4%BB%8EReentrantLock%E7%B1%BB%E7%9C%8BAQS%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E8%B7%B5(%E4%B8%8A%E7%AF%87)/image-20240905222334246.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/%E4%BB%8EReentrantLock%E7%B1%BB%E7%9C%8BAQS%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E8%B7%B5(%E4%B8%8A%E7%AF%87)/image-20240905223051037.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/%E4%BB%8EReentrantLock%E7%B1%BB%E7%9C%8BAQS%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E8%B7%B5(%E4%B8%8A%E7%AF%87)/image-20240905223202540.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/%E4%BB%8EReentrantLock%E7%B1%BB%E7%9C%8BAQS%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E8%B7%B5(%E4%B8%8A%E7%AF%87)/image-20240905223344262.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/%E4%BB%8EReentrantLock%E7%B1%BB%E7%9C%8BAQS%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E8%B7%B5(%E4%B8%8A%E7%AF%87)/image-20240905223731507.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/%E4%BB%8EReentrantLock%E7%B1%BB%E7%9C%8BAQS%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E8%B7%B5(%E4%B8%8A%E7%AF%87)/image-20240905223946829.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/%E4%BB%8EReentrantLock%E7%B1%BB%E7%9C%8BAQS%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E8%B7%B5(%E4%B8%8A%E7%AF%87)/image-20240905224053472.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/%E4%BB%8EReentrantLock%E7%B1%BB%E7%9C%8BAQS%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E8%B7%B5(%E4%B8%8A%E7%AF%87)/image-20240905224158458.png">
<meta property="article:published_time" content="2023-11-17T02:03:48.559Z">
<meta property="article:modified_time" content="2024-09-05T14:48:05.590Z">
<meta property="article:author" content="hulingF">
<meta property="article:tag" content="并发编程">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://hulingf.github.io/imgs/%E4%BB%8EReentrantLock%E7%B1%BB%E7%9C%8BAQS%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E8%B7%B5(%E4%B8%8A%E7%AF%87)/image-20240905220638103.png">
    
    
      
        
          <link rel="shortcut icon" href="/images/favicon.ico">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
        
      
    
    <!-- title -->
    <title>从ReentrantLock类看AQS的原理及实践</title>
    <!-- async scripts -->
    <!-- Google Analytics -->


    <!-- Umami Analytics -->


    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
    <!-- rss -->
    
    
	<!-- mathjax -->
	
<meta name="generator" content="Hexo 6.3.0"></head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#" aria-label="Menu"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#" aria-label="Menu"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" aria-label="Top" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa-solid fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
        <!--
       --><li><a href="/">Home</a></li><!--
     --><!--
       --><li><a href="/about/">About</a></li><!--
     --><!--
       --><li><a href="/archives/">Writing</a></li><!--
     --><!--
       --><li><a href="/tags/">Tag</a></li><!--
     --><!--
       --><li><a target="_blank" rel="noopener" href="http://github.com/hulingF">Projects</a></li><!--
     -->
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" aria-label="Previous post" href="/2023/11/18/CountDownLatch%E7%B1%BB%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"><i class="fa-solid fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" aria-label="Next post" href="/2023/11/15/LongAdder%E7%B1%BB%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"><i class="fa-solid fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" aria-label="Back to top" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" aria-label="Share post" href="#"><i class="fa-solid fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://hulingf.github.io/2023/11/17/%E4%BB%8EReentrantLock%E7%B1%BB%E7%9C%8BAQS%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E8%B7%B5/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://hulingf.github.io/2023/11/17/%E4%BB%8EReentrantLock%E7%B1%BB%E7%9C%8BAQS%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E8%B7%B5/&text=从ReentrantLock类看AQS的原理及实践"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://hulingf.github.io/2023/11/17/%E4%BB%8EReentrantLock%E7%B1%BB%E7%9C%8BAQS%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E8%B7%B5/&title=从ReentrantLock类看AQS的原理及实践"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://hulingf.github.io/2023/11/17/%E4%BB%8EReentrantLock%E7%B1%BB%E7%9C%8BAQS%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E8%B7%B5/&is_video=false&description=从ReentrantLock类看AQS的原理及实践"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=从ReentrantLock类看AQS的原理及实践&body=Check out this article: https://hulingf.github.io/2023/11/17/%E4%BB%8EReentrantLock%E7%B1%BB%E7%9C%8BAQS%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E8%B7%B5/"><i class="fa-solid fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://hulingf.github.io/2023/11/17/%E4%BB%8EReentrantLock%E7%B1%BB%E7%9C%8BAQS%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E8%B7%B5/&title=从ReentrantLock类看AQS的原理及实践"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://hulingf.github.io/2023/11/17/%E4%BB%8EReentrantLock%E7%B1%BB%E7%9C%8BAQS%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E8%B7%B5/&title=从ReentrantLock类看AQS的原理及实践"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://hulingf.github.io/2023/11/17/%E4%BB%8EReentrantLock%E7%B1%BB%E7%9C%8BAQS%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E8%B7%B5/&title=从ReentrantLock类看AQS的原理及实践"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://hulingf.github.io/2023/11/17/%E4%BB%8EReentrantLock%E7%B1%BB%E7%9C%8BAQS%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E8%B7%B5/&title=从ReentrantLock类看AQS的原理及实践"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://hulingf.github.io/2023/11/17/%E4%BB%8EReentrantLock%E7%B1%BB%E7%9C%8BAQS%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E8%B7%B5/&name=从ReentrantLock类看AQS的原理及实践&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://hulingf.github.io/2023/11/17/%E4%BB%8EReentrantLock%E7%B1%BB%E7%9C%8BAQS%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E8%B7%B5/&t=从ReentrantLock类看AQS的原理及实践"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    
    
      <div id="toc">
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%8EReentrantLock%E7%B1%BB%E7%9C%8BAQS%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E8%B7%B5"><span class="toc-number">1.</span> <span class="toc-text">从ReentrantLock类看AQS的原理及实践</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E5%AD%A6%E4%B9%A0AQS%E7%9A%84%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86"><span class="toc-number">1.1.</span> <span class="toc-text">一、学习AQS的前置知识</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-LockSupport%E5%B7%A5%E5%85%B7%E7%B1%BB"><span class="toc-number">1.1.1.</span> <span class="toc-text">1.LockSupport工具类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Java%E4%B8%AD%E6%96%AD%E6%9C%BA%E5%88%B6"><span class="toc-number">1.1.2.</span> <span class="toc-text">2.Java中断机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%A8%A1%E6%9D%BF%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.1.3.</span> <span class="toc-text">3.模板设计模式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81ReentrantLock%E7%B1%BB%E7%9A%84%E7%AE%80%E4%BB%8B"><span class="toc-number">1.2.</span> <span class="toc-text">二、ReentrantLock类的简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81ReentrantLock%E7%B1%BB%E7%9A%84%E7%BB%93%E6%9E%84"><span class="toc-number">1.3.</span> <span class="toc-text">三、ReentrantLock类的结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-ReentrantLock%E7%B1%BB%E7%9A%84%E6%80%BB%E4%BD%93%E6%9E%B6%E6%9E%84"><span class="toc-number">1.3.1.</span> <span class="toc-text">1.ReentrantLock类的总体架构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Lock%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.3.2.</span> <span class="toc-text">2.Lock接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-Sync%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">1.3.3.</span> <span class="toc-text">3.Sync内部类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81AQS%E7%9A%84%E9%87%8D%E7%82%B9%E5%8E%9F%E7%90%86"><span class="toc-number">1.4.</span> <span class="toc-text">三、AQS的重点原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-AQS%E7%9A%84%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0"><span class="toc-number">1.4.1.</span> <span class="toc-text">1.AQS的原理概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-AQS%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">1.4.2.</span> <span class="toc-text">2.AQS的数据结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-AQS%E9%87%8D%E8%A6%81%E6%96%B9%E6%B3%95%E4%B8%8EReentrantLock%E7%9A%84%E5%85%B3%E8%81%94"><span class="toc-number">1.4.3.</span> <span class="toc-text">3.AQS重要方法与ReentrantLock的关联</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-AQS%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">1.4.4.</span> <span class="toc-text">4.AQS的应用场景</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81ReentrantLock%E7%B1%BB%E7%9A%84%E5%8A%A0%E9%94%81%E6%B5%81%E7%A8%8B"><span class="toc-number">1.5.</span> <span class="toc-text">四、ReentrantLock类的加锁流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81ReentrantLock%E7%B1%BB%E7%9A%84%E8%A7%A3%E9%94%81%E6%B5%81%E7%A8%8B"><span class="toc-number">1.6.</span> <span class="toc-text">五、ReentrantLock类的解锁流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81ReentrantLock%E7%B1%BB%E7%9A%84%E5%85%B6%E4%BB%96%E6%96%B9%E6%B3%95"><span class="toc-number">1.7.</span> <span class="toc-text">六、ReentrantLock类的其他方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-lockInterruptibly"><span class="toc-number">1.7.1.</span> <span class="toc-text">1.lockInterruptibly</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-tryLock%E5%B0%9D%E8%AF%95%E5%8A%A0%E9%94%81"><span class="toc-number">1.7.2.</span> <span class="toc-text">2.tryLock尝试加锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-tryLock%E8%B6%85%E6%97%B6%E5%8A%A0%E9%94%81"><span class="toc-number">1.7.3.</span> <span class="toc-text">3.tryLock超时加锁</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E8%87%AA%E5%AE%9A%E4%B9%89%E5%90%8C%E6%AD%A5%E5%B7%A5%E5%85%B7-%E7%8B%AC%E5%8D%A0%E9%94%81"><span class="toc-number">1.8.</span> <span class="toc-text">七、自定义同步工具-独占锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AB%E3%80%81%E8%87%AA%E5%AE%9A%E4%B9%89%E5%90%8C%E6%AD%A5%E5%B7%A5%E5%85%B7-%E5%85%B1%E4%BA%AB%E9%94%81"><span class="toc-number">1.9.</span> <span class="toc-text">八、自定义同步工具-共享锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B9%9D%E3%80%81Condition%E6%8E%A5%E5%8F%A3%E8%AF%A6%E8%A7%A3"><span class="toc-number">1.10.</span> <span class="toc-text">九、Condition接口详解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Condition%E6%8E%A5%E5%8F%A3%E4%B8%8E%E7%A4%BA%E4%BE%8B"><span class="toc-number">1.10.1.</span> <span class="toc-text">1.Condition接口与示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Condition%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%88%86%E6%9E%90"><span class="toc-number">1.10.2.</span> <span class="toc-text">2.Condition的实现分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1%E7%AD%89%E5%BE%85%E9%98%9F%E5%88%97"><span class="toc-number">1.10.2.1.</span> <span class="toc-text">2.1等待队列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2%E7%AD%89%E5%BE%85"><span class="toc-number">1.10.2.2.</span> <span class="toc-text">2.2等待</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3%E9%80%9A%E7%9F%A5"><span class="toc-number">1.10.2.3.</span> <span class="toc-text">2.3通知</span></a></li></ol></li></ol></li></ol></li></ol>
      </div>
    
  </span>
</div>

    
    <div class="content index py4 ">
        
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle p-name" itemprop="name headline">
        从ReentrantLock类看AQS的原理及实践
    </h1>



    <div class="meta">
      <span class="author p-author h-card" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span class="p-name" itemprop="name">hulingF</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2023-11-17T02:03:48.559Z" class="dt-published" itemprop="datePublished">2023-11-17</time>
        
      
    </div>


      

      
    <div class="article-tag">
        <i class="fa-solid fa-tag"></i>
        <a class="p-category" href="/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" rel="tag">并发编程</a>
    </div>


    </div>
  </header>
  

  <div class="content e-content" itemprop="articleBody">
    <h1 id="从ReentrantLock类看AQS的原理及实践"><a href="#从ReentrantLock类看AQS的原理及实践" class="headerlink" title="从ReentrantLock类看AQS的原理及实践"></a>从ReentrantLock类看AQS的原理及实践</h1><h2 id="一、学习AQS的前置知识"><a href="#一、学习AQS的前置知识" class="headerlink" title="一、学习AQS的前置知识"></a>一、学习AQS的前置知识</h2><p>大名鼎鼎的<code>AQS抽象队列同步器</code>是JUC并发包下许多同步组件的基础框架，它的设计可以说考虑了方方面面的需求显得尤为复杂，从ReentrantLock的lock方法来看AQS，线程因为无法获取锁进入同步队列阻塞等待所使用的就是LockSupport的part方法，这也是我们要说的第一个前置知识。</p>
<h3 id="1-LockSupport工具类"><a href="#1-LockSupport工具类" class="headerlink" title="1.LockSupport工具类"></a>1.LockSupport工具类</h3><p><img src="/imgs/%E4%BB%8EReentrantLock%E7%B1%BB%E7%9C%8BAQS%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E8%B7%B5(%E4%B8%8A%E7%AF%87)/image-20240905220638103.png" alt="image-20240905220638103"></p>
<p>LockSupport是一个工具类，提供了基本的<code>线程阻塞</code>和<code>唤醒</code>功能（相较于wait、notify、notifyAll可以做到<code>精准唤醒</code>指定的线程），它是创建锁和其他同步组件的基础工具，内部是使用<code>sun.misc.Unsafe</code>类实现的。LockSupport和使用它的线程都会关联一个许可permmit，park方法表示消耗一个许可，调用park方法时，如果许可可用则park方法返回，如果没有许可则一直阻塞直到许可可用。unpark方法表示增加一个许可，<code>多次调用并不会积累许可</code>，因为许可数最大值为1。当然这里所讲的permit在LockSupport的代码当中没有体现，需要到HotSpot的源码当中查看，以下为截图供查看：</p>
<p>1、&#x2F;share&#x2F;vm&#x2F;runtime&#x2F;park.hpp中许可的定义字段_counter</p>
<p><img src="/imgs/%E4%BB%8EReentrantLock%E7%B1%BB%E7%9C%8BAQS%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E8%B7%B5(%E4%B8%8A%E7%AF%87)/fc14a34cdcf9ec2dfdc58a17d7d131a54504e4fd.png@670w_!web-note.webp" alt="img"></p>
<p>2、park()的实现(部分截图)【os&#x2F;bsd&#x2F;vm&#x2F;os_bsd.cpp】</p>
<p><img src="/imgs/%E4%BB%8EReentrantLock%E7%B1%BB%E7%9C%8BAQS%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E8%B7%B5(%E4%B8%8A%E7%AF%87)/a41d79c1d94ae81f7b5a011be9b0f7bf41bd5ecc.png@670w_!web-note.webp" alt="img"></p>
<p>3、unpark()实现(部分截图)【os&#x2F;bsd&#x2F;vm&#x2F;os_bsd.cpp】</p>
<p><img src="/imgs/%E4%BB%8EReentrantLock%E7%B1%BB%E7%9C%8BAQS%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E8%B7%B5(%E4%B8%8A%E7%AF%87)/7f9d49c534c5e9a8a56a2efe469c465eeb13d94c.png@670w_!web-note.webp" alt="img"></p>
<p>在Java 6中，LockSupport增加了park(Object blocker)、parkNanos(Object blocker,long nanos)和parkUntil(Object blocker,long deadline)3个方法，用于实现阻塞当前线程的功能，其中<code>参数blocker是用来标识当前线程在等待的对象</code>（以下称为阻塞对象），该对象<code>主要用于问题排查和系统监控</code>。</p>
<p>从表的线程dump结果可以看出，代码片段的内容都是阻塞当前线程10秒，但从线程dump结果可以看出，有阻塞对象的parkNanos方法能够传递给开发人员更多的现场信息。这是由于在Java 5之前，当线程阻塞（使用synchronized关键字）在一个对象上时，<code>通过线程dump能够查看到该线程的阻塞对象，方便问题定位</code>，而Java 5推出的Lock等并发工具时却遗漏了这一点，致使在线程dump时无法提供阻塞对象的信息。因此，在Java 6中，LockSupport新增了上述3个含有阻塞对象的park方法，用以替代原有的park方法。</p>
<p><img src="/imgs/%E4%BB%8EReentrantLock%E7%B1%BB%E7%9C%8BAQS%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E8%B7%B5(%E4%B8%8A%E7%AF%87)/image-20240905221052742.png" alt="image-20240905221052742"></p>
<h3 id="2-Java中断机制"><a href="#2-Java中断机制" class="headerlink" title="2.Java中断机制"></a>2.Java中断机制</h3><p><img src="/imgs/%E4%BB%8EReentrantLock%E7%B1%BB%E7%9C%8BAQS%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E8%B7%B5(%E4%B8%8A%E7%AF%87)/image-20231118213227293.png" alt="image-20231118213227293"></p>
<p>注意：线程调用LockSupport的part方法会进入WAITING状态，如果此时对该线程调用interrupt方法，线程会立即苏醒恢复。</p>
<h3 id="3-模板设计模式"><a href="#3-模板设计模式" class="headerlink" title="3.模板设计模式"></a>3.模板设计模式</h3><h2 id="二、ReentrantLock类的简介"><a href="#二、ReentrantLock类的简介" class="headerlink" title="二、ReentrantLock类的简介"></a>二、ReentrantLock类的简介</h2><p>ReentrantLock类是<code>可重入互斥锁</code>，与使用同步方法和语句访问的<code>隐式监视器锁</code>具有相同的基本行为和语义，但具有扩展功能。ReentrantLock由最后一次成功锁定但尚未解锁的线程拥有，当锁不被另一个线程拥有时，调用加锁的线程将返回并成功获取锁。如果当前线程已经拥有锁，该lock方法将立即返回，这可以使用<code>isHeldByCurrentThread</code>和<code>getHoldCount</code>方法进行检查。<br>此类的构造函数接受可选的公平参数，当设置为true时，在争用情况下，锁倾向于授予<code>等待时间最长</code>的线程访问权限（即同步队列的队头虚节点的下一个节点），否则该锁不保证任何特定的访问顺序。使用由许多线程访问的公平锁的程序可能会显示比使用默认设置的程序更低的总体吞吐量（即更慢，<code>通常慢得多</code>），但在获取锁的时间上具有较小的差异并<code>保证不会出现饥饿</code>。</p>
<blockquote>
<p>关于公平与非公平的额外说明：</p>
<p>在AQS持有锁的线程释放锁以后，可能来竞争锁的线程有两种类型，<strong>一种就是在同步队列中线程</strong>，准确的说就是队列中第一个等待的线程，因为只有它才有争抢锁的资格(FIFO规则)。<strong>另外一种想要争抢锁的线程就是队列外的线程</strong>,也就是没有排队的线程。如果释放的锁可以被这些没有排队的线程优先抢到的话，那对于排队的线程来说就是<strong>非公平的，</strong>如果我们优先队列中的线程获取到锁的话，那对于他们就是<strong>公平的。说到底就是允不允许争抢锁的时候插队，当然这里的插队，是指插在队头！允许插队就是不公平的，不允许就是公平的。</strong></p>
</blockquote>
<p>为了帮助大家更好地理解ReentrantLock的特性，我们先将ReentrantLock跟常用的Synchronized进行比较，其特性如下（蓝色部分为本篇文章主要剖析的点）：</p>
<p><img src="/imgs/%E4%BB%8EReentrantLock%E7%B1%BB%E7%9C%8BAQS%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E8%B7%B5(%E4%B8%8A%E7%AF%87)/412d294ff5535bbcddc0d979b2a339e6102264.png" alt="img"></p>
<h2 id="三、ReentrantLock类的结构"><a href="#三、ReentrantLock类的结构" class="headerlink" title="三、ReentrantLock类的结构"></a>三、ReentrantLock类的结构</h2><h3 id="1-ReentrantLock类的总体架构"><a href="#1-ReentrantLock类的总体架构" class="headerlink" title="1.ReentrantLock类的总体架构"></a>1.ReentrantLock类的总体架构</h3><p><img src="/imgs/%E4%BB%8EReentrantLock%E7%B1%BB%E7%9C%8BAQS%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E8%B7%B5(%E4%B8%8A%E7%AF%87)/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI1MTc4MzUz,size_16,color_FFFFFF,t_70.png" alt="img"></p>
<p>借鉴网上的一张ReentrantLock类的结构图，可以看出ReentrantLock首先继承了<code>Lock</code>接口并实现了其中的6个方法，其次ReentrantLock包含了一个内部类对象<code>sync</code>是AQS的实现类<code>Sync</code>，根据构造函数的公平参数<code>sync</code>可以<code>Sync</code>的两个实现子类<code>FairSync</code>或<code>NonfairSync</code>之一。</p>
<h3 id="2-Lock接口"><a href="#2-Lock接口" class="headerlink" title="2.Lock接口"></a>2.Lock接口</h3><p>我们先来看一下Lock接口的信息：</p>
<p><img src="/imgs/%E4%BB%8EReentrantLock%E7%B1%BB%E7%9C%8BAQS%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E8%B7%B5(%E4%B8%8A%E7%AF%87)/image-20231117111109191.png" alt="image-20231117111109191"></p>
<p>Lock实现提供了比使用synchronized方法和语句更广泛的锁定操作。它们允许<code>更灵活的结构</code>，可能具有完全不同的属性，并且可能支持<code>多个关联的Condition对象</code>。</p>
<p>虽然synchronized方法和语句的作用域机制使使用监视器锁进行编程变得更加容易，并且有助于避免许多涉及锁的常见编程错误，但有时您需要以更灵活的方式使用锁。例如，一些遍历并发访问数据结构的算法需要使用<code>hand-over-hand</code>或<code>chain locking</code>：获取节点A的锁，然后获取节点B的锁，然后释放A并获取C，然后释放B并获得D等。Lock接口的实现允许在不同范围内获取和释放锁，并允许以任何顺序获取和释放多个锁，从而允许使用此类技术。随着灵活性的增加，责任也随之增加。在大多数情况下，应该使用以下习惯用法：</p>
<p><img src="/imgs/%E4%BB%8EReentrantLock%E7%B1%BB%E7%9C%8BAQS%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E8%B7%B5(%E4%B8%8A%E7%AF%87)/image-20231117120915463.png" alt="image-20231117120915463"></p>
<p>当加锁和解锁发生在不同的作用域时，必须注意确保持有锁时执行的所有代码都受到<code>try-finally</code>或<code>try-catch</code>的保护，以确保在必要时释放锁。&#x3D;&#x3D;Lock实现通过提供非阻塞尝试获取锁 (tryLock())、获取可中断锁 (lockInterruptically) 以及尝试获取可以超时的锁(tryLock(long, TimeUnit))，从而提供了使用同步方法和语句的附加功能。&#x3D;&#x3D;</p>
<p>ReentrantLock作为Lock接口的实现类，实现了Lock接口定义的所有方法，并且都是委托给内部的<code>sync</code>对象实现，以lock方法为例，其余方法都是同理：</p>
<p><img src="/imgs/%E4%BB%8EReentrantLock%E7%B1%BB%E7%9C%8BAQS%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E8%B7%B5(%E4%B8%8A%E7%AF%87)/image-20231117122652255.png" alt="image-20231117122652255"></p>
<h3 id="3-Sync内部类"><a href="#3-Sync内部类" class="headerlink" title="3.Sync内部类"></a>3.Sync内部类</h3><p>本篇不会涉及到AQS的条件队列，因此为了便于理解，不相关的方法不会贴出，这里我们也只是简单的解释其中出现的方法，后面设计到ReentrantLock的加锁和解锁流程时涉及到的会展开详细解释：</p>
<blockquote>
<p>公平性锁保证了锁的获取按照FIFO原则，而代价是<code>进行大量的线程切换</code>。非公平性锁虽然可能造成线程饥饿，但极少的线程切换，保证了其<code>更大的吞吐量</code>。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Sync</span> <span class="keyword">extends</span> <span class="title class_">AbstractQueuedSynchronizer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">5179523762034025860L</span>;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 由于ReentrantLock有公平和非公平两种模式，因此lock方法需要留给FairSync和NonfairSync单独实现</span></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试获取锁的逻辑在公平锁和非公平锁模式下都是同样的，首先判断当前锁是否被持有，如果没有被持有则通过CAS加锁(加锁成功后会设置锁的独占线程)，如果锁已经被持有了则判断当前线程是否是锁持有线程，如果是同一个线程的重复加锁则进行锁可重入次数的递增</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">nonfairTryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 发现锁还是空闲状态就直接通过CAS尝试获取锁</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                setExclusiveOwnerThread(current);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">            <span class="comment">// ReentrantLock是可重入锁</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c + acquires;</span><br><span class="line">            <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">            setState(nextc);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解锁的逻辑无论公平还是非公平模式都是一致的，Sync直接定义好了，首先判断锁持有线程是否是当前线程，如果不是则抛出IllegalMonitorStateException异常，否则锁重入次数递减，如果递减为0则表明锁被完全释放了，清空锁的独占线程</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span> releases)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState() - releases;</span><br><span class="line">        <span class="comment">// 只有持有锁的线程才能释放锁</span></span><br><span class="line">        <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line">        <span class="comment">// 是否[完全]释放锁的标记</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">free</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 可重入锁被完全释放，设置锁的独占线程为空</span></span><br><span class="line">            free = <span class="literal">true</span>;</span><br><span class="line">            setExclusiveOwnerThread(<span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 更新锁的重入次数</span></span><br><span class="line">        setState(c);</span><br><span class="line">        <span class="keyword">return</span> free;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查当前线程是否是独占锁的持有者</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">isHeldExclusively</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getExclusiveOwnerThread() == Thread.currentThread();</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 获取ReentrantLock独占锁的持有者线程</span></span><br><span class="line">    <span class="keyword">final</span> Thread <span class="title function_">getOwner</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getState() == <span class="number">0</span> ? <span class="literal">null</span> : getExclusiveOwnerThread();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前线程锁重入的次数</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getHoldCount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> isHeldExclusively() ? getState() : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查锁是否已经被占用</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">isLocked</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getState() != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/imgs/%E4%BB%8EReentrantLock%E7%B1%BB%E7%9C%8BAQS%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E8%B7%B5(%E4%B8%8A%E7%AF%87)/image-20231117155101378.png" alt="image-20231117155101378"></p>
<blockquote>
<p>为什么nonfairTryAcquire方法是在Sync类中定义的而不是NonfairSync类定义的呢？其实是因为ReentrantLock类提供给开发者的tryLock方法需要使用到nonfairTryAcquire方法，无论是公平模式还是非公平模式下的ReentrantLock都是如此，因此作者选择将nonfairTryAcquire方法放入NonfairSync和FairSync的父类Sync中实现，这一点后面也会看到。</p>
</blockquote>
<p><img src="/imgs/%E4%BB%8EReentrantLock%E7%B1%BB%E7%9C%8BAQS%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E8%B7%B5(%E4%B8%8A%E7%AF%87)/image-20240829162839826.png" alt="image-20240829162839826"></p>
<p>当然，ReentrantLock所依靠的真正实现类其实还是<code>Sync</code>的两个实现类<code>FairSync</code>和<code>NonfairSync</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">NonfairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">7316153563782823691L</span>;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 非公平加锁，后续的线程可以直接插队参与竞争锁</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">            setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">FairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">3000897897090466540L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 公平加锁，符合FIFO队列的顺序加锁特点</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 加入了同步队列中当前节点是否有前驱节点的判断，如果该方法返回true，则表示有线程比当前线程更早地请求获取锁，因此需要等待前驱线程获取并释放锁之后才能继续获取锁。</span></span><br><span class="line">            <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">                compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                setExclusiveOwnerThread(current);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c + acquires;</span><br><span class="line">            <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">            setState(nextc);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="三、AQS的重点原理"><a href="#三、AQS的重点原理" class="headerlink" title="三、AQS的重点原理"></a>三、AQS的重点原理</h2><p>看了这么多，最终还是需要AQS框架的介入，首先，我们通过下面的架构图来整体了解一下AQS框架：</p>
<p><img src="/imgs/%E4%BB%8EReentrantLock%E7%B1%BB%E7%9C%8BAQS%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E8%B7%B5(%E4%B8%8A%E7%AF%87)/82077ccf14127a87b77cefd1ccf562d3253591.png" alt="img"></p>
<ul>
<li>上图中有颜色的为Method，无颜色的为Attribution。</li>
<li>总的来说，AQS框架共分为五层，自上而下由浅入深，从AQS对外暴露的API到底层基础数据。</li>
<li>当有自定义同步器接入时，只需<code>重写第一层所需要的部分方法</code>即可，不需要关注底层具体的实现流程。当自定义同步器进行加锁或者解锁操作时，先经过第一层的API进入AQS内部方法，然后经过第二层进行锁的获取，接着对于获取锁失败的流程，进入第三层和第四层的等待队列处理，而这些处理方式均依赖于第五层的基础数据提供层。</li>
</ul>
<p>下面我们会从整体到细节，从流程到方法逐一剖析AQS框架，主要分析过程如下：</p>
<p><img src="/imgs/%E4%BB%8EReentrantLock%E7%B1%BB%E7%9C%8BAQS%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E8%B7%B5(%E4%B8%8A%E7%AF%87)/d2f7f7fffdc30d85d17b44266c3ab05323338.png" alt="img"></p>
<h3 id="1-AQS的原理概述"><a href="#1-AQS的原理概述" class="headerlink" title="1.AQS的原理概述"></a>1.AQS的原理概述</h3><p>AQS核心思想是:<code>如果被请求的共享资源空闲，那么就将当前请求资源的线程设置为有效工作线程，将共享资源设置为锁定状态；如果共享资源被占用，就需要一定的阻塞等待唤醒机制来保证锁分配</code>。这个机制主要用的是<code>CLH队列的变体</code>实现的，将暂时获取不到锁的线程加入到队列中。</p>
<p>CLH：Craig、Landin and Hagersten队列，是单向链表，AQS中的队列是CLH变体的<code>虚拟双向队列（FIFO）</code>，AQS是通过<code>将每条请求共享资源的线程封装成一个节点来实现锁的分配</code>。</p>
<p><img src="/imgs/%E4%BB%8EReentrantLock%E7%B1%BB%E7%9C%8BAQS%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E8%B7%B5(%E4%B8%8A%E7%AF%87)/7132e4cef44c26f62835b197b239147b18062.png" alt="img"></p>
<p>AQS使用一个<code>volatile</code>的int类型的成员变量<code>state</code>来表示同步状态，<code>通过内置的FIFO队列来完成资源获取的排队工作，通过CAS完成对state值的修改</code>。</p>
<h3 id="2-AQS的数据结构"><a href="#2-AQS的数据结构" class="headerlink" title="2.AQS的数据结构"></a>2.AQS的数据结构</h3><p>先来看下AQS中最基本的数据结构——Node，Node即为上面CLH变体队列中的节点。</p>
<p><img src="/imgs/%E4%BB%8EReentrantLock%E7%B1%BB%E7%9C%8BAQS%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E8%B7%B5(%E4%B8%8A%E7%AF%87)/960271cf2b5c8a185eed23e98b72c75538637.png" alt="img"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="comment">// 共享锁的标记</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">SHARED</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">    <span class="comment">// 独占锁的标记</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">EXCLUSIVE</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 表明节点因为超时或中断而取消</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CANCELLED</span> <span class="operator">=</span>  <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 表明后继节点需要被唤醒</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SIGNAL</span>    <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 条件队列中才会使用到</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CONDITION</span> <span class="operator">=</span> -<span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 共享锁模式下才会使用到</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">PROPAGATE</span> <span class="operator">=</span> -<span class="number">3</span>;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 同步队列中节点的当前状态，初始化为0</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">int</span> waitStatus;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 前驱节点</span></span><br><span class="line">    <span class="keyword">volatile</span> Node prev;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 后继节点</span></span><br><span class="line">    <span class="keyword">volatile</span> Node next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 入队等待的线程</span></span><br><span class="line">    <span class="keyword">volatile</span> Thread thread;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 双重作用，既可以指示链接的下一个Condition节点，又可以表示锁的两种模式：SHARED或EXCLUSIVE</span></span><br><span class="line">    Node nextWaiter;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">isShared</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> nextWaiter == SHARED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Node <span class="title function_">predecessor</span><span class="params">()</span> <span class="keyword">throws</span> NullPointerException &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> prev;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node() &#123;    <span class="comment">// Used to establish initial head or SHARED marker</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node(Thread thread, Node mode) &#123;     <span class="comment">// Used by addWaiter</span></span><br><span class="line">        <span class="built_in">this</span>.nextWaiter = mode;</span><br><span class="line">        <span class="built_in">this</span>.thread = thread;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node(Thread thread, <span class="type">int</span> waitStatus) &#123; <span class="comment">// Used by Condition</span></span><br><span class="line">        <span class="built_in">this</span>.waitStatus = waitStatus;</span><br><span class="line">        <span class="built_in">this</span>.thread = thread;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在了解数据结构后，接下来了解一下AQS的同步状态——State。AQS中维护了一个名为state的字段，意为同步状态，是由volatile修饰的，用于展示当前临界资源的获锁情况。</p>
<p><img src="/imgs/%E4%BB%8EReentrantLock%E7%B1%BB%E7%9C%8BAQS%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E8%B7%B5(%E4%B8%8A%E7%AF%87)/image-20231117161623954.png" alt="image-20231117161623954"></p>
<p>这几个方法都是final修饰的，说明子类中无法重写它们。我们可以通过修改state字段表示的同步状态来实现多线程的独占模式和共享模式（加锁过程）。</p>
<p><img src="/imgs/%E4%BB%8EReentrantLock%E7%B1%BB%E7%9C%8BAQS%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E8%B7%B5(%E4%B8%8A%E7%AF%87)/27605d483e8935da683a93be015713f331378.png" alt="img"></p>
<p><img src="/imgs/%E4%BB%8EReentrantLock%E7%B1%BB%E7%9C%8BAQS%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E8%B7%B5(%E4%B8%8A%E7%AF%87)/3f1e1a44f5b7d77000ba4f9476189b2e32806.png" alt="img"></p>
<p>对于我们自定义的同步工具，需要自定义获取同步状态和释放状态的方式，也就是AQS架构图中的第一层：API层。</p>
<h3 id="3-AQS重要方法与ReentrantLock的关联"><a href="#3-AQS重要方法与ReentrantLock的关联" class="headerlink" title="3.AQS重要方法与ReentrantLock的关联"></a>3.AQS重要方法与ReentrantLock的关联</h3><p>从架构图中可以得知，AQS提供了大量用于自定义同步器实现的protected方法。自定义同步器实现的相关方法也只是为了通过修改state字段来实现多线程的独占模式或者共享模式。自定义同步器需要实现以下方法（ReentrantLock需要实现的方法如下，并不是全部）：</p>
<table>
<thead>
<tr>
<th align="left">方法名</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">protected boolean isHeldExclusively()</td>
<td align="left">该线程是否正在独占资源。只有用到Condition才需要去实现它。</td>
</tr>
<tr>
<td align="left">protected boolean tryAcquire(int arg)</td>
<td align="left">独占方式。arg为获取锁的次数，尝试获取资源，成功则返回True，失败则返回False。</td>
</tr>
<tr>
<td align="left">protected boolean tryRelease(int arg)</td>
<td align="left">独占方式。arg为释放锁的次数，尝试释放资源，成功则返回True，失败则返回False。</td>
</tr>
<tr>
<td align="left">protected int tryAcquireShared(int arg)</td>
<td align="left">共享方式。arg为获取锁的次数，尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</td>
</tr>
<tr>
<td align="left">protected boolean tryReleaseShared(int arg)</td>
<td align="left">共享方式。arg为释放锁的次数，尝试释放资源，如果释放后允许唤醒后续等待结点返回True，否则返回False。</td>
</tr>
</tbody></table>
<p>一般来说，自定义同步器要么是独占方式，要么是共享方式，它们也只需实现tryAcquire-tryRelease、tryAcquireShared-tryReleaseShared中的一种即可。AQS也支持自定义同步器同时实现独占和共享两种方式，如ReentrantReadWriteLock。ReentrantLock是独占锁，所以实现了tryAcquire-tryRelease。</p>
<blockquote>
<p>AQS使用<code>模板设计模式</code>封装了很多同步组件都需要的步骤，仅仅预留了tryAcquire、tryRelease、tryAcquireShared、tryReleaseShared和isHeldExclusively这五个方法为protected方法，那么为什么AQS本身没有任何抽象方法但AQS类本身却被声明为抽象类呢？为什么AQS被声明为了抽象类其内部却没有抽象方法呢？</p>
<p>1.第一个问题的答案就是<code>AQS本身的初衷是为其他众多的同步组件提供强大的基础框架，本身不希望被直接拿来使用</code>，因此表明为抽象类。</p>
<p>2.第二个问题的答案是<code>AQS作为并发包下的基础性框架因为要兼顾很多同步组件的需求，因此内容非常丰富如支持独占和共享两种模式</code>，而很多组件如ReentrantLock本身只需要实现独占模式，如果将上面的五个预留的方法声明为abstract，则ReentrantLock就必须全部实现，这显然是不合适的，因此AQS使用protected方法，具体的同步组件可以自由选择实现哪些方法。</p>
</blockquote>
<h3 id="4-AQS的应用场景"><a href="#4-AQS的应用场景" class="headerlink" title="4.AQS的应用场景"></a>4.AQS的应用场景</h3><p>除了上边ReentrantLock的可重入性的应用，AQS作为并发编程的框架，为很多其他同步工具提供了良好的解决方案。下面列出了JUC中的几种同步工具，大体介绍一下AQS的应用场景：</p>
<table>
<thead>
<tr>
<th align="left">同步工具</th>
<th align="left">同步工具与AQS的关联</th>
</tr>
</thead>
<tbody><tr>
<td align="left">ReentrantLock</td>
<td align="left">使用AQS保存锁<code>重复持有的次数</code>。当一个线程获取锁时，ReentrantLock记录当前获得锁的线程标识，用于检测是否重复获取，以及错误线程试图解锁操作时异常情况的处理。</td>
</tr>
<tr>
<td align="left">Semaphore</td>
<td align="left">使用AQS同步状态来保存<code>信号量的当前计数</code>。tryRelease会增加计数，acquireShared会减少计数。</td>
</tr>
<tr>
<td align="left">CountDownLatch</td>
<td align="left">使用AQS同步状态来表示<code>计数</code>。计数为0时，所有的Acquire操作（CountDownLatch的await方法）才可以通过。</td>
</tr>
<tr>
<td align="left">ReentrantReadWriteLock</td>
<td align="left">使用AQS<code>同步状态中的16位保存写锁持有的次数，剩下的16位用于保存读锁的持有次数</code>。</td>
</tr>
<tr>
<td align="left">ThreadPoolExecutor</td>
<td align="left">Worker利用AQS同步状态实现对独占线程变量的设置（tryAcquire和tryRelease）。</td>
</tr>
</tbody></table>
<h2 id="四、ReentrantLock类的加锁流程"><a href="#四、ReentrantLock类的加锁流程" class="headerlink" title="四、ReentrantLock类的加锁流程"></a>四、ReentrantLock类的加锁流程</h2><p>我们以非公平锁为例，全流程讲解整个加锁的过程，首先我们先看加锁的入口函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">    sync.lock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以说，ReentrantLock的加锁是委托给内部的<code>sync</code>对象完成的，以非公平的<code>NonFairSync</code>为例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 新的线程直接尝试CAS获取锁，可以完成插队加锁</span></span><br><span class="line">    <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">        <span class="comment">// 加锁成功后设置独占锁的持有者线程为当前线程</span></span><br><span class="line">        setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 加锁失败后的流程</span></span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当第一个线程请求加锁时发现当前state值为0，锁还没有被占用，于是调用compareAndSetState加锁成功，开始处理后续业务逻辑；当然这是理想情况，如果此时恰好第二个线程提前抢占了锁，则本次compareAndSetState加锁失败，就会进入acquire方法寻求解决方案，让我们走进acquire的世界吧：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个AQS中的acquire方法中先后出现了四个函数，首先会调用子类(本节中就是<code>NonfairSync</code>)重写的<code>tryAcquire</code>方法，也许你会疑惑为什么在AQS中为什么不把tryAcquire方法定义为抽象方法而是保护方法，原因就是保证实现类可以根据自己的需求重写特定的方法实现功能逻辑，例如ReentrantLock中的<code>NonfairSync</code>只需要实现<code>tryAcquire</code>和<code>tryRelease</code>方法即可，其余的像<code>tryAcquireShared</code>、<code>tryReleaseShared</code>等方法根本不需要：</p>
<p><img src="/imgs/%E4%BB%8EReentrantLock%E7%B1%BB%E7%9C%8BAQS%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E8%B7%B5(%E4%B8%8A%E7%AF%87)/image-20231117170552419.png" alt="image-20231117170552419"></p>
<p>回到正题中，让我们看看<code>NonfairSync</code>的<code>tryAcquire</code>方法的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">nonfairTryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">    <span class="comment">// 此刻发现锁已经被释放了，可以进行竞争抢占</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 加锁成功后还是设置独占锁的持有者线程为当前线程，并返回true表示加锁成功</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 上一步竞争抢占锁失败或者锁一直被占用着，进一步判断是不是持有锁线程的重入加锁</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="comment">// ReentrantLock锁可重入</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c + acquires;</span><br><span class="line">        <span class="comment">// ReentrantLock锁有递归次数限制，不能超过整型表示的最大正数2^31-1</span></span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">        <span class="comment">// 线程已经持有锁，不需要通过CAS方法修改state</span></span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回false表示加锁失败</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看到tryAcquire内部其实还是调用了父类<code>Sync</code>就定义好的<code>nonfairTryAcquire</code>方法，整个tryAcquire做的事情就是检查一下独占锁有没有被释放，如果锁被释放了就进行竞争抢占，否则判断是不是重入加锁，如果都不是表明当前线程可能只能进入同步队列等待了。</p>
<p>针对tryAcquire加锁成功acquire方法的判断逻辑就已经结束了，下面我们进一步查看tryAcquire加锁失败即返回false的后续操作，首当其冲的就是addWaiter方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Node <span class="title function_">addWaiter</span><span class="params">(Node mode)</span> &#123;</span><br><span class="line">    <span class="comment">// 把线程封装到Node节点中，其中mode在这里是独占模式Node.EXCLUSIVE</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(Thread.currentThread(), mode);</span><br><span class="line">    <span class="comment">// Try the fast path of enq; backup to full enq on failure</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">pred</span> <span class="operator">=</span> tail;</span><br><span class="line">    <span class="comment">// 尾节点不为空，表明同步队列已经初始化具有虚头节点，直接插入队尾即可</span></span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="literal">null</span>) &#123;</span><br><span class="line">        node.prev = pred;</span><br><span class="line">        <span class="comment">// CAS修改队尾指针成功，可能会因为并发线程修改队尾指针导致本次CAS失败，这种情况需要交给后续enq保证节点入队</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 负责同步队列的初始化和保证节点入队尾</span></span><br><span class="line">    enq(node);</span><br><span class="line">    <span class="comment">// 返回插入的新节点</span></span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Node <span class="title function_">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> &#123;</span><br><span class="line">    <span class="comment">// 自旋很重要！</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail;</span><br><span class="line">        <span class="comment">// 初始化同步队列</span></span><br><span class="line">        <span class="keyword">if</span> (t == <span class="literal">null</span>) &#123; </span><br><span class="line">            <span class="comment">// CAS修改队头指针为虚节点，可能会因为并发线程进入enq方法初始化队列而CAS失败，但是自旋保证了即使发生这种情况也会使节点正确入队尾</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> <span class="title class_">Node</span>()))</span><br><span class="line">                <span class="comment">// 初始化的状态是队头、队尾指针都指向虚节点</span></span><br><span class="line">                tail = head;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 新节点插入队尾</span></span><br><span class="line">            node.prev = t;</span><br><span class="line">            <span class="comment">// CAS修改队尾指针为新节点，可能会因为并发线程插入队尾导致CAS失败，但是自旋保证了即使发生这种情况也会使节点正确入队尾</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                t.next = node;</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此，总的来说<code>addWaiter</code>方法利用CAS保证了同步队列的初始化和节点入队尾的并发安全性。</p>
<p>接着，既然节点已经插入同步队列的尾部了，那么后续的阻塞等待逻辑怎么完成的呢，这就需要我们再一次查看<code>acquireQueued</code>方法的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="comment">// 是否获取到锁的标记，默认为true表示没有获取到锁</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 加锁过程中是否中断的标记，ReentrantLock的lock方法并不处理中断，仅仅记录中断标记</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 自旋很重要！</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">// 新插入节点的前驱节点</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();</span><br><span class="line">            <span class="comment">// 只有头节点的后一个节点(即第一个有效节点，符合FIFO规则)才有资格竞争锁</span></span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                <span class="comment">// 新插入的节点加锁成功的话，虚节点后移一位变成当前持有锁的</span></span><br><span class="line">                setHead(node);</span><br><span class="line">                <span class="comment">// help GC</span></span><br><span class="line">                p.next = <span class="literal">null</span>; </span><br><span class="line">                <span class="comment">// 修改标记为false表示获取到锁</span></span><br><span class="line">                failed = <span class="literal">false</span>;</span><br><span class="line">                <span class="comment">// 返回中断标记</span></span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 新插入的节点不是第一个有效节点，或者虽然是第一个有效节点但是尝试加锁失败</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                <span class="comment">// 如果阻塞等待期间当前线程被中断了，修改中断标记为true</span></span><br><span class="line">                interrupted = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            <span class="comment">// 发生异常，取消正在获取锁的线程节点</span></span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码告诉我们只有队头节点的后一个节点才有资格去竞争锁，这也符合AQS的FIFO同步队列的规则定义，有的同学可能会认为调用ReentrantLock的lock方法加锁失败会就会立即去同步队列阻塞等待，这其实是错误的观点，不是每个节点都有资格竞争锁的，而且第一个有效节点也不会立刻就阻塞等待而是会再次尝试加锁多次，实在获取不到锁才会阻塞等待。</p>
<p>下面我们去看一下acquireQueued中获取不到锁处理流程的第一个函数<code>shouldParkAfterFailedAcquire</code>，顾名思义就是在加锁失败后判断是否应该阻塞等待的逻辑函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> &#123;</span><br><span class="line">    <span class="comment">// 前置节点的状态</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> pred.waitStatus;</span><br><span class="line">    <span class="comment">// 前置节点状态为SIGNAL，表示前置节点可以负责后继节点的唤醒工作，当前节点可以安心阻塞等待了，返回true</span></span><br><span class="line">    <span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * This node has already set status asking a release</span></span><br><span class="line"><span class="comment">         * to signal it, so it can safely park.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 前置节点的状态为CANCELLED，移除前面所有无效的Cancelled节点，我们本节用不到</span></span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Predecessor was cancelled. Skip over predecessors and</span></span><br><span class="line"><span class="comment">         * indicate retry.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            node.prev = pred = pred.prev;</span><br><span class="line">        &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">        pred.next = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * waitStatus must be 0 or PROPAGATE.  Indicate that we</span></span><br><span class="line"><span class="comment">         * need a signal, but don&#x27;t park yet.  Caller will need to</span></span><br><span class="line"><span class="comment">         * retry to make sure it cannot acquire before parking.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">// 节点的默认状态为0，通过CAS修改前置节点状态为SIGNAL</span></span><br><span class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 除了前置节点状态为SIGNAL这种情况外，其余都返回false表示当前节点不应该阻塞，需要再次尝试</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一开始节点的默认状态都是0，因此<code>shouldParkAfterFailedAcquire</code>会修改前置节点状态为<code>SIGNAL</code>，然后再次自旋重试加锁(针对有效节点)，如果还是没有获取到锁则再次进入<code>shouldParkAfterFailedAcquire</code>方法并返回true表示当前节点可以阻塞了，随即调用后续的<code>parkAndCheckInterrupt</code>方法阻塞当前线程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">parkAndCheckInterrupt</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 当前线程阻塞，等待后续解锁唤醒，也可能会被中断唤醒(我们这里可以理解为虚假唤醒，因为原则上ReentrantLock不响应中断)，唤醒后需要去竞争加锁，可能会被外来线程插队(这就是非公平锁的特点)</span></span><br><span class="line">    LockSupport.park(<span class="built_in">this</span>);</span><br><span class="line">    <span class="comment">// 唤醒后返回当前线程阻塞等待期间是否被中断的标识，会清除线程的中断位</span></span><br><span class="line">    <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到这里，<code>acquire</code>方法内的前三个主要函数都已经讲解完毕，我们再次回顾该方法的逻辑：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同步队列的第一个有效节点被唤醒并成功加锁后，返回阻塞等待期间是否被中断的标识，如果确实被中断过，此时调用<code>selfInterrupt</code>方法设置当前线程的中断位，因此可以看出，ReentrantLock的lock方法确实不处理中断：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">selfInterrupt</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 设置中断位</span></span><br><span class="line">    Thread.currentThread().interrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="五、ReentrantLock类的解锁流程"><a href="#五、ReentrantLock类的解锁流程" class="headerlink" title="五、ReentrantLock类的解锁流程"></a>五、ReentrantLock类的解锁流程</h2><p>讲完ReentrantLock的加锁流程，下面我们看一下ReentrantLock的解锁流程，首先看一下解锁的入口函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">    sync.release(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以说，ReentrantLock的解锁也是委托给内部的<code>sync</code>对象完成的，以非公平的<code>NonFairSync</code>为例(其实解锁对于公平或非公平模型都是一样的操作)：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">release</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="comment">// 尝试[完全]释放锁成功后的情况，这里的完全指的是重入锁全部释放</span></span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="comment">// 同步队列头的虚节点状态是SIGNAL，可以唤醒其后继节点</span></span><br><span class="line">        <span class="keyword">if</span> (h != <span class="literal">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先解锁的第一个方法就是<code>tryRelease</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span> releases)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState() - releases;</span><br><span class="line">    <span class="comment">// 只有持有锁的线程才能释放锁，否则抛出IllegalMonitorStateException，跟synchronized相似</span></span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line">    <span class="comment">// 完全释放锁的标记，默认false表示没有完全释放锁</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">free</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 重入次数归零表明已经完全释放锁</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 修改标记位true表示完全释放锁</span></span><br><span class="line">        free = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 独占锁的持有者线程置为空</span></span><br><span class="line">        setExclusiveOwnerThread(<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 持有锁的线程修改state值不需要使用CAS操作</span></span><br><span class="line">    setState(c);</span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于完全释放锁后唤醒同步队列中等待的第一个节点，<code>unparkSuccessor</code>给出了操作逻辑：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">unparkSuccessor</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">    <span class="comment">// 把虚节点的状态重置为0，让其退出唤醒后继节点的工作，这个操作成不成功都无所谓</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> node.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line">	<span class="comment">// 虚节点的后继节点，也就是我们需要唤醒的节点</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">s</span> <span class="operator">=</span> node.next;</span><br><span class="line">    <span class="comment">// 从前往后找非取消节点存在可能无法完整遍历同步队列的问题，因为addWaiter方法中新节点入队的CAS操作与设置上一次尾节点的next引用不是原子性的，可能同步队列还没有来得及建立最后面节点之间的next指向，因此只能使用从后往前的遍历方式！</span></span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        s = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail; t != <span class="literal">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 唤醒后继节点</span></span><br><span class="line">    <span class="keyword">if</span> (s != <span class="literal">null</span>)</span><br><span class="line">        LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="六、ReentrantLock类的其他方法"><a href="#六、ReentrantLock类的其他方法" class="headerlink" title="六、ReentrantLock类的其他方法"></a>六、ReentrantLock类的其他方法</h2><h3 id="1-lockInterruptibly"><a href="#1-lockInterruptibly" class="headerlink" title="1.lockInterruptibly"></a>1.lockInterruptibly</h3><p>该方法不同于lock方法不响应等待阻塞过程中的中断，而是一旦等待过程中发现线程中断就抛出中断异常InterruptedException，用的时机很少。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    sync.acquireInterruptibly(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquireInterruptibly</span><span class="params">(<span class="type">int</span> arg)</span></span><br><span class="line">    <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg))</span><br><span class="line">        doAcquireInterruptibly(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/imgs/从ReentrantLock类看AQS的原理及实践(上篇)/image-20231118204104012.png" alt="image-20231118204104012" style="zoom:67%;" />

<h3 id="2-tryLock尝试加锁"><a href="#2-tryLock尝试加锁" class="headerlink" title="2.tryLock尝试加锁"></a>2.tryLock尝试加锁</h3><p>该方法不同于lock方法会一直阻塞等待获取锁，而是去尝试获取锁，如果拿不到锁也无所谓返回false即可，后续业务逻辑会自行决定如何处理，这也是为了避免我们的业务系统因为迟迟获取不到锁而发生严重阻塞，导致大量请求的堆积甚至系统发生崩溃。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> sync.nonfairTryAcquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-tryLock超时加锁"><a href="#3-tryLock超时加锁" class="headerlink" title="3.tryLock超时加锁"></a>3.tryLock超时加锁</h3><p>该方法相对于tryLock原方式增加了超时等待限制，如果获取不到锁会先等待一定时间，如果超时后还拿不到锁就返回false，增加了tryLock调用的灵活性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(<span class="type">long</span> timeout, TimeUnit unit)</span></span><br><span class="line">    <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">return</span> sync.tryAcquireNanos(<span class="number">1</span>, unit.toNanos(timeout));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquireNanos</span><span class="params">(<span class="type">int</span> arg, <span class="type">long</span> nanosTimeout)</span></span><br><span class="line">    <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="comment">// 进入方法时检查当前线程是否被中断，如果是的话抛出InterruptedException</span></span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">    <span class="comment">// 尝试获取锁，如果没有获取到就调用超时版本的doAcquireNanos方法</span></span><br><span class="line">    <span class="keyword">return</span> tryAcquire(arg) ||</span><br><span class="line">        doAcquireNanos(arg, nanosTimeout);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">doAcquireNanos</span><span class="params">(<span class="type">int</span> arg, <span class="type">long</span> nanosTimeout)</span></span><br><span class="line">    <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="comment">// 等待时间小于等于零，直接返回false表示没有拿到锁</span></span><br><span class="line">    <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0L</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 计算超时时刻</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">long</span> <span class="variable">deadline</span> <span class="operator">=</span> System.nanoTime() + nanosTimeout;</span><br><span class="line">    <span class="comment">// 下面的代码逻辑与前面的tryLock方法中的一样</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> addWaiter(Node.EXCLUSIVE);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="literal">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 计算剩余等待时间</span></span><br><span class="line">            nanosTimeout = deadline - System.nanoTime();</span><br><span class="line">            <span class="comment">// 超时时刻已到，返回false表示没有拿到锁</span></span><br><span class="line">            <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0L</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">// 调用LockSupport的超时阻塞方法，注意如果剩余阻塞等待时间还不到spinForTimeoutThreshold，那么选择自旋可能程序效率更高，因为线程状态切换也需要一定开销(操作系统调度线程从用户态到内核态需要一定时钟周期)</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                nanosTimeout &gt; spinForTimeoutThreshold)</span><br><span class="line">                LockSupport.parkNanos(<span class="built_in">this</span>, nanosTimeout);</span><br><span class="line">            <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="七、自定义同步工具-独占锁"><a href="#七、自定义同步工具-独占锁" class="headerlink" title="七、自定义同步工具-独占锁"></a>七、自定义同步工具-独占锁</h2><p>了解AQS基本原理以后，按照上面所说的AQS知识点，自己实现一个同步工具。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LeeLock</span>  &#123;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 不可重入的非阻塞独占锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Sync</span> <span class="keyword">extends</span> <span class="title class_">AbstractQueuedSynchronizer</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span> <span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> compareAndSetState(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span> <span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">            setState(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">isHeldExclusively</span> <span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> getState() == <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="type">Sync</span> <span class="variable">sync</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Sync</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span> <span class="params">()</span> &#123;</span><br><span class="line">        sync.acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span> <span class="params">()</span> &#123;</span><br><span class="line">        sync.release(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LeeMain</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">LeeLock</span> <span class="variable">leeLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LeeLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span> <span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">runnable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span> <span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    leeLock.lock();</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">                        count++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    leeLock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(runnable);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(runnable);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        thread1.join();</span><br><span class="line">        thread2.join();</span><br><span class="line">        System.out.println(count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码每次运行结果都会是20000。通过简单的几行代码就能实现同步功能，这就是AQS的强大之处。</p>
<h2 id="八、自定义同步工具-共享锁"><a href="#八、自定义同步工具-共享锁" class="headerlink" title="八、自定义同步工具-共享锁"></a>八、自定义同步工具-共享锁</h2><p>设计一个同步工具：该工具在同一时刻，只允许至多两个线程同时访问，超过两个线程的访问将被阻塞，我们将这个同步工具命名为TwinsLock。</p>
<p>首先，确定访问模式。TwinsLock能够在同一时刻支持多个线程的访问，这显然是共享式访问，因此，需要使用同步器提供的acquireShared(int args)方法等和Shared相关的方法，这就要求TwinsLock必须重写tryAcquireShared(int args)方法和tryReleaseShared(int args)方法，这样才能保证同步器的共享式同步状态的获取与释放方法得以执行。</p>
<p>其次，定义资源数。TwinsLock在同一时刻允许至多两个线程的同时访问，表明同步资源数为2，这样可以设置初始状态status为2，当一个线程进行获取，status减1，该线程释放，则status加1，状态的合法范围为0、1和2，其中0表示当前已经有两个线程获取了同步资源，此时再有其他线程对同步状态进行获取，该线程只能被阻塞。在同步状态变更时，需要使用compareAndSet(int expect,int update)方法做原子性保障。</p>
<p>最后，组合自定义同步器。前面提到，自定义同步组件通过组合自定义同步器来完成同步功能，一般情况下自定义同步器会被定义为自定义同步组件的内部类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TwinsLock</span> <span class="keyword">implements</span> <span class="title class_">Lock</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Sync</span> <span class="variable">sync</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Sync</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Sync</span> <span class="keyword">extends</span> <span class="title class_">AbstractQueuedSynchronizer</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">7889272986162341211L</span>;</span><br><span class="line"></span><br><span class="line">        Sync(<span class="type">int</span> count) &#123;</span><br><span class="line">            <span class="keyword">if</span> (count &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;count must large than zero.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            setState(count);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">tryAcquireShared</span><span class="params">(<span class="type">int</span> reduceCount)</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">current</span> <span class="operator">=</span> getState();</span><br><span class="line">                <span class="type">int</span> <span class="variable">newCount</span> <span class="operator">=</span> current - reduceCount;</span><br><span class="line">                <span class="keyword">if</span> (newCount &lt; <span class="number">0</span> || compareAndSetState(current, newCount)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> newCount;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryReleaseShared</span><span class="params">(<span class="type">int</span> returnCount)</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">current</span> <span class="operator">=</span> getState();</span><br><span class="line">                <span class="type">int</span> <span class="variable">newCount</span> <span class="operator">=</span> current + returnCount;</span><br><span class="line">                <span class="keyword">if</span> (compareAndSetState(current, newCount)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> ConditionObject <span class="title function_">newCondition</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConditionObject</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">        sync.acquireShared(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">        sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        sync.acquireSharedInterruptibly(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sync.tryAcquireShared(<span class="number">1</span>) &gt;= <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(<span class="type">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">return</span> sync.tryAcquireSharedNanos(<span class="number">1</span>, unit.toNanos(time));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Condition <span class="title function_">newCondition</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sync.newCondition();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，TwinsLock实现了Lock接口，提供了面向使用者的接口，使用者调用lock()方法获取锁，随后调用unlock()方法释放锁，而同一时刻只能有两个线程同时获取到锁。TwinsLock同时包含了一个自定义同步器Sync，而该同步器面向线程访问和同步状态控制。以共享式获取同步状态为例：同步器会先计算出获取后的同步状态，然后通过CAS确保状态的正确设置，当tryAcquireShared(int reduceCount)方法返回值大于等于0时，当前线程才获取同步状态，对于上层的TwinsLock而言，则表示当前线程获得了锁。</p>
<p>下面编写一个测试来验证TwinsLock是否能按照预期工作。在测试用例中，定义了工作者线程Worker，该线程在执行过程中获取锁，当获取锁之后使当前线程睡眠1秒（并不释放锁），随后打印当前线程名称，最后再次睡眠1秒并释放锁。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TwinsLockTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TwinsLock</span>();</span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">Worker</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                    lock.lock();</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        SleepUtils.second(<span class="number">1</span>);</span><br><span class="line">                        System.out.println(Thread.currentThread().getName());</span><br><span class="line">                        SleepUtils.second(<span class="number">1</span>);</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        lock.unlock();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 启动10个线程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="type">Worker</span> <span class="variable">w</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Worker</span>();</span><br><span class="line">            w.setDaemon(<span class="literal">true</span>);</span><br><span class="line">            w.start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 每隔1秒换行</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            SleepUtils.second(<span class="number">1</span>);</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行该测试用例，可以看到线程名称成对输出，也就是在同一时刻只有两个线程能够获取到锁，这表明TwinsLock可以按照预期正确工作。</p>
<h2 id="九、Condition接口详解"><a href="#九、Condition接口详解" class="headerlink" title="九、Condition接口详解"></a>九、Condition接口详解</h2><p>任意一个Java对象，都拥有一组监视器方法，主要包括wait()、wait(long timeout)、notify()以及notifyAll()方法，这些方法与synchronized同步关键字配合，可以实现等待&#x2F;通知模式。Condition接口也提供了类似Object的监视器方法，与Lock配合可以实现等待&#x2F;通知模式，但是这两者在使用方式以及功能特性上还是有差别的。</p>
<p><img src="/imgs/%E4%BB%8EReentrantLock%E7%B1%BB%E7%9C%8BAQS%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E8%B7%B5(%E4%B8%8A%E7%AF%87)/image-20240905222014198.png" alt="image-20240905222014198"></p>
<h3 id="1-Condition接口与示例"><a href="#1-Condition接口与示例" class="headerlink" title="1.Condition接口与示例"></a>1.Condition接口与示例</h3><p>Condition定义了等待&#x2F;通知两种类型的方法，当前线程调用这些方法时，需要提前获取到Condition对象关联的锁。Condition对象是由Lock对象（调用Lock对象的newCondition()方法）创建出来的，换句话说，Condition是依赖Lock对象的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConditionUseCase</span> &#123;</span><br><span class="line">    <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="type">Condition</span> <span class="variable">condition</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">conditionWait</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            condition.await();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">conditionSignal</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            condition.signal();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当调用await()方法后，当前线程会释放锁并在此等待，而其他线程调用Condition对象的signal()方法，通知当前线程后，当前线程才从await()方法返回，并且在返回前已经获取了锁。</p>
<p><img src="/imgs/%E4%BB%8EReentrantLock%E7%B1%BB%E7%9C%8BAQS%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E8%B7%B5(%E4%B8%8A%E7%AF%87)/image-20240905222334246.png" alt="image-20240905222334246"></p>
<p>获取一个Condition必须通过Lock的newCondition()方法。下面通过一个有界队列的示例来深入了解Condition的使用方式。有界队列是一种特殊的队列，当队列为空时，队列的获取操作将会阻塞获取线程，直到队列中有新增元素，当队列已满时，队列的插入操作将会阻塞插入线程，直到队列出现空位。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BoundedQueue</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> Object[]  items;</span><br><span class="line">    <span class="comment">// 添加的下标，删除的下标和数组当前数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>       addIndex, removeIndex, count;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Lock</span>      <span class="variable">lock</span>     <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Condition</span> <span class="variable">notEmpty</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Condition</span> <span class="variable">notFull</span>  <span class="operator">=</span> lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BoundedQueue</span><span class="params">(<span class="type">int</span> size)</span> &#123;</span><br><span class="line">        items = <span class="keyword">new</span> <span class="title class_">Object</span>[size];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加一个元素，如果数组满，则添加线程进入等待状态，直到有空位</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(T t)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (count == items.length)</span><br><span class="line">                notFull.await();</span><br><span class="line">            items[addIndex] = t;</span><br><span class="line">            <span class="keyword">if</span> (++addIndex == items.length)</span><br><span class="line">                addIndex = <span class="number">0</span>;</span><br><span class="line">            ++count;</span><br><span class="line">            notEmpty.signal();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 由头部删除一个元素，如果数组空，则删除线程进入等待状态，直到有新添加元素</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">remove</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (count == <span class="number">0</span>)</span><br><span class="line">                notEmpty.await();</span><br><span class="line">            <span class="type">Object</span> <span class="variable">x</span> <span class="operator">=</span> items[removeIndex];</span><br><span class="line">            <span class="keyword">if</span> (++removeIndex == items.length)</span><br><span class="line">                removeIndex = <span class="number">0</span>;</span><br><span class="line">            --count;</span><br><span class="line">            notFull.signal();</span><br><span class="line">            <span class="keyword">return</span> (T) x;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在添加和删除方法中使用while循环而非if判断，目的是防止过早或意外的通知，只有条件符合才能够退出循环。回想之前提到的等待&#x2F;通知的经典范式，二者是非常类似的。</p>
<h3 id="2-Condition的实现分析"><a href="#2-Condition的实现分析" class="headerlink" title="2.Condition的实现分析"></a>2.Condition的实现分析</h3><p><code>ConditionObject</code>是同步器AbstractQueuedSynchronizer的内部类，因为Condition的操作需要获取相关联的锁，所以作为同步器的内部类也较为合理。<code>每个Condition对象都包含着一个队列（以下称为等待队列），该队列是Condition对象实现等待/通知功能的关键</code>。</p>
<p><img src="/imgs/%E4%BB%8EReentrantLock%E7%B1%BB%E7%9C%8BAQS%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E8%B7%B5(%E4%B8%8A%E7%AF%87)/image-20240905223051037.png" alt="image-20240905223051037"></p>
<p>下面将分析Condition的实现，主要包括：等待队列、等待和通知，下面提到的Condition如果不加说明均指的是ConditionObject。</p>
<h4 id="2-1等待队列"><a href="#2-1等待队列" class="headerlink" title="2.1等待队列"></a>2.1等待队列</h4><p>等待队列是一个FIFO的队列，在队列中的每个节点都包含了一个线程引用，该线程就是在Condition对象上等待的线程，如果一个线程调用了Condition.await()方法，那么该线程将会<code>释放锁、构造成节点加入等待队列并进入等待状态</code>。事实上，节点的定义复用了同步器中节点的定义，也就是说，同步队列和等待队列中节点类型都是同步器的静态内部类AbstractQueuedSynchronizer.Node。</p>
<p>一个Condition包含一个等待队列，Condition拥有首节点firstWaiter和尾节点lastWaiter。当前线程调用Condition.await()方法，将会以当前线程构造节点，并将节点从尾部加入等待队列，等待队列的基本结构如图所示。</p>
<p><img src="/imgs/%E4%BB%8EReentrantLock%E7%B1%BB%E7%9C%8BAQS%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E8%B7%B5(%E4%B8%8A%E7%AF%87)/image-20240905223202540.png" alt="image-20240905223202540"></p>
<blockquote>
<p>如图所示，Condition拥有首尾节点的引用，而新增节点只需要将原有的尾节点nextWaiter指向它，并且更新尾节点即可。<code>上述节点引用更新的过程并没有使用CAS保证，原因在于调用await()方法的线程必定是获取了锁的线程，也就是说该过程是由锁来保证线程安全的。</code></p>
</blockquote>
<p>在Object的监视器模型上，一个对象拥有一个同步队列和等待队列，而并发包中的Lock（更确切地说是同步器）拥有<code>一个同步队列</code>和<code>多个等待队列</code>，其对应关系如图所示。</p>
<p><img src="/imgs/%E4%BB%8EReentrantLock%E7%B1%BB%E7%9C%8BAQS%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E8%B7%B5(%E4%B8%8A%E7%AF%87)/image-20240905223344262.png" alt="image-20240905223344262"></p>
<p>如图所示，Condition的实现是同步器的内部类，因此每个Condition实例都能够访问同步器提供的方法，相当于每个Condition都拥有所属同步器的引用。</p>
<h4 id="2-2等待"><a href="#2-2等待" class="headerlink" title="2.2等待"></a>2.2等待</h4><p>调用Condition的await()方法（或者以await开头的方法），会使当前线程进入等待队列并释放锁，同时线程状态变为等待状态。当从await()方法返回时，当前线程一定获取了Condition相关联的锁。</p>
<blockquote>
<p>如果从队列（同步队列和等待队列）的角度看await()方法，当调用await()方法时，<code>相当于同步队列的首节点（获取了锁的节点）移动到Condition的等待队列中</code>。</p>
</blockquote>
<p><img src="/imgs/%E4%BB%8EReentrantLock%E7%B1%BB%E7%9C%8BAQS%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E8%B7%B5(%E4%B8%8A%E7%AF%87)/image-20240905223731507.png" alt="image-20240905223731507"></p>
<p>调用该方法的线程成功获取了锁的线程，也就是同步队列中的首节点，该方法会将当前线程构造成节点并加入等待队列中，然后释放同步状态，唤醒同步队列中的后继节点，然后当前线程会进入等待状态。</p>
<p>当等待队列中的节点被唤醒，则唤醒节点的线程开始尝试获取同步状态。如果不是通过其他线程调用Condition.signal()方法唤醒，而是对等待线程进行中断，则会抛出InterruptedException。</p>
<p><img src="/imgs/%E4%BB%8EReentrantLock%E7%B1%BB%E7%9C%8BAQS%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E8%B7%B5(%E4%B8%8A%E7%AF%87)/image-20240905223946829.png" alt="image-20240905223946829"></p>
<h4 id="2-3通知"><a href="#2-3通知" class="headerlink" title="2.3通知"></a>2.3通知</h4><p>调用Condition的signal()方法，将会唤醒在等待队列中等待时间最长的节点（首节点），在唤醒节点之前，会将节点移到同步队列中。</p>
<p><img src="/imgs/%E4%BB%8EReentrantLock%E7%B1%BB%E7%9C%8BAQS%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E8%B7%B5(%E4%B8%8A%E7%AF%87)/image-20240905224053472.png" alt="image-20240905224053472"></p>
<p>调用该方法的前置条件是当前线程必须获取了锁，可以看到signal()方法进行了isHeldExclusively()检查，也就是当前线程必须是获取了锁的线程。接着获取等待队列的首节点，将其移动到同步队列并使用LockSupport唤醒节点中的线程。</p>
<p><img src="/imgs/%E4%BB%8EReentrantLock%E7%B1%BB%E7%9C%8BAQS%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E8%B7%B5(%E4%B8%8A%E7%AF%87)/image-20240905224158458.png" alt="image-20240905224158458"></p>
<p>通过调用同步器的enq(Node node)方法，等待队列中的头节点线程安全地移动到同步队列。<code>当节点移动到同步队列后，当前线程再使用LockSupport唤醒该节点的线程</code>。被唤醒后的线程，将从await()方法中的while循环中退出（<code>isOnSyncQueue(Node node)</code>方法返回true，节点已经在同步队列中），进而调用同步器的<code>acquireQueued()</code>方法加入到获取同步状态的竞争中。</p>
<p>成功获取同步状态（或者说锁）之后，被唤醒的线程将从先前调用的await()方法返回，此时该线程已经成功地获取了锁。Condition的signalAll()方法，相当于对等待队列中的每个节点均执行一次signal()方法，效果就是将等待队列中所有节点全部移动到同步队列中，并唤醒每个节点的线程。</p>

  </div>
</article>

    <div class="blog-post-comments">
        <div id="disqus_thread">
            <noscript>Please enable JavaScript to view the comments.</noscript>
        </div>
    </div>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
        
          <li><a href="/">Home</a></li>
        
          <li><a href="/about/">About</a></li>
        
          <li><a href="/archives/">Writing</a></li>
        
          <li><a href="/tags/">Tag</a></li>
        
          <li><a target="_blank" rel="noopener" href="http://github.com/hulingF">Projects</a></li>
        
      </ul>
    </div>

    
    
      <div id="toc-footer" style="display: none">
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%8EReentrantLock%E7%B1%BB%E7%9C%8BAQS%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E8%B7%B5"><span class="toc-number">1.</span> <span class="toc-text">从ReentrantLock类看AQS的原理及实践</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E5%AD%A6%E4%B9%A0AQS%E7%9A%84%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86"><span class="toc-number">1.1.</span> <span class="toc-text">一、学习AQS的前置知识</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-LockSupport%E5%B7%A5%E5%85%B7%E7%B1%BB"><span class="toc-number">1.1.1.</span> <span class="toc-text">1.LockSupport工具类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Java%E4%B8%AD%E6%96%AD%E6%9C%BA%E5%88%B6"><span class="toc-number">1.1.2.</span> <span class="toc-text">2.Java中断机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%A8%A1%E6%9D%BF%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.1.3.</span> <span class="toc-text">3.模板设计模式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81ReentrantLock%E7%B1%BB%E7%9A%84%E7%AE%80%E4%BB%8B"><span class="toc-number">1.2.</span> <span class="toc-text">二、ReentrantLock类的简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81ReentrantLock%E7%B1%BB%E7%9A%84%E7%BB%93%E6%9E%84"><span class="toc-number">1.3.</span> <span class="toc-text">三、ReentrantLock类的结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-ReentrantLock%E7%B1%BB%E7%9A%84%E6%80%BB%E4%BD%93%E6%9E%B6%E6%9E%84"><span class="toc-number">1.3.1.</span> <span class="toc-text">1.ReentrantLock类的总体架构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Lock%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.3.2.</span> <span class="toc-text">2.Lock接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-Sync%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">1.3.3.</span> <span class="toc-text">3.Sync内部类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81AQS%E7%9A%84%E9%87%8D%E7%82%B9%E5%8E%9F%E7%90%86"><span class="toc-number">1.4.</span> <span class="toc-text">三、AQS的重点原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-AQS%E7%9A%84%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0"><span class="toc-number">1.4.1.</span> <span class="toc-text">1.AQS的原理概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-AQS%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">1.4.2.</span> <span class="toc-text">2.AQS的数据结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-AQS%E9%87%8D%E8%A6%81%E6%96%B9%E6%B3%95%E4%B8%8EReentrantLock%E7%9A%84%E5%85%B3%E8%81%94"><span class="toc-number">1.4.3.</span> <span class="toc-text">3.AQS重要方法与ReentrantLock的关联</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-AQS%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">1.4.4.</span> <span class="toc-text">4.AQS的应用场景</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81ReentrantLock%E7%B1%BB%E7%9A%84%E5%8A%A0%E9%94%81%E6%B5%81%E7%A8%8B"><span class="toc-number">1.5.</span> <span class="toc-text">四、ReentrantLock类的加锁流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81ReentrantLock%E7%B1%BB%E7%9A%84%E8%A7%A3%E9%94%81%E6%B5%81%E7%A8%8B"><span class="toc-number">1.6.</span> <span class="toc-text">五、ReentrantLock类的解锁流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81ReentrantLock%E7%B1%BB%E7%9A%84%E5%85%B6%E4%BB%96%E6%96%B9%E6%B3%95"><span class="toc-number">1.7.</span> <span class="toc-text">六、ReentrantLock类的其他方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-lockInterruptibly"><span class="toc-number">1.7.1.</span> <span class="toc-text">1.lockInterruptibly</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-tryLock%E5%B0%9D%E8%AF%95%E5%8A%A0%E9%94%81"><span class="toc-number">1.7.2.</span> <span class="toc-text">2.tryLock尝试加锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-tryLock%E8%B6%85%E6%97%B6%E5%8A%A0%E9%94%81"><span class="toc-number">1.7.3.</span> <span class="toc-text">3.tryLock超时加锁</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E8%87%AA%E5%AE%9A%E4%B9%89%E5%90%8C%E6%AD%A5%E5%B7%A5%E5%85%B7-%E7%8B%AC%E5%8D%A0%E9%94%81"><span class="toc-number">1.8.</span> <span class="toc-text">七、自定义同步工具-独占锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AB%E3%80%81%E8%87%AA%E5%AE%9A%E4%B9%89%E5%90%8C%E6%AD%A5%E5%B7%A5%E5%85%B7-%E5%85%B1%E4%BA%AB%E9%94%81"><span class="toc-number">1.9.</span> <span class="toc-text">八、自定义同步工具-共享锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B9%9D%E3%80%81Condition%E6%8E%A5%E5%8F%A3%E8%AF%A6%E8%A7%A3"><span class="toc-number">1.10.</span> <span class="toc-text">九、Condition接口详解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Condition%E6%8E%A5%E5%8F%A3%E4%B8%8E%E7%A4%BA%E4%BE%8B"><span class="toc-number">1.10.1.</span> <span class="toc-text">1.Condition接口与示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Condition%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%88%86%E6%9E%90"><span class="toc-number">1.10.2.</span> <span class="toc-text">2.Condition的实现分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1%E7%AD%89%E5%BE%85%E9%98%9F%E5%88%97"><span class="toc-number">1.10.2.1.</span> <span class="toc-text">2.1等待队列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2%E7%AD%89%E5%BE%85"><span class="toc-number">1.10.2.2.</span> <span class="toc-text">2.2等待</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3%E9%80%9A%E7%9F%A5"><span class="toc-number">1.10.2.3.</span> <span class="toc-text">2.3通知</span></a></li></ol></li></ol></li></ol></li></ol>
      </div>
    

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://hulingf.github.io/2023/11/17/%E4%BB%8EReentrantLock%E7%B1%BB%E7%9C%8BAQS%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E8%B7%B5/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://hulingf.github.io/2023/11/17/%E4%BB%8EReentrantLock%E7%B1%BB%E7%9C%8BAQS%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E8%B7%B5/&text=从ReentrantLock类看AQS的原理及实践"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://hulingf.github.io/2023/11/17/%E4%BB%8EReentrantLock%E7%B1%BB%E7%9C%8BAQS%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E8%B7%B5/&title=从ReentrantLock类看AQS的原理及实践"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://hulingf.github.io/2023/11/17/%E4%BB%8EReentrantLock%E7%B1%BB%E7%9C%8BAQS%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E8%B7%B5/&is_video=false&description=从ReentrantLock类看AQS的原理及实践"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=从ReentrantLock类看AQS的原理及实践&body=Check out this article: https://hulingf.github.io/2023/11/17/%E4%BB%8EReentrantLock%E7%B1%BB%E7%9C%8BAQS%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E8%B7%B5/"><i class="fa-solid fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://hulingf.github.io/2023/11/17/%E4%BB%8EReentrantLock%E7%B1%BB%E7%9C%8BAQS%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E8%B7%B5/&title=从ReentrantLock类看AQS的原理及实践"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://hulingf.github.io/2023/11/17/%E4%BB%8EReentrantLock%E7%B1%BB%E7%9C%8BAQS%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E8%B7%B5/&title=从ReentrantLock类看AQS的原理及实践"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://hulingf.github.io/2023/11/17/%E4%BB%8EReentrantLock%E7%B1%BB%E7%9C%8BAQS%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E8%B7%B5/&title=从ReentrantLock类看AQS的原理及实践"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://hulingf.github.io/2023/11/17/%E4%BB%8EReentrantLock%E7%B1%BB%E7%9C%8BAQS%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E8%B7%B5/&title=从ReentrantLock类看AQS的原理及实践"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://hulingf.github.io/2023/11/17/%E4%BB%8EReentrantLock%E7%B1%BB%E7%9C%8BAQS%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E8%B7%B5/&name=从ReentrantLock类看AQS的原理及实践&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://hulingf.github.io/2023/11/17/%E4%BB%8EReentrantLock%E7%B1%BB%E7%9C%8BAQS%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E8%B7%B5/&t=从ReentrantLock类看AQS的原理及实践"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fa-solid fa-bars fa-lg" aria-hidden="true"></i> Menu</a>
        
          <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fa-solid fa-list fa-lg" aria-hidden="true"></i> TOC</a>
        
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fa-solid fa-share-alt fa-lg" aria-hidden="true"></i> Share</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2024
    hulingF
  </div>
  <div class="footer-right">
    <nav>
      <ul>
        <!--
       --><li><a href="/">Home</a></li><!--
     --><!--
       --><li><a href="/about/">About</a></li><!--
     --><!--
       --><li><a href="/archives/">Writing</a></li><!--
     --><!--
       --><li><a href="/tags/">Tag</a></li><!--
     --><!--
       --><li><a target="_blank" rel="noopener" href="http://github.com/hulingF">Projects</a></li><!--
     -->
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->



  <link rel="preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" crossorigin="anonymous" onload="this.onload=null;this.rel='stylesheet'"/>


    <!-- jquery -->

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" crossorigin="anonymous"></script>




<!-- clipboard -->

  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.7/clipboard.min.js" crossorigin="anonymous"></script>
  
  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"Copy to clipboard!\">";
    btn += '<i class="fa-regular fa-clone"></i>';
    btn += '</span>';
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "Copied!");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Disqus Comments -->

    <script type="text/javascript">
        var disqus_shortname = 'hulingF';

        (function(){
            var dsq = document.createElement('script');
            dsq.type = 'text/javascript';
            dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        }());
    </script>

<!-- utterances Comments -->

</body>
</html>
