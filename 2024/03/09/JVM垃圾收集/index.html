<!DOCTYPE html>
<html lang=en>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5" />
    <meta name="description" content="JVM垃圾收集为什么需要垃圾回收想要学习GC，首先需要理解为什么需要GC？  对于高级语言来说，一个基本认知是如果不进行垃圾回收，内存迟早都会被消耗完，因为不断地分配内存空间而不进行回收，就好像不停地生产生活垃圾而从来不打扫一样。 除了释放没用的对象，垃圾回收也可以清除内存里的记录碎片。碎片整理将所占用的堆内存移到堆的一端，以便JVM将整理出的内存分配给新的对象。 随着应用程序所应付的业务越来越庞">
<meta property="og:type" content="article">
<meta property="og:title" content="JVM垃圾收集">
<meta property="og:url" content="https://hulingf.github.io/2024/03/09/JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/index.html">
<meta property="og:site_name" content="大军的秘密花园">
<meta property="og:description" content="JVM垃圾收集为什么需要垃圾回收想要学习GC，首先需要理解为什么需要GC？  对于高级语言来说，一个基本认知是如果不进行垃圾回收，内存迟早都会被消耗完，因为不断地分配内存空间而不进行回收，就好像不停地生产生活垃圾而从来不打扫一样。 除了释放没用的对象，垃圾回收也可以清除内存里的记录碎片。碎片整理将所占用的堆内存移到堆的一端，以便JVM将整理出的内存分配给新的对象。 随着应用程序所应付的业务越来越庞">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://hulingf.github.io/imgs/JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/image-20240310170338438.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/image-20240310171821691.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/image-20240310174936719.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/image-20240310175618271.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/image-20240310173051473.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/image-20240310173519912.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/image-20240310181110325.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/image-20240310185655702.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/image-20240310190633085.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/image-20240310221945619.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/image-20240310222118218.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/image-20240310222311885.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/image-20240310222516256.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/image-20240310222640915.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/image-20240310222902142.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/image-20240310223040257.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/image-20240311093946543.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/image-20240311100222550.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/image-20240311101831530.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/image-20240311102551871.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/image-20240311103428494.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/%E7%AC%AC17%E7%AB%A0_%E7%BB%8F%E5%85%B8%E7%9A%847%E7%A7%8DGC.jpg">
<meta property="og:image" content="https://hulingf.github.io/imgs/JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/%E7%AC%AC17%E7%AB%A0_%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E7%BB%84%E5%90%88.jpg">
<meta property="og:image" content="https://hulingf.github.io/imgs/JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/image-20240311152105460.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/image-20240311152259165.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/image-20240311193747239.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/image-20240311195439721.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/image-20240315155523987.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/image-20240315160242801.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/image-20240315165414382.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/image-20240317200906382.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/image-20240317202611902.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/image-20240317212404469.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/image-20240412123427125.png">
<meta property="article:published_time" content="2024-03-09T12:00:02.891Z">
<meta property="article:modified_time" content="2024-04-12T04:36:08.952Z">
<meta property="article:author" content="hulingF">
<meta property="article:tag" content="JVM">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://hulingf.github.io/imgs/JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/image-20240310170338438.png">
    
    
      
        
          <link rel="shortcut icon" href="/images/favicon.ico">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
        
      
    
    <!-- title -->
    <title>JVM垃圾收集</title>
    <!-- async scripts -->
    <!-- Google Analytics -->


    <!-- Umami Analytics -->


    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
    <!-- rss -->
    
    
	<!-- mathjax -->
	
<meta name="generator" content="Hexo 6.3.0"></head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#" aria-label="Menu"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#" aria-label="Menu"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" aria-label="Top" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa-solid fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
        <!--
       --><li><a href="/">Home</a></li><!--
     --><!--
       --><li><a href="/about/">About</a></li><!--
     --><!--
       --><li><a href="/archives/">Writing</a></li><!--
     --><!--
       --><li><a href="/tags/">Tag</a></li><!--
     --><!--
       --><li><a target="_blank" rel="noopener" href="http://github.com/hulingF">Projects</a></li><!--
     -->
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" aria-label="Previous post" href="/2024/03/23/Redis%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"><i class="fa-solid fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" aria-label="Next post" href="/2024/03/04/MySQL%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB%E9%9A%94%E7%A6%BB%E7%AD%89%E7%BA%A7%E4%B8%8B%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%B9%BB%E8%AF%BB%E9%97%AE%E9%A2%98/"><i class="fa-solid fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" aria-label="Back to top" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" aria-label="Share post" href="#"><i class="fa-solid fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://hulingf.github.io/2024/03/09/JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://hulingf.github.io/2024/03/09/JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/&text=JVM垃圾收集"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://hulingf.github.io/2024/03/09/JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/&title=JVM垃圾收集"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://hulingf.github.io/2024/03/09/JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/&is_video=false&description=JVM垃圾收集"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=JVM垃圾收集&body=Check out this article: https://hulingf.github.io/2024/03/09/JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/"><i class="fa-solid fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://hulingf.github.io/2024/03/09/JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/&title=JVM垃圾收集"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://hulingf.github.io/2024/03/09/JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/&title=JVM垃圾收集"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://hulingf.github.io/2024/03/09/JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/&title=JVM垃圾收集"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://hulingf.github.io/2024/03/09/JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/&title=JVM垃圾收集"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://hulingf.github.io/2024/03/09/JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/&name=JVM垃圾收集&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://hulingf.github.io/2024/03/09/JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/&t=JVM垃圾收集"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    
    
      <div id="toc">
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86"><span class="toc-number">1.</span> <span class="toc-text">JVM垃圾收集</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="toc-number">1.1.</span> <span class="toc-text">为什么需要垃圾回收</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%A9%E6%9C%9F%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6"><span class="toc-number">1.2.</span> <span class="toc-text">早期垃圾回收机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6"><span class="toc-number">1.3.</span> <span class="toc-text">Java垃圾回收机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95"><span class="toc-number">1.4.</span> <span class="toc-text">垃圾回收相关算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E8%AE%B0%E9%98%B6%E6%AE%B5%E7%9A%84%E7%9B%AE%E7%9A%84"><span class="toc-number">1.4.1.</span> <span class="toc-text">标记阶段的目的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E8%AE%B0%E9%98%B6%E6%AE%B5%EF%BC%9A%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E7%AE%97%E6%B3%95"><span class="toc-number">1.4.2.</span> <span class="toc-text">标记阶段：引用计数算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E8%AE%B0%E9%98%B6%E6%AE%B5%EF%BC%9A%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90%E7%AE%97%E6%B3%95"><span class="toc-number">1.4.3.</span> <span class="toc-text">标记阶段：可达性分析算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84finalize%E6%9C%BA%E5%88%B6"><span class="toc-number">1.4.4.</span> <span class="toc-text">对象的finalize机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E4%BB%A3%E6%94%B6%E9%9B%86%E7%90%86%E8%AE%BA"><span class="toc-number">1.4.5.</span> <span class="toc-text">分代收集理论</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B8%85%E9%99%A4%E9%98%B6%E6%AE%B5%EF%BC%9A%E6%A0%87%E8%AE%B0-%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95"><span class="toc-number">1.4.6.</span> <span class="toc-text">清除阶段：标记-清除算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B8%85%E9%99%A4%E9%98%B6%E6%AE%B5%EF%BC%9A%E6%A0%87%E8%AE%B0-%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95"><span class="toc-number">1.4.7.</span> <span class="toc-text">清除阶段：标记-复制算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B8%85%E9%99%A4%E9%98%B6%E6%AE%B5%EF%BC%9A%E6%A0%87%E8%AE%B0-%E6%95%B4%E7%90%86%E7%AE%97%E6%B3%95"><span class="toc-number">1.4.8.</span> <span class="toc-text">清除阶段：标记-整理算法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5"><span class="toc-number">1.5.</span> <span class="toc-text">垃圾回收相关概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#System-gc-%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">1.5.1.</span> <span class="toc-text">System.gc()的理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#STW%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">1.5.2.</span> <span class="toc-text">STW的理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%8D%E8%B0%88%E5%BC%95%E7%94%A8%E6%A6%82%E8%BF%B0"><span class="toc-number">1.5.3.</span> <span class="toc-text">再谈引用概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%8D%E8%B0%88%E5%BC%95%E7%94%A8%EF%BC%9A%E5%BC%BA%E5%BC%95%E7%94%A8"><span class="toc-number">1.5.4.</span> <span class="toc-text">再谈引用：强引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%8D%E8%B0%88%E5%BC%95%E7%94%A8%EF%BC%9A%E8%BD%AF%E5%BC%95%E7%94%A8"><span class="toc-number">1.5.5.</span> <span class="toc-text">再谈引用：软引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%8D%E8%B0%88%E5%BC%95%E7%94%A8%EF%BC%9A%E5%BC%B1%E5%BC%95%E7%94%A8"><span class="toc-number">1.5.6.</span> <span class="toc-text">再谈引用：弱引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%8D%E8%B0%88%E5%BC%95%E7%94%A8%EF%BC%9A%E8%99%9A%E5%BC%95%E7%94%A8"><span class="toc-number">1.5.7.</span> <span class="toc-text">再谈引用：虚引用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8"><span class="toc-number">1.6.</span> <span class="toc-text">垃圾回收器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7%E6%AC%BE%E7%BB%8F%E5%85%B8%E7%9A%84%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">1.6.1.</span> <span class="toc-text">7款经典的垃圾收集器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E7%9A%84%E7%BB%84%E5%90%88%E5%85%B3%E7%B3%BB"><span class="toc-number">1.6.2.</span> <span class="toc-text">垃圾收集器的组合关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Serial%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">1.6.3.</span> <span class="toc-text">Serial收集器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ParNew%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">1.6.4.</span> <span class="toc-text">ParNew收集器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Parallel-Scavenge%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">1.6.5.</span> <span class="toc-text">Parallel Scavenge收集器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Serial-Old%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">1.6.6.</span> <span class="toc-text">Serial Old收集器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Parallel-Old%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">1.6.7.</span> <span class="toc-text">Parallel Old收集器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CMS%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">1.6.8.</span> <span class="toc-text">CMS收集器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#G1%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">1.6.9.</span> <span class="toc-text">G1收集器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8ERegion%E7%9A%84%E5%8C%BA%E5%9F%9F%E5%88%86%E4%BB%A3"><span class="toc-number">1.6.9.1.</span> <span class="toc-text">基于Region的区域分代</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E9%A2%84%E6%B5%8B%E7%9A%84%E5%81%9C%E9%A1%BF%E6%97%B6%E9%97%B4%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.6.9.2.</span> <span class="toc-text">可预测的停顿时间模型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E8%BF%87%E7%A8%8B"><span class="toc-number">1.6.9.3.</span> <span class="toc-text">垃圾收集过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A9%BA%E9%97%B4%E6%95%B4%E5%90%88"><span class="toc-number">1.6.9.4.</span> <span class="toc-text">空间整合</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%AD%A5%E9%AA%A4"><span class="toc-number">1.6.9.5.</span> <span class="toc-text">使用步骤</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E5%90%88%E9%80%82%E7%9A%84%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">1.6.10.</span> <span class="toc-text">选择合适的垃圾收集器</span></a></li></ol></li></ol></li></ol>
      </div>
    
  </span>
</div>

    
    <div class="content index py4 ">
        
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle p-name" itemprop="name headline">
        JVM垃圾收集
    </h1>



    <div class="meta">
      <span class="author p-author h-card" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span class="p-name" itemprop="name">hulingF</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2024-03-09T12:00:02.891Z" class="dt-published" itemprop="datePublished">2024-03-09</time>
        
      
    </div>


      

      
    <div class="article-tag">
        <i class="fa-solid fa-tag"></i>
        <a class="p-category" href="/tags/JVM/" rel="tag">JVM</a>
    </div>


    </div>
  </header>
  

  <div class="content e-content" itemprop="articleBody">
    <h1 id="JVM垃圾收集"><a href="#JVM垃圾收集" class="headerlink" title="JVM垃圾收集"></a>JVM垃圾收集</h1><h2 id="为什么需要垃圾回收"><a href="#为什么需要垃圾回收" class="headerlink" title="为什么需要垃圾回收"></a>为什么需要垃圾回收</h2><p><strong>想要学习GC，首先需要理解为什么需要GC？</strong></p>
<ol>
<li>对于高级语言来说，一个基本认知是如果不进行垃圾回收，<code>内存迟早都会被消耗完</code>，因为不断地分配内存空间而不进行回收，就好像不停地生产生活垃圾而从来不打扫一样。</li>
<li>除了释放没用的对象，垃圾回收也可以清除内存里的记录碎片。碎片整理将所占用的堆内存移到堆的一端，<code>以便JVM将整理出的内存分配给新的对象</code>。</li>
<li>随着应用程序所应付的业务越来越庞大、复杂，用户越来越多，没有GC就不能保证应用程序的正常进行。而经常造成STW的GC又跟不上实际的需求，所以才会不断地尝试对GC进行优化。</li>
</ol>
<h2 id="早期垃圾回收机制"><a href="#早期垃圾回收机制" class="headerlink" title="早期垃圾回收机制"></a>早期垃圾回收机制</h2><p>在早期的C&#x2F;C++时代，垃圾回收基本上是手工进行的。开发人员可以使用new关键字进行内存申请，并使用delete关键字进行内存释放。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MibBridge *pBridge= <span class="keyword">new</span> cmBaseGroupBridge（）；</span><br><span class="line"><span class="comment">//如果注册失败，使用Delete释放该对象所占内存区域</span></span><br><span class="line"><span class="keyword">if</span>（pBridge-&gt;Register（kDestroy）！= NO ERROR）</span><br><span class="line">  <span class="keyword">delete</span> pBridge；</span><br></pre></td></tr></table></figure>

<p>这种方式可以灵活控制内存释放的时间，但是会给开发人员带来<strong>频繁申请和释放内存的管理负担</strong>。倘若有一处内存区间由于程序员编码的问题忘记被回收，那么就会产生<strong>内存泄漏</strong>，垃圾对象永远无法被清除，随着系统运行时间的不断增长，垃圾对象所耗内存可能持续上升，直到出现内存溢出并造成<strong>应用程序崩溃</strong>。</p>
<p>有了垃圾回收机制后，上述代码极有可能变成这样</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MibBridge *pBridge = <span class="keyword">new</span> <span class="built_in">cmBaseGroupBridge</span>(); </span><br><span class="line">pBridge-&gt;<span class="built_in">Register</span>(kDestroy);</span><br></pre></td></tr></table></figure>

<p>现在，除了Java以外，C#、Python、Ruby等语言都使用了自动垃圾回收的思想，也是未来发展趋势，可以说这种自动化的内存分配和垃圾回收方式已经成为了现代开发语言必备的标准。</p>
<h2 id="Java垃圾回收机制"><a href="#Java垃圾回收机制" class="headerlink" title="Java垃圾回收机制"></a>Java垃圾回收机制</h2><p><strong>自动内存管理的优点</strong></p>
<ol>
<li>自动内存管理，无需开发人员手动参与内存的分配与回收，这样降低内存泄漏和内存溢出的风险。</li>
<li>没有垃圾回收器，Java也会和C++一样，各种悬垂指针，野指针，泄露问题让你头疼不已。</li>
<li>自动内存管理机制，<code>将程序员从繁重的内存管理中释放出来</code>，可以更专心地专注于业务开发。</li>
</ol>
<p><strong>关于自动内存管理的担忧</strong></p>
<ol>
<li>对于Java开发人员而言，自动内存管理就像是一个黑匣子，如果过度依赖于“自动”，那么这将会是一场灾难，最严重的就会<strong>弱化Java开发人员在程序出现内存溢出时定位问题和解决问题的能力</strong>。</li>
<li>此时，了解JVM的自动内存分配和内存回收原理就显得非常重要，只有在真正了解JVM是如何管理内存后，我们才能够在遇见<code>OutofMemoryError</code>时，快速地根据错误异常日志定位问题和解决问题。</li>
<li>当需要排查各种内存溢出、内存泄漏问题时，当垃圾收集成为系统达到更高并发量的瓶颈时，我们就必须对这些“自动化”的技术<strong>实施必要的监控和调节</strong>。</li>
</ol>
<blockquote>
<p>频繁收集年轻代，较少收集老年代，基本不动方法区！</p>
</blockquote>
<h2 id="垃圾回收相关算法"><a href="#垃圾回收相关算法" class="headerlink" title="垃圾回收相关算法"></a>垃圾回收相关算法</h2><h3 id="标记阶段的目的"><a href="#标记阶段的目的" class="headerlink" title="标记阶段的目的"></a>标记阶段的目的</h3><p>垃圾标记阶段：<code>主要是为了判断对象是否存活</code></p>
<ol>
<li>在堆里存放着几乎所有的Java对象实例，在GC执行垃圾回收之前，首先需要区分出内存中哪些是存活对象，哪些是已经死亡的对象。只有被标记为己经死亡的对象，GC才会在执行垃圾回收时，释放掉其所占用的内存空间，因此这个过程我们可以称为垃圾标记阶段。</li>
<li>那么在JVM中究竟是如何标记一个死亡对象呢？<strong>简单来说，当一个对象已经不再被任何的存活对象继续引用时，就可以宣判为已经死亡。</strong></li>
<li>判断对象存活一般有两种方式：<code>引用计数算法</code>和<code>可达性分析算法</code>。</li>
</ol>
<h3 id="标记阶段：引用计数算法"><a href="#标记阶段：引用计数算法" class="headerlink" title="标记阶段：引用计数算法"></a>标记阶段：引用计数算法</h3><p>很多教科书判断对象是否存活的算法是这样的：在对象中添加一个<code>引用计数器</code>，每当有一个地方引用它时，计数器值就加一；当引用失效时，计数器值就减一；任何时刻计数器为零的对象就是不可能再被使用的。笔者面试过很多应届生和一些有多年工作经验的开发人员，他们对于这个问题给予的都是这个答案。</p>
<p>客观地说，引用计数算法（Reference Counting）虽然<code>占用了一些额外的内存空间</code>来进行计数，但它的<code>原理简单</code>，<code>判定效率也很高</code>，在大多数情况下它都是一个不错的算法。也有一些比较著名的应用案例，例如微软COM（Component Object Model）技术、使用ActionScript 3的FlashPlayer、Python语言以及在游戏脚本领域得到许多应用的Squirrel中都使用了引用计数算法进行内存管理。但是，在Java领域，至少主流的Java虚拟机里面都没有选用引用计数算法来管理内存，主要原因是，这个看似简单的算法有很多例外情况要考虑，必须要配合大量额外处理才能保证正确地工作，譬如单纯的引用计数就很难解决对象之间相互<code>循环引用</code>的问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * -XX:+PrintGCDetails</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloReferenceCounter</span> &#123;</span><br><span class="line">    <span class="comment">//这个成员属性唯一的作用就是占用一点内存</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">byte</span>[] bigSize = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">5</span> * <span class="number">1024</span> * <span class="number">1024</span>];<span class="comment">//5MB</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">reference</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">HelloReferenceCounter</span> <span class="variable">obj1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HelloReferenceCounter</span>();</span><br><span class="line">        <span class="type">HelloReferenceCounter</span> <span class="variable">obj2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HelloReferenceCounter</span>();</span><br><span class="line">        obj1.reference = obj2;</span><br><span class="line">        obj2.reference = obj1;</span><br><span class="line"></span><br><span class="line">        obj1 = <span class="literal">null</span>;</span><br><span class="line">        obj2 = <span class="literal">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/imgs/JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/image-20240310170338438.png" alt="image-20240310170338438"></p>
<p>从运行结果中可以清楚看到内存回收日志中包含“18042K-&gt;872K”，意味着虚拟机并没有因为这两个对象互相引用就放弃回收它们，这也从侧面说明了Java虚拟机并不是通过引用计数算法来判断对象是否存活的。</p>
<p>Python如何解决循环引用？</p>
<ul>
<li><code>手动解除</code>：在不需要使用对象时，手动将对象的引用断开，使其成为垃圾对象。这种方法需要开发者手动维护引用关系，不够灵活和方便，也容易出现遗漏。</li>
<li><code>使用弱引用weakref</code>，weakref是Python提供的标准库，旨在解决循环引用。</li>
<li>使用<code>gc模块</code>：gc模块是Python内置的垃圾回收机制，通过手动设置<code>gc.enable()</code>和<code>gc.disable()</code>，可以启用或禁用垃圾回收器，从而解决循环引用问题。但是，这种方法需要开发者手动管理垃圾回收器，容易出现不必要的性能损失。</li>
</ul>
<h3 id="标记阶段：可达性分析算法"><a href="#标记阶段：可达性分析算法" class="headerlink" title="标记阶段：可达性分析算法"></a>标记阶段：可达性分析算法</h3><p>当前主流的商用程序语言（Java、C#，上溯至前面提到的古老的Lisp）的内存管理子系统，都是通过可达性分析（Reachability Analysis）算法来判定对象是否存活的。这个算法的基本思路就是通过一系列称为<code>“GC Roots”</code>的根对象作为<code>起始节点集</code>，从这些节点开始，根据引用关系向下搜索，搜索过程所走过的路径称为“引用链”（Reference Chain），如果某个对象到GC Roots间没有任何引用链相连，或者用图论的话来说就是从GC Roots到这个对象不可达时，则证明此对象是不可能再被使用的。</p>
<p><img src="/imgs/JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/image-20240310171821691.png" alt="image-20240310171821691"></p>
<p><strong>GC Roots可以是哪些元素？</strong></p>
<ol>
<li>在虚拟机栈（栈帧中的本地变量表）中引用的对象，譬如各个线程被调用的方法栈中使用到的参数、局部变量、临时变量等。</li>
<li>本地方法栈内JNI（通常说的本地方法）引用的对象</li>
<li>方法区中类静态属性引用的对象，比如：Java类的引用类型静态变量</li>
<li>方法区中常量引用的对象，比如：字符串常量池（StringTable）里的引用</li>
<li>所有被同步锁synchronized持有的对象</li>
<li>Java虚拟机内部的引用，基本数据类型对应的Class对象，一些常驻的异常对象（如：NullPointerException、OutofMemoryError），系统类加载器。</li>
<li>反映Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。</li>
</ol>
<p>除了这些固定的GC Roots集合以外，根据用户所选用的垃圾收集器以及当前回收的内存区域不同，还可以有<code>其他对象“临时性”地加入</code>，共同构成完整GC Roots集合。譬如后文将会提到的分代收集和局部回收（Partial GC），如果只针对Java堆中某一块区域发起垃圾收集时（如最典型的只针对新生代的垃圾收集），必须考虑到内存区域是虚拟机自己的实现细节（在用户视角里任何内存区域都是不可见的），更不是孤立封闭的，所以某个区域里的对象完全有可能被位于堆中其他区域的对象所引用，这时候就需要将这些关联区域的对象也一并加入GC Roots集合中去，才能保证可达性分析的正确性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloGCRoots</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;Object&gt; numList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">Date</span> <span class="variable">birth</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            numList.add(String.valueOf(i));</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">10</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;数据添加完毕，请操作：&quot;</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in).next();</span><br><span class="line">        numList = <span class="literal">null</span>;</span><br><span class="line">        birth = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;numList、birth已置空，请操作：&quot;</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in).next();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/imgs/JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/image-20240310174936719.png" alt="image-20240310174936719"></p>
<p>当numList、birth已置空时，再次查看对应的堆dump文件，发现GC Roots中main线程中的这两个变量已经不见：</p>
<p><img src="/imgs/JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/image-20240310175618271.png" alt="image-20240310175618271"></p>
<h3 id="对象的finalize机制"><a href="#对象的finalize机制" class="headerlink" title="对象的finalize机制"></a>对象的finalize机制</h3><p>即使在可达性分析算法中判定为不可达的对象，也不是“非死不可”的，这时候它们暂时还处于“缓刑”阶段，要真正宣告一个对象死亡，至少要经历<code>两次标记</code>过程：如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它将会被<code>第一次标记</code>，随后进行一次筛选，筛选的条件是此对象是否<code>有必要执行finalize()方法</code>。<strong>假如对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用过，那么虚拟机将这两种情况都视为“没有必要执行”。</strong></p>
<p>如果这个对象被判定为确有必要执行finalize()方法，那么该对象将会被放置在一个名为<code>F-Queue</code>的队列之中，并在稍后由一条由虚拟机自动建立的、低调度优先级的<code>Finalizer</code>线程去执行它们的finalize()方法。这里所说的“执行”是指虚拟机会触发这个方法开始运行，但并不承诺一定会等待它运行结束。这样做的原因是，如果某个对象的finalize()方法执行缓慢，或者更极端地发生了死循环，将很可能导致F-Queue队列中的其他对象永久处于等待，甚至导致整个内存回收子系统的崩溃。finalize()方法是对象逃脱死亡命运的最后一次机会，稍后收集器将对F-Queue中的对象进行<code>第二次小规模的标记</code>，如果对象要在finalize()中成功拯救自己——只要重新与引用链上的任何一个对象建立关联即可，譬如把自己（this关键字）赋值给某个类变量或者对象的成员变量，那在第二次标记时它将被移出“即将回收”的集合；如果对象这时候还没有逃脱，那基本上它就真的要被回收了。</p>
<p><img src="/imgs/JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/image-20240310173051473.png" alt="image-20240310173051473"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloFinalizer</span> &#123;</span><br><span class="line">    <span class="comment">// 类静态变量，属于GC Root集合</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Object obj;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// finalize方法只能被调用一次</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="built_in">super</span>.finalize();</span><br><span class="line">        System.out.println(<span class="string">&quot;调用当前类重写的finalize()方法&quot;</span>);</span><br><span class="line">        <span class="comment">// 当前待回收的对象在finalize()方法中与引用链上的一个对象obj建立了联系</span></span><br><span class="line">        obj = <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            obj = <span class="keyword">new</span> <span class="title class_">HelloFinalizer</span>();</span><br><span class="line">            <span class="comment">// 对象第一次成功拯救自己</span></span><br><span class="line">            obj = <span class="literal">null</span>;</span><br><span class="line">            System.gc();</span><br><span class="line">            System.out.println(<span class="string">&quot;第1次 gc&quot;</span>);</span><br><span class="line">            <span class="comment">// 因为Finalizer线程优先级很低，暂停2秒，以等待它</span></span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            <span class="keyword">if</span> (obj == <span class="literal">null</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;obj is dead&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;obj is still alive&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;第2次 gc&quot;</span>);</span><br><span class="line">            <span class="comment">// 下面这段代码与上面的完全相同，但是这次自救却失败了</span></span><br><span class="line">            obj = <span class="literal">null</span>;</span><br><span class="line">            System.gc();</span><br><span class="line">            <span class="comment">// 因为Finalizer线程优先级很低，暂停2秒，以等待它</span></span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            <span class="keyword">if</span> (obj == <span class="literal">null</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;obj is dead&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;obj is still alive&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/imgs/JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/image-20240310173519912.png" alt="image-20240310173519912"></p>
<p>代码中有两段完全一样的代码片段，执行结果却是一次逃脱成功，一次失败了。这是因为任何一个对象的finalize()方法都<code>只会被系统自动调用一次</code>，如果对象面临下一次回收，它的finalize()方法不会被再次执行，因此第二段代码的自救行动失败了。</p>
<p>还有一点需要特别说明，上面关于对象死亡时finalize()方法的描述可能带点悲情的艺术加工，笔者并不鼓励大家使用这个方法来拯救对象。相反，笔者建议大家<code>尽量避免使用它</code>，因为它并不能等同于C和C++语言中的析构函数，而是Java刚诞生时为了使传统C、C++程序员更容易接受Java所做出的一项妥协。它的<code>运行代价高昂</code>，<code>不确定性大</code>，<code>无法保证各个对象的调用顺序</code>，如今已被官方明确声明为<code>不推荐使用的语法</code>。有些教材中描述它适合做“关闭外部资源”之类的清理性工作，这完全是对finalize()方法用途的一种自我安慰。finalize()能做的所有工作，使用try-finally或者其他方式都可以做得更好、更及时，所以笔者建议大家完全可以忘掉Java语言里面的这个方法。</p>
<h3 id="分代收集理论"><a href="#分代收集理论" class="headerlink" title="分代收集理论"></a>分代收集理论</h3><p>当前商业虚拟机的垃圾收集器，大多数都遵循了“分代收集”（Generational Collection）的理论进行设计，分代收集名为理论，实质是一套符合大多数程序运行实际情况的经验法则，它建立在两个分代假说之上：</p>
<ul>
<li><code>弱分代假说（Weak Generational Hypothesis）：绝大多数对象都是朝生夕灭的</code>。</li>
<li><code>强分代假说（Strong Generational Hypothesis）：熬过越多次垃圾收集过程的对象就越难以消亡</code>。</li>
</ul>
<p>这两个分代假说共同奠定了多款常用的垃圾收集器的一致的设计原则：收集器应该将Java堆划分出不同的区域，然后将回收对象依据其年龄（年龄即对象熬过垃圾收集过程的次数）分配到不同的区域之中存储。显而易见，如果一个区域中大多数对象都是朝生夕灭，难以熬过垃圾收集过程的话，那么把它们集中放在一起，每次回收时只关注如何保留少量存活而不是去标记那些大量将要被回收的对象，就能以较低代价回收到大量的空间；如果剩下的都是难以消亡的对象，那把它们集中放在一块，虚拟机便可以使用较低的频率来回收这个区域，这就同时兼顾了垃圾收集的时间开销和内存的空间有效利用。</p>
<p>假如要现在进行一次只局限于新生代区域内的收集（Minor GC），但新生代中的对象是完全有可能被老年代所引用的，为了找出该区域中的存活对象，不得不在固定的GC Roots之外，再额外遍历整个老年代中所有对象来确保可达性分析结果的正确性，反过来也是一样。遍历整个老年代所有对象的方案虽然理论上可行，但无疑会为内存回收带来很大的性能负担。为了解决这个问题，就需要对分代收集理论添加第三条经验法则：</p>
<ul>
<li><code>跨代引用假说（Intergenerational Reference Hypothesis）：跨代引用相对于同代引用来说仅占极少数</code>。</li>
</ul>
<p>这其实是可根据前两条假说逻辑推理得出的隐含推论：存在互相引用关系的两个对象，是应该倾向于同时生存或者同时消亡的。举个例子，如果某个新生代对象存在跨代引用，由于老年代对象难以消亡，该引用会使得新生代对象在收集时同样得以存活，进而在年龄增长之后晋升到老年代中，这时跨代引用也随即被消除了。</p>
<p>依据这条假说，我们就不应再为了少量的跨代引用去扫描整个老年代，也不必浪费空间专门记录每一个对象是否存在及存在哪些跨代引用，只需在新生代上建立一个<code>全局的数据结构</code>（该结构被称为“记忆集”，<code>Remembered Set</code>），这个结构<code>把老年代划分成若干小块</code>，标识出老年代的哪一块内存会存在跨代引用。此后当发生Minor GC时，只有包含了跨代引用的小块内存里的对象才会被加入到GC Roots进行扫描。<strong>虽然这种方法需要在对象改变引用关系（如将自己或者某个属性赋值）时维护记录数据的正确性，会增加一些运行时的开销，但比起收集时扫描整个老年代来说仍然是划算的。</strong></p>
<h3 id="清除阶段：标记-清除算法"><a href="#清除阶段：标记-清除算法" class="headerlink" title="清除阶段：标记-清除算法"></a>清除阶段：标记-清除算法</h3><p>当成功区分出内存中存活对象和死亡对象后，GC接下来的任务就是执行垃圾回收，释放掉无用对象所占用的内存空间，以便有足够的可用内存空间为新对象分配内存。</p>
<p>标记-清除算法（Mark-Sweep）是一种非常基础和常见的垃圾收集算法，该算法被J.McCarthy等人在1960年提出并并应用于Lisp语言。</p>
<p>当堆中的有效内存空间被耗尽的时候，就会停止整个程序（也被称为STW），然后进行两项工作，第一项则是标记，第二项则是清除：</p>
<ol>
<li>标记：Collector<code>从引用根节点开始遍历</code>，标记所有被引用的对象。一般是在对象的Header中记录为可达对象。<ul>
<li>注意：<strong>标记的是被引用的对象，也就是可达对象，并非标记的是即将被清除的垃圾对象</strong></li>
</ul>
</li>
<li>清除：Collector<code>对堆内存从头到尾进行线性的遍历</code>，如果发现某个对象在其Header中没有标记为可达对象，则将其回收。</li>
</ol>
<p><img src="/imgs/JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/image-20240310181110325.png" alt="image-20240310181110325"></p>
<p>之所以说它是最基础的收集算法，是因为后续的收集算法大多都是以标记-清除算法为基础，对其缺点进行改进而得到的。它的主要缺点有两个：第一个是<code>执行效率不稳定</code>，如果Java堆中包含大量对象，而且其中大部分是需要被回收的，这时必须进行大量标记和清除的动作，导致标记和清除两个过程的执行效率都随对象数量增长而降低；第二个是<code>内存空间的碎片化问题</code>，标记、清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致当以后在程序运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。</p>
<h3 id="清除阶段：标记-复制算法"><a href="#清除阶段：标记-复制算法" class="headerlink" title="清除阶段：标记-复制算法"></a>清除阶段：标记-复制算法</h3><p>标记-复制算法常被简称为复制算法。为了解决标记-清除算法面对<code>大量可回收对象时执行效率低</code>的问题，1969年Fenichel提出了一种称为“半区复制”（Semispace Copying）的垃圾收集算法，它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。<strong>如果内存中多数对象都是存活的，这种算法将会产生大量的内存间复制的开销，但对于多数对象都是可回收的情况，算法需要复制的就是占少数的存活对象，而且每次都是针对整个半区进行内存回收，分配内存时也就不用考虑有空间碎片的复杂情况，只要移动堆顶指针，按顺序分配即可。</strong>这样实现简单，运行高效，不过其缺陷也显而易见，这种复制回收算法的代价是<code>将可用内存缩小为了原来的一半，空间浪费未免太多了一点</code>。</p>
<p><img src="/imgs/JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/image-20240310185655702.png" alt="image-20240310185655702"></p>
<p>现在的商用Java虚拟机大多都优先采用了这种收集算法去回收新生代，IBM公司曾有一项专门研究对新生代“朝生夕灭”的特点做了更量化的诠释——<strong>新生代中的对象有98%熬不过第一轮收集</strong>。因此 并不需要按照1∶1的比例来划分新生代的内存空间。</p>
<p>在1989年，Andrew Appel针对具备“朝生夕灭”特点的对象，提出了一种更优化的半区复制分代策略，现在称为“Appel式回收”。HotSpot虚拟机的Serial、ParNew等新生代收集器均采用了这种策略来设计新生代的内存布局。Appel式回收的具体做法是<code>把新生代分为一块较大的Eden空间和两块较小的Survivor空间</code>，每次分配内存只使用Eden和其中一块Survivor。发生垃圾收集时，将Eden和Survivor中仍然存活的对象一次性复制到另外一块Survivor空间上，然后直接清理掉Eden和已用过的那块Survivor空间。HotSpot虚拟机默认Eden和Survivor的大小比例是<code>8∶1</code>，也即每次新生代中可用内存空间为整个新生代容量的90%（Eden的80%加上一个Survivor的10%），只有一个Survivor空间，即10%的新生代是会被“浪费”的。当然，98%的对象可被回收仅仅是“普通场景”下测得的数据，任何人都没有办法百分百保证每次回收都只有不多于10%的对象存活，因此Appel式回收还有一个<code>充当罕见情况的“逃生门”的安全设计</code>，当Survivor空间不足以容纳一次Minor GC之后存活的对象时，就需要依赖其他内存区域（实际上大多就是老年代）进行<code>分配担保（Handle Promotion）</code>。</p>
<h3 id="清除阶段：标记-整理算法"><a href="#清除阶段：标记-整理算法" class="headerlink" title="清除阶段：标记-整理算法"></a>清除阶段：标记-整理算法</h3><p>标记-复制算法在<code>对象存活率较高时就要进行较多的复制操作</code>，效率将会降低。更关键的是，如果不想浪费50%的空间，就需要有额外的空间进行<code>分配担保</code>，以应对被使用的内存中所有对象都100%存活的极端情况，所以在老年代一般不能直接选用这种算法。</p>
<p>针对老年代对象的存亡特征，1974年Edward Lueders提出了另外一种有针对性的“标记-整理”（Mark-Compact）算法，其中的标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向内存空间一端移动，然后直接清理掉边界以外的内存。</p>
<p>标记-清除算法与标记-整理算法的本质差异在于<code>前者是一种非移动式的回收算法，而后者是移动式的</code>。是否移动回收后的存活对象是一项优缺点并存的风险决策：</p>
<p><img src="/imgs/JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/image-20240310190633085.png" alt="image-20240310190633085"></p>
<p><strong>如果移动存活对象，尤其是在老年代这种每次回收都有大量对象存活区域，移动存活对象并更新所有引用这些对象的地方将会是一种极为负重的操作，而且这种对象移动操作必须全程暂停用户应用程序才能进行，这就更加让使用者不得不小心翼翼地权衡其弊端了</strong>，像这样的停顿被最初的虚拟机设计者形象地描述为“Stop The World”。</p>
<p>但如果跟标记-清除算法那样完全不考虑移动和整理存活对象的话，弥散于堆中的存活对象导致的空间碎片化问题就只能依赖更为复杂的内存分配器和内存访问器来解决。譬如通过“分区空闲分配链表”来解决内存分配问题（计算机硬盘存储大文件就不要求物理连续的磁盘空间，能够在碎片化的硬盘上存储和访问就是通过硬盘分区表实现的）。内存的访问是用户程序最频繁的操作，甚至都没有之一，假如在这个环节上增加了额外的负担，势必会直接影响应用程序的吞吐量。</p>
<p>基于以上两点，是否移动对象都存在弊端，<code>移动则内存回收时会更复杂，不移动则内存分配时会更复杂</code>。<code>从垃圾收集的停顿时间来看，不移动对象停顿时间会更短，甚至可以不需要停顿，但是从整个程序的吞吐量来看，移动对象会更划算</code>。此语境中，吞吐量的实质是赋值器（Mutator，可以理解为使用垃圾收集的用户程序）与收集器的效率总和。即使不移动对象会使得收集器的效率提升一些，但因内存分配和访问相比垃圾收集频率要高得多，这部分的耗时增加，总吞吐量仍然是下降的。<strong>HotSpot虚拟机里面关注吞吐量的Parallel Scavenge收集器是基于标记-整理算法的，而关注延迟的CMS收集器则是基于标记-清除算法的，这也从侧面印证这点。</strong></p>
<blockquote>
<p>另外，还有一种“和稀泥式”解决方案可以不在内存分配和访问上增加太大额外负担，做法是让虚拟机平时多数时间都采用标记-清除算法，暂时容忍内存碎片的存在，直到内存空间的碎片化程度已经大到影响对象分配时，再采用标记-整理算法收集一次，以获得规整的内存空间。前面提到的基于标记-清除算法的CMS收集器面临空间碎片过多时采用的就是这种处理办法。</p>
</blockquote>
<h2 id="垃圾回收相关概念"><a href="#垃圾回收相关概念" class="headerlink" title="垃圾回收相关概念"></a>垃圾回收相关概念</h2><h3 id="System-gc-的理解"><a href="#System-gc-的理解" class="headerlink" title="System.gc()的理解"></a>System.gc()的理解</h3><ol>
<li>在默认情况下，通过System.gc()者Runtime.getRuntime().gc()的调用，会显式触发<code>Full GC</code>，同时对老年代和新生代包括方法区进行回收，尝试释放被丢弃对象占用的内存。</li>
<li>然而System.gc()调用附带一个<code>免责声明</code>，无法保证对垃圾收集器的调用(不能确保立即生效)。</li>
<li>JVM实现者可以通过System.gc()调用来决定JVM的GC行为。<strong>而一般情况下，垃圾回收应该是自动进行的，无须手动触发</strong>，否则就太过于麻烦了。在一些特殊情况下，如我们正在编写一个<code>性能基准</code>，我们可以在运行之间调用System.gc()</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LocalVarGC</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">localVarGC1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">10</span> * <span class="number">1024</span> * <span class="number">1024</span>];<span class="comment">//10MB</span></span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">localVarGC2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">10</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">        buffer = <span class="literal">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">localVarGC3</span><span class="params">()</span> &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">10</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">localVarGC4</span><span class="params">()</span> &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">10</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">localVarGC5</span><span class="params">()</span> &#123;</span><br><span class="line">        localVarGC1();</span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">LocalVarGC</span> <span class="variable">local</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LocalVarGC</span>();</span><br><span class="line">        local.localVarGC1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试<code>localVarGC1</code>的效果，因为buffer变量属于GC Roots集合，因此其关联的数组并不会被GC回收：</p>
<p><img src="/imgs/JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/image-20240310221945619.png" alt="image-20240310221945619"></p>
<p>测试<code>localVarGC2</code>的效果，因为buffer变量指向null，因此数组变成不可达对象，可以被GC回收：</p>
<p><img src="/imgs/JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/image-20240310222118218.png" alt="image-20240310222118218"></p>
<p>测试<code>localVarGC3</code>的效果，因为即使GC发生时已经超出buffer变量作用域了，但是当前栈帧的局部变量表依然保留着buffer引用：</p>
<p><img src="/imgs/JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/image-20240310222311885.png" alt="image-20240310222311885"></p>
<p><img src="/imgs/JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/image-20240310222516256.png" alt="image-20240310222516256"></p>
<blockquote>
<p>局部变量最大槽数为2，即this引用与buffer引用</p>
</blockquote>
<p>测试<code>localVarGC4</code>的效果，因为value变量占据了局部变量表中原buffer变量的位置，因此buffer变量引用的数组也就不可达了，可以被GC回收：</p>
<p><img src="/imgs/JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/image-20240310222640915.png" alt="image-20240310222640915"></p>
<p><img src="/imgs/JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/image-20240310222902142.png" alt="image-20240310222902142"></p>
<p>测试<code>localVarGC5</code>的效果，因为localVarGC1执行完后其线程栈帧便会弹出，自然栈帧内的局部变量表中的buffer变量也就不再属于GC Roots集合了，数组对象也需要被GC回收了：</p>
<p><img src="/imgs/JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/image-20240310223040257.png" alt="image-20240310223040257"></p>
<h3 id="STW的理解"><a href="#STW的理解" class="headerlink" title="STW的理解"></a>STW的理解</h3><ol>
<li>Stop-the-World，简称STW，指的是GC事件发生过程中，会产生应用程序的停顿。<strong>停顿产生时整个应用程序线程都会被暂停，没有任何响应</strong>，有点像卡死的感觉，这个停顿称为STW。</li>
<li>可达性分析算法中枚举根节点（GC Roots）会导致所有Java执行线程停顿，为什么需要停顿所有Java执行线程呢？<ul>
<li>分析工作必须在一个能确保一致性的快照中进行</li>
<li>一致性指整个分析期间整个执行系统看起来像被冻结在某个时间点上</li>
<li><strong>如果出现分析过程中对象引用关系还在不断变化，则分析结果的准确性无法保证</strong></li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloStopTheWorld</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">WorkThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">        List&lt;<span class="type">byte</span>[]&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;<span class="type">byte</span>[]&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; <span class="number">1000</span>;i++)&#123;</span><br><span class="line">                        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">                        list.add(buffer);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span>(list.size() &gt; <span class="number">10000</span>)&#123;</span><br><span class="line">                        list.clear();</span><br><span class="line">                        <span class="comment">//会触发FULL GC，进而会出现STW事件</span></span><br><span class="line">                        System.gc();</span><br><span class="line">                     </span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                ex.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">PrintThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                    <span class="comment">// 每秒打印时间信息</span></span><br><span class="line">                    <span class="type">long</span> <span class="variable">t</span> <span class="operator">=</span> System.currentTimeMillis() - startTime;</span><br><span class="line">                    System.out.println(t / <span class="number">1000</span> + <span class="string">&quot;.&quot;</span> + t % <span class="number">1000</span>);</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                ex.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">WorkThread</span> <span class="variable">w</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WorkThread</span>();</span><br><span class="line">        <span class="type">PrintThread</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintThread</span>();</span><br><span class="line">        w.start();</span><br><span class="line">        p.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查看时间循环打印信息，发现第一次打印相差1.7s，出现了明显的停顿，这就是STW：</p>
<p><img src="/imgs/JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/image-20240311093946543.png" alt="image-20240311093946543"></p>
<h3 id="再谈引用概述"><a href="#再谈引用概述" class="headerlink" title="再谈引用概述"></a>再谈引用概述</h3><p>我们希望能描述这样一类对象：当内存空间还足够时，则能保留在内存中；如果内存空间在进行垃圾收集后还是很紧张，则可以抛弃这些对象。</p>
<p>在JDK1.2版之后，Java对引用的概念进行了扩充，将引用分为：</p>
<ul>
<li>强引用（Strong Reference）</li>
<li>软引用（Soft Reference）</li>
<li>弱引用（Weak Reference）</li>
<li>虚引用（Phantom Reference）</li>
</ul>
<p>这4种引用强度依次逐渐减弱。除强引用外，其他3种引用均可以在<code>java.lang.ref</code>包中找到它们的身影。如下图，显示了这3种引用类型对应的类，开发人员可以在应用程序中直接使用它们。</p>
<p><img src="/imgs/JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/image-20240311100222550.png" alt="image-20240311100222550"></p>
<p>Reference子类中只有终结器引用是包内可见的，其他3种引用类型均为public，可以在应用程序中直接使用:</p>
<ol>
<li>强引用（StrongReference）：最传统的“引用”的定义，是指在程序代码之中普遍存在的引用赋值，即类似“<code>object obj = new Object()</code>”这种引用关系。无论任何情况下，只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象。宁可报OOM，也不会GC强引用。</li>
<li>软引用（SoftReference）：在系统<code>将要发生内存溢出</code>之前，将会把这些对象列入回收范围之中进行第二次回收。如果这次回收后还没有足够的内存，才会抛出内存溢出异常。</li>
<li>弱引用（WeakReference）：被弱引用关联的对象<code>只能生存到下一次垃圾收集之前</code>。当垃圾收集器工作时，无论内存空间是否足够，都会回收掉被弱引用关联的对象。</li>
<li>虚引用（PhantomReference）：一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来获得一个对象的实例。<strong>为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知</strong>。</li>
</ol>
<h3 id="再谈引用：强引用"><a href="#再谈引用：强引用" class="headerlink" title="再谈引用：强引用"></a>再谈引用：强引用</h3><ol>
<li>在Java程序中，最常见的引用类型是强引用（普通系统99%以上都是强引用），也就是我们最常见的普通对象引用，也是<code>默认的引用类型</code>。当在Java语言中使用new操作符创建一个新的对象，并将其赋值给一个变量的时候，这个变量就成为指向该对象的一个强引用。</li>
<li><strong>只要强引用的对象是可触及的，垃圾收集器就永远不会回收掉被引用的对象。</strong>只要强引用的对象是可达的，JVM宁可报OOM，也不会回收强引用。</li>
<li>对于一个普通的对象，如果没有其他的引用关系，只要超过了引用的作用域或者显式地将相应（强）引用赋值为null，就是可以当做垃圾被收集了，当然具体回收时机还是要看垃圾收集策略。</li>
<li>相对的，软引用、弱引用和虚引用的对象是软可触及、弱可触及和虚可触及的，在一定条件下，都是可以被回收的。所以，<code>强引用是造成Java内存泄漏的主要原因</code>。</li>
</ol>
<h3 id="再谈引用：软引用"><a href="#再谈引用：软引用" class="headerlink" title="再谈引用：软引用"></a>再谈引用：软引用</h3><p><strong>软引用（Soft Reference）：内存不足即回收</strong></p>
<ol>
<li>软引用是用来描述一些还有用，但非必需的对象。只被软引用关联着的对象，在<code>系统将要发生内存溢出异常前</code>，会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存，才会抛出内存溢出异常。注意，这里的第一次回收是不可达的对象。</li>
<li>软引用通常用来实现<code>内存敏感的缓存</code>。比如：高速缓存就有用到软引用。如果还有空闲内存，就可以暂时保留缓存，当内存不足时清理掉，这样就保证了使用缓存的同时，不会耗尽内存。</li>
<li>垃圾回收器在某个时刻决定回收软可达的对象的时候，会清理软引用，并可选地把引用存放到一个引用队列（Reference Queue）。</li>
<li>一句话概括：当内存足够时，不会回收软引用可达的对象。内存不够时，会回收软引用的可达对象</li>
</ol>
<p>在JDK1.2版之后提供了<code>SoftReference</code>类来实现软引用:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();<span class="comment">// 声明强引用</span></span><br><span class="line">SoftReference&lt;Object&gt; sf = <span class="keyword">new</span> <span class="title class_">SoftReference</span>&lt;&gt;(obj);</span><br><span class="line">obj = <span class="literal">null</span>; <span class="comment">//销毁强引用</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SoftReferenceTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">User</span><span class="params">(<span class="type">int</span> id, String name)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.id = id;</span><br><span class="line">            <span class="built_in">this</span>.name = name;</span><br><span class="line">            <span class="built_in">this</span>.address = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span> * <span class="number">1024</span> * <span class="number">5</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> id;</span><br><span class="line">        <span class="keyword">public</span> String name;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">byte</span>[] address;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;[id=&quot;</span> + id + <span class="string">&quot;, name=&quot;</span> + name + <span class="string">&quot;] &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建对象，建立软引用</span></span><br><span class="line">        SoftReference&lt;User&gt; userSoftRef = <span class="keyword">new</span> <span class="title class_">SoftReference</span>&lt;User&gt;(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">1</span>, <span class="string">&quot;hhh&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从软引用中重新获得强引用对象</span></span><br><span class="line">        System.out.println(userSoftRef.get());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;---目前内存还不紧张---&quot;</span>);</span><br><span class="line">        System.gc();</span><br><span class="line">        System.out.println(<span class="string">&quot;After GC:&quot;</span>);</span><br><span class="line">        <span class="comment">// 垃圾回收之后获得软引用中的对象</span></span><br><span class="line">        <span class="comment">// 由于堆空间内存足够，所有不会回收软引用的可达对象</span></span><br><span class="line">        System.out.println(userSoftRef.get());</span><br><span class="line">        System.out.println(<span class="string">&quot;---下面开始内存紧张了---&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 让系统认为内存资源紧张、不够</span></span><br><span class="line">            <span class="type">byte</span>[] b = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span> * <span class="number">1024</span> * <span class="number">30</span>];</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 再次从软引用中获取数据</span></span><br><span class="line">            <span class="comment">// 在报OOM之前，垃圾回收器会回收软引用的可达对象</span></span><br><span class="line">            System.out.println(userSoftRef.get());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JVM参数:<code>-Xms30m -Xmx30m</code>，在JVM内存不足时，会清理软引用对象：</p>
<p><img src="/imgs/JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/image-20240311101831530.png" alt="image-20240311101831530"></p>
<h3 id="再谈引用：弱引用"><a href="#再谈引用：弱引用" class="headerlink" title="再谈引用：弱引用"></a>再谈引用：弱引用</h3><p><strong>弱引用（Weak Reference）：发现即回收</strong></p>
<ol>
<li>弱引用也是用来描述那些非必需对象，<code>只被弱引用关联的对象只能生存到下一次垃圾收集发生为止</code>。在系统GC时，只要发现弱引用，不管系统堆空间内存是否充足，都会回收掉只被弱引用关联的对象。</li>
<li>但是，由于垃圾回收器的线程通常优先级很低，因此，并不一定能很快地发现持有弱引用的对象。在这种情况下，弱引用对象可以存在较长的时间。</li>
<li>弱引用和软引用一样，在构造弱引用时，也可以指定一个引用队列，当弱引用对象被回收时，就会加入指定的引用队列，通过这个队列可以跟踪对象的回收情况。</li>
<li><code>软引用、弱引用都非常适合来保存那些可有可无的缓存数据</code>。如果这么做，<strong>当系统内存不足时，这些缓存数据会被回收，不会导致内存溢出。而当内存资源充足时，这些缓存数据又可以存在相当长的时间，从而起到加速系统的作用</strong>。</li>
</ol>
<p>在JDK1.2版之后提供了<code>WeakReference</code>类来实现弱引用:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明强引用</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">WeakReference&lt;Object&gt; sf = <span class="keyword">new</span> <span class="title class_">WeakReference</span>&lt;&gt;(obj);</span><br><span class="line">obj = <span class="literal">null</span>; <span class="comment">//销毁强引用</span></span><br></pre></td></tr></table></figure>

<p>弱引用对象与软引用对象的最大不同就在于，当GC在进行回收时，需要通过算法检查是否回收软引用对象，而对于弱引用对象，GC总是进行回收。弱引用对象更容易、更快被GC回收。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WeakReferenceTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">User</span><span class="params">(<span class="type">int</span> id, String name)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.id = id;</span><br><span class="line">            <span class="built_in">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> id;</span><br><span class="line">        <span class="keyword">public</span> String name;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;[id=&quot;</span> + id + <span class="string">&quot;, name=&quot;</span> + name + <span class="string">&quot;] &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//构造了弱引用</span></span><br><span class="line">        WeakReference&lt;User&gt; userWeakRef = <span class="keyword">new</span> <span class="title class_">WeakReference</span>&lt;User&gt;(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">1</span>, <span class="string">&quot;hhh&quot;</span>));</span><br><span class="line">        <span class="comment">//从弱引用中重新获取对象</span></span><br><span class="line">        System.out.println(userWeakRef.get());</span><br><span class="line"></span><br><span class="line">        System.gc();</span><br><span class="line">        <span class="comment">// 不管当前内存空间足够与否，都会回收它的内存</span></span><br><span class="line">        System.out.println(<span class="string">&quot;After GC:&quot;</span>);</span><br><span class="line">        <span class="comment">//重新尝试从弱引用中获取对象</span></span><br><span class="line">        System.out.println(userWeakRef.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/imgs/JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/image-20240311102551871.png" alt="image-20240311102551871"></p>
<h3 id="再谈引用：虚引用"><a href="#再谈引用：虚引用" class="headerlink" title="再谈引用：虚引用"></a>再谈引用：虚引用</h3><p><strong>虚引用（Phantom Reference）：对象回收跟踪</strong></p>
<ol>
<li>一个对象是否有虚引用的存在，完全不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它和没有引用几乎是一样的，随时都可能被垃圾回收器回收。</li>
<li>它不能单独使用，也无法通过虚引用来获取被引用的对象。当试图通过虚引用的get()方法取得对象时，总是null。</li>
<li>为一个对象设置虚引用关联的唯一目的在于<code>跟踪垃圾回收过程</code>。比如：能在这个对象被收集器回收时收到一个系统通知。</li>
<li><code>虚引用必须和引用队列一起使用</code>。虚引用在创建时必须提供一个引用队列作为参数。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象后，将这个虚引用加入引用队列，以通知应用程序对象的回收情况。</li>
</ol>
<p>在JDK1.2版之后提供了<code>PhantomReference</code>类来实现虚引用:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明强引用</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="comment">// 声明引用队列</span></span><br><span class="line"><span class="type">ReferenceQueue</span> <span class="variable">phantomQueue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReferenceQueue</span>();</span><br><span class="line"><span class="comment">// 声明虚引用（还需要传入引用队列）</span></span><br><span class="line">PhantomReference&lt;Object&gt; sf = <span class="keyword">new</span> <span class="title class_">PhantomReference</span>&lt;&gt;(obj, phantomQueue);</span><br><span class="line">obj = <span class="literal">null</span>; </span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PhantomReferenceTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> PhantomReferenceTest obj;<span class="comment">//当前类对象的声明</span></span><br><span class="line">    <span class="keyword">static</span> ReferenceQueue&lt;PhantomReferenceTest&gt; phantomQueue = <span class="literal">null</span>;<span class="comment">//引用队列</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">CheckRefQueue</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (phantomQueue != <span class="literal">null</span>) &#123;</span><br><span class="line">                    PhantomReference&lt;PhantomReferenceTest&gt; objt = <span class="literal">null</span>;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        objt = (PhantomReference&lt;PhantomReferenceTest&gt;) phantomQueue.remove();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (objt != <span class="literal">null</span>) &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;追踪垃圾回收过程：PhantomReferenceTest实例被GC了&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CheckRefQueue</span>();</span><br><span class="line">        t.setDaemon(<span class="literal">true</span>);</span><br><span class="line">        t.start();</span><br><span class="line"></span><br><span class="line">        phantomQueue = <span class="keyword">new</span> <span class="title class_">ReferenceQueue</span>&lt;&gt;();</span><br><span class="line">        obj = <span class="keyword">new</span> <span class="title class_">PhantomReferenceTest</span>();</span><br><span class="line">        <span class="comment">// 构造了PhantomReferenceTest对象的虚引用，并指定了引用队列</span></span><br><span class="line">        PhantomReference&lt;PhantomReferenceTest&gt; phantomRef = <span class="keyword">new</span> <span class="title class_">PhantomReference</span>&lt;PhantomReferenceTest&gt;(obj, phantomQueue);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 不可获取虚引用中的对象</span></span><br><span class="line">            System.out.println(phantomRef.get());</span><br><span class="line">            <span class="comment">// 将强引用去除</span></span><br><span class="line">            obj = <span class="literal">null</span>;</span><br><span class="line">            <span class="comment">// 一旦将obj对象回收，就会将此虚引用存放到引用队列中</span></span><br><span class="line">            System.gc();</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/imgs/JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/image-20240311103428494.png" alt="image-20240311103428494"></p>
<h2 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h2><p><strong>吞吐量 vs 暂停时间</strong></p>
<ol>
<li>高吞吐量较好，因为这会让应用程序的最终用户感觉只有应用程序线程在做“生产性”工作。直觉上，吞吐量越高程序运行越快。</li>
<li>低暂停时间较好，是从最终用户的角度来看，不管是GC还是其他原因导致一个应用被挂起始终是不好的。这取决于应用程序的类型，有时候甚至短暂的200毫秒暂停都可能打断终端用户体验。因此，具有较低的暂停时间是非常重要的，特别是对于一个交互式应用程序。</li>
<li>不幸的是”高吞吐量”和”低暂停时间”是一对相互竞争的目标。<ul>
<li>因为如果选择吞吐量优先，那么<strong>必然需要降低内存回收的执行频率</strong>，但是这样会导致GC需要更长的暂停时间来执行内存回收。</li>
<li>如果选择低延迟优先，那么为了降低每次执行内存回收时的暂停时间，也<strong>只能频繁地执行内存回收</strong>，但这又引起了程序吞吐量的下降。</li>
</ul>
</li>
<li>在设计GC算法时，我们必须确定我们的目标：一个GC算法只可能针对两个目标之一（即只专注于较大吞吐量或最小暂停时间），或尝试找到一个二者的折衷。</li>
<li>现在标准：<strong>在可控的停顿时间内，最大化吞吐量</strong>。</li>
</ol>
<h3 id="7款经典的垃圾收集器"><a href="#7款经典的垃圾收集器" class="headerlink" title="7款经典的垃圾收集器"></a>7款经典的垃圾收集器</h3><ol>
<li>串行回收器：Serial、Serial old</li>
<li>并行回收器：ParNew、Parallel Scavenge、Parallel old</li>
<li>并发回收器：CMS、G1</li>
</ol>
<p><img src="/imgs/JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/%E7%AC%AC17%E7%AB%A0_%E7%BB%8F%E5%85%B8%E7%9A%847%E7%A7%8DGC.jpg" alt="第17章_经典的7种GC"></p>
<h3 id="垃圾收集器的组合关系"><a href="#垃圾收集器的组合关系" class="headerlink" title="垃圾收集器的组合关系"></a>垃圾收集器的组合关系</h3><p><img src="/imgs/JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/%E7%AC%AC17%E7%AB%A0_%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E7%BB%84%E5%90%88.jpg" alt="第17章_垃圾收集器组合"></p>
<p>虽然我们会对各个收集器进行比较，但并非为了挑选一个最好的收集器出来。没有一种放之四海皆准、任何场景下都适用的完美收集器存在，更加没有万能的收集器。所以<code>我们选择的只是对具体应用最合适的收集器</code>。</p>
<blockquote>
<p>JDK14中已经删除了CMS垃圾回收器，推荐的垃圾收集器组合方案：</p>
<ol>
<li>Serial GC+Serial Old GC（适合单CPU的Client模式的JVM）</li>
<li>Parallel Scavenge GC+Parallel Old GC（适合多CPU的Server模式的JVM）</li>
<li>G1 GC（JDK9默认的垃圾收集器）</li>
</ol>
</blockquote>
<p><code>-XX:+PrintCommandLineFlags</code>：查看命令行相关参数（包含使用的垃圾收集器）</p>
<p>使用命令行指令：<code>jinfo -flag</code> 相关垃圾回收器参数 进程ID</p>
<p>JDK8的环境：</p>
<p><img src="/imgs/JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/image-20240311152105460.png" alt="image-20240311152105460"></p>
<p><img src="/imgs/JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/image-20240311152259165.png" alt="image-20240311152259165"></p>
<h3 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h3><p>Serial收集器是最基础、历史最悠久的收集器，曾经（在JDK 1.3.1之前）是HotSpot虚拟机新生代收集器的唯一选择。大家只看名字就能够猜到，这个收集器是一个<code>单线程工作</code>的收集器，但它的“单线程”的意义并不仅仅是说明它只会使用一个处理器或一条收集线程去完成垃圾收集工作，更重要的是强调在它进行垃圾收集时，必须暂停其他所有工作线程，直到它收集结束。“Stop The World”这个词语也许听起来很酷，但这项工作是由虚拟机在后台自动发起和自动完成的，在用户不可知、不可控的情况 下把用户的正常工作的线程全部停掉，这对很多应用来说都是不能接受的。</p>
<p><img src="/imgs/JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/image-20240311193747239.png" alt="image-20240311193747239"></p>
<p>迄今为止，它依然是HotSpot虚拟机运行在<code>客户端模式</code>下的默认新生代收集器，有着优于其他收集器的地方，那就是<code>简单而高效</code>（与其他收集器的单线程相比），对于内存资源受限的环境，它是所有收集器里额外内存消耗（Memory Footprint）最小的；<strong>对于单核处理器或处理器核心数较少的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率</strong>。在用户桌面的应用场景以及近年来流行的部分微服务应用中，分配给虚拟机管理的内存一般来说并不会特别大，收集几十兆甚至一两百兆的新生代（仅仅是指新生代使用的内存，桌面应用甚少超过这个容量），垃圾收集的停顿时间完全可以控制在十几、几十毫秒，最多一百多毫秒以内，只要不是频繁发生收集，这点停顿时间对许多用户来说是完全可以接受的。所以，Serial收集器对于运行在客户端模式下的虚拟机来说是一个很好的选择。</p>
<h3 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h3><p>ParNew收集器实质上是Serial收集器的<code>多线程并行版本</code>，除了同时使用多条线程进行垃圾收集之外，其余的行为包括Serial收集器可用的所有控制参数（例如：-XX:SurvivorRatio、-XX:PretenureSizeThreshold、-XX:HandlePromotionFailure等）、收集算法、Stop The World、对象分配规则、回收策略等都与Serial收集器完全一致，在实现上这两种收集器也共用了相当多的代码。</p>
<p><img src="/imgs/JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/image-20240311195439721.png" alt="image-20240311195439721"></p>
<p>ParNew收集器除了支持多线程并行收集之外，其他与Serial收集器相比并没有太多创新之处，但它却是不少运行在服务端模式下的HotSpot虚拟机，尤其是JDK 7之前的遗留系统中首选的新生代收集器，其中有一个与功能、性能无关但其实很重要的原因是：<strong>除了Serial收集器外，目前只有它能与CMS收集器配合工作</strong>。</p>
<p>在JDK 5发布时，HotSpot推出了一款在强交互应用中几乎可称为具有划时代意义的垃圾收集器——CMS收集器。这款收集器是HotSpot虚拟机中第一款真正意义上支持并发的垃圾收集器，它首次实现了让垃圾收集线程与用户线程（基本上）同时工作。</p>
<p>遗憾的是，CMS作为老年代的收集器，却无法与JDK 1.4.0中已经存在的新生代收集器Parallel Scavenge配合工作，所以在JDK 5中使用CMS来收集老年代的时候，新生代只能选择ParNew或者Serial收集器中的一个。(除了一个面向低延迟一个面向高吞吐量的目标不一致外，技术上的原因是Parallel Scavenge收集器及后面提到的G1收集器等都没有使用HotSpot中原本设计的垃圾收集器的分代框架，而选择另外独立实现。Serial、ParNew收集器则共用了这部分的框架代码)</p>
<p>ParNew收集器是激活CMS后（使用<code>-XX:+UseConcMarkSweepGC</code>选项）的默认新生代收集器，也可以使用<code>-XX:+/-UseParNewGC</code>选项来强制指定或者禁用它。<strong>ParNew收集器在单核心处理器的环境中绝对不会有比Serial收集器更好的效果，甚至由于存在线程交互的开销，该收集器在通过超线程（Hyper-Threading）技术实现的伪双核处理器环境中都不能百分之百保证超越Serial收集器</strong>。当然，随着可以被使用的处理器核心数量的增加，ParNew对于垃圾收集时系统资源的高效利用还是很有好处的。它默认开启的收集线程数与处理器核心数量相同，在处理器核心非常多（譬如32个，现在CPU都是多核加超线程设计，服务器达到或超过32个逻辑核心的情况非常普遍）的环境中，可以使用<code>-XX:ParallelGCThreads</code>参数来限制垃圾收集的线程数。</p>
<h3 id="Parallel-Scavenge收集器"><a href="#Parallel-Scavenge收集器" class="headerlink" title="Parallel Scavenge收集器"></a>Parallel Scavenge收集器</h3><p>Parallel Scavenge收集器也是一款新生代收集器，它同样是基于标记-复制算法实现的收集器，也是能够并行收集的多线程收集器……Parallel Scavenge的诸多特性从表面上看和ParNew非常相似，那它有什么特别之处呢？</p>
<p>Parallel Scavenge收集器的特点是它的关注点与其他收集器不同，<code>CMS等收集器</code>的关注点是<code>尽可能地缩短垃圾收集时用户线程的停顿时间</code>，而<code>Parallel Scavenge收集器</code>的目标则是<code>达到一个可控制的吞吐量（Throughput）</code>。所谓吞吐量就是处理器用于运行用户代码的时间与处理器总消耗时间的比值。</p>
<p>如果虚拟机完成某个任务，用户代码加上垃圾收集总共耗费了100分钟，其中垃圾收集花掉1分钟，那吞吐量就是99%。停顿时间越短就越适合需要与用户交互或需要保证服务响应质量的程序，良好的响应速度能提升用户体验；而高吞吐量则可以最高效率地利用处理器资源，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的分析任务。</p>
<p>Parallel Scavenge收集器提供了两个参数用于精确控制吞吐量，分别是控制最大垃圾收集停顿时间的<code>-XX:MaxGCPauseMillis</code>参数以及直接设置吞吐量大小的<code>-XX:GCTimeRatio</code>参数。</p>
<p><code>-XX:MaxGCPauseMillis</code>参数允许的值是一个大于0的毫秒数，收集器将<code>尽力保证内存回收花费的时间不超过用户设定值</code>。不过大家不要异想天开地认为如果把这个参数的值设置得更小一点就能使得系统的垃圾收集速度变得更快，<strong>垃圾收集停顿时间缩短是以牺牲吞吐量和新生代空间为代价换取的</strong>：系统把新生代调得小一些，收集300MB新生代肯定比收集500MB快，但这也直接导致垃圾收集发生得更频繁，原来10秒收集一次、每次停顿100毫秒，现在变成5秒收集一次、每次停顿70毫秒。停顿时间的确在下降，但吞吐量也降下来了。</p>
<h3 id="Serial-Old收集器"><a href="#Serial-Old收集器" class="headerlink" title="Serial Old收集器"></a>Serial Old收集器</h3><p>Serial Old是Serial收集器的老年代版本，它同样是一个<code>单线程收集器</code>，使用<code>标记-整理</code>算法。这个收集器的主要意义也是供客户端模式下的HotSpot虚拟机使用。如果在服务端模式下，它也可能有两种用途：一种是在JDK 5以及之前的版本中与Parallel Scavenge收集器搭配使用，另外一种就是作为<code>CMS收集器发生失败时的后备预案</code>，在并发收集发生Concurrent Mode Failure时使用。</p>
<p><img src="/imgs/JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/image-20240315155523987.png" alt="image-20240315155523987"></p>
<h3 id="Parallel-Old收集器"><a href="#Parallel-Old收集器" class="headerlink" title="Parallel Old收集器"></a>Parallel Old收集器</h3><p>Parallel Old是Parallel Scavenge收集器的老年代版本，支持多线程并发收集，基于<code>标记-整理</code>算法实现。这个收集器是直到JDK 6时才开始提供的，在此之前，新生代的Parallel Scavenge收集器一直处于相当尴尬的状态，原因是如果新生代选择了Parallel Scavenge收集器，老年代除了Serial Old（PS MarkSweep）收集器以外别无选择，其他表现良好的老年代收集器，如CMS无法与它配合工作。由于 老年代Serial Old收集器在服务端应用性能上的“拖累”，使用Parallel Scavenge收集器也未必能在整体上获得吞吐量最大化的效果。同样，由于单线程的老年代收集中无法充分利用服务器多处理器的并行处理能力，在老年代内存空间很大而且硬件规格比较高级的运行环境中，这种组合的总吞吐量甚至不一定比ParNew加CMS的组合来得优秀。</p>
<p>直到Parallel Old收集器出现后，“吞吐量优先”收集器终于有了比较名副其实的搭配组合，在注重吞吐量或者处理器资源较为稀缺的场合，都可以优先考虑Parallel Scavenge加Parallel Old收集器这个组合。</p>
<p><img src="/imgs/JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/image-20240315160242801.png" alt="image-20240315160242801"></p>
<h3 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h3><p>CMS（Concurrent Mark Sweep）收集器是一种以获取<code>最短回收停顿时间</code>为目标的收集器。目前很大一部分的Java应用集中在互联网网站或者基于浏览器的B&#x2F;S系统的服务端上，这类应用通常都会较为关注服务的响应速度，希望系统停顿时间尽可能短，以给用户带来良好的交互体验。CMS收集器就非常符合这类应用的需求。 </p>
<p>从名字（包含“Mark Sweep”）上就可以看出CMS收集器是基于<code>标记-清除</code>算法实现的，它的运作过程相对于前面几种收集器来说要更复杂一些，整个过程分为四个步骤，包括：</p>
<p>1）初始标记（CMS initial mark） </p>
<p>2）并发标记（CMS concurrent mark） </p>
<p>3）重新标记（CMS remark） </p>
<p>4）并发清除（CMS concurrent sweep）</p>
<p>其中初始标记、重新标记这两个步骤仍然需要“Stop The World”。初始标记仅仅只是标记一下GC Roots能<code>直接关联到的对象</code>，速度很快；并发标记阶段就是从GC Roots的直接关联对象开始遍历整个对象图的过程，这个过程耗时较长但是不需要停顿用户线程，可以与垃圾收集线程一起并发运行；而重新标记阶段则是为了<code>修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录</code>，这个阶段的停顿时间通常会比初始标记阶段稍长一些，但也远比并发标记阶段的时间短；最后是并发清除阶段，清理删除掉标记阶段判断的已经死亡的对象，由于<code>不需要移动存活对象</code>，所以这个阶段也是可以与用户线程同时并发的。</p>
<p>由于在整个过程中耗时最长的并发标记和并发清除阶段中，垃圾收集器线程都可以与用户线程一起工作，所以从总体上来说，CMS收集器的内存回收过程是与用户线程一起并发执行的。通过图可以比较清楚地看到CMS收集器的运作步骤中并发和需要停顿的阶段。</p>
<p><img src="/imgs/JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/image-20240315165414382.png" alt="image-20240315165414382"></p>
<p>CMS是一款优秀的收集器，它最主要的优点在名字上已经体现出来：<code>并发收集</code>、<code>低停顿</code>，一些官方公开文档里面也称之为“并发低停顿收集器”（Concurrent Low Pause Collector）。CMS收集器是HotSpot虚拟机追求低停顿的第一次成功尝试，但是它还远达不到完美的程度，至少有以下三个明显的缺点：</p>
<p>(1)首先，<strong>CMS收集器对处理器资源非常敏感</strong>。事实上，面向并发设计的程序都对处理器资源比较敏感。在并发阶段，它虽然不会导致用户线程停顿，但却会因为占用了一部分线程（或者说处理器的计算能力）而导致应用程序变慢，降低总吞吐量。<code>CMS默认启动的回收线程数是（处理器核心数量+3）/4</code>，也就是说，如果处理器核心数在四个或以上，并发回收时垃圾收集线程只占用不超过25%的处理器运算资源，并且会随着处理器核心数量的增加而下降。但是当处理器核心数量不足四个时，CMS对用户程序的影响就可能变得很大。如果应用本来的处理器负载就很高，还要分出一半的运算能力去执行收集器线程，就可能导致用户程序的执行速度忽然大幅降低，可以通过参数<code>-XX:ParallelCMSThreads</code>设置CMS线程数。</p>
<p>(2)然后，由于CMS收集器无法处理<code>浮动垃圾</code>（Floating Garbage），有可能出现<code>Concurrent Mode Failure</code>失败进而导致另一次完全<code>Stop The World</code>的Full GC的产生。在CMS的<code>并发标记</code>和<code>并发清理</code>阶段，用户线程是还在继续运行的，程序在运行自然就还会伴随有新的垃圾对象不断产生，但这一部分垃圾对象是出现在标记过程结束以后，CMS无法在当次收集中处理掉它们，只好留待下一次垃圾收集时再清理掉。这一部分垃圾就称为“浮动垃圾”。<strong>同样也是由于在垃圾收集阶段用户线程还需要持续运行，那就还需要预留足够内存空间提供给用户线程使用，因此CMS收集器不能像其他收集器那样等待到老年代几乎完全被填满了再进行收集，必须预留一部分空间供并发收集时的程序运作使用。</strong></p>
<p>在JDK 5的默认设置下，CMS收集器当老年代使用了<code>68%</code>的空间后就会被激活，这是一个偏保守的设置，<strong>如果在实际应用中老年代增长并不是太快</strong>，可以适当调高参数<code>-XX:CMSInitiatingOccupancyFraction</code>的值来提高CMS的触发百分比，降低内存回收频率，获取更好的性能。到了JDK 6时，CMS收集器的启动阈值就已经默认提升至<code>92%</code>。但这又会更容易面临另一种风险：<strong>要是CMS运行期间预留的内存无法满足程序分配新对象的需要，就会出现一次“并发失败”（Concurrent Mode Failure），这时候虚拟机将不得不启动后备预案：冻结用户线程的执行，临时启用Serial Old收集器来重新进行老年代的垃圾收集，但这样停顿时间就很长了</strong>。<code>-XX:CMSInitiatingOccupancyFraction</code>设置得太高将会很容易导致大量的并发失败产生，性能反而降低，用户应在生产环境中根据实际应用情况来权衡设置。</p>
<p>(3)还有最后一个缺点，CMS是一款基于“标记-清除”算法实现的收集器，这意味着<strong>收集结束时会有大量空间碎片产生</strong>。空间碎片过多时，将会给大对象分配带来很大麻烦，往往会出现老年代还有很多剩余空间，但就是无法找到足够大的连续空间来分配当前对象，而不得不提前触发一次Full GC的情况。为了解决这个问题，CMS收集器提供了一个<code>-XX:+UseCMSCompactAtFullCollection</code>开关参数（默认是开启的，此参数从 JDK 9开始废弃），用于在CMS收集器不得不进行Full GC时开启内存碎片的合并整理过程，由于这个内存整理必须移动存活对象，（在Shenandoah和ZGC出现前）是无法并发的。这样空间碎片问题是解决了，但停顿时间又会变长，因此虚拟机设计者们还提供了另外一个参数<code>-XX:CMSFullGCsBeforeCompaction</code>（此参数从JDK 9开始废弃），这个参数的作用是要求CMS收集器在执行过若干次（数量由参数值决定）不整理空间的Full GC之后，下一次进入Full GC前会先进行碎片整理（默认值为0，表示每次进入Full GC时都进行碎片整理）。</p>
<h3 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h3><p>Garbage First（简称G1）收集器是垃圾收集器技术发展历史上的里程碑式的成果，它开创了收集器<code>面向局部收集</code>的设计思路和<code>基于Region的内存布局</code>形式。早在JDK 7刚刚确立项目目标、Oracle公司 制定的JDK 7 RoadMap里面，G1收集器就被视作JDK 7中HotSpot虚拟机的一项重要进化特征。</p>
<p>G1是一款主要<code>面向服务端应用</code>的垃圾收集器。HotSpot开发团队最初赋予它的期望是（在比较长期的）未来可以替换掉JDK 5中发布的CMS收集器。现在这个期望目标已经实现过半了，<code>JDK 9</code>发布之日，G1宣告取代<code>Parallel Scavenge加Parallel Old</code>组合，成为服务端模式下的<code>默认垃圾收集器</code>，而CMS则沦落至被声明为不推荐使用（Deprecate）的收集器。如果对JDK 9及以上版本的HotSpot虚拟机使用参数<code>-XX:+UseConcMarkSweepGC</code>来开启CMS收集器的话，用户会收到一个警告信息，提示CMS未来将会被废弃：</p>
<p><img src="/imgs/JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/image-20240317200906382.png" alt="image-20240317200906382"></p>
<p>但作为一款曾被广泛运用过的收集器，经过多个版本的开发迭代后，CMS（以及之前几款收集器）的代码与HotSpot的内存管理、执行、编译、监控等子系统都有千丝万缕的联系，这是历史原因导致的，并不符合职责分离的设计原则。为此，规划JDK 10功能目标时，HotSpot虚拟机提出了<code>“统一垃圾收集器接口” </code>，将内存回收的“行为”与“实现”进行分离，CMS以及其他收集器都重构成基于这套接口的一种实现。以此为基础，日后要移除或者加入某一款收集器，都会变得容易许多，风险也可以控制，这算是在为CMS退出历史舞台铺下最后的道路了。</p>
<p>作为CMS收集器的替代者和继承人，设计者们希望做出一款能够建立起<code>“停顿时间模型”（Pause Prediction Model）</code>的收集器，停顿时间模型的意思是能够支持指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间大概率不超过N毫秒这样的目标，这几乎已经是软实时垃圾收集器特征了。</p>
<h4 id="基于Region的区域分代"><a href="#基于Region的区域分代" class="headerlink" title="基于Region的区域分代"></a>基于Region的区域分代</h4><p>那具体要怎么做才能实现这个目标呢？首先要有一个思想上的改变，在G1收集器出现之前的所有其他收集器，包括CMS在内，<strong>垃圾收集的目标范围要么是整个新生代（Minor GC），要么就是整个老年代（Major GC），再要么就是整个Java堆（Full GC）</strong>。而G1跳出了这个樊笼，它可以面向堆内存任何部分来组成回收集（Collection Set，一般简称CSet）进行回收，衡量标准不再是它属于哪个分代，而是哪块内存中存放的<code>垃圾数量最多</code>，<code>回收收益最大</code>，这就是G1收集器的<code>Mixed GC</code>模式。</p>
<p>G1开创的<code>基于Region的堆内存布局</code>是它能够实现这个目标的关键。虽然G1也仍是遵循分代收集理论设计的，但其堆内存的布局与其他收集器有非常明显的差异：<strong>G1不再坚持固定大小以及固定数量的分代区域划分，而是把连续的Java堆划分为多个大小相等的独立区域（Region）</strong>，每一个Region都可以根据需要，扮演新生代的Eden空间、Survivor空间，或者老年代空间。收集器能够对扮演不同角色的Region采用不同的策略去处理，这样无论是新创建的对象还是已经存活了一段时间、熬过多次收集的旧对象都能获取很好的收集效果。</p>
<p>Region中还有一类特殊的<code>Humongous区域</code>，专门用来存储大对象。G1认为只要<code>大小超过了一个Region容量一半</code>的对象即可判定为大对象。每个Region的大小可以通过参数<code>-XX:G1HeapRegionSize</code>设定，取值范围为<code>1MB～32MB</code>，且应为2的N次幂。而对于那些超过了整个Region容量的超级大对象，将会被存放在N个连续的Humongous Region之中，G1的大多数行为都把Humongous Region作为老年代的一部分来进行看待。</p>
<p><img src="/imgs/JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/image-20240317202611902.png" alt="image-20240317202611902"></p>
<h4 id="可预测的停顿时间模型"><a href="#可预测的停顿时间模型" class="headerlink" title="可预测的停顿时间模型"></a>可预测的停顿时间模型</h4><p>虽然G1仍然保留新生代和老年代的概念，但新生代和老年代不再是固定的了，它们都是一系列区域（不需要连续）的动态集合。<strong>G1收集器之所以能建立可预测的停顿时间模型，是因为它将Region作为单次回收的最小单元，即每次收集到的内存空间都是Region大小的整数倍，这样可以有计划地避免在整个Java堆中进行全区域的垃圾收集</strong>。更具体的处理思路是让G1收集器去跟踪各个Region里面的垃圾堆积的“价值”大小，价值即<code>回收所获得的空间大小以及回收所需时间的经验值</code>，然后在后台维护一个<code>优先级列表</code>，每次根据用户设定允许的收集停顿时间（使用参数<code>-XX:MaxGCPauseMillis</code>指定，默认值是200毫秒），<strong>优先处理回收价值收益最大的那些Region</strong>，这也就是“Garbage First”名字的由来。<strong>这种使用Region划分内存空间，以及具有优先级的区域回收方式，保证了G1收集器在有限的时间内获取尽可能高的收集效率。</strong></p>
<p>G1将堆内存“化整为零”的“解题思路”，看起来似乎没有太多令人惊讶之处，也完全不难理解，但其中的实现细节可是远远没有想象中那么简单，否则就不会从2004年Sun实验室发表第一篇关于G1的论文后一直拖到2012年4月JDK 7 Update 4发布，用将近10年时间才倒腾出能够商用的G1收集器来。G1收集器至少有（不限于）以下这些关键的细节问题需要妥善解决：</p>
<p>(1)譬如，将Java堆分成多个独立Region后，Region里面存在的跨Region引用对象如何解决？解决的思路我们已经知道：<code>使用记忆集避免全堆作为GC Roots扫描</code>，但在G1收集器上记忆集的应用其实要复杂很多，<strong>它的每个Region都维护有自己的记忆集，这些记忆集会记录下别的Region指向自己的指针，并标记这些指针分别在哪些卡页的范围之内</strong>。G1的记忆集在存储结构的本质上是一种哈希表，Key是别的Region的起始地址，Value是一个集合，里面存储的元素是卡表的索引号。这种“双向”的卡表结构（卡表是“我指向谁”，这种结构还记录了“谁指向我”）比原来的卡表实现起来更复杂，同时由于Region数量比传统收集器的分代数量明显要多得多，因此G1收集器要比其他的传统垃圾收集器有着更高的内存占用负担。根据经验，<code>G1至少要耗费大约相当于Java堆容量10%至20%的额外内存来维持收集器工作</code>。</p>
<p>(2)譬如，在并发标记阶段如何保证收集线程与用户线程互不干扰地运行？这里首先要解决的是<code>用户线程改变对象引用关系时，必须保证其不能打破原本的对象图结构，导致标记结果出现错误</code>，该问题的解决办法笔者已经抽出独立小节来讲解过：CMS收集器采用<code>增量更新</code>算法实现，而G1收集器则是通过<code>原始快照（SATB）</code>算法来实现的。此外，垃圾收集对用户线程的影响还体现在回收过程中新创建对象的内存分配上，程序要继续运行就肯定会持续有新对象被创建，G1为每一个Region设计了两个名为TAMS（Top at Mark Start）的指针，把Region中的一部分空间划分出来用于并发回收过程中的新对象分配，并发回收时新分配的对象地址都必须要在这两个指针位置以上。G1收集器默认在这个地址以上的对象是被隐式标记过的，即默认它们是存活的，不纳入回收范围。与CMS中的“Concurrent Mode Failure”失败会导致Full GC类似，如果内存回收的速度赶不上内存分配的速度，G1收集器也要被迫冻结用户线程执行，导致Full GC而产生长时间“Stop The World”。</p>
<p>(3)譬如，怎样建立起可靠的停顿预测模型？用户通过<code>-XX:MaxGCPauseMillis</code>参数指定的停顿时间只意味着垃圾收集发生之前的期望值，但G1收集器要怎么做才能满足用户的期望呢？G1收集器的停顿预测模型是以<code>衰减均值（Decaying Average）</code>为理论基础来实现的，在垃圾收集过程中，G1收集器会记录<code>每个Region的回收耗时</code>、<code>每个Region记忆集里的脏卡数量</code>等各个可测量的步骤花费的成本，并分析得出平均值、标准偏差、置信度等统计信息。这里强调的“衰减平均值”是指它会比普通的平均值更容易受到新数据的影响，平均值代表整体平均状态，但衰减平均值更准确地代表<code>最近的</code>平均状态。换句话说，<code>Region的统计状态越新越能决定其回收的价值</code>。然后通过这些信息预测现在开始回收的话，由哪些Region组成回收集才可以在不超过期望停顿时间的约束下获得最高的收益。</p>
<h4 id="垃圾收集过程"><a href="#垃圾收集过程" class="headerlink" title="垃圾收集过程"></a>垃圾收集过程</h4><p>如果我们不去计算用户线程运行过程中的动作（如使用写屏障维护记忆集的操作），G1收集器的运作过程大致可划分为以下四个步骤：</p>
<p>(1)<strong>初始标记（Initial Marking）</strong>：仅仅只是标记一下<code>GC Roots能直接关联到的对象</code>，并且修改TAMS指针的值，让下一阶段用户线程并发运行时，能正确地在可用的Region中分配新对象。这个阶段需要停顿线程，但耗时很短，而且是借用进行Minor GC的时候同步完成的，所以G1收集器在这个阶段实际并没有额外的停顿。</p>
<p>(2)<strong>并发标记（Concurrent Marking）</strong>：从GC Root开始对堆中对象进行可达性分析，递归扫描整个堆里的对象图，找出要回收的对象，这阶段耗时较长，但可与用户程序并发执行。当对象图扫描完成以后，还要重新处理SATB记录下的在并发时有引用变动的对象。</p>
<p>(3)<strong>最终标记（Final Marking）</strong>：对用户线程做另一个短暂的暂停，用于处理并发阶段结束后仍遗留下来的最后那少量的SATB记录。</p>
<p>(4)<strong>筛选回收（Live Data Counting and Evacuation）</strong>：负责更新Region的统计数据，对各个Region的回收价值和成本进行排序，根据用户所期望的停顿时间来制定回收计划，可以自由选择任意多个Region构成回收集，然后<code>把决定回收的那一部分Region的存活对象复制到空的Region中</code>，再清理掉整个旧Region的全部空间。这里的操作涉及存活对象的移动，是必须暂停用户线程，由多条收集器线程<code>并行</code>完成的。</p>
<p>从上述阶段的描述可以看出，G1收集器除了并发标记外，其余阶段也是要完全暂停用户线程的，换言之，它并非纯粹地追求低延迟，官方给它设定的目标是<code>在延迟可控的情况下获得尽可能高的吞吐量</code>，所以才能担当起“全功能收集器”的重任与期望。</p>
<p><img src="/imgs/JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/image-20240317212404469.png" alt="image-20240317212404469"></p>
<p>毫无疑问，可以由用户指定期望的停顿时间是G1收集器很强大的一个功能，设置不同的期望停顿时间，可使得G1在不同应用场景中取得关注吞吐量和关注延迟之间的最佳平衡。不过，这里设置的“期望值”必须是符合实际的，不能异想天开，毕竟G1是要冻结用户线程来复制对象的，这个停顿时间再怎么低也得有个限度。它默认的停顿目标为两百毫秒，一般来说，回收阶段占到几十到一百甚至接近两百毫秒都很正常，<strong>但如果我们把停顿时间调得非常低，譬如设置为二十毫秒，很可能出现的结果就是由于停顿目标时间太短，导致每次选出来的回收集只占堆内存很小的一部分，收集器收集的速度逐渐跟不上分配器分配的速度，导致垃圾慢慢堆积。很可能一开始收集器还能从空闲的堆内存中获得一些喘息的时间，但应用运行时间一长就不行了，最终占满堆引发Full GC反而降低性能</strong>，所以通常把期望停顿时间设置为一两百毫秒或者两三百毫秒会是比较合理的。</p>
<p>从G1开始，最先进的垃圾收集器的设计导向都不约而同地变为追求能够应付<code>应用的内存分配速率 （Allocation Rate）</code>，而不追求一次把整个Java堆全部清理干净。这样，应用在分配，同时收集器在收集，只要收集的速度能跟得上对象分配的速度，那一切就能运作得很完美。这种新的收集器设计思路从工程实现上看是从G1开始兴起的，所以说G1是收集器技术发展的一个里程碑。</p>
<p>G1收集器常会被拿来与CMS收集器互相比较，毕竟它们都非常关注停顿时间的控制，官方资料中将它们两个并称为“The Mostly Concurrent Collectors”。在未来，G1收集器最终还是要取代CMS的，而当下它们两者并存的时间里，分个高低优劣就无可避免。</p>
<h4 id="空间整合"><a href="#空间整合" class="headerlink" title="空间整合"></a>空间整合</h4><p>相比CMS，G1的优点有很多，暂且不论<code>可以指定最大停顿时间</code>、<code>分Region的内存布局</code>、<code>按收益动态确定回收集</code>这些创新性设计带来的红利，单从最传统的算法理论上看，G1也更有发展潜力。与CMS的<code>标记-清除</code>算法不同，G1从<code>整体</code>来看是基于<code>标记-整理</code>算法实现的收集器，但从<code>局部（两个Region之间）</code>上看又是基于<code>标记-复制</code>算法实现，无论如何，这两种算法都意味着<code>G1运作期间不会产生内存空间碎片</code>，垃圾收集完成之后能提供规整的可用内存。这种特性有利于程序长时间运行，在程序为大对象分配内存时不容易因无法找到连续内存空间而提前触发下一次收集。</p>
<p>不过，G1相对于CMS仍然不是占全方位、压倒性优势的，从它出现几年仍不能在所有应用场景中代替CMS就可以得知这个结论。比起CMS，G1的弱项也可以列举出不少，如在用户程序运行过程中，<strong>G1无论是为了垃圾收集产生的内存占用（Footprint）还是程序运行时的额外执行负载 （Overload）都要比CMS要高</strong>。</p>
<h4 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h4><p>G1的设计原则就是简化JVM调优，开发人员只需要简单的三步即可完成调优：</p>
<ul>
<li>第一步：开启G1垃圾收集器<code>-XX:+UseG1GC</code></li>
<li>第二步：设置堆的最大内存<code>-Xmx</code></li>
<li>第三步：设置最大停顿时间<code>-XX:MaxGCPauseMillis</code></li>
</ul>
<p>G1提供了三种不同的垃圾回收模式：Young GC、Mixed GC、Full GC，在不同的条件下被触发。</p>
<h3 id="选择合适的垃圾收集器"><a href="#选择合适的垃圾收集器" class="headerlink" title="选择合适的垃圾收集器"></a>选择合适的垃圾收集器</h3><p><img src="/imgs/JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/image-20240412123427125.png" alt="image-20240412123427125"></p>

  </div>
</article>

    <div class="blog-post-comments">
        <div id="disqus_thread">
            <noscript>Please enable JavaScript to view the comments.</noscript>
        </div>
    </div>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
        
          <li><a href="/">Home</a></li>
        
          <li><a href="/about/">About</a></li>
        
          <li><a href="/archives/">Writing</a></li>
        
          <li><a href="/tags/">Tag</a></li>
        
          <li><a target="_blank" rel="noopener" href="http://github.com/hulingF">Projects</a></li>
        
      </ul>
    </div>

    
    
      <div id="toc-footer" style="display: none">
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86"><span class="toc-number">1.</span> <span class="toc-text">JVM垃圾收集</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="toc-number">1.1.</span> <span class="toc-text">为什么需要垃圾回收</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%A9%E6%9C%9F%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6"><span class="toc-number">1.2.</span> <span class="toc-text">早期垃圾回收机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6"><span class="toc-number">1.3.</span> <span class="toc-text">Java垃圾回收机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95"><span class="toc-number">1.4.</span> <span class="toc-text">垃圾回收相关算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E8%AE%B0%E9%98%B6%E6%AE%B5%E7%9A%84%E7%9B%AE%E7%9A%84"><span class="toc-number">1.4.1.</span> <span class="toc-text">标记阶段的目的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E8%AE%B0%E9%98%B6%E6%AE%B5%EF%BC%9A%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E7%AE%97%E6%B3%95"><span class="toc-number">1.4.2.</span> <span class="toc-text">标记阶段：引用计数算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E8%AE%B0%E9%98%B6%E6%AE%B5%EF%BC%9A%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90%E7%AE%97%E6%B3%95"><span class="toc-number">1.4.3.</span> <span class="toc-text">标记阶段：可达性分析算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84finalize%E6%9C%BA%E5%88%B6"><span class="toc-number">1.4.4.</span> <span class="toc-text">对象的finalize机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E4%BB%A3%E6%94%B6%E9%9B%86%E7%90%86%E8%AE%BA"><span class="toc-number">1.4.5.</span> <span class="toc-text">分代收集理论</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B8%85%E9%99%A4%E9%98%B6%E6%AE%B5%EF%BC%9A%E6%A0%87%E8%AE%B0-%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95"><span class="toc-number">1.4.6.</span> <span class="toc-text">清除阶段：标记-清除算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B8%85%E9%99%A4%E9%98%B6%E6%AE%B5%EF%BC%9A%E6%A0%87%E8%AE%B0-%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95"><span class="toc-number">1.4.7.</span> <span class="toc-text">清除阶段：标记-复制算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B8%85%E9%99%A4%E9%98%B6%E6%AE%B5%EF%BC%9A%E6%A0%87%E8%AE%B0-%E6%95%B4%E7%90%86%E7%AE%97%E6%B3%95"><span class="toc-number">1.4.8.</span> <span class="toc-text">清除阶段：标记-整理算法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5"><span class="toc-number">1.5.</span> <span class="toc-text">垃圾回收相关概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#System-gc-%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">1.5.1.</span> <span class="toc-text">System.gc()的理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#STW%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">1.5.2.</span> <span class="toc-text">STW的理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%8D%E8%B0%88%E5%BC%95%E7%94%A8%E6%A6%82%E8%BF%B0"><span class="toc-number">1.5.3.</span> <span class="toc-text">再谈引用概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%8D%E8%B0%88%E5%BC%95%E7%94%A8%EF%BC%9A%E5%BC%BA%E5%BC%95%E7%94%A8"><span class="toc-number">1.5.4.</span> <span class="toc-text">再谈引用：强引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%8D%E8%B0%88%E5%BC%95%E7%94%A8%EF%BC%9A%E8%BD%AF%E5%BC%95%E7%94%A8"><span class="toc-number">1.5.5.</span> <span class="toc-text">再谈引用：软引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%8D%E8%B0%88%E5%BC%95%E7%94%A8%EF%BC%9A%E5%BC%B1%E5%BC%95%E7%94%A8"><span class="toc-number">1.5.6.</span> <span class="toc-text">再谈引用：弱引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%8D%E8%B0%88%E5%BC%95%E7%94%A8%EF%BC%9A%E8%99%9A%E5%BC%95%E7%94%A8"><span class="toc-number">1.5.7.</span> <span class="toc-text">再谈引用：虚引用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8"><span class="toc-number">1.6.</span> <span class="toc-text">垃圾回收器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7%E6%AC%BE%E7%BB%8F%E5%85%B8%E7%9A%84%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">1.6.1.</span> <span class="toc-text">7款经典的垃圾收集器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E7%9A%84%E7%BB%84%E5%90%88%E5%85%B3%E7%B3%BB"><span class="toc-number">1.6.2.</span> <span class="toc-text">垃圾收集器的组合关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Serial%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">1.6.3.</span> <span class="toc-text">Serial收集器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ParNew%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">1.6.4.</span> <span class="toc-text">ParNew收集器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Parallel-Scavenge%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">1.6.5.</span> <span class="toc-text">Parallel Scavenge收集器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Serial-Old%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">1.6.6.</span> <span class="toc-text">Serial Old收集器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Parallel-Old%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">1.6.7.</span> <span class="toc-text">Parallel Old收集器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CMS%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">1.6.8.</span> <span class="toc-text">CMS收集器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#G1%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">1.6.9.</span> <span class="toc-text">G1收集器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8ERegion%E7%9A%84%E5%8C%BA%E5%9F%9F%E5%88%86%E4%BB%A3"><span class="toc-number">1.6.9.1.</span> <span class="toc-text">基于Region的区域分代</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E9%A2%84%E6%B5%8B%E7%9A%84%E5%81%9C%E9%A1%BF%E6%97%B6%E9%97%B4%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.6.9.2.</span> <span class="toc-text">可预测的停顿时间模型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E8%BF%87%E7%A8%8B"><span class="toc-number">1.6.9.3.</span> <span class="toc-text">垃圾收集过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A9%BA%E9%97%B4%E6%95%B4%E5%90%88"><span class="toc-number">1.6.9.4.</span> <span class="toc-text">空间整合</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%AD%A5%E9%AA%A4"><span class="toc-number">1.6.9.5.</span> <span class="toc-text">使用步骤</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E5%90%88%E9%80%82%E7%9A%84%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">1.6.10.</span> <span class="toc-text">选择合适的垃圾收集器</span></a></li></ol></li></ol></li></ol>
      </div>
    

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://hulingf.github.io/2024/03/09/JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://hulingf.github.io/2024/03/09/JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/&text=JVM垃圾收集"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://hulingf.github.io/2024/03/09/JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/&title=JVM垃圾收集"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://hulingf.github.io/2024/03/09/JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/&is_video=false&description=JVM垃圾收集"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=JVM垃圾收集&body=Check out this article: https://hulingf.github.io/2024/03/09/JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/"><i class="fa-solid fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://hulingf.github.io/2024/03/09/JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/&title=JVM垃圾收集"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://hulingf.github.io/2024/03/09/JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/&title=JVM垃圾收集"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://hulingf.github.io/2024/03/09/JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/&title=JVM垃圾收集"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://hulingf.github.io/2024/03/09/JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/&title=JVM垃圾收集"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://hulingf.github.io/2024/03/09/JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/&name=JVM垃圾收集&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://hulingf.github.io/2024/03/09/JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/&t=JVM垃圾收集"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fa-solid fa-bars fa-lg" aria-hidden="true"></i> Menu</a>
        
          <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fa-solid fa-list fa-lg" aria-hidden="true"></i> TOC</a>
        
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fa-solid fa-share-alt fa-lg" aria-hidden="true"></i> Share</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2024
    hulingF
  </div>
  <div class="footer-right">
    <nav>
      <ul>
        <!--
       --><li><a href="/">Home</a></li><!--
     --><!--
       --><li><a href="/about/">About</a></li><!--
     --><!--
       --><li><a href="/archives/">Writing</a></li><!--
     --><!--
       --><li><a href="/tags/">Tag</a></li><!--
     --><!--
       --><li><a target="_blank" rel="noopener" href="http://github.com/hulingF">Projects</a></li><!--
     -->
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->



  <link rel="preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" crossorigin="anonymous" onload="this.onload=null;this.rel='stylesheet'"/>


    <!-- jquery -->

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" crossorigin="anonymous"></script>




<!-- clipboard -->

  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.7/clipboard.min.js" crossorigin="anonymous"></script>
  
  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"Copy to clipboard!\">";
    btn += '<i class="fa-regular fa-clone"></i>';
    btn += '</span>';
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "Copied!");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Disqus Comments -->

    <script type="text/javascript">
        var disqus_shortname = 'hulingF';

        (function(){
            var dsq = document.createElement('script');
            dsq.type = 'text/javascript';
            dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        }());
    </script>

<!-- utterances Comments -->

</body>
</html>
