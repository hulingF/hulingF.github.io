<!DOCTYPE html>
<html lang=en>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5" />
    <meta name="description" content="eBPF冒险记(一)1.eBPF简要介绍1.1应用介绍eBPF是什么呢？ 从它的全称“扩展的伯克利数据包过滤器 (Extended Berkeley Packet Filter)” 来看，它是一种数据包过滤技术，是从BPF(Berkeley Packet Filter)技术扩展而来的。BPF提供了一种在内核事件和用户程序事件发生时安全注入代码的机制，这就让非内核开发人员也可以对内核进行控制。随着内">
<meta property="og:type" content="article">
<meta property="og:title" content="eBPF冒险记(一)">
<meta property="og:url" content="https://hulingf.github.io/2024/09/15/eBPF%E5%86%92%E9%99%A9%E8%AE%B0(%E4%B8%80)/index.html">
<meta property="og:site_name" content="大军的秘密花园">
<meta property="og:description" content="eBPF冒险记(一)1.eBPF简要介绍1.1应用介绍eBPF是什么呢？ 从它的全称“扩展的伯克利数据包过滤器 (Extended Berkeley Packet Filter)” 来看，它是一种数据包过滤技术，是从BPF(Berkeley Packet Filter)技术扩展而来的。BPF提供了一种在内核事件和用户程序事件发生时安全注入代码的机制，这就让非内核开发人员也可以对内核进行控制。随着内">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://hulingf.github.io/imgs/eBPF%E5%86%92%E9%99%A9%E8%AE%B0(%E4%B8%80)/7de332b0fd6dc10b757a660305a90153.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/eBPF%E5%86%92%E9%99%A9%E8%AE%B0(%E4%B8%80)/b44562381748de369b50403219c0d1ff.jpg">
<meta property="og:image" content="https://hulingf.github.io/imgs/eBPF%E5%86%92%E9%99%A9%E8%AE%B0(%E4%B8%80)/a7165eea1fd9fc24090a3a1e8987986a.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/eBPF%E5%86%92%E9%99%A9%E8%AE%B0(%E4%B8%80)/53af7f7db99c3ca57f981f00303949dd.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/eBPF%E5%86%92%E9%99%A9%E8%AE%B0(%E4%B8%80)/image-20240916065247579.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/eBPF%E5%86%92%E9%99%A9%E8%AE%B0(%E4%B8%80)/image-20240916070832997.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/eBPF%E5%86%92%E9%99%A9%E8%AE%B0(%E4%B8%80)/image-20240916072750870.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/eBPF%E5%86%92%E9%99%A9%E8%AE%B0(%E4%B8%80)/453f8d99cea1b35da8f6c57e552yy3d2.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/eBPF%E5%86%92%E9%99%A9%E8%AE%B0(%E4%B8%80)/image-20240916121809468.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/eBPF%E5%86%92%E9%99%A9%E8%AE%B0(%E4%B8%80)/image-20240916121911986.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/eBPF%E5%86%92%E9%99%A9%E8%AE%B0(%E4%B8%80)/image-20240916121944750.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/eBPF%E5%86%92%E9%99%A9%E8%AE%B0(%E4%B8%80)/image-20240916123536077.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/eBPF%E5%86%92%E9%99%A9%E8%AE%B0(%E4%B8%80)/image-20240916122616741.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/eBPF%E5%86%92%E9%99%A9%E8%AE%B0(%E4%B8%80)/image-20240916123709787.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/eBPF%E5%86%92%E9%99%A9%E8%AE%B0(%E4%B8%80)/a7165eea1fd9fc24090a3a1e8987986a-1726462595626-11.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/eBPF%E5%86%92%E9%99%A9%E8%AE%B0(%E4%B8%80)/image-20240916130428224.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/eBPF%E5%86%92%E9%99%A9%E8%AE%B0(%E4%B8%80)/7cc33d0bdd8a3ba0dda7f533f3375b88.jpg">
<meta property="og:image" content="https://hulingf.github.io/imgs/eBPF%E5%86%92%E9%99%A9%E8%AE%B0(%E4%B8%80)/0b3edac18276a1236dde7135b961d8cb.jpg">
<meta property="og:image" content="https://hulingf.github.io/imgs/eBPF%E5%86%92%E9%99%A9%E8%AE%B0(%E4%B8%80)/d87b409fa85d3a07973a8689b228cf11.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/eBPF%E5%86%92%E9%99%A9%E8%AE%B0(%E4%B8%80)/f3210199e6689e7659057a935e7fc5d7.jpg">
<meta property="og:image" content="https://hulingf.github.io/imgs/eBPF%E5%86%92%E9%99%A9%E8%AE%B0(%E4%B8%80)/45bbf696e8620d322d857ceab3871720.jpg">
<meta property="og:image" content="https://hulingf.github.io/imgs/eBPF%E5%86%92%E9%99%A9%E8%AE%B0(%E4%B8%80)/image-20240916141837897.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/eBPF%E5%86%92%E9%99%A9%E8%AE%B0(%E4%B8%80)/042fe319b51yy6bc153ce0f877f54a38.jpg">
<meta property="og:image" content="https://hulingf.github.io/imgs/eBPF%E5%86%92%E9%99%A9%E8%AE%B0(%E4%B8%80)/xdp-packet-processing-1024x560.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/eBPF%E5%86%92%E9%99%A9%E8%AE%B0(%E4%B8%80)/a2cayy9f21129590a91ca07604b070a7.jpg">
<meta property="og:image" content="https://hulingf.github.io/imgs/eBPF%E5%86%92%E9%99%A9%E8%AE%B0(%E4%B8%80)/31ecf04f2477bd4765be9544a62deed5.jpg">
<meta property="og:image" content="https://hulingf.github.io/imgs/eBPF%E5%86%92%E9%99%A9%E8%AE%B0(%E4%B8%80)/0e57bf041262114198fd29e1e5c04044.jpg">
<meta property="og:image" content="https://hulingf.github.io/imgs/eBPF%E5%86%92%E9%99%A9%E8%AE%B0(%E4%B8%80)/93ae17801e82579e07937e5f1595a0f2.jpg">
<meta property="article:published_time" content="2024-09-15T08:38:02.182Z">
<meta property="article:modified_time" content="2024-09-16T06:44:52.794Z">
<meta property="article:author" content="hulingF">
<meta property="article:tag" content="性能优化">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://hulingf.github.io/imgs/eBPF%E5%86%92%E9%99%A9%E8%AE%B0(%E4%B8%80)/7de332b0fd6dc10b757a660305a90153.png">
    
    
      
        
          <link rel="shortcut icon" href="/images/favicon.ico">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
        
      
    
    <!-- title -->
    <title>eBPF冒险记(一)</title>
    <!-- async scripts -->
    <!-- Google Analytics -->


    <!-- Umami Analytics -->


    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
    <!-- rss -->
    
    
	<!-- mathjax -->
	
<meta name="generator" content="Hexo 6.3.0"></head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#" aria-label="Menu"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#" aria-label="Menu"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" aria-label="Top" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa-solid fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
        <!--
       --><li><a href="/">Home</a></li><!--
     --><!--
       --><li><a href="/about/">About</a></li><!--
     --><!--
       --><li><a href="/archives/">Writing</a></li><!--
     --><!--
       --><li><a href="/tags/">Tag</a></li><!--
     --><!--
       --><li><a target="_blank" rel="noopener" href="http://github.com/hulingF">Projects</a></li><!--
     -->
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" aria-label="Previous post" href="/2024/09/16/eBPF%E5%86%92%E9%99%A9%E8%AE%B0(%E4%BA%8C)/"><i class="fa-solid fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" aria-label="Next post" href="/2024/09/14/Vagrant%E5%86%92%E9%99%A9%E8%AE%B0(%E4%B8%80)/"><i class="fa-solid fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" aria-label="Back to top" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" aria-label="Share post" href="#"><i class="fa-solid fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://hulingf.github.io/2024/09/15/eBPF%E5%86%92%E9%99%A9%E8%AE%B0(%E4%B8%80)/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://hulingf.github.io/2024/09/15/eBPF%E5%86%92%E9%99%A9%E8%AE%B0(%E4%B8%80)/&text=eBPF冒险记(一)"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://hulingf.github.io/2024/09/15/eBPF%E5%86%92%E9%99%A9%E8%AE%B0(%E4%B8%80)/&title=eBPF冒险记(一)"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://hulingf.github.io/2024/09/15/eBPF%E5%86%92%E9%99%A9%E8%AE%B0(%E4%B8%80)/&is_video=false&description=eBPF冒险记(一)"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=eBPF冒险记(一)&body=Check out this article: https://hulingf.github.io/2024/09/15/eBPF%E5%86%92%E9%99%A9%E8%AE%B0(%E4%B8%80)/"><i class="fa-solid fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://hulingf.github.io/2024/09/15/eBPF%E5%86%92%E9%99%A9%E8%AE%B0(%E4%B8%80)/&title=eBPF冒险记(一)"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://hulingf.github.io/2024/09/15/eBPF%E5%86%92%E9%99%A9%E8%AE%B0(%E4%B8%80)/&title=eBPF冒险记(一)"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://hulingf.github.io/2024/09/15/eBPF%E5%86%92%E9%99%A9%E8%AE%B0(%E4%B8%80)/&title=eBPF冒险记(一)"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://hulingf.github.io/2024/09/15/eBPF%E5%86%92%E9%99%A9%E8%AE%B0(%E4%B8%80)/&title=eBPF冒险记(一)"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://hulingf.github.io/2024/09/15/eBPF%E5%86%92%E9%99%A9%E8%AE%B0(%E4%B8%80)/&name=eBPF冒险记(一)&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://hulingf.github.io/2024/09/15/eBPF%E5%86%92%E9%99%A9%E8%AE%B0(%E4%B8%80)/&t=eBPF冒险记(一)"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    
    
      <div id="toc">
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#eBPF%E5%86%92%E9%99%A9%E8%AE%B0-%E4%B8%80"><span class="toc-number">1.</span> <span class="toc-text">eBPF冒险记(一)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-eBPF%E7%AE%80%E8%A6%81%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.1.</span> <span class="toc-text">1.eBPF简要介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1%E5%BA%94%E7%94%A8%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.1.1.</span> <span class="toc-text">1.1应用介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2%E5%8F%91%E5%B1%95%E5%8E%86%E7%A8%8B"><span class="toc-number">1.1.2.</span> <span class="toc-text">1.2发展历程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3%E7%AE%80%E8%A6%81%E5%8E%9F%E7%90%86"><span class="toc-number">1.1.3.</span> <span class="toc-text">1.3简要原理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-eBPF%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA"><span class="toc-number">1.2.</span> <span class="toc-text">2.eBPF环境搭建</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1%E5%89%8D%E7%BD%AE%E7%8E%AF%E5%A2%83"><span class="toc-number">1.2.1.</span> <span class="toc-text">2.1前置环境</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">2.2快速上手</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3%E7%A8%8B%E5%BA%8F%E4%BC%98%E5%8C%96"><span class="toc-number">1.2.2.</span> <span class="toc-text">2.3程序优化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-eBPF%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86"><span class="toc-number">1.3.</span> <span class="toc-text">3.eBPF运行原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1eBPF%E8%99%9A%E6%8B%9F%E6%9C%BA"><span class="toc-number">1.3.1.</span> <span class="toc-text">3.1eBPF虚拟机</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2BPF%E6%8C%87%E4%BB%A4%E6%A0%BC%E5%BC%8F"><span class="toc-number">1.3.2.</span> <span class="toc-text">3.2BPF指令格式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3%E5%85%B7%E4%BD%93%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="toc-number">1.3.3.</span> <span class="toc-text">3.3具体执行过程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-eBPF%E7%BC%96%E7%A8%8B%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.4.</span> <span class="toc-text">4.eBPF编程接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1BPF%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-number">1.4.1.</span> <span class="toc-text">4.1BPF系统调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2BPF%E8%BE%85%E5%8A%A9%E5%87%BD%E6%95%B0"><span class="toc-number">1.4.2.</span> <span class="toc-text">4.2BPF辅助函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3BPF%E6%98%A0%E5%B0%84"><span class="toc-number">1.4.3.</span> <span class="toc-text">4.3BPF映射</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4BPF%E7%B1%BB%E5%9E%8B%E6%A0%BC%E5%BC%8F"><span class="toc-number">1.4.4.</span> <span class="toc-text">4.4BPF类型格式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-eBPF%E4%BA%8B%E4%BB%B6%E8%A7%A6%E5%8F%91"><span class="toc-number">1.5.</span> <span class="toc-text">5.eBPF事件触发</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1%E8%B7%9F%E8%B8%AA%E7%B1%BBeBPF%E7%A8%8B%E5%BA%8F"><span class="toc-number">1.5.1.</span> <span class="toc-text">5.1跟踪类eBPF程序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2%E7%BD%91%E7%BB%9C%E7%B1%BBeBPF%E7%A8%8B%E5%BA%8F"><span class="toc-number">1.5.2.</span> <span class="toc-text">5.2网络类eBPF程序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-1XDP%E7%A8%8B%E5%BA%8F"><span class="toc-number">1.5.2.1.</span> <span class="toc-text">5.2.1XDP程序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-2TC%E7%A8%8B%E5%BA%8F"><span class="toc-number">1.5.2.2.</span> <span class="toc-text">5.2.2TC程序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-3%E5%A5%97%E6%8E%A5%E5%AD%97%E7%A8%8B%E5%BA%8F"><span class="toc-number">1.5.2.3.</span> <span class="toc-text">5.2.3套接字程序</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3%E5%85%B6%E4%BB%96%E7%A8%8B%E5%BA%8F"><span class="toc-number">1.5.3.</span> <span class="toc-text">5.3其他程序</span></a></li></ol></li></ol></li></ol>
      </div>
    
  </span>
</div>

    
    <div class="content index py4 ">
        
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle p-name" itemprop="name headline">
        eBPF冒险记(一)
    </h1>



    <div class="meta">
      <span class="author p-author h-card" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span class="p-name" itemprop="name">hulingF</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2024-09-15T08:38:02.182Z" class="dt-published" itemprop="datePublished">2024-09-15</time>
        
      
    </div>


      

      
    <div class="article-tag">
        <i class="fa-solid fa-tag"></i>
        <a class="p-category" href="/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" rel="tag">性能优化</a>
    </div>


    </div>
  </header>
  

  <div class="content e-content" itemprop="articleBody">
    <h1 id="eBPF冒险记-一"><a href="#eBPF冒险记-一" class="headerlink" title="eBPF冒险记(一)"></a>eBPF冒险记(一)</h1><h2 id="1-eBPF简要介绍"><a href="#1-eBPF简要介绍" class="headerlink" title="1.eBPF简要介绍"></a>1.eBPF简要介绍</h2><h3 id="1-1应用介绍"><a href="#1-1应用介绍" class="headerlink" title="1.1应用介绍"></a>1.1应用介绍</h3><p>eBPF是什么呢？ 从它的全称“扩展的伯克利数据包过滤器 (Extended Berkeley Packet Filter)” 来看，它是一种<code>数据包过滤技术</code>，是从BPF(Berkeley Packet Filter)技术扩展而来的。BPF提供了一种<code>在内核事件和用户程序事件发生时安全注入代码的机制</code>，这就让非内核开发人员也可以对内核进行控制。随着内核的发展，BPF逐步从最初的数据包过滤扩展到了网络、内核、安全、跟踪等，而且它的功能特性还在快速发展中。实际上，现代内核所运行的都是eBPF，如果没有特殊说明，内核和开源社区中提到的BPF等同于eBPF。在eBPF之前，内核模块是注入内核的最主要机制。由于缺乏对内核模块的安全控制，内核的基本功能很容易被一个有缺陷的内核模块破坏。而eBPF则借助即时编译器（JIT），在内核中运行了一个虚拟机，保证<code>只有被验证安全的eBPF指令才会被内核执行</code>。同时，因为eBPF指令依然运行在内核中，无需向用户态复制数据，这就大大提高了事件处理的效率。</p>
<p><img src="/imgs/eBPF%E5%86%92%E9%99%A9%E8%AE%B0(%E4%B8%80)/7de332b0fd6dc10b757a660305a90153.png" alt="img"></p>
<h3 id="1-2发展历程"><a href="#1-2发展历程" class="headerlink" title="1.2发展历程"></a>1.2发展历程</h3><p>为了更好地理解eBPF的发展历程，eBPF诞生以来的发展过程如图所示：</p>
<p><img src="/imgs/eBPF%E5%86%92%E9%99%A9%E8%AE%B0(%E4%B8%80)/b44562381748de369b50403219c0d1ff.jpg" alt="img"></p>
<h3 id="1-3简要原理"><a href="#1-3简要原理" class="headerlink" title="1.3简要原理"></a>1.3简要原理</h3><p>eBPF程序并不像常规的线程那样，启动后就一直运行在那里，它需要<code>事件触发</code>后才会执行。这些事件包括系统调用、内核跟踪点、内核函数和用户态函数的调用退出、网络事件，等等。借助于强大的内核态插桩（kprobe）和用户态插桩（uprobe），eBPF程序几乎可以在内核和应用的任意位置进行插桩。看到这个令人惊叹的能力，你一定有疑问：这会不会像内核模块一样，一个异常的eBPF程序就会损坏整个内核的稳定性呢？其实，确保安全和稳定一直都是eBPF的首要任务，不安全的eBPF程序根本就不会提交到内核虚拟机中执行。</p>
<p>通常我们借助<code>LLVM</code>把编写的eBPF程序转换为<code>BPF字节码</code>，然后再通过<code>bpf</code>系统调用提交给内核执行。内核在接受BPF字节码之前，会首先通过验证器对字节码进行校验，只有校验通过的BPF字节码才会提交到即时编译器执行(如BPF程序不能包含无限循环、BPF程序不能导致内核崩溃、BPF程序必须在有限时间内完成)。</p>
<p><img src="/imgs/eBPF%E5%86%92%E9%99%A9%E8%AE%B0(%E4%B8%80)/a7165eea1fd9fc24090a3a1e8987986a.png" alt="img"></p>
<p>BPF程序可以利用<code>BPF映射（map）</code>进行存储，而用户程序通常也需要通过BPF映射同运行在内核中的BPF程序进行交互。在性能观测中，BPF 程序收集内核运行状态存储在映射中，用户程序再从映射中读出这些状态。可以看到，eBPF程序的运行需要历经<code>编译</code>、<code>加载</code>、<code>验证</code>和<code>内核态执行</code>等过程，而用户态程序则需要借助BPF映射来获取内核态eBPF程序的运行状态。</p>
<p><img src="/imgs/eBPF%E5%86%92%E9%99%A9%E8%AE%B0(%E4%B8%80)/53af7f7db99c3ca57f981f00303949dd.png" alt="img"></p>
<h2 id="2-eBPF环境搭建"><a href="#2-eBPF环境搭建" class="headerlink" title="2.eBPF环境搭建"></a>2.eBPF环境搭建</h2><h3 id="2-1前置环境"><a href="#2-1前置环境" class="headerlink" title="2.1前置环境"></a>2.1前置环境</h3><p>作为eBPF最重大的改进之一，一次编译到处执行（简称CO-RE）解决了内核数据结构在不同版本差异导致的兼容性问题。不过，在使用CO-RE之前，内核需要开启<code>CONFIG_DEBUG_INFO_BTF=y</code>和<code>CONFIG_DEBUG_INFO=y</code>这两个编译选项。为了避免首次学习eBPF时就去重新编译内核，推荐使用已经默认开启这些编译选项的发行版，作为你的开发环境，比如Ubuntu 20.10+。</p>
<p><img src="/imgs/eBPF%E5%86%92%E9%99%A9%E8%AE%B0(%E4%B8%80)/image-20240916065247579.png" alt="image-20240916065247579"></p>
<p>虚拟机创建好之后，接下来就需要安装eBPF开发和运行所需要的开发工具：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">For Ubuntu20.10+</span></span><br><span class="line">sudo apt-get install -y  make clang llvm libelf-dev libbpf-dev bpfcc-tools libbpfcc-dev linux-tools-$(uname -r) linux-headers-$(uname -r)</span><br></pre></td></tr></table></figure>

<h4 id="2-2快速上手"><a href="#2-2快速上手" class="headerlink" title="2.2快速上手"></a>2.2快速上手</h4><p>BCC是一个BPF编译器集合，包含了用于构建BPF程序的编程框架和库，并提供了大量可以直接使用的工具。使用BCC的好处是，它把eBPF执行过程通过内置框架抽象了起来，并提供了Python、C++等编程语言接口。这样，你就可以直接通过Python语言去跟eBPF的各种事件和数据进行交互。接下来，我就以跟踪openat(即打开文件)这个系统调用为例，来看看如何开发并运行第一个eBPF程序。</p>
<p>(1)使用C开发BPF程序</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BPF程序，后续会被LLVM编译成字节码并通过bpf系统调用提交给内核检查并执行</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">hello_world</span><span class="params">(<span class="type">void</span> *ctx)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// BPF辅助函数，输出是内核调试文件/sys/kernel/debug/tracing/trace_pipe</span></span><br><span class="line">    bpf_trace_printk(<span class="string">&quot;Hello, World!&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>(2)使用Python和BCC库开发用户态程序</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># 1) import bcc library</span></span><br><span class="line"><span class="keyword">from</span> bcc <span class="keyword">import</span> BPF</span><br><span class="line"><span class="comment"># 2) load BPF program</span></span><br><span class="line">b = BPF(src_file=<span class="string">&quot;hello.c&quot;</span>)</span><br><span class="line"><span class="comment"># 3) attach kprobe</span></span><br><span class="line">b.attach_kprobe(event=<span class="string">&quot;do_sys_openat2&quot;</span>, fn_name=<span class="string">&quot;hello_world&quot;</span>)</span><br><span class="line"><span class="comment"># 4) read and print /sys/kernel/debug/tracing/trace_pipe</span></span><br><span class="line">b.trace_print()</span><br></pre></td></tr></table></figure>

<p>(3)执行eBPF程序</p>
<p><img src="/imgs/eBPF%E5%86%92%E9%99%A9%E8%AE%B0(%E4%B8%80)/image-20240916070832997.png" alt="image-20240916070832997"></p>
<p>到了这里，我们已经成功开发并运行了第一个eBPF程序！不过，短暂的兴奋之后，发现这个程序还有不少的缺点，比如：</p>
<ul>
<li>既然跟踪的是打开文件的系统调用，除了调用这个接口进程的名字之外，被打开的文件名也应该在输出中；</li>
<li>bpf_trace_printk() 的输出格式不够灵活，像是CPU编号、bpf_trace_printk函数名等内容没必要输出；</li>
<li>……</li>
</ul>
<h3 id="2-3程序优化"><a href="#2-3程序优化" class="headerlink" title="2.3程序优化"></a>2.3程序优化</h3><blockquote>
<p>实际上，并不推荐通过内核调试文件系统输出日志的方式。一方面，它会带来很大的性能问题；另一方面，所有的eBPF程序都会把内容输出到同一个位置，很难根据eBPF程序去区分日志的来源。接下来，我们就试着一起改进这个程序。</p>
</blockquote>
<p>(1)使用C开发BPF程序</p>
<p>为了解决上面提到的第一个问题，即获取被打开文件名的问题，我们就要引入BPF映射。为了简化BPF映射的交互，BCC定义了一系列的库函数和辅助宏定义，比如，可以使用<code>BPF_PERF_OUTPUT</code>来定义一个Perf事件类型的BPF映射:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 包含头文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;uapi/linux/openat2.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/sched.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义数据结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">data_t</span> &#123;</span></span><br><span class="line">  u32 pid;</span><br><span class="line">  u64 ts;</span><br><span class="line">  <span class="type">char</span> comm[TASK_COMM_LEN];</span><br><span class="line">  <span class="type">char</span> fname[NAME_MAX];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义性能事件映射events</span></span><br><span class="line">BPF_PERF_OUTPUT(events);</span><br></pre></td></tr></table></figure>

<p>然后，在eBPF程序中，填充这个数据结构，并调用<code>perf_submit()</code>把数据提交到刚才定义的BPF映射中:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义kprobe处理函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">hello_world</span><span class="params">(<span class="keyword">struct</span> pt_regs *ctx, <span class="type">int</span> dfd, <span class="type">const</span> <span class="type">char</span> __user * filename, <span class="keyword">struct</span> open_how *how)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">data_t</span> <span class="title">data</span> =</span> &#123; &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取PID和时间</span></span><br><span class="line">  data.pid = bpf_get_current_pid_tgid();</span><br><span class="line">  data.ts = bpf_ktime_get_ns();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取进程名</span></span><br><span class="line">  <span class="keyword">if</span> (bpf_get_current_comm(&amp;data.comm, <span class="keyword">sizeof</span>(data.comm)) == <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    bpf_probe_read(&amp;data.fname, <span class="keyword">sizeof</span>(data.fname), (<span class="type">void</span> *)filename);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 提交性能事件</span></span><br><span class="line">  events.perf_submit(ctx, &amp;data, <span class="keyword">sizeof</span>(data));</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>bpf_get_current_pid_tgid</code>用于获取进程的TGID和PID。因为这儿定义的data.pid数据类型为u32，所以高32位舍弃掉后就是进程的PID；</li>
<li><code>bpf_ktime_get_ns</code>用于获取系统自启动以来的时间，单位是纳秒；</li>
<li><code>bpf_get_current_comm</code>用于获取进程名，并把进程名复制到预定义的缓冲区中；</li>
<li><code>bpf_probe_read</code>用于从指定指针处读取固定大小的数据，这里则用于读取进程打开的文件名。</li>
</ul>
<p>(2)使用Python和BCC库开发用户态程序</p>
<p>有了BPF映射之后，前面我们调用的bpf_trace_printk()其实就不再需要了，因为用户态进程可以直接从BPF映射中读取内核eBPF程序的运行状态。这其实也就是上面提到的第二个待解决问题。那么，怎样从用户态读取BPF映射内容并输出到标准输出STDOUT呢？</p>
<p>在BCC中，与eBPF程序中BPF_PERF_OUTPUT相对应的用户态辅助函数是<code>open_perf_buffer()</code>。它需要传入一个<code>回调函数</code>，用于处理从Perf事件类型的BPF映射中读取到的数据。具体的使用方法如下所示:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> bcc <span class="keyword">import</span> BPF</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1) load BPF program</span></span><br><span class="line">b = BPF(src_file=<span class="string">&quot;trace-open.c&quot;</span>)</span><br><span class="line">b.attach_kprobe(event=<span class="string">&quot;do_sys_openat2&quot;</span>, fn_name=<span class="string">&quot;hello_world&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2) print header</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;%-18s %-16s %-6s %-16s&quot;</span> % (<span class="string">&quot;TIME(s)&quot;</span>, <span class="string">&quot;COMM&quot;</span>, <span class="string">&quot;PID&quot;</span>, <span class="string">&quot;FILE&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3) define the callback for perf event</span></span><br><span class="line">start = <span class="number">0</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">print_event</span>(<span class="params">cpu, data, size</span>):</span><br><span class="line">    <span class="keyword">global</span> start</span><br><span class="line">    event = b[<span class="string">&quot;events&quot;</span>].event(data)</span><br><span class="line">    <span class="keyword">if</span> start == <span class="number">0</span>:</span><br><span class="line">            start = event.ts</span><br><span class="line">    time_s = (<span class="built_in">float</span>(event.ts - start)) / <span class="number">1000000000</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;%-18.9f %-16s %-6d %-16s&quot;</span> % (time_s, event.comm, event.pid, event.fname))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4) loop with callback to print_event</span></span><br><span class="line">b[<span class="string">&quot;events&quot;</span>].open_perf_buffer(print_event)</span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        b.perf_buffer_poll()</span><br><span class="line">    <span class="keyword">except</span> KeyboardInterrupt:</span><br><span class="line">        exit()</span><br></pre></td></tr></table></figure>

<p>(3)执行eBPF程序</p>
<p><img src="/imgs/eBPF%E5%86%92%E9%99%A9%E8%AE%B0(%E4%B8%80)/image-20240916072750870.png" alt="image-20240916072750870"></p>
<p>恭喜，我们已经开发了第一个完整的eBPF程序。相对于前面的Hello World，它的输出不仅格式更为清晰，还把进程打开的文件名输出出来了，这在<code>排查频繁打开文件相关的性能问题</code>时尤其有用。</p>
<h2 id="3-eBPF运行原理"><a href="#3-eBPF运行原理" class="headerlink" title="3.eBPF运行原理"></a>3.eBPF运行原理</h2><h3 id="3-1eBPF虚拟机"><a href="#3-1eBPF虚拟机" class="headerlink" title="3.1eBPF虚拟机"></a>3.1eBPF虚拟机</h3><p>eBPF是一个运行在内核中的虚拟机，很多人在初次接触它时，会把它跟系统虚拟化（比如KVM）中的虚拟机弄混。其实，虽然都被称为虚拟机，系统虚拟化和eBPF虚拟机还是有着本质不同的。</p>
<blockquote>
<p>系统虚拟化基于<code>x86</code>或<code>arm64</code>等<code>通用指令集</code>，这些指令集足以完成完整计算机的所有功能。而为了确保在内核中安全地执行，eBPF只提供了<code>非常有限的指令集</code>。这些指令集可用于完成一部分内核的功能，但却远不足以模拟完整的计算机。为了更高效地与内核进行交互，eBPF指令还有意采用了<code>C调用约定</code>，其提供的辅助函数可以在C语言中直接调用，极大地方便了eBPF程序的开发。</p>
</blockquote>
<p><img src="/imgs/eBPF%E5%86%92%E9%99%A9%E8%AE%B0(%E4%B8%80)/453f8d99cea1b35da8f6c57e552yy3d2.png" alt="img"></p>
<ul>
<li>第一个模块是<code>eBPF辅助函数</code>。它提供了一系列用于eBPF程序与内核其他模块进行交互的函数。这些函数并不是任意一个eBPF程序都可以调用的，具体可用的函数集由BPF程序类型决定。</li>
<li>第二个模块是<code>eBPF验证器</code>。它用于确保eBPF程序的安全。验证器会将待执行的指令创建为一个<code>有向无环图（DAG）</code>，确保程序中不包含不可达指令；接着再模拟指令的执行过程，确保不会执行无效指令。</li>
<li>第三个模块是由<code>11个64位寄存器</code>、<code>一个程序计数器</code>和<code>一个512字节的栈</code>组成的存储模块。这个模块用于控制eBPF程序的执行。其中<code>R0</code>寄存器用于存储函数调用和eBPF程序的返回值，这意味着函数调用最多只能有一个返回值；<code>R1-R5</code>寄存器用于函数调用的参数，因此函数调用的参数最多不能超过5个；而<code>R10</code>则是一个只读寄存器，用于从栈中读取数据。</li>
<li>第四个模块是<code>即时编译器</code>，它将eBPF字节码编译成本地机器指令，以便更高效地在内核中执行。</li>
<li>第五个模块是<code>BPF映射（map）</code>，它用于提供大块的存储。这些存储可被用户空间程序用来进行访问，进而控制eBPF程序的运行状态。</li>
</ul>
<h3 id="3-2BPF指令格式"><a href="#3-2BPF指令格式" class="headerlink" title="3.2BPF指令格式"></a>3.2BPF指令格式</h3><p>只看图中的这些模块，你可能觉得它们并不是太直观。所以接下来，我们还是用上一讲的Hello World作为例子，一起看下BPF指令到底是什么样子的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">hello_world</span><span class="params">(<span class="type">void</span> *ctx)</span></span><br><span class="line">&#123;</span><br><span class="line">  bpf_trace_printk(<span class="string">&quot;Hello, World!&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先，打开一个新的终端，执行下面的命令，查询系统中正在运行的eBPF程序：</p>
<p><img src="/imgs/eBPF%E5%86%92%E9%99%A9%E8%AE%B0(%E4%B8%80)/image-20240916121809468.png" alt="image-20240916121809468"></p>
<p>输出中，19是这个eBPF程序的编号，kprobe是程序的类型，而hello_world是程序的名字。有了eBPF程序编号之后，执行下面的命令就可以导出这个eBPF程序的指令：</p>
<p><img src="/imgs/eBPF%E5%86%92%E9%99%A9%E8%AE%B0(%E4%B8%80)/image-20240916121911986.png" alt="image-20240916121911986"></p>
<p>其中，分号开头的部分，正是我们前面写的C代码，而其他行则是具体的BPF指令。具体每一行的BPF指令又分为三部分：</p>
<ul>
<li>第一部分，冒号前面的数字0-12 ，代表BPF指令行数；</li>
<li>第二部分，括号中的16进制数值，表示BPF指令码。</li>
<li>第三部分，括号后面的部分，就是BPF指令的伪代码。</li>
</ul>
<p>结合前面讲述的各个寄存器的作用，不难理解这些BPF指令的含义：</p>
<ul>
<li>第0-8行，借助R10寄存器从栈中把字符串“Hello, World!”读出来，并放入R1寄存器中；</li>
<li>第9行，向R2寄存器写入字符串的长度14（即代码注释里面的sizeof(_fmt)）；</li>
<li>第10行，调用BPF辅助函数bpf_trace_printk输出字符串；</li>
<li>第11行，向R0寄存器写入0，表示程序的返回值是0；</li>
<li>最后一行，程序执行成功退出。</li>
</ul>
<blockquote>
<p>总结起来，这些指令先通过R1和R2寄存器设置了bpf_trace_printk的参数，然后调用bpf_trace_printk函数输出字符串，最后再通过R0寄存器返回成功。</p>
</blockquote>
<p>当这些BPF指令加载到内核后，BPF即时编译器会将其编译成本地机器指令，最后才会执行编译后的机器指令：</p>
<p><img src="/imgs/eBPF%E5%86%92%E9%99%A9%E8%AE%B0(%E4%B8%80)/image-20240916121944750.png" alt="image-20240916121944750"></p>
<h3 id="3-3具体执行过程"><a href="#3-3具体执行过程" class="headerlink" title="3.3具体执行过程"></a>3.3具体执行过程</h3><p>BCC负责了eBPF程序的编译和加载过程。因而，要了解BPF指令的加载过程，就可以从BCC执行eBPF程序的过程入手。那么，怎么才能查看到BCC的执行过程呢？那就是跟踪它的系统调用过程。</p>
<p><img src="/imgs/eBPF%E5%86%92%E9%99%A9%E8%AE%B0(%E4%B8%80)/image-20240916123536077.png" alt="image-20240916123536077"></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">bpf(BPF_PROG_LOAD,</span><br><span class="line">    &#123;</span><br><span class="line">        prog_type=BPF_PROG_TYPE_KPROBE,</span><br><span class="line">        insn_cnt=13,</span><br><span class="line">        insns=[</span><br><span class="line">            &#123;code=BPF_ALU64|BPF_K|BPF_MOV, dst_reg=BPF_REG_1, src_reg=BPF_REG_0, off=0, imm=0x21&#125;,</span><br><span class="line">            &#123;code=BPF_STX|BPF_H|BPF_MEM, dst_reg=BPF_REG_10, src_reg=BPF_REG_1, off=-4, imm=0&#125;,</span><br><span class="line">            &#123;code=BPF_ALU64|BPF_K|BPF_MOV, dst_reg=BPF_REG_1, src_reg=BPF_REG_0, off=0, imm=0x646c726f&#125;,</span><br><span class="line">            &#123;code=BPF_STX|BPF_W|BPF_MEM, dst_reg=BPF_REG_10, src_reg=BPF_REG_1, off=-8, imm=0&#125;,</span><br><span class="line">            &#123;code=BPF_LD|BPF_DW|BPF_IMM, dst_reg=BPF_REG_1, src_reg=BPF_REG_0, off=0, imm=0x6c6c6548&#125;,</span><br><span class="line">            &#123;code=BPF_LD|BPF_W|BPF_IMM, dst_reg=BPF_REG_0, src_reg=BPF_REG_0, off=0, imm=0x57202c6f&#125;,</span><br><span class="line">            &#123;code=BPF_STX|BPF_DW|BPF_MEM, dst_reg=BPF_REG_10, src_reg=BPF_REG_1, off=-16, imm=0&#125;,</span><br><span class="line">            &#123;code=BPF_ALU64|BPF_X|BPF_MOV, dst_reg=BPF_REG_1, src_reg=BPF_REG_10, off=0, imm=0&#125;,</span><br><span class="line">            &#123;code=BPF_ALU64|BPF_K|BPF_ADD, dst_reg=BPF_REG_1, src_reg=BPF_REG_0, off=0, imm=0xfffffff0&#125;,</span><br><span class="line">            &#123;code=BPF_ALU64|BPF_K|BPF_MOV, dst_reg=BPF_REG_2, src_reg=BPF_REG_0, off=0, imm=0xe&#125;,</span><br><span class="line">            &#123;code=BPF_JMP|BPF_K|BPF_CALL, dst_reg=BPF_REG_0, src_reg=BPF_REG_0, off=0, imm=0x6&#125;,</span><br><span class="line">            &#123;code=BPF_ALU64|BPF_K|BPF_MOV, dst_reg=BPF_REG_0, src_reg=BPF_REG_0, off=0, imm=0&#125;,</span><br><span class="line">            &#123;code=BPF_JMP|BPF_K|BPF_EXIT, dst_reg=BPF_REG_0, src_reg=BPF_REG_0, off=0, imm=0&#125;</span><br><span class="line">        ],</span><br><span class="line">        prog_name=&quot;hello_world&quot;,</span><br><span class="line">        ...</span><br><span class="line">    &#125;,</span><br><span class="line">    128) = 4</span><br></pre></td></tr></table></figure>

<p>这些参数看起来很复杂，但实际上，如果你查询bpf系统调用的格式（执行man bpf命令），就可以发现，它实际上只需要三个参数：</p>
<p><img src="/imgs/eBPF%E5%86%92%E9%99%A9%E8%AE%B0(%E4%B8%80)/image-20240916122616741.png" alt="image-20240916122616741"></p>
<p>对应前面的strace输出结果，这三个参数的具体含义如下。</p>
<ul>
<li>第一个参数是<code>BPF_PROG_LOAD</code>，表示加载BPF程序。</li>
<li>第二个参数是<code>bpf_attr</code>类型的结构体，表示BPF程序的属性。其中，有几个需要你留意的参数，比如：<ul>
<li><code>prog_type</code>表示BPF程序的类型，这儿是<code>BPF_PROG_TYPE_KPROBE</code>，跟我们Python代码中的attach_kprobe一致；</li>
<li><code>insn_cnt(instructions count)</code>表示指令条数；</li>
<li><code>insns(instructions)</code>包含了具体的每一条指令，这儿的13条指令跟我们前面bpftool prog dump的结果是一致的；</li>
<li><code>prog_name</code>则表示BPF程序的名字，即hello_world。</li>
</ul>
</li>
<li>第三个参数128表示属性的大小。</li>
</ul>
<blockquote>
<p>eBPF程序并不像常规的线程那样，启动后就一直运行在那里，它需要事件触发后才会执行。这些事件包括系统调用、内核跟踪点、内核函数和用户态函数的调用退出、网络事件，等等。对于我们的Hello World来说，由于调用了attach_kprobe函数，很明显，这是一个内核跟踪事件。</p>
</blockquote>
<p>所以，除了把eBPF程序加载到内核之外，还需要把加载后的程序跟具体的内核函数调用事件进行绑定。在eBPF的实现中，诸如内核跟踪（kprobe）、用户跟踪（uprobe）等的事件绑定，都是通过<code>perf_event_open()</code>来完成的。</p>
<p><img src="/imgs/eBPF%E5%86%92%E9%99%A9%E8%AE%B0(%E4%B8%80)/image-20240916123709787.png" alt="image-20240916123709787"></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">/* 1) 加载BPF程序 */</span><br><span class="line">bpf(BPF_PROG_LOAD,...) = 4</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">/* 2）查询事件类型 */</span><br><span class="line">openat(AT_FDCWD, &quot;/sys/bus/event_source/devices/kprobe/type&quot;, O_RDONLY) = 5</span><br><span class="line">read(5, &quot;6\n&quot;, 4096)                    = 2</span><br><span class="line">close(5)                                = 0</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">/* 3）创建性能监控事件 */</span><br><span class="line">perf_event_open(</span><br><span class="line">    &#123;</span><br><span class="line">        type=0x6 /* PERF_TYPE_??? */,</span><br><span class="line">        size=PERF_ATTR_SIZE_VER7,</span><br><span class="line">        ...</span><br><span class="line">        wakeup_events=1,</span><br><span class="line">        config1=0x7f275d195c50,</span><br><span class="line">        ...</span><br><span class="line">    &#125;,</span><br><span class="line">    -1,</span><br><span class="line">    0,</span><br><span class="line">    -1,</span><br><span class="line">    PERF_FLAG_FD_CLOEXEC) = 5</span><br><span class="line"></span><br><span class="line">/* 4）绑定BPF到kprobe事件 */</span><br><span class="line">ioctl(5, PERF_EVENT_IOC_SET_BPF, 4)     = 0</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>从输出中，你可以看出BPF与性能事件的绑定过程分为以下几步：</p>
<ul>
<li>首先，借助<code>bpf系统调用</code>，加载BPF程序，并记住返回的文件描述符；</li>
<li>然后，查询<code>kprobe类型的事件编号</code>。BCC实际上是通过&#x2F;sys&#x2F;bus&#x2F;event_source&#x2F;devices&#x2F;kprobe&#x2F;type来查询的；</li>
<li>接着，调用<code>perf_event_open</code>创建性能监控事件。比如，事件类型（type是上一步查询到的6）、事件的参数（config1包含了内核函数do_sys_openat2）等；</li>
<li>最后，再通过ioctl的<code>PERF_EVENT_IOC_SET_BPF</code>命令，将BPF程序绑定到性能监控事件。</li>
</ul>
<h2 id="4-eBPF编程接口"><a href="#4-eBPF编程接口" class="headerlink" title="4.eBPF编程接口"></a>4.eBPF编程接口</h2><p>用高级语言开发的eBPF程序，需要首先编译为BPF字节码，然后借助bpf系统调用加载到内核中，最后再通过性能监控等接口与具体的内核事件进行绑定。这样，内核的性能监控模块才会在内核事件发生时，自动执行我们开发的eBPF程序。</p>
<h3 id="4-1BPF系统调用"><a href="#4-1BPF系统调用" class="headerlink" title="4.1BPF系统调用"></a>4.1BPF系统调用</h3><p>一个完整的eBPF程序通常包含用户态和内核态两部分。其中，<code>用户态负责eBPF程序的加载、事件绑定以及eBPF程序运行结果的汇总输出</code>；内核态运行在eBPF虚拟机中，<code>负责定制和控制系统的运行状态</code>。</p>
<p><img src="/imgs/eBPF%E5%86%92%E9%99%A9%E8%AE%B0(%E4%B8%80)/a7165eea1fd9fc24090a3a1e8987986a-1726462595626-11.png" alt="img"></p>
<p>对于用户态程序来说，我想你已经了解，它们与内核进行交互时必须要通过系统调用来完成。而对应到eBPF程序中，我们最常用到的就是bpf系统调用:</p>
<p><img src="/imgs/eBPF%E5%86%92%E9%99%A9%E8%AE%B0(%E4%B8%80)/image-20240916130428224.png" alt="image-20240916130428224"></p>
<p><img src="/imgs/eBPF%E5%86%92%E9%99%A9%E8%AE%B0(%E4%B8%80)/7cc33d0bdd8a3ba0dda7f533f3375b88.jpg" alt="img"></p>
<h3 id="4-2BPF辅助函数"><a href="#4-2BPF辅助函数" class="headerlink" title="4.2BPF辅助函数"></a>4.2BPF辅助函数</h3><p>eBPF程序并不能随意调用内核函数，因此，内核定义了一系列的辅助函数，用于eBPF程序与内核其他模块进行交互。需要注意的是，并不是所有的辅助函数都可以在eBPF程序中随意使用，不同类型的eBPF程序所支持的辅助函数是不同的。比如，对于Hello World示例这类内核探针（kprobe）类型的eBPF程序，你可以在命令行中执行<code>bpftool feature probe</code>，来查询当前系统支持的辅助函数列表：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">bpftool feature probe</span></span><br><span class="line">...</span><br><span class="line">eBPF helpers supported for program type kprobe:</span><br><span class="line">  - bpf_map_lookup_elem</span><br><span class="line">  - bpf_map_update_elem</span><br><span class="line">  - bpf_map_delete_elem</span><br><span class="line">  - bpf_probe_read</span><br><span class="line">  - bpf_ktime_get_ns</span><br><span class="line">  - bpf_get_prandom_u32</span><br><span class="line">  - bpf_get_smp_processor_id</span><br><span class="line">  - bpf_tail_call</span><br><span class="line">  - bpf_get_current_pid_tgid</span><br><span class="line">  - bpf_get_current_uid_gid</span><br><span class="line">  - bpf_get_current_comm</span><br><span class="line">  - bpf_perf_event_read</span><br><span class="line">  - bpf_perf_event_output</span><br><span class="line">  - bpf_get_stackid</span><br><span class="line">  - bpf_get_current_task</span><br><span class="line">  - bpf_current_task_under_cgroup</span><br><span class="line">  - bpf_get_numa_node_id</span><br><span class="line">  - bpf_probe_read_str</span><br><span class="line">  - bpf_perf_event_read_value</span><br><span class="line">  - bpf_override_return</span><br><span class="line">  - bpf_get_stack</span><br><span class="line">  - bpf_get_current_cgroup_id</span><br><span class="line">  - bpf_map_push_elem</span><br><span class="line">  - bpf_map_pop_elem</span><br><span class="line">  - bpf_map_peek_elem</span><br><span class="line">  - bpf_send_signal</span><br><span class="line">  - bpf_probe_read_user</span><br><span class="line">  - bpf_probe_read_kernel</span><br><span class="line">  - bpf_probe_read_user_str</span><br><span class="line">  - bpf_probe_read_kernel_str</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p><img src="/imgs/eBPF%E5%86%92%E9%99%A9%E8%AE%B0(%E4%B8%80)/0b3edac18276a1236dde7135b961d8cb.jpg" alt="img"></p>
<blockquote>
<p>这其中，需要你特别注意的是以bpf_probe_read开头的一系列函数。eBPF内部的内存空间只有寄存器和栈。所以，要访问其他的内核空间或用户空间地址，就需要借助<code>bpf_probe_read</code>这一系列的辅助函数。<code>这些函数会进行安全性检查，并禁止缺页中断的发生。</code></p>
</blockquote>
<p>而在eBPF程序需要大块存储时，就不能像常规的内核代码那样去直接分配内存了，而是必须通过BPF映射（BPF Map）来完成。</p>
<h3 id="4-3BPF映射"><a href="#4-3BPF映射" class="headerlink" title="4.3BPF映射"></a>4.3BPF映射</h3><p>BPF映射用于提供大块的键值存储，这些存储可被用户空间程序访问，进而获取eBPF程序的运行状态。eBPF程序最多可以访问64个不同的BPF映射，并且不同的eBPF程序也可以通过相同的BPF映射来共享它们的状态。</p>
<p><img src="/imgs/eBPF%E5%86%92%E9%99%A9%E8%AE%B0(%E4%B8%80)/d87b409fa85d3a07973a8689b228cf11.png" alt="img"></p>
<p>在前面的BPF系统调用和辅助函数小节中，你也看到，有很多系统调用命令和辅助函数都是用来访问BPF映射的。我相信细心的你已经发现了BPF辅助函数中并没有BPF映射的创建函数，<code>BPF映射只能通过用户态程序的系统调用来创建</code>。比如，你可以通过下面的示例代码来创建一个BPF映射，并返回映射的文件描述符：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">bpf_create_map</span><span class="params">(<span class="keyword">enum</span> bpf_map_type map_type,</span></span><br><span class="line"><span class="params">       <span class="type">unsigned</span> <span class="type">int</span> key_size,</span></span><br><span class="line"><span class="params">       <span class="type">unsigned</span> <span class="type">int</span> value_size, <span class="type">unsigned</span> <span class="type">int</span> max_entries)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">union</span> <span class="title">bpf_attr</span> <span class="title">attr</span> =</span> &#123;</span><br><span class="line">    .map_type = map_type,</span><br><span class="line">    .key_size = key_size,</span><br><span class="line">    .value_size = value_size,</span><br><span class="line">    .max_entries = max_entries</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> bpf(BPF_MAP_CREATE, &amp;attr, <span class="keyword">sizeof</span>(attr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这其中，最关键的是设置映射的类型。你可以使用如下的bpftool命令，来查询当前系统支持哪些映射类型：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">bpftool feature probe | grep map_type</span></span><br><span class="line">eBPF map_type hash is available</span><br><span class="line">eBPF map_type array is available</span><br><span class="line">eBPF map_type prog_array is available</span><br><span class="line">eBPF map_type perf_event_array is available</span><br><span class="line">eBPF map_type percpu_hash is available</span><br><span class="line">eBPF map_type percpu_array is available</span><br><span class="line">eBPF map_type stack_trace is available</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p><img src="/imgs/eBPF%E5%86%92%E9%99%A9%E8%AE%B0(%E4%B8%80)/f3210199e6689e7659057a935e7fc5d7.jpg" alt="img"></p>
<blockquote>
<p>除了创建之外，映射的删除也需要你特别注意。BPF系统调用中并没有删除映射的命令，这是因为BPF映射会在用户态程序关闭文件描述符的时候自动删除即close(fd)。如果你想在程序退出后还保留映射，就需要调用<code>BPF_OBJ_PIN</code>命令，将映射挂载到&#x2F;sys&#x2F;fs&#x2F;bpf中。</p>
</blockquote>
<h3 id="4-4BPF类型格式"><a href="#4-4BPF类型格式" class="headerlink" title="4.4BPF类型格式"></a>4.4BPF类型格式</h3><p>了解过BPF辅助函数和映射之后，我们再来看一个开发eBPF程序时最常碰到的问题：内核数据结构的定义。在安装BCC工具的时候，你可能就注意到了，<code>内核头文件linux-headers-$(uname -r)</code>也是必须要安装的一个依赖项。这是因为BCC在编译eBPF程序时，需要从内核头文件中找到相应的内核数据结构定义。这样，你在调用<code>bpf_probe_read</code>时，才能从内存地址中提取到正确的数据类型。但是，编译时依赖内核头文件也会带来很多问题。主要有这三个方面：</p>
<ul>
<li>首先，在开发eBPF程序时，为了获得内核数据结构的定义，就需要引入一大堆的内核头文件；</li>
<li>其次，内核头文件的路径和数据结构定义在不同内核版本中很可能不同。因此，你在升级内核版本时，就会遇到找不到头文件和数据结构定义错误的问题；</li>
<li>最后，在很多生产环境的机器中，出于安全考虑，并不允许安装内核头文件，这时就无法得到内核数据结构的定义。在程序中重定义数据结构虽然可以暂时解决这个问题，但也很容易把使用着错误数据结构的eBPF程序带入新版本内核中运行。</li>
</ul>
<p>那么，这么多的问题该怎么解决呢？不用担心，BPF类型格式（BPF Type Format, BTF）的诞生正是为了解决这些问题。从内核5.2开始，只要开启了<code>CONFIG_DEBUG_INFO_BTF</code>，在编译内核时，<code>内核数据结构的定义就会自动内嵌在内核二进制文件vmlinux中</code>。并且，你还可以借助下面的命令，把这些数据结构的定义导出到一个头文件中（通常命名为vmlinux.h）:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bpftool btf dump file /sys/kernel/btf/vmlinux format c &gt; vmlinux.h</span><br></pre></td></tr></table></figure>

<p>有了内核数据结构的定义，你在开发eBPF程序时只需要引入一个<code>vmlinux.h</code>即可，不用再引入一大堆的内核头文件了。</p>
<p><img src="/imgs/eBPF%E5%86%92%E9%99%A9%E8%AE%B0(%E4%B8%80)/45bbf696e8620d322d857ceab3871720.jpg" alt="img"></p>
<p>同时，借助BTF、bpftool等工具，我们也可以更好地了解BPF程序的内部信息，这也会让调试变得更加方便。比如，在查看BPF映射的内容时，你可以直接看到结构化的数据，而不只是十六进制数值：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">bpftool map dump <span class="built_in">id</span> 386</span></span><br><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">      &quot;key&quot;: 0,</span><br><span class="line">      &quot;value&quot;: &#123;</span><br><span class="line">          &quot;eth0&quot;: &#123;</span><br><span class="line">              &quot;value&quot;: 0,</span><br><span class="line">              &quot;ifindex&quot;: 0,</span><br><span class="line">              &quot;mac&quot;: []</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>解决了内核数据结构的定义问题，接下来的问题就是，如何让eBPF程序在内核升级之后，不需要重新编译就可以直接运行。eBPF的一次编译到处执行（<code>Compile Once Run Everywhere</code>，简称CO-RE）项目借助了BTF提供的调试信息，再通过下面的两个步骤，使得eBPF程序可以适配不同版本的内核：</p>
<ul>
<li>第一，通过对BPF代码中的访问偏移量进行重写，解决了不同内核版本中数据结构偏移量不同的问题；</li>
<li>第二，在libbpf中预定义不同内核版本中的数据结构的修改，解决了不同内核中数据结构不兼容的问题。</li>
</ul>
<p>BTF和一次编译到处执行带来了很多的好处，但你也需要注意这一点：它们都要求比较新的内核版本（&gt;&#x3D;5.2），并且需要非常新的发行版（如 Ubuntu20.10+、RHEL8.2+ 等）才会默认打开内核配置CONFIG_DEBUG_INFO_BTF。</p>
<h2 id="5-eBPF事件触发"><a href="#5-eBPF事件触发" class="headerlink" title="5.eBPF事件触发"></a>5.eBPF事件触发</h2><p>eBPF程序类型决定了一个eBPF程序可以挂载的事件类型和事件参数，这也就意味着，内核中不同事件会触发不同类型的eBPF程序。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">bpf_prog_type</span> &#123;</span></span><br><span class="line">  BPF_PROG_TYPE_UNSPEC, <span class="comment">/* Reserve 0 as invalid program type */</span></span><br><span class="line">  BPF_PROG_TYPE_SOCKET_FILTER,</span><br><span class="line">  BPF_PROG_TYPE_KPROBE,</span><br><span class="line">  BPF_PROG_TYPE_SCHED_CLS,</span><br><span class="line">  BPF_PROG_TYPE_SCHED_ACT,</span><br><span class="line">  BPF_PROG_TYPE_TRACEPOINT,</span><br><span class="line">  BPF_PROG_TYPE_XDP,</span><br><span class="line">  BPF_PROG_TYPE_PERF_EVENT,</span><br><span class="line">  BPF_PROG_TYPE_CGROUP_SKB,</span><br><span class="line">  BPF_PROG_TYPE_CGROUP_SOCK,</span><br><span class="line">  BPF_PROG_TYPE_LWT_IN,</span><br><span class="line">  BPF_PROG_TYPE_LWT_OUT,</span><br><span class="line">  BPF_PROG_TYPE_LWT_XMIT,</span><br><span class="line">  BPF_PROG_TYPE_SOCK_OPS,</span><br><span class="line">  BPF_PROG_TYPE_SK_SKB,</span><br><span class="line">  BPF_PROG_TYPE_CGROUP_DEVICE,</span><br><span class="line">  BPF_PROG_TYPE_SK_MSG,</span><br><span class="line">  BPF_PROG_TYPE_RAW_TRACEPOINT,</span><br><span class="line">  BPF_PROG_TYPE_CGROUP_SOCK_ADDR,</span><br><span class="line">  BPF_PROG_TYPE_LWT_SEG6LOCAL,</span><br><span class="line">  BPF_PROG_TYPE_LIRC_MODE2,</span><br><span class="line">  BPF_PROG_TYPE_SK_REUSEPORT,</span><br><span class="line">  BPF_PROG_TYPE_FLOW_DISSECTOR,</span><br><span class="line">  BPF_PROG_TYPE_CGROUP_SYSCTL,</span><br><span class="line">  BPF_PROG_TYPE_RAW_TRACEPOINT_WRITABLE,</span><br><span class="line">  BPF_PROG_TYPE_CGROUP_SOCKOPT,</span><br><span class="line">  BPF_PROG_TYPE_TRACING,</span><br><span class="line">  BPF_PROG_TYPE_STRUCT_OPS,</span><br><span class="line">  BPF_PROG_TYPE_EXT,</span><br><span class="line">  BPF_PROG_TYPE_LSM,</span><br><span class="line">  BPF_PROG_TYPE_SK_LOOKUP,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>对于具体的内核来说，因为不同内核的版本和编译配置选项不同，一个内核并不会支持所有的程序类型。你可以在命令行中执行下面的命令，来查询当前系统支持的程序类型：</p>
<p><img src="/imgs/eBPF%E5%86%92%E9%99%A9%E8%AE%B0(%E4%B8%80)/image-20240916141837897.png" alt="image-20240916141837897"></p>
<p>根据具体功能和应用场景的不同，这些程序类型大致可以划分为三类：</p>
<ul>
<li>第一类是<code>跟踪</code>，即从内核和程序的运行状态中提取跟踪信息，来了解当前系统正在发生什么。</li>
<li>第二类是<code>网络</code>，即对网络数据包进行过滤和处理，以便了解和控制网络数据包的收发过程。</li>
<li>第三类是除跟踪和网络之外的<code>其他</code>类型，包括安全控制、BPF扩展等等。</li>
</ul>
<h3 id="5-1跟踪类eBPF程序"><a href="#5-1跟踪类eBPF程序" class="headerlink" title="5.1跟踪类eBPF程序"></a>5.1跟踪类eBPF程序</h3><p>跟踪类eBPF程序主要用于<code>从系统中提取跟踪信息，进而为监控、排错、性能优化等提供数据支撑</code>。比如，我们前几讲中的Hello World示例就是一个BPF_PROG_TYPE_KPROBE类型的跟踪程序，它的目的是跟踪内核函数是否被某个进程调用了。</p>
<p><img src="/imgs/eBPF%E5%86%92%E9%99%A9%E8%AE%B0(%E4%B8%80)/042fe319b51yy6bc153ce0f877f54a38.jpg" alt="img"></p>
<p>这其中，KPROBE、TRACEPOINT以及PERF_EVENT都是最常用的eBPF程序类型，大量应用于监控跟踪、性能优化以及调试排错等场景中。我们前几讲中提到的BCC工具集，其中包含的绝大部分工具也都属于这个类型。</p>
<h3 id="5-2网络类eBPF程序"><a href="#5-2网络类eBPF程序" class="headerlink" title="5.2网络类eBPF程序"></a>5.2网络类eBPF程序</h3><p>网络类eBPF程序主要用于<code>对网络数据包进行过滤和处理，进而实现网络的观测、过滤、流量控制以及性能优化等各种丰富的功能</code>。根据事件触发位置的不同，网络类eBPF程序又可以分为XDP（eXpress Data Path，高速数据路径）程序、TC（Traffic Control，流量控制）程序、套接字程序以及cgroup程序，下面我们来分别看看。</p>
<h4 id="5-2-1XDP程序"><a href="#5-2-1XDP程序" class="headerlink" title="5.2.1XDP程序"></a>5.2.1XDP程序</h4><p>XDP程序的类型定义为<code>BPF_PROG_TYPE_XDP</code>，它在<code>网络驱动程序刚刚收到数据包时</code>触发执行。由于无需通过繁杂的内核网络协议栈，XDP程序可用来实现高性能的网络处理方案，常用于DDoS 防御、防火墙、4层负载均衡等场景。</p>
<p>需要注意，XDP程序并不是绕过了内核协议栈，它只是在内核协议栈之前处理数据包，而处理过的数据包还可以正常通过内核协议栈继续处理。</p>
<p><img src="/imgs/eBPF%E5%86%92%E9%99%A9%E8%AE%B0(%E4%B8%80)/xdp-packet-processing-1024x560.png" alt="XDP Packet Processing"></p>
<p>根据网卡和网卡驱动是否原生支持XDP程序，XDP运行模式可以分为下面这三种：</p>
<ul>
<li><code>通用模式</code>。它不需要网卡和网卡驱动的支持，XDP程序像常规的网络协议栈一样运行在内核中，性能相对较差，一般用于测试；</li>
<li><code>原生模式</code>。它需要网卡驱动程序的支持，XDP程序在网卡驱动程序的早期路径运行；</li>
<li><code>卸载模式</code>。它需要网卡固件支持XDP卸载，XDP程序直接运行在网卡上，而不再需要消耗主机的CPU资源，具有最好的性能。</li>
</ul>
<p>无论哪种模式，XDP程序在处理过网络包之后，都需要根据eBPF程序执行结果，决定数据包的去处。这些执行结果对应以下5种XDP程序结果码：</p>
<p><img src="/imgs/eBPF%E5%86%92%E9%99%A9%E8%AE%B0(%E4%B8%80)/a2cayy9f21129590a91ca07604b070a7.jpg" alt="img"></p>
<p>通常来说，XDP程序通过<code>ip link</code>命令加载到具体的网卡上，加载格式为：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">eth1 为网卡名</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">xdpgeneric 设置运行模式为通用模式</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">xdp-example.o 为编译后的 XDP 字节码</span></span><br><span class="line">sudo ip link set dev eth1 xdpgeneric object xdp-example.o</span><br></pre></td></tr></table></figure>

<p>而卸载XDP程序也是通过<code>ip link</code>命令，具体参数如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ip link set veth1 xdpgeneric off</span><br></pre></td></tr></table></figure>

<p>除了ip link之外，BCC也提供了方便的库函数，让我们可以在同一个程序中管理XDP程序的生命周期：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">from bcc import BPF</span><br><span class="line"></span><br><span class="line"># 编译XDP程序</span><br><span class="line">b = BPF(src_file=<span class="string">&quot;xdp-example.c&quot;</span>)</span><br><span class="line">fn = b.load_func(<span class="string">&quot;xdp-example&quot;</span>, BPF.XDP)</span><br><span class="line"></span><br><span class="line"># 加载XDP程序到eth0网卡</span><br><span class="line">device = <span class="string">&quot;eth0&quot;</span></span><br><span class="line">b.attach_xdp(device, fn, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"># 其他处理逻辑</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"># 卸载XDP程序</span><br><span class="line">b.remove_xdp(device)</span><br></pre></td></tr></table></figure>

<h4 id="5-2-2TC程序"><a href="#5-2-2TC程序" class="headerlink" title="5.2.2TC程序"></a>5.2.2TC程序</h4><p>TC程序的类型定义为<code>BPF_PROG_TYPE_SCHED_CLS</code>和<code>BPF_PROG_TYPE_SCHED_ACT</code>，分别作为Linux流量控制的分类器和执行器。Linux流量控制通过网卡队列、排队规则、分类器、过滤器以及执行器等，实现了对网络流量的整形调度和带宽控制。</p>
<p>得益于内核v4.4引入的direct-action模式，TC程序可以直接在一个程序内完成分类和执行的动作，而无需再调用其他的TC排队规则和分类器，具体如下图所示：</p>
<p><img src="/imgs/eBPF%E5%86%92%E9%99%A9%E8%AE%B0(%E4%B8%80)/31ecf04f2477bd4765be9544a62deed5.jpg" alt="img"></p>
<p>同XDP程序相比，TC程序可以直接获取内核解析后的网络报文数据结构<code>sk_buff</code>（XDP则是<code>xdp_buff</code>），并且可在网卡的接收和发送两个方向上执行（XDP则只能用于接收）。下面我们来具体看看TC程序的执行位置：</p>
<ul>
<li>对于接收的网络包，TC程序在网卡接收（GRO）之后、协议栈处理（包括IP层处理和iptables等）之前执行；</li>
<li>对于发送的网络包，TC程序在协议栈处理（包括IP层处理和iptables等）之后、数据包发送到网卡队列（GSO）之前执行。</li>
</ul>
<p>除此之外，由于TC运行在内核协议栈中，不需要网卡驱动程序做任何改动，因而可以挂载到任意类型的网卡设备（包括容器等使用的虚拟网卡）上。同XDP程序一样，TC eBPF程序也可以通过Linux命令行工具来加载到网卡上，不过相应的工具要换成<code>tc</code>。你可以通过下面的命令，分别加载接收和发送方向的eBPF程序：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建 clsact 类型的排队规则</span></span><br><span class="line">sudo tc qdisc add dev eth0 clsact</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">加载接收方向的 eBPF 程序</span></span><br><span class="line">sudo tc filter add dev eth0 ingress bpf da obj tc-example.o sec ingress</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">加载发送方向的 eBPF 程序</span></span><br><span class="line">sudo tc filter add dev eth0 egress bpf da obj tc-example.o sec egress</span><br></pre></td></tr></table></figure>

<h4 id="5-2-3套接字程序"><a href="#5-2-3套接字程序" class="headerlink" title="5.2.3套接字程序"></a>5.2.3套接字程序</h4><p>套接字程序用于过滤、观测或重定向套接字网络包，具体的种类也比较丰富。根据类型的不同，套接字eBPF程序可以挂载到套接字（socket）、控制组（cgroup ）以及网络命名空间（netns）等各个位置。你可以根据具体的应用场景，选择一个或组合多个类型的eBPF程序，去控制套接字的网络包收发过程。</p>
<p><img src="/imgs/eBPF%E5%86%92%E9%99%A9%E8%AE%B0(%E4%B8%80)/0e57bf041262114198fd29e1e5c04044.jpg" alt="img"></p>
<p>注意，这几类网络eBPF程序是在不同的事件触发时执行的，因此，在实际应用中我们通常可以把多个类型的eBPF程序结合起来，一起使用，来实现复杂的网络控制功能。比如，最流行的Kubernetes网络方案Cilium就大量使用了XDP、TC和套接字eBPF程序。</p>
<h3 id="5-3其他程序"><a href="#5-3其他程序" class="headerlink" title="5.3其他程序"></a>5.3其他程序</h3><p>除了上面的跟踪和网络eBPF程序之外，Linux内核还支持很多其他的类型。这些类型的eBPF程序虽然不太常用，但在需要的时候也可以帮你解决很多特定的问题。</p>
<p><img src="/imgs/eBPF%E5%86%92%E9%99%A9%E8%AE%B0(%E4%B8%80)/93ae17801e82579e07937e5f1595a0f2.jpg" alt="img"></p>
<p>虽然每个eBPF程序都有特定的类型和触发事件，但这并不意味着它们都是完全独立的。通过BPF映射提供的状态共享机制，各种不同类型的eBPF程序完全可以相互配合，不仅可以绕过单个eBPF程序指令数量的限制，还可以实现更为复杂的控制逻辑。</p>

  </div>
</article>

    <div class="blog-post-comments">
        <div id="disqus_thread">
            <noscript>Please enable JavaScript to view the comments.</noscript>
        </div>
    </div>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
        
          <li><a href="/">Home</a></li>
        
          <li><a href="/about/">About</a></li>
        
          <li><a href="/archives/">Writing</a></li>
        
          <li><a href="/tags/">Tag</a></li>
        
          <li><a target="_blank" rel="noopener" href="http://github.com/hulingF">Projects</a></li>
        
      </ul>
    </div>

    
    
      <div id="toc-footer" style="display: none">
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#eBPF%E5%86%92%E9%99%A9%E8%AE%B0-%E4%B8%80"><span class="toc-number">1.</span> <span class="toc-text">eBPF冒险记(一)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-eBPF%E7%AE%80%E8%A6%81%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.1.</span> <span class="toc-text">1.eBPF简要介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1%E5%BA%94%E7%94%A8%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.1.1.</span> <span class="toc-text">1.1应用介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2%E5%8F%91%E5%B1%95%E5%8E%86%E7%A8%8B"><span class="toc-number">1.1.2.</span> <span class="toc-text">1.2发展历程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3%E7%AE%80%E8%A6%81%E5%8E%9F%E7%90%86"><span class="toc-number">1.1.3.</span> <span class="toc-text">1.3简要原理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-eBPF%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA"><span class="toc-number">1.2.</span> <span class="toc-text">2.eBPF环境搭建</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1%E5%89%8D%E7%BD%AE%E7%8E%AF%E5%A2%83"><span class="toc-number">1.2.1.</span> <span class="toc-text">2.1前置环境</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">2.2快速上手</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3%E7%A8%8B%E5%BA%8F%E4%BC%98%E5%8C%96"><span class="toc-number">1.2.2.</span> <span class="toc-text">2.3程序优化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-eBPF%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86"><span class="toc-number">1.3.</span> <span class="toc-text">3.eBPF运行原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1eBPF%E8%99%9A%E6%8B%9F%E6%9C%BA"><span class="toc-number">1.3.1.</span> <span class="toc-text">3.1eBPF虚拟机</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2BPF%E6%8C%87%E4%BB%A4%E6%A0%BC%E5%BC%8F"><span class="toc-number">1.3.2.</span> <span class="toc-text">3.2BPF指令格式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3%E5%85%B7%E4%BD%93%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="toc-number">1.3.3.</span> <span class="toc-text">3.3具体执行过程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-eBPF%E7%BC%96%E7%A8%8B%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.4.</span> <span class="toc-text">4.eBPF编程接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1BPF%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-number">1.4.1.</span> <span class="toc-text">4.1BPF系统调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2BPF%E8%BE%85%E5%8A%A9%E5%87%BD%E6%95%B0"><span class="toc-number">1.4.2.</span> <span class="toc-text">4.2BPF辅助函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3BPF%E6%98%A0%E5%B0%84"><span class="toc-number">1.4.3.</span> <span class="toc-text">4.3BPF映射</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4BPF%E7%B1%BB%E5%9E%8B%E6%A0%BC%E5%BC%8F"><span class="toc-number">1.4.4.</span> <span class="toc-text">4.4BPF类型格式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-eBPF%E4%BA%8B%E4%BB%B6%E8%A7%A6%E5%8F%91"><span class="toc-number">1.5.</span> <span class="toc-text">5.eBPF事件触发</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1%E8%B7%9F%E8%B8%AA%E7%B1%BBeBPF%E7%A8%8B%E5%BA%8F"><span class="toc-number">1.5.1.</span> <span class="toc-text">5.1跟踪类eBPF程序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2%E7%BD%91%E7%BB%9C%E7%B1%BBeBPF%E7%A8%8B%E5%BA%8F"><span class="toc-number">1.5.2.</span> <span class="toc-text">5.2网络类eBPF程序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-1XDP%E7%A8%8B%E5%BA%8F"><span class="toc-number">1.5.2.1.</span> <span class="toc-text">5.2.1XDP程序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-2TC%E7%A8%8B%E5%BA%8F"><span class="toc-number">1.5.2.2.</span> <span class="toc-text">5.2.2TC程序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-3%E5%A5%97%E6%8E%A5%E5%AD%97%E7%A8%8B%E5%BA%8F"><span class="toc-number">1.5.2.3.</span> <span class="toc-text">5.2.3套接字程序</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3%E5%85%B6%E4%BB%96%E7%A8%8B%E5%BA%8F"><span class="toc-number">1.5.3.</span> <span class="toc-text">5.3其他程序</span></a></li></ol></li></ol></li></ol>
      </div>
    

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://hulingf.github.io/2024/09/15/eBPF%E5%86%92%E9%99%A9%E8%AE%B0(%E4%B8%80)/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://hulingf.github.io/2024/09/15/eBPF%E5%86%92%E9%99%A9%E8%AE%B0(%E4%B8%80)/&text=eBPF冒险记(一)"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://hulingf.github.io/2024/09/15/eBPF%E5%86%92%E9%99%A9%E8%AE%B0(%E4%B8%80)/&title=eBPF冒险记(一)"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://hulingf.github.io/2024/09/15/eBPF%E5%86%92%E9%99%A9%E8%AE%B0(%E4%B8%80)/&is_video=false&description=eBPF冒险记(一)"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=eBPF冒险记(一)&body=Check out this article: https://hulingf.github.io/2024/09/15/eBPF%E5%86%92%E9%99%A9%E8%AE%B0(%E4%B8%80)/"><i class="fa-solid fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://hulingf.github.io/2024/09/15/eBPF%E5%86%92%E9%99%A9%E8%AE%B0(%E4%B8%80)/&title=eBPF冒险记(一)"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://hulingf.github.io/2024/09/15/eBPF%E5%86%92%E9%99%A9%E8%AE%B0(%E4%B8%80)/&title=eBPF冒险记(一)"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://hulingf.github.io/2024/09/15/eBPF%E5%86%92%E9%99%A9%E8%AE%B0(%E4%B8%80)/&title=eBPF冒险记(一)"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://hulingf.github.io/2024/09/15/eBPF%E5%86%92%E9%99%A9%E8%AE%B0(%E4%B8%80)/&title=eBPF冒险记(一)"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://hulingf.github.io/2024/09/15/eBPF%E5%86%92%E9%99%A9%E8%AE%B0(%E4%B8%80)/&name=eBPF冒险记(一)&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://hulingf.github.io/2024/09/15/eBPF%E5%86%92%E9%99%A9%E8%AE%B0(%E4%B8%80)/&t=eBPF冒险记(一)"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fa-solid fa-bars fa-lg" aria-hidden="true"></i> Menu</a>
        
          <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fa-solid fa-list fa-lg" aria-hidden="true"></i> TOC</a>
        
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fa-solid fa-share-alt fa-lg" aria-hidden="true"></i> Share</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2024
    hulingF
  </div>
  <div class="footer-right">
    <nav>
      <ul>
        <!--
       --><li><a href="/">Home</a></li><!--
     --><!--
       --><li><a href="/about/">About</a></li><!--
     --><!--
       --><li><a href="/archives/">Writing</a></li><!--
     --><!--
       --><li><a href="/tags/">Tag</a></li><!--
     --><!--
       --><li><a target="_blank" rel="noopener" href="http://github.com/hulingF">Projects</a></li><!--
     -->
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->



  <link rel="preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" crossorigin="anonymous" onload="this.onload=null;this.rel='stylesheet'"/>


    <!-- jquery -->

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" crossorigin="anonymous"></script>




<!-- clipboard -->

  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.7/clipboard.min.js" crossorigin="anonymous"></script>
  
  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"Copy to clipboard!\">";
    btn += '<i class="fa-regular fa-clone"></i>';
    btn += '</span>';
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "Copied!");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Disqus Comments -->

    <script type="text/javascript">
        var disqus_shortname = 'hulingF';

        (function(){
            var dsq = document.createElement('script');
            dsq.type = 'text/javascript';
            dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        }());
    </script>

<!-- utterances Comments -->

</body>
</html>
