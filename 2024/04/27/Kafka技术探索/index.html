<!DOCTYPE html>
<html lang=en>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5" />
    <meta name="description" content="Kafka技术探索第1章 Kafka入门1.1 概述1.1.1 初识KafkaKafka是一个由Scala和Java语言开发的，经典高吞吐量的分布式消息发布和订阅系统，也是大数据技术领域中用作数据交换的核心组件之一。以高吞吐，低延迟，高伸缩，高可靠性，高并发，且社区活跃度高等特性，从而备受广大技术组织的喜爱。  因为备受技术组织的喜爱，2011年，Kafka软件被捐献给Apache基金会，并于7月">
<meta property="og:type" content="article">
<meta property="og:title" content="Kafka技术探索">
<meta property="og:url" content="https://hulingf.github.io/2024/04/27/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/index.html">
<meta property="og:site_name" content="大军的秘密花园">
<meta property="og:description" content="Kafka技术探索第1章 Kafka入门1.1 概述1.1.1 初识KafkaKafka是一个由Scala和Java语言开发的，经典高吞吐量的分布式消息发布和订阅系统，也是大数据技术领域中用作数据交换的核心组件之一。以高吞吐，低延迟，高伸缩，高可靠性，高并发，且社区活跃度高等特性，从而备受广大技术组织的喜爱。  因为备受技术组织的喜爱，2011年，Kafka软件被捐献给Apache基金会，并于7月">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://hulingf.github.io/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240427135245141.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240427134506417.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240427141415060.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240427142444917.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240427144257213.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240427150835625.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240427145051515.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240427145149328.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240427150542871.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240427150632339.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240427151020788.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240427151411014.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240427152411088.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240427152700617.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240427153003130.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240427154442392.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240427155233130.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240427155838274.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240427160617064.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240427160652321.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240427162725190.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240427164621444.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240427163934876.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240427164134740.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240427165117122.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240427165133415.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240427165200812.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240427165716354.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240427170608831.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240427171118763.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240427171932255.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240427172253401.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240427180933897.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240427181416380.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240427181647955.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240427182233007.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240427182803170.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240427183549123.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240427183631376.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240427183815758.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240427184341097.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240427185256204.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240427185502734.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240427185704383.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240427185646303.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240427190121016.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240427213253128.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240427213530618.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240427213729353.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240427213749881.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240427214156546.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240427214315328.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240427215442772.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240427215733055.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240428155755449.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240428155823107.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240428160004995.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240428160717743.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240428161203206.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240428161301545.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240428161558461.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240428162939197.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240428162252090.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240428163058286.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240428163206159.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240428163341069.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240428163458871.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240428164256414.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240428164332126.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240428164634056.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240428164808894.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240428164905064.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240428164925785.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240428165810209.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240428170030658.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240428170146483.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240428170249018.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240428170712704.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240428170754361.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240428170838266.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240428170935538.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240428171148879.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240428171221461.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240428171257414.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240428171319526.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240428172017690.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240428172052001.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240428172133131.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240428172234387.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240428195526286.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240428195615914.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240428195924781.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240428200052256.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240428200808205.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240428204630492.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240428205810058.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240428205846182.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240428205139613.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240428210529334.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240428210615311.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240428211248196.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240428211602096.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240428212545858.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240428213137350.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240428214051211.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240428214612711.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240428214755561.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240428214843094.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240428214957062.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240428215023891.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240428215219716.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240428215306657.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240428215349451.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240428215433214.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240428215607287.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240428215644699.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240428215743927.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240428215809592.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240428215902766.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240428215925337.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240428220252472.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240428220408804.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240428222140144.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240428222516419.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240428222620257.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240428222716360.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240428222807751.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240428223038793.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240428223648494.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240428223731697.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240428223907358.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240428223929390.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240428224116726.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240428224220155.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240428224313324.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240428224336839.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240428224519668.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240428224600552.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240428224701418.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240428224804396.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240428224834085.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240428224840167.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240428225126226.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240428225225932.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240428225430546.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240428225550064.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240428225609098.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240429142907777.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240429193535365.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240429194300516.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240429194447160.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240429200434078.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240429200543721.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240429202953305.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240429203635918.png">
<meta property="article:published_time" content="2024-04-27T05:30:02.777Z">
<meta property="article:modified_time" content="2024-04-29T12:41:07.290Z">
<meta property="article:author" content="hulingF">
<meta property="article:tag" content="Kafka">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://hulingf.github.io/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240427135245141.png">
    
    
      
        
          <link rel="shortcut icon" href="/images/favicon.ico">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
        
      
    
    <!-- title -->
    <title>Kafka技术探索</title>
    <!-- async scripts -->
    <!-- Google Analytics -->


    <!-- Umami Analytics -->


    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
    <!-- rss -->
    
    
	<!-- mathjax -->
	
<meta name="generator" content="Hexo 6.3.0"></head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#" aria-label="Menu"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#" aria-label="Menu"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" aria-label="Top" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa-solid fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
        <!--
       --><li><a href="/">Home</a></li><!--
     --><!--
       --><li><a href="/about/">About</a></li><!--
     --><!--
       --><li><a href="/archives/">Writing</a></li><!--
     --><!--
       --><li><a href="/tags/">Tag</a></li><!--
     --><!--
       --><li><a target="_blank" rel="noopener" href="http://github.com/hulingF">Projects</a></li><!--
     -->
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" aria-label="Previous post" href="/2024/04/29/Kafka%E6%8A%80%E6%9C%AF%E8%BF%9B%E9%98%B6/"><i class="fa-solid fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" aria-label="Next post" href="/2024/04/17/Redis%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/"><i class="fa-solid fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" aria-label="Back to top" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" aria-label="Share post" href="#"><i class="fa-solid fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://hulingf.github.io/2024/04/27/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://hulingf.github.io/2024/04/27/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/&text=Kafka技术探索"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://hulingf.github.io/2024/04/27/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/&title=Kafka技术探索"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://hulingf.github.io/2024/04/27/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/&is_video=false&description=Kafka技术探索"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=Kafka技术探索&body=Check out this article: https://hulingf.github.io/2024/04/27/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/"><i class="fa-solid fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://hulingf.github.io/2024/04/27/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/&title=Kafka技术探索"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://hulingf.github.io/2024/04/27/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/&title=Kafka技术探索"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://hulingf.github.io/2024/04/27/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/&title=Kafka技术探索"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://hulingf.github.io/2024/04/27/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/&title=Kafka技术探索"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://hulingf.github.io/2024/04/27/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/&name=Kafka技术探索&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://hulingf.github.io/2024/04/27/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/&t=Kafka技术探索"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    
    
      <div id="toc">
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2"><span class="toc-number">1.</span> <span class="toc-text">Kafka技术探索</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC1%E7%AB%A0-Kafka%E5%85%A5%E9%97%A8"><span class="toc-number">1.1.</span> <span class="toc-text">第1章 Kafka入门</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E6%A6%82%E8%BF%B0"><span class="toc-number">1.1.1.</span> <span class="toc-text">1.1 概述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-1-%E5%88%9D%E8%AF%86Kafka"><span class="toc-number">1.1.1.1.</span> <span class="toc-text">1.1.1 初识Kafka</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-2-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="toc-number">1.1.1.2.</span> <span class="toc-text">1.1.2 消息队列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-3-%E7%94%9F%E4%BA%A7%E8%80%85-x2F-%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.1.1.3.</span> <span class="toc-text">1.1.3 生产者&#x2F;消费者模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-4-%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%AF%B9%E6%AF%94"><span class="toc-number">1.1.1.4.</span> <span class="toc-text">1.1.4 消息中间件对比</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-5-ZooKeeper"><span class="toc-number">1.1.1.5.</span> <span class="toc-text">1.1.5 ZooKeeper</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B"><span class="toc-number">1.1.2.</span> <span class="toc-text">1.2 快速上手</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-1-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85"><span class="toc-number">1.1.2.1.</span> <span class="toc-text">1.2.1 环境安装</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-2-%E6%B6%88%E6%81%AF%E4%B8%BB%E9%A2%98"><span class="toc-number">1.1.2.2.</span> <span class="toc-text">1.2.2 消息主题</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-2-2-1-%E5%88%9B%E5%BB%BA%E4%B8%BB%E9%A2%98"><span class="toc-number">1.1.2.2.1.</span> <span class="toc-text">1.2.2.1 创建主题</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-2-2-2-%E6%9F%A5%E8%AF%A2%E4%B8%BB%E9%A2%98"><span class="toc-number">1.1.2.2.2.</span> <span class="toc-text">1.2.2.2 查询主题</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-2-2-3-%E4%BF%AE%E6%94%B9%E4%B8%BB%E9%A2%98"><span class="toc-number">1.1.2.2.3.</span> <span class="toc-text">1.2.2.3 修改主题</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-2-2-4-%E5%88%A0%E9%99%A4%E4%B8%BB%E9%A2%98"><span class="toc-number">1.1.2.2.4.</span> <span class="toc-text">1.2.2.4 删除主题</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-3-%E7%94%9F%E4%BA%A7%E6%95%B0%E6%8D%AE"><span class="toc-number">1.1.2.3.</span> <span class="toc-text">1.2.3 生产数据</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-2-3-1-%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%93%8D%E4%BD%9C"><span class="toc-number">1.1.2.3.1.</span> <span class="toc-text">1.2.3.1 命令行操作</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-2-3-2-%E5%B7%A5%E5%85%B7%E6%93%8D%E4%BD%9C"><span class="toc-number">1.1.2.3.2.</span> <span class="toc-text">1.2.3.2 工具操作</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-2-3-3-Java-API%E6%93%8D%E4%BD%9C"><span class="toc-number">1.1.2.3.3.</span> <span class="toc-text">1.2.3.3 Java API操作</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-4-%E6%B6%88%E8%B4%B9%E6%95%B0%E6%8D%AE"><span class="toc-number">1.1.2.4.</span> <span class="toc-text">1.2.4 消费数据</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-2-4-1-%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%93%8D%E4%BD%9C"><span class="toc-number">1.1.2.4.1.</span> <span class="toc-text">1.2.4.1 命令行操作</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-2-4-2-Java-API%E6%93%8D%E4%BD%9C"><span class="toc-number">1.1.2.4.2.</span> <span class="toc-text">1.2.4.2 Java API操作</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC2%E7%AB%A0-Kafka%E5%9F%BA%E7%A1%80"><span class="toc-number">1.2.</span> <span class="toc-text">第2章 Kafka基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2"><span class="toc-number">1.2.1.</span> <span class="toc-text">2.1 集群部署</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E9%9B%86%E7%BE%A4%E5%90%AF%E5%8A%A8"><span class="toc-number">1.2.2.</span> <span class="toc-text">2.2 集群启动</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-1-%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">2.2.1 相关概念</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-2-1-1-%E4%BB%A3%E7%90%86Broker"><span class="toc-number">1.2.2.1.1.</span> <span class="toc-text">2.2.1.1 代理Broker</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-2-1-2-%E6%8E%A7%E5%88%B6%E5%99%A8Controller"><span class="toc-number">1.2.2.1.2.</span> <span class="toc-text">2.2.1.2 控制器Controller</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-2-%E5%90%AF%E5%8A%A8ZooKeeper"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">2.2.2 启动ZooKeeper</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-3-%E5%90%AF%E5%8A%A8Kafka"><span class="toc-number">1.2.2.3.</span> <span class="toc-text">2.2.3 启动Kafka</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-2-3-1-%E5%88%9D%E5%A7%8B%E5%8C%96ZooKeeper"><span class="toc-number">1.2.2.3.1.</span> <span class="toc-text">2.2.3.1 初始化ZooKeeper</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-2-3-2-%E5%88%9D%E5%A7%8B%E5%8C%96%E6%9C%8D%E5%8A%A1"><span class="toc-number">1.2.2.3.2.</span> <span class="toc-text">2.2.3.2 初始化服务</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-2-3-3-%E5%90%AF%E5%8A%A8%E6%8E%A7%E5%88%B6%E5%99%A8"><span class="toc-number">1.2.2.3.3.</span> <span class="toc-text">2.2.3.3 启动控制器</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E5%88%9B%E5%BB%BA%E4%B8%BB%E9%A2%98"><span class="toc-number">1.2.3.</span> <span class="toc-text">2.3 创建主题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-1-%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5"><span class="toc-number">1.2.3.1.</span> <span class="toc-text">2.3.1 相关概念</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-3-1-1-%E4%B8%BB%E9%A2%98Topic"><span class="toc-number">1.2.3.1.1.</span> <span class="toc-text">2.3.1.1 主题Topic</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-3-1-2-%E5%88%86%E5%8C%BAPartition"><span class="toc-number">1.2.3.1.2.</span> <span class="toc-text">2.3.1.2 分区Partition</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-3-1-3-%E5%89%AF%E6%9C%ACReplication"><span class="toc-number">1.2.3.1.3.</span> <span class="toc-text">2.3.1.3 副本Replication</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-3-1-4-%E5%89%AF%E6%9C%AC%E7%B1%BB%E5%9E%8BLeader-x2F-Follower"><span class="toc-number">1.2.3.1.4.</span> <span class="toc-text">2.3.1.4 副本类型Leader&#x2F;Follower</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-3-1-5-%E6%97%A5%E5%BF%97Log"><span class="toc-number">1.2.3.1.5.</span> <span class="toc-text">2.3.1.5 日志Log</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-2-%E5%88%9B%E5%BB%BA%E7%AC%AC%E4%B8%80%E4%B8%AA%E4%B8%BB%E9%A2%98"><span class="toc-number">1.2.3.2.</span> <span class="toc-text">2.3.2 创建第一个主题</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-3-2-1-ZooKeeper%E8%8A%82%E7%82%B9%E5%8F%98%E5%8C%96"><span class="toc-number">1.2.3.2.1.</span> <span class="toc-text">2.3.2.1 ZooKeeper节点变化</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-3-2-2-%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E4%BD%8D%E7%BD%AE"><span class="toc-number">1.2.3.2.2.</span> <span class="toc-text">2.3.2.2 数据存储位置</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-3-%E5%88%9B%E5%BB%BA%E7%AC%AC%E4%BA%8C%E4%B8%AA%E4%B8%BB%E9%A2%98"><span class="toc-number">1.2.3.3.</span> <span class="toc-text">2.3.3 创建第二个主题</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-3-3-1-ZooKeeper%E8%8A%82%E7%82%B9%E5%8F%98%E5%8C%96"><span class="toc-number">1.2.3.3.1.</span> <span class="toc-text">2.3.3.1 ZooKeeper节点变化</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-3-3-2-%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E4%BD%8D%E7%BD%AE"><span class="toc-number">1.2.3.3.2.</span> <span class="toc-text">2.3.3.2 数据存储位置</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-4-%E5%88%9B%E5%BB%BA%E7%AC%AC%E4%B8%89%E4%B8%AA%E4%B8%BB%E9%A2%98"><span class="toc-number">1.2.3.4.</span> <span class="toc-text">2.3.4 创建第三个主题</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-3-4-1-ZooKeeper%E8%8A%82%E7%82%B9%E5%8F%98%E5%8C%96"><span class="toc-number">1.2.3.4.1.</span> <span class="toc-text">2.3.4.1 ZooKeeper节点变化</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-3-4-2-%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E4%BD%8D%E7%BD%AE"><span class="toc-number">1.2.3.4.2.</span> <span class="toc-text">2.3.4.2 数据存储位置</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-5-%E5%88%9B%E5%BB%BA%E4%B8%BB%E9%A2%98%E6%B5%81%E7%A8%8B"><span class="toc-number">1.2.3.5.</span> <span class="toc-text">2.3.5 创建主题流程</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-3-5-1-%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%8F%90%E4%BA%A4%E5%88%9B%E5%BB%BA%E6%8C%87%E4%BB%A4"><span class="toc-number">1.2.3.5.1.</span> <span class="toc-text">2.3.5.1 命令行提交创建指令</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-3-5-2-Controller%E6%8E%A5%E6%94%B6%E5%88%9B%E5%BB%BA%E4%B8%BB%E9%A2%98%E8%AF%B7%E6%B1%82"><span class="toc-number">1.2.3.5.2.</span> <span class="toc-text">2.3.5.2 Controller接收创建主题请求</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-3-5-3-%E5%88%9B%E5%BB%BA%E4%B8%BB%E9%A2%98"><span class="toc-number">1.2.3.5.3.</span> <span class="toc-text">2.3.5.3 创建主题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-%E7%94%9F%E4%BA%A7%E6%B6%88%E6%81%AF"><span class="toc-number">1.2.4.</span> <span class="toc-text">2.4 生产消息</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-1-%E7%94%9F%E4%BA%A7%E6%B6%88%E6%81%AF%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%AD%A5%E9%AA%A4"><span class="toc-number">1.2.4.1.</span> <span class="toc-text">2.4.1 生产消息的基本步骤</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-2-%E7%94%9F%E4%BA%A7%E6%B6%88%E6%81%AF%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BB%A3%E7%A0%81"><span class="toc-number">1.2.4.2.</span> <span class="toc-text">2.4.2 生产消息的基本代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-3-%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF"><span class="toc-number">1.2.4.3.</span> <span class="toc-text">2.4.3 发送消息</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-4-3-1-%E6%8B%A6%E6%88%AA%E5%99%A8"><span class="toc-number">1.2.4.3.1.</span> <span class="toc-text">2.4.3.1 拦截器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-4-3-2-%E5%9B%9E%E8%B0%83%E6%96%B9%E6%B3%95"><span class="toc-number">1.2.4.3.2.</span> <span class="toc-text">2.4.3.2 回调方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-4-3-3-%E5%BC%82%E6%AD%A5%E5%8F%91%E9%80%81"><span class="toc-number">1.2.4.3.3.</span> <span class="toc-text">2.4.3.3 异步发送</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-4-3-4-%E5%90%8C%E6%AD%A5%E5%8F%91%E9%80%81"><span class="toc-number">1.2.4.3.4.</span> <span class="toc-text">2.4.3.4 同步发送</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-4-%E6%B6%88%E6%81%AF%E5%88%86%E5%8C%BA"><span class="toc-number">1.2.4.4.</span> <span class="toc-text">2.4.4 消息分区</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-4-4-1-%E6%8C%87%E5%AE%9A%E5%88%86%E5%8C%BA"><span class="toc-number">1.2.4.4.1.</span> <span class="toc-text">2.4.4.1 指定分区</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-4-4-2-%E6%9C%AA%E6%8C%87%E5%AE%9A%E5%88%86%E5%8C%BA"><span class="toc-number">1.2.4.4.2.</span> <span class="toc-text">2.4.4.2 未指定分区</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-4-4-3-%E5%88%86%E5%8C%BA%E5%99%A8"><span class="toc-number">1.2.4.4.3.</span> <span class="toc-text">2.4.4.3 分区器</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-5-%E6%B6%88%E6%81%AF%E5%8F%AF%E9%9D%A0%E6%80%A7"><span class="toc-number">1.2.4.5.</span> <span class="toc-text">2.4.5 消息可靠性</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-4-5-1-ACK-x3D-0"><span class="toc-number">1.2.4.5.1.</span> <span class="toc-text">2.4.5.1 ACK&#x3D;0</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-4-5-2-ACK-x3D-1"><span class="toc-number">1.2.4.5.2.</span> <span class="toc-text">2.4.5.2 ACK&#x3D;1</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-4-5-3-ACK-x3D-all"><span class="toc-number">1.2.4.5.3.</span> <span class="toc-text">2.4.5.3 ACK&#x3D;all</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-6-%E6%B6%88%E6%81%AF%E5%8E%BB%E9%87%8D-amp-%E6%9C%89%E5%BA%8F"><span class="toc-number">1.2.4.6.</span> <span class="toc-text">2.4.6 消息去重&amp;有序</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-4-6-1-%E6%95%B0%E6%8D%AE%E9%87%8D%E8%AF%95"><span class="toc-number">1.2.4.6.1.</span> <span class="toc-text">2.4.6.1 数据重试</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-4-6-2-%E6%95%B0%E6%8D%AE%E4%B9%B1%E5%BA%8F"><span class="toc-number">1.2.4.6.2.</span> <span class="toc-text">2.4.6.2 数据乱序</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-4-6-3-%E6%95%B0%E6%8D%AE%E5%B9%82%E7%AD%89%E6%80%A7"><span class="toc-number">1.2.4.6.3.</span> <span class="toc-text">2.4.6.3 数据幂等性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-4-6-4-%E6%95%B0%E6%8D%AE%E4%BA%8B%E5%8A%A1"><span class="toc-number">1.2.4.6.4.</span> <span class="toc-text">2.4.6.4 数据事务</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-4-6-5-%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E8%AF%AD%E4%B9%89"><span class="toc-number">1.2.4.6.5.</span> <span class="toc-text">2.4.6.5 数据传输语义</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-%E5%AD%98%E5%82%A8%E6%B6%88%E6%81%AF"><span class="toc-number">1.2.5.</span> <span class="toc-text">2.5 存储消息</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5-1-%E5%AD%98%E5%82%A8%E7%BB%84%E4%BB%B6"><span class="toc-number">1.2.5.1.</span> <span class="toc-text">2.5.1 存储组件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5-2-%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8"><span class="toc-number">1.2.5.2.</span> <span class="toc-text">2.5.2 数据存储</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-5-2-1-ACKS%E6%A0%A1%E9%AA%8C"><span class="toc-number">1.2.5.2.1.</span> <span class="toc-text">2.5.2.1 ACKS校验</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-5-2-2-%E5%86%85%E9%83%A8%E4%B8%BB%E9%A2%98%E6%A0%A1%E9%AA%8C"><span class="toc-number">1.2.5.2.2.</span> <span class="toc-text">2.5.2.2 内部主题校验</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-5-2-3-ACKS%E5%BA%94%E7%AD%94%E5%8F%8A%E5%89%AF%E6%9C%AC%E6%95%B0%E9%87%8F%E5%85%B3%E7%B3%BB%E6%A0%A1%E9%AA%8C"><span class="toc-number">1.2.5.2.3.</span> <span class="toc-text">2.5.2.3 ACKS应答及副本数量关系校验</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-5-2-4-%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6%E6%BB%9A%E5%8A%A8%E5%88%A4%E6%96%AD"><span class="toc-number">1.2.5.2.4.</span> <span class="toc-text">2.5.2.4 日志文件滚动判断</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-5-2-5-%E8%AF%B7%E6%B1%82%E6%95%B0%E6%8D%AE%E9%87%8D%E5%A4%8D%E6%80%A7%E6%A0%A1%E9%AA%8C"><span class="toc-number">1.2.5.2.5.</span> <span class="toc-text">2.5.2.5 请求数据重复性校验</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-5-2-6-%E8%AF%B7%E6%B1%82%E6%95%B0%E6%8D%AE%E5%BA%8F%E5%88%97%E5%8F%B7%E6%A0%A1%E9%AA%8C"><span class="toc-number">1.2.5.2.6.</span> <span class="toc-text">2.5.2.6 请求数据序列号校验</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-5-2-7-%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8"><span class="toc-number">1.2.5.2.7.</span> <span class="toc-text">2.5.2.7 数据存储</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5-3-%E5%AD%98%E5%82%A8%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F"><span class="toc-number">1.2.5.3.</span> <span class="toc-text">2.5.3 存储文件格式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-5-3-1-%E6%95%B0%E6%8D%AE%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6"><span class="toc-number">1.2.5.3.1.</span> <span class="toc-text">2.5.3.1 数据日志文件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-5-3-2-%E6%95%B0%E6%8D%AE%E7%B4%A2%E5%BC%95%E6%96%87%E4%BB%B6"><span class="toc-number">1.2.5.3.2.</span> <span class="toc-text">2.5.3.2 数据索引文件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-5-3-3-%E6%95%B0%E6%8D%AE%E6%97%B6%E9%97%B4%E6%88%B3%E7%B4%A2%E5%BC%95%E6%96%87%E4%BB%B6"><span class="toc-number">1.2.5.3.3.</span> <span class="toc-text">2.5.3.3 数据时间戳索引文件</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5-4-%E6%95%B0%E6%8D%AE%E5%88%B7%E5%86%99"><span class="toc-number">1.2.5.4.</span> <span class="toc-text">2.5.4 数据刷写</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5-5-%E5%89%AF%E6%9C%AC%E5%90%8C%E6%AD%A5"><span class="toc-number">1.2.5.5.</span> <span class="toc-text">2.5.5 副本同步</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-5-5-1-%E5%90%AF%E5%8A%A8%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.2.5.5.1.</span> <span class="toc-text">2.5.5.1 启动数据同步线程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-5-5-2-%E7%94%9F%E6%88%90%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5%E8%AF%B7%E6%B1%82"><span class="toc-number">1.2.5.5.2.</span> <span class="toc-text">2.5.5.2 生成数据同步请求</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-5-5-3-%E5%A4%84%E7%90%86%E6%95%B0%E6%8D%AE%E5%93%8D%E5%BA%94"><span class="toc-number">1.2.5.5.3.</span> <span class="toc-text">2.5.5.3 处理数据响应</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-5-5-4-%E6%9B%B4%E6%96%B0%E6%95%B0%E6%8D%AE%E5%81%8F%E7%A7%BB%E9%87%8F"><span class="toc-number">1.2.5.5.4.</span> <span class="toc-text">2.5.5.4 更新数据偏移量</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5-6-%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7"><span class="toc-number">1.2.5.6.</span> <span class="toc-text">2.5.6 数据一致性</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-5-6-1-%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7%E8%A1%A8%E7%8E%B0"><span class="toc-number">1.2.5.6.1.</span> <span class="toc-text">2.5.6.1 数据一致性表现</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-5-6-2-HW%E5%9C%A8%E5%89%AF%E6%9C%AC%E4%B9%8B%E9%97%B4%E7%9A%84%E4%BC%A0%E9%80%92"><span class="toc-number">1.2.5.6.2.</span> <span class="toc-text">2.5.6.2 HW在副本之间的传递</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-5-6-3-ISR%EF%BC%88In-Sync-Replicas%EF%BC%89%E4%BC%B8%E7%BC%A9"><span class="toc-number">1.2.5.6.3.</span> <span class="toc-text">2.5.6.3 ISR（In-Sync-Replicas）伸缩</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6-%E6%B6%88%E8%B4%B9%E6%B6%88%E6%81%AF"><span class="toc-number">1.2.6.</span> <span class="toc-text">2.6 消费消息</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-6-1-%E6%B6%88%E8%B4%B9%E6%B6%88%E6%81%AF%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%AD%A5%E9%AA%A4"><span class="toc-number">1.2.6.1.</span> <span class="toc-text">2.6.1 消费消息的基本步骤</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-6-2-%E6%B6%88%E8%B4%B9%E6%B6%88%E6%81%AF%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BB%A3%E7%A0%81"><span class="toc-number">1.2.6.2.</span> <span class="toc-text">2.6.2 消费消息的基本代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-6-3-%E6%B6%88%E8%B4%B9%E6%B6%88%E6%81%AF%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86"><span class="toc-number">1.2.6.3.</span> <span class="toc-text">2.6.3 消费消息的基本原理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-6-3-1-%E6%B6%88%E8%B4%B9%E8%80%85%E7%BB%84"><span class="toc-number">1.2.6.3.1.</span> <span class="toc-text">2.6.3.1 消费者组</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-6-3-2-%E7%BB%84%E8%B0%83%E5%BA%A6%E5%99%A8GroupCoordinator"><span class="toc-number">1.2.6.3.2.</span> <span class="toc-text">2.6.3.2 组调度器GroupCoordinator</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-6-3-3-%E6%B6%88%E8%B4%B9%E8%80%85%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5Assignor"><span class="toc-number">1.2.6.3.3.</span> <span class="toc-text">2.6.3.3 消费者分配策略Assignor</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-6-3-4-%E6%B6%88%E8%B4%B9%E8%80%85%E5%81%8F%E7%A7%BB%E9%87%8F"><span class="toc-number">1.2.6.3.4.</span> <span class="toc-text">2.6.3.4 消费者偏移量</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-6-3-5-%E6%B6%88%E8%B4%B9%E8%80%85%E4%BA%8B%E5%8A%A1"><span class="toc-number">1.2.6.3.5.</span> <span class="toc-text">2.6.3.5 消费者事务</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-6-3-6-%E5%81%8F%E7%A7%BB%E9%87%8F%E4%BF%9D%E5%AD%98"><span class="toc-number">1.2.6.3.6.</span> <span class="toc-text">2.6.3.6 偏移量保存</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-6-3-7-%E6%B6%88%E8%B4%B9%E6%95%B0%E6%8D%AE"><span class="toc-number">1.2.6.3.7.</span> <span class="toc-text">2.6.3.7 消费数据</span></a></li></ol></li></ol></li></ol></li></ol></li></ol>
      </div>
    
  </span>
</div>

    
    <div class="content index py4 ">
        
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle p-name" itemprop="name headline">
        Kafka技术探索
    </h1>



    <div class="meta">
      <span class="author p-author h-card" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span class="p-name" itemprop="name">hulingF</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2024-04-27T05:30:02.777Z" class="dt-published" itemprop="datePublished">2024-04-27</time>
        
      
    </div>


      

      
    <div class="article-tag">
        <i class="fa-solid fa-tag"></i>
        <a class="p-category" href="/tags/Kafka/" rel="tag">Kafka</a>
    </div>


    </div>
  </header>
  

  <div class="content e-content" itemprop="articleBody">
    <h1 id="Kafka技术探索"><a href="#Kafka技术探索" class="headerlink" title="Kafka技术探索"></a>Kafka技术探索</h1><h2 id="第1章-Kafka入门"><a href="#第1章-Kafka入门" class="headerlink" title="第1章 Kafka入门"></a>第1章 Kafka入门</h2><h3 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h3><h4 id="1-1-1-初识Kafka"><a href="#1-1-1-初识Kafka" class="headerlink" title="1.1.1 初识Kafka"></a>1.1.1 初识Kafka</h4><p>Kafka是一个由<code>Scala</code>和<code>Java</code>语言开发的，经典高吞吐量的<code>分布式消息发布和订阅系统</code>，也是大数据技术领域中用作数据交换的核心组件之一。以高吞吐，低延迟，高伸缩，高可靠性，高并发，且社区活跃度高等特性，从而备受广大技术组织的喜爱。</p>
<p><img src="/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240427135245141.png" alt="image-20240427135245141"></p>
<p>因为备受技术组织的喜爱，2011年，Kafka软件被捐献给Apache基金会，并于7月被纳入Apache软件基金会孵化器项目进行孵化。2012年10月，Kafka从孵化器项目中毕业，转成Apache的顶级项目。由独立的消息日志传输系统转型为<code>开源分布式事件流处理平台系统</code>，被数千家公司用于高性能数据管道、流分析、数据集成和关键任务应用程序。</p>
<p><img src="/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240427134506417.png" alt="image-20240427134506417"></p>
<h4 id="1-1-2-消息队列"><a href="#1-1-2-消息队列" class="headerlink" title="1.1.2 消息队列"></a>1.1.2 消息队列</h4><p>Kafka软件最初的设计就是专门用于数据传输的消息系统，类似功能的软件有RabbitMQ、ActiveMQ、RocketMQ等。这些软件名称中的MQ是英文单词<code>Message Queue</code>的简称，也就是所谓的消息队列的意思。这些软件的核心功能是传输数据，而Java中如果想要实现数据传输功能，那么这个软件一般需要遵循Java消息服务技术规范<code>JMS（Java Message Service）</code>。</p>
<p>前面提到的ActiveMQ软件就完全遵循了JMS技术规范，而RabbitMQ是遵循了类似JMS规范并兼容JMS规范的跨平台的<code>AMQP（Advanced Message Queuing Protocol）</code>规范。Kafka拥有作为一个消息系统应该具备的功能，但是却有着独特的设计。可以这样说，Kafka借鉴了JMS规范的思想，但是却并没有完全遵循JMS规范。这也恰恰是软件名称为Kafka，而不是KafkaMQ的原因。</p>
<p>由上可知，无论学习哪一种消息传输系统，JMS规范都是大家应该首先了解的。所以咱们这里就对JMS规范做一个简单的介绍：</p>
<ul>
<li><p>JMS是<code>Java平台的消息中间件通用规范</code>，定义了主要用于消息中间件的标准接口。如果不是很理解这个概念，可以简单地将JMS类比为Java和数据库之间的JDBC规范。Java应用程序根据JDBC规范中的接口访问关系型数据库，而每个关系型数据库厂商可以根据JDBC接口来实现具体的访问规则。JMS定义的就是系统和系统之间传输消息的接口。</p>
</li>
<li><p>为了实现系统和系统之间的数据传输，JMS规范中定义很多用于通信的组件：</p>
<p><img src="/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240427141415060.png" alt="image-20240427141415060"></p>
<ul>
<li>JMS Provider:JMS消息提供者。其实就是实现JMS接口和规范的消息中间件，也就是我们提供消息服务的软件系统，比如RabbitMQ、ActiveMQ、Kafka。</li>
<li>JMS Message:JMS消息。一般采用Java数据模型进行封装，其中包含消息头，消息属性和消息主体内容。</li>
<li>JMS Producer:JMS消息生产者。所谓的生产者，就是生产数据的客户端应用程序，这些应用通过JMS接口发送JMS消息。</li>
<li>JMS Consumer:JMS消息消费者。所谓的消费者，就是获取数据的客户端应用程序，这些应用通过JMS接口接收JMS消息。</li>
</ul>
</li>
<li><p>JMS支持两种消息发送和接收模型：一种是点对点（Peer-to-Peer）模型，另外一种是发布订阅（Publish&#x2F;Subscribe）模型。</p>
<ul>
<li><code>点对点模型</code>：P2P模型是基于队列的，消息生产者将数据发送到消息队列中，消息消费者从消息队列中接收消息。因为队列的存在，消息的异步传输成为可能。P2P模型的规定就是<code>每一个消息数据，只能有一个消费者</code>，当发送者发送消息以后，不管接收者有没有运行都不影响消息发布到队列中。接收者在成功接收消息后会向发送者发送接收成功的消息。</li>
<li><code>发布订阅模型</code>：所谓得发布订阅模型就是事先将传输的数据进行分类，我们管这个数据的分类称之为主题（Topic）。也就是说，生产者发送消息时，会根据主题进行发送，感兴趣的消费者可以申请订阅特定的主题，然后从该主题中获取消息。这样，也就是说<code>一个消息，是允许被多个消费者同时消费的</code>。这里生产者向主题中发送消息，我们称之为发布消息，而消费者从主题中获取消息，我们就称之为订阅消息。Kafka采用就是这种模型。</li>
</ul>
</li>
</ul>
<h4 id="1-1-3-生产者-x2F-消费者模式"><a href="#1-1-3-生产者-x2F-消费者模式" class="headerlink" title="1.1.3 生产者&#x2F;消费者模式"></a>1.1.3 生产者&#x2F;消费者模式</h4><p>生产者-消费者模式是通过一个数据容器来解决生产者和消费者的强耦合问题。<code>生产者和消费者彼此之间不直接通信，而通过阻塞队列来进行通信</code>，所以生产者生产完数据之后不用等待消费者处理，直接扔给阻塞队列，消费者不找生产者要数据，而是直接从阻塞队列里取，阻塞队列就相当于一个消息缓冲区，平衡了生产者和消费者的处理能力。在数据传输过程中，起到了一个削弱峰值的作用，也就是我们经常说到的削峰。</p>
<p><img src="/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240427142444917.png" alt="image-20240427142444917"></p>
<p>图形中的缓冲区就是用来给生产者和消费者解耦的。在单点环境中，我们一般会采用阻塞式队列实现这个缓冲区。而在分布式环境中，一般会采用第三方软件实现缓冲区，这个第三方软件我们一般称之为中间件。纵观大多数应用场景，解耦合最常用的方式就是增加中间件。</p>
<h4 id="1-1-4-消息中间件对比"><a href="#1-1-4-消息中间件对比" class="headerlink" title="1.1.4 消息中间件对比"></a>1.1.4 消息中间件对比</h4><table>
<thead>
<tr>
<th align="center">特性</th>
<th align="center">ActiveMQ</th>
<th align="center">RabbitMQ</th>
<th align="center">RocketMQ</th>
<th align="center">Kafka</th>
</tr>
</thead>
<tbody><tr>
<td align="center">单机吞吐量</td>
<td align="center">万级，比RocketMQ,Kafka低一个数量级</td>
<td align="center">万级，比RocketMQ,Kafka低一个数量级</td>
<td align="center">10万级，支持高吞吐</td>
<td align="center">10万级，支持高吞吐</td>
</tr>
<tr>
<td align="center">Topic数量对吞吐量的影响</td>
<td align="center"></td>
<td align="center"></td>
<td align="center">Topic可以达到几百&#x2F;几千量级</td>
<td align="center">Topic可以达到几百量级，如果更多的话，吞吐量会大幅度下降</td>
</tr>
<tr>
<td align="center">时效性</td>
<td align="center">ms级</td>
<td align="center">微秒级别，延迟最低</td>
<td align="center">ms级</td>
<td align="center">ms级</td>
</tr>
<tr>
<td align="center">可用性</td>
<td align="center">高，基于主从架构实现高可用</td>
<td align="center">高，基于主从架构实现高可用</td>
<td align="center">非常高，分布式架构</td>
<td align="center">非常高，分布式架构</td>
</tr>
<tr>
<td align="center">消息可靠性</td>
<td align="center">有较低的概率丢失数据</td>
<td align="center">基本不丢</td>
<td align="center">经过参数优化配置，可以做到0丢失</td>
<td align="center">经过参数优化配置，可以做到0丢失</td>
</tr>
<tr>
<td align="center">功能支持</td>
<td align="center">MQ领域的功能极其完备</td>
<td align="center">并发能力强，性能极好，延时很低</td>
<td align="center">MQ功能较为完善，分布式，扩展性好</td>
<td align="center">功能较为简单，支持简单的MQ功能，在大数据领域被广泛使用</td>
</tr>
<tr>
<td align="center">其他</td>
<td align="center">很早的软件，社区不是很活跃</td>
<td align="center">开源，稳定，社区活跃度高</td>
<td align="center">阿里开发，社区活跃度不高</td>
<td align="center">开源，高吞吐量，社区活跃度极高</td>
</tr>
</tbody></table>
<h4 id="1-1-5-ZooKeeper"><a href="#1-1-5-ZooKeeper" class="headerlink" title="1.1.5 ZooKeeper"></a>1.1.5 ZooKeeper</h4><p>ZooKeeper是一个<code>开源的分布式应用程序协调服务软件</code>。在当前的软件开发中，多节点分布式的架构设计已经成为必然，那么如何保证架构中不同的节点所运行的环境，系统配置是相同的，就是一个非常重要的话题。一般情况下，我们会采用独立的第三方软件保存分布式系统中的全局环境信息以及系统配置信息，这样系统中的每一个节点在运行时就可以从第三方软件中获取一致的数据。也就是说通过这个第三方软件来协调分布式各个节点之间的环境以及配置信息。Kafka软件是一个分布式事件流处理平台系统，底层采用分布式的架构设计，就是说，也存在多个服务节点，多个节点之间Kafka就是采用ZooKeeper来实现协调调度的。</p>
<p>ZooKeeper的核心作用：</p>
<ul>
<li>ZooKeeper的数据存储结构可以简单地理解为一个Tree结构，而Tree结构上的每一个节点可以用于存储数据，所以一般情况下，我们可以将分布式系统的<code>元数据（环境信息以及系统配置信息）</code>保存在ZooKeeper节点中。</li>
<li>ZooKeeper创建数据节点时，会根据业务场景创建临时节点或持久节点。<code>持久节点</code>就是无论客户端是否连接上ZooKeeper都一直存在的节点，而<code>临时节点</code>指的是客户端连接时创建，断开连接后删除的节点。同时，ZooKeeper也提供了<code>Watch机制</code>用于监控节点的变化，然后通知对应的客户端进行相应的变化。Kafka软件中就内置了ZooKeeper的客户端，用于进行ZooKeeper的连接和通信。</li>
</ul>
<p>其实，Kafka作为一个独立的分布式消息传输系统，还需要第三方软件进行节点间的协调调度，不能实现自我管理，无形中就导致Kafka和其他软件之间形成了耦合性，制约了Kafka软件的发展，所以从Kafka 2.8.X版本开始，Kafka就尝试增加了<code>Raft算法</code>实现节点间的协调管理，来代替ZooKeeper。不过Kafka官方不推荐此方式应用在生产环境中，计划在Kafka 4.X版本中完全移除ZooKeeper，让我们拭目以待。</p>
<h3 id="1-2-快速上手"><a href="#1-2-快速上手" class="headerlink" title="1.2 快速上手"></a>1.2 快速上手</h3><h4 id="1-2-1-环境安装"><a href="#1-2-1-环境安装" class="headerlink" title="1.2.1 环境安装"></a>1.2.1 环境安装</h4><p>作为开源分布式事件流处理平台，Kafka分布式软件环境的安装相对比较复杂，不利于Kafka软件的入门学习和练习。所以我们这里先搭建相对比较简单的Windows单机环境，让初学者快速掌握软件的基本原理和用法，后面的课程中，我们再深入学习Kafka软件在生产环境中的安装和使用。</p>
<p><code>zookeeper.properties</code>文件的配置中需要修改的部分：</p>
<p><img src="/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240427144257213.png" alt="image-20240427144257213"></p>
<p><code>server.properties</code>文件的配置中需要修改的部分：</p>
<p><img src="/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240427150835625.png" alt="image-20240427150835625"></p>
<p>启动Kafka单节点集群后的效果：</p>
<p><img src="/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240427145051515.png" alt="image-20240427145051515"></p>
<p><img src="/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240427145149328.png" alt="image-20240427145149328"></p>
<h4 id="1-2-2-消息主题"><a href="#1-2-2-消息主题" class="headerlink" title="1.2.2 消息主题"></a>1.2.2 消息主题</h4><p>有很多种方式都可以操作Kafka消息中的主题（Topic）：命令行、第三方工具、Java API、自动创建。而对于初学者来讲，掌握基本的命令行操作是必要的。所以接下来，我们采用命令行进行操作。</p>
<h5 id="1-2-2-1-创建主题"><a href="#1-2-2-1-创建主题" class="headerlink" title="1.2.2.1 创建主题"></a>1.2.2.1 创建主题</h5><p><img src="/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240427150542871.png" alt="image-20240427150542871"></p>
<h5 id="1-2-2-2-查询主题"><a href="#1-2-2-2-查询主题" class="headerlink" title="1.2.2.2 查询主题"></a>1.2.2.2 查询主题</h5><p><img src="/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240427150632339.png" alt="image-20240427150632339"></p>
<h5 id="1-2-2-3-修改主题"><a href="#1-2-2-3-修改主题" class="headerlink" title="1.2.2.3 修改主题"></a>1.2.2.3 修改主题</h5><p><img src="/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240427151020788.png" alt="image-20240427151020788"></p>
<h5 id="1-2-2-4-删除主题"><a href="#1-2-2-4-删除主题" class="headerlink" title="1.2.2.4 删除主题"></a>1.2.2.4 删除主题</h5><p><img src="/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240427151411014.png" alt="image-20240427151411014"></p>
<p>注意：Windows系统中由于权限或进程锁定的问题，删除topic会导致Kafka服务节点异常关闭。</p>
<h4 id="1-2-3-生产数据"><a href="#1-2-3-生产数据" class="headerlink" title="1.2.3 生产数据"></a>1.2.3 生产数据</h4><h5 id="1-2-3-1-命令行操作"><a href="#1-2-3-1-命令行操作" class="headerlink" title="1.2.3.1 命令行操作"></a>1.2.3.1 命令行操作</h5><p><img src="/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240427152411088.png" alt="image-20240427152411088"></p>
<h5 id="1-2-3-2-工具操作"><a href="#1-2-3-2-工具操作" class="headerlink" title="1.2.3.2 工具操作"></a>1.2.3.2 工具操作</h5><p><img src="/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240427152700617.png" alt="image-20240427152700617"></p>
<p><img src="/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240427153003130.png" alt="image-20240427153003130"></p>
<h5 id="1-2-3-3-Java-API操作"><a href="#1-2-3-3-Java-API操作" class="headerlink" title="1.2.3.3 Java API操作"></a>1.2.3.3 Java API操作</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">KafkaProducerTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 配置连接信息和序列化器</span></span><br><span class="line">        Map&lt;String, Object&gt; configs = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        configs.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, <span class="string">&quot;localhost:9092&quot;</span>);</span><br><span class="line">        configs.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, StringSerializer.class.getName());</span><br><span class="line">        configs.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, StringSerializer.class.getName());</span><br><span class="line">        <span class="comment">// 创建生产者对象</span></span><br><span class="line">        KafkaProducer&lt;String, String&gt; kafkaProducer = <span class="keyword">new</span> <span class="title class_">KafkaProducer</span>&lt;&gt;(configs);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 创建消息对象</span></span><br><span class="line">            ProducerRecord&lt;String, String&gt; record = <span class="keyword">new</span> <span class="title class_">ProducerRecord</span>&lt;&gt;(<span class="string">&quot;test&quot;</span>, <span class="string">&quot;key&quot;</span> + i, <span class="string">&quot;value&quot;</span> + i);</span><br><span class="line">            <span class="comment">// 发送消息</span></span><br><span class="line">            kafkaProducer.send(record);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 关闭生产者对象</span></span><br><span class="line">        kafkaProducer.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-2-4-消费数据"><a href="#1-2-4-消费数据" class="headerlink" title="1.2.4 消费数据"></a>1.2.4 消费数据</h4><h5 id="1-2-4-1-命令行操作"><a href="#1-2-4-1-命令行操作" class="headerlink" title="1.2.4.1 命令行操作"></a>1.2.4.1 命令行操作</h5><p><img src="/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240427154442392.png" alt="image-20240427154442392"></p>
<h5 id="1-2-4-2-Java-API操作"><a href="#1-2-4-2-Java-API操作" class="headerlink" title="1.2.4.2 Java API操作"></a>1.2.4.2 Java API操作</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">KafkaConsumerTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 配置连接信息和反序列化器</span></span><br><span class="line">        Map&lt;String, Object&gt; configs = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        configs.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, <span class="string">&quot;localhost:9092&quot;</span>);</span><br><span class="line">        configs.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class.getName());</span><br><span class="line">        configs.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class.getName());</span><br><span class="line">        configs.put(ConsumerConfig.GROUP_ID_CONFIG, <span class="string">&quot;groupId1&quot;</span>);</span><br><span class="line">        configs.put(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG, <span class="string">&quot;earliest&quot;</span>);</span><br><span class="line">        <span class="comment">// 创建消费者对象</span></span><br><span class="line">        KafkaConsumer&lt;String, String&gt; kafkaConsumer = <span class="keyword">new</span> <span class="title class_">KafkaConsumer</span>&lt;&gt;(configs);</span><br><span class="line">        <span class="comment">// 订阅主题</span></span><br><span class="line">        kafkaConsumer.subscribe(Collections.singletonList(<span class="string">&quot;test&quot;</span>));</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 拉取消息</span></span><br><span class="line">            ConsumerRecords&lt;String, String&gt; records = kafkaConsumer.poll(Duration.ofSeconds(<span class="number">100</span>));</span><br><span class="line">            <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records) &#123;</span><br><span class="line">                System.out.println(record);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 关闭消费者对象</span></span><br><span class="line">        <span class="comment">// kafkaConsumer.close();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240427155233130.png" alt="image-20240427155233130"></p>
<h2 id="第2章-Kafka基础"><a href="#第2章-Kafka基础" class="headerlink" title="第2章 Kafka基础"></a>第2章 Kafka基础</h2><p>Kafka借鉴了JMS规范的思想，但是却并没有完全遵循JMS规范，因此从设计原理上，Kafka的内部也会有很多用于数据传输的组件对象，这些组件对象之间会形成关联，组合在一起实现高效的数据传输。所以接下来，我们就按照数据流转的过程详细讲一讲Kafka中的基础概念以及核心组件。</p>
<h3 id="2-1-集群部署"><a href="#2-1-集群部署" class="headerlink" title="2.1 集群部署"></a>2.1 集群部署</h3><p>生产环境都是采用Linux系统搭建服务器集群，但是我们的重点是在于学习Kafka的基础概念和核心组件，所以这里我们搭建一个简单易用的Windows集群方便大家的学习和练习。Linux集群的搭建会在第3章给大家进行讲解。</p>
<p><img src="/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240427155838274.png" alt="image-20240427155838274"></p>
<p>三个Kafka节点分别是kafka-broker-1、kafka-broker-2、kafka-broker-3，分别修改其对应的<code>server.properties</code>配置文件：</p>
<ul>
<li><p><code>broker.id</code>分别是1、2、3</p>
</li>
<li><p><code>listeners</code>分别是<code>PLAINTEXT://:9091</code>、<code>PLAINTEXT://:9092</code>、<code>PLAINTEXT://:9093</code></p>
</li>
<li><p><code>log.dirs</code>分别是D:&#x2F;cluster&#x2F;kafka-broker-1&#x2F;data、D:&#x2F;cluster&#x2F;kafka-broker-2&#x2F;data、D:&#x2F;cluster&#x2F;kafka-broker-3&#x2F;data</p>
</li>
<li><p><code>zookeeper.connect</code>均为localhost:21810</p>
</li>
</ul>
<p>集群启动脚本<code>cluster.cmd</code>的内容为：</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> kafka-zookeeper</span><br><span class="line"><span class="built_in">start</span> zk.<span class="built_in">cmd</span></span><br><span class="line"><span class="built_in">ping</span> <span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span> -n <span class="number">10</span> &gt;<span class="built_in">nul</span></span><br><span class="line"><span class="built_in">cd</span> ../kafka-broker-<span class="number">1</span></span><br><span class="line"><span class="built_in">start</span> kafka.<span class="built_in">cmd</span></span><br><span class="line"><span class="built_in">cd</span> ../kafka-broker-<span class="number">2</span></span><br><span class="line"><span class="built_in">start</span> kafka.<span class="built_in">cmd</span></span><br><span class="line"><span class="built_in">cd</span> ../kafka-broker-<span class="number">3</span></span><br><span class="line"><span class="built_in">start</span> kafka.<span class="built_in">cmd</span></span><br></pre></td></tr></table></figure>

<p>集群清理脚本<code>cluster-clear.cmd</code>的内容为：</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> kafka-zookeeper</span><br><span class="line"><span class="built_in">rd</span> /s /q data</span><br><span class="line"><span class="built_in">cd</span> ../kafka-broker-<span class="number">1</span></span><br><span class="line"><span class="built_in">rd</span> /s /q data</span><br><span class="line"><span class="built_in">cd</span> ../kafka-broker-<span class="number">2</span></span><br><span class="line"><span class="built_in">rd</span> /s /q data</span><br><span class="line"><span class="built_in">cd</span> ../kafka-broker-<span class="number">3</span></span><br><span class="line"><span class="built_in">rd</span> /s /q data</span><br></pre></td></tr></table></figure>

<p>启动Kafka多节点集群后的效果：</p>
<p><img src="/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240427160617064.png" alt="image-20240427160617064"></p>
<p><img src="/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240427160652321.png" alt="image-20240427160652321"></p>
<h3 id="2-2-集群启动"><a href="#2-2-集群启动" class="headerlink" title="2.2 集群启动"></a>2.2 集群启动</h3><h4 id="2-2-1-相关概念"><a href="#2-2-1-相关概念" class="headerlink" title="2.2.1 相关概念"></a>2.2.1 相关概念</h4><h5 id="2-2-1-1-代理Broker"><a href="#2-2-1-1-代理Broker" class="headerlink" title="2.2.1.1 代理Broker"></a>2.2.1.1 代理Broker</h5><p>使用Kafka前，我们都会启动Kafka服务进程，这里的Kafka服务进程我们一般会称之为<code>Kafka Broker</code>或Kafka Server。因为Kafka是分布式消息系统，所以在实际的生产环境中，是需要多个服务进程形成集群提供消息服务的。所以每一个服务节点都是一个broker，而且在Kafka集群中，为了区分不同的服务节点，每一个broker都应该有一个不重复的全局ID，称之为<code>broker.id</code>，这个ID可以在Kafka软件的配置文件server.properties中进行配置。</p>
<table>
<thead>
<tr>
<th>主机</th>
<th>kafka-broker1</th>
<th>kafka-broker2</th>
<th>kafka-broker3</th>
</tr>
</thead>
<tbody><tr>
<td>broker.id</td>
<td>1</td>
<td>2</td>
<td>3</td>
</tr>
</tbody></table>
<h5 id="2-2-1-2-控制器Controller"><a href="#2-2-1-2-控制器Controller" class="headerlink" title="2.2.1.2 控制器Controller"></a>2.2.1.2 控制器Controller</h5><p>Kafka是分布式消息传输系统，所以存在多个Broker服务节点，但是它的软件架构采用的是分布式系统中比较常见的主从架构，也就是说需要从多个Broker中找到一个用于管理整个Kafka集群的Master节点，这个节点，我们就称之为Controller。它是Apache Kafka的核心组件非常重要。它的主要作用是<code>在Zookeeper的帮助下管理和协调控制整个Kafka集群</code>。</p>
<p><img src="/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240427162725190.png" alt="image-20240427162725190"></p>
<p>如果在运行过程中，Controller节点出现了故障，那么Kafka会依托于ZooKeeper软件选举其他的节点作为新的Controller，让Kafka集群实现高可用。</p>
<p>Kafka集群中Controller的基本功能：</p>
<ul>
<li><p>Broker管理(监听<code>/brokers/ids</code>节点相关的变化)</p>
<ul>
<li>Broker数量增加或减少的变化</li>
</ul>
<p><img src="/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240427164621444.png" alt="image-20240427164621444"></p>
<ul>
<li>Broker对应的数据变化</li>
</ul>
</li>
<li><p>Topic管理</p>
<ul>
<li>新增：监听<code>/brokers/topics</code>节点相关的变化</li>
</ul>
<p><img src="/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240427163934876.png" alt="image-20240427163934876"></p>
<ul>
<li>修改：监听<code>/brokers/topics</code>节点相关的变化</li>
<li>删除：监听<code>/admin/delete_topics</code>节点相关的变化</li>
</ul>
<p><img src="/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240427164134740.png" alt="image-20240427164134740"></p>
</li>
<li><p>Partation管理</p>
<ul>
<li>监听<code>/admin/reassign_partitions</code>节点相关的变化</li>
<li>监听<code>/isr_change_notification</code>节点相关的变化</li>
<li>监听<code>/preferred_replica_election</code>节点相关的变化</li>
</ul>
</li>
<li><p>数据服务</p>
</li>
<li><p>启动分区状态机和副本状态机</p>
</li>
</ul>
<h4 id="2-2-2-启动ZooKeeper"><a href="#2-2-2-启动ZooKeeper" class="headerlink" title="2.2.2 启动ZooKeeper"></a>2.2.2 启动ZooKeeper</h4><p>Kafka集群中含有多个服务节点，而分布式系统中经典的主从（Master-Slave）架构就要求从多个服务节点中找一个节点作为集群管理Master，Kafka集群中的这个Master，我们称之为集群控制器Controller。</p>
<p><img src="/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240427165117122.png" alt="image-20240427165117122"></p>
<p>如果此时Controller节点出现故障，它就不能再管理集群功能，那么其他的Slave节点该如何是好呢？</p>
<p><img src="/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240427165133415.png" alt="image-20240427165133415"></p>
<p>如果从剩余的2个Slave节点中选一个节点出来作为新的集群控制器是不是一个不错的方案，我们将这个选择的过程称之为：选举（elect）。方案是不错，但是问题就在于选哪一个Slave节点呢？不同的软件实现类似的选举功能都会有一些选举算法，而Kafka是依赖于ZooKeeper软件实现Broker节点选举功能。</p>
<p><img src="/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240427165200812.png" alt="image-20240427165200812"></p>
<p>ZooKeeper如何实现Kafka的节点选举呢？这就要说到我们用到ZooKeeper的3个功能：</p>
<ul>
<li>一个是在ZooKeeper软件中创建节点Node，创建一个Node时，我们会设定这个节点是持久节点，还是临时节点。所谓的持久节点，就是Node一旦创建后会一直存在，而临时创建，是根据当前的客户端连接创建的临时节点，一旦客户端连接断开，那么这个临时节点也会被自动删除，所以这样的节点称之为临时节点。</li>
<li>ZooKeeper节点是不允许有重复的,所以多个客户端创建同一个节点，只能有一个创建成功。</li>
<li>另外一个是客户端可以在ZooKeeper的节点上增加监听器，用于监听节点的状态变化，一旦监听的节点状态发生变化，那么监听器就会触发响应，实现特定监听功能。</li>
</ul>
<p>有了上面的三个知识点，我们这里就介绍一下Kafka是如何利用ZooKeeper实现Controller节点的选举的：</p>
<ol>
<li>第一次启动Kafka集群时，会同时启动多个Broker节点，每一个Broker节点就会连接ZooKeeper，并尝试创建一个临时节点 <code>/controller</code>。</li>
<li>因为ZooKeeper中一个节点不允许重复创建，所以多个Broker节点，最终只能有一个Broker节点可以创建成功，那么这个创建成功的Broker节点就会自动作为Kafka集群控制器节点，用于管理整个Kafka集群。</li>
<li>没有选举成功的其他Slave节点会创建<code>Node监听器</code>，用于监听<code>/controller</code>节点的状态变化。</li>
<li>一旦Controller节点出现故障或挂掉了，那么对应的ZooKeeper客户端连接就会中断。ZooKeeper中的<code>/controller</code>节点就会自动被删除，而其他的那些Slave节点因为增加了监听器，所以当监听到<code>/controller</code>节点被删除后，就会马上向ZooKeeper发出创建 <code>/controller</code>节点的请求，一旦创建成功，那么该Broker就变成了新的Controller节点了。</li>
</ol>
<p><img src="/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240427165716354.png" alt="image-20240427165716354"></p>
<p>现在我们能明白启动Kafka集群之前，为什么要先启动ZooKeeper集群了吧。就是因为ZooKeeper可以协助Kafka进行集群管理。</p>
<h4 id="2-2-3-启动Kafka"><a href="#2-2-3-启动Kafka" class="headerlink" title="2.2.3 启动Kafka"></a>2.2.3 启动Kafka</h4><p>ZooKeeper已经启动好了，那我们现在可以启动多个Kafka Broker节点构建Kafka集群了。构建的过程中，每一个Broker节点就是一个Java进程，而在这个进程中，有很多需要提前准备好，并进行初始化的内部组件对象。</p>
<h5 id="2-2-3-1-初始化ZooKeeper"><a href="#2-2-3-1-初始化ZooKeeper" class="headerlink" title="2.2.3.1 初始化ZooKeeper"></a>2.2.3.1 初始化ZooKeeper</h5><p>Kafka Broker启动时，首先会先创建ZooKeeper客户端（<code>KafkaZkClient</code>），用于和ZooKeeper进行交互。客户端对象创建完成后，会通过该客户端对象向ZooKeeper发送创建Node的请求，注意，这里创建的Node都是持久化Node。</p>
<p><img src="/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240427170608831.png" alt="image-20240427170608831"></p>
<table>
<thead>
<tr>
<th>节点</th>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>&#x2F;admin&#x2F;delete_topics</td>
<td>持久化节点</td>
<td>配置需要删除的topic，因为删除过程中，可能broker下线，或执行失败，那么就需要在broker重新上线后，根据当前节点继续删除操作，一旦topic所有的分区数据全部删除，那么当前节点的数据才会进行清理</td>
</tr>
<tr>
<td>&#x2F;brokers&#x2F;ids</td>
<td>持久化节点</td>
<td>服务节点ID标识，只要broker启动，那么就会在当前节点中增加子节点，brokerID不能重复</td>
</tr>
<tr>
<td>&#x2F;brokers&#x2F;topics</td>
<td>持久化节点</td>
<td>服务节点中的主题详细信息，包括分区，副本</td>
</tr>
<tr>
<td>&#x2F;brokers&#x2F;seqid</td>
<td>持久化节点</td>
<td>seqid主要用于自动生产brokerId</td>
</tr>
<tr>
<td>&#x2F;config&#x2F;changes</td>
<td>持久化节点</td>
<td>kafka的元数据发生变化时，会向该节点下创建子节点，并写入对应信息</td>
</tr>
<tr>
<td>&#x2F;config&#x2F;clients</td>
<td>持久化节点</td>
<td>客户端配置，默认为空</td>
</tr>
<tr>
<td>&#x2F;config&#x2F;brokers</td>
<td>持久化节点</td>
<td>服务节点相关配置，默认为空</td>
</tr>
<tr>
<td>&#x2F;config&#x2F;ips</td>
<td>持久化节点</td>
<td>IP配置，默认为空</td>
</tr>
<tr>
<td>&#x2F;config&#x2F;topics</td>
<td>持久化节点</td>
<td>主题配置，默认为空</td>
</tr>
<tr>
<td>&#x2F;config&#x2F;users</td>
<td>持久化节点</td>
<td>用户配置，默认为空</td>
</tr>
<tr>
<td>&#x2F;consumers</td>
<td>持久化节点</td>
<td>消费者节点，用于记录消费者相关信息</td>
</tr>
<tr>
<td>&#x2F;isr_change_notification</td>
<td>持久化节点</td>
<td>ISR列表发生变更时候的通知，在kafka当中由于存在ISR列表变更的情况发生,为了保证ISR列表更新的及时性，定义了isr_change_notification这个节点，主要用于通知Controller来及时将ISR列表进行变更。</td>
</tr>
<tr>
<td>&#x2F;latest_producer_id_block</td>
<td>持久化节点</td>
<td>保存PID块，主要用于能够保证生产者的任意写入请求都能够得到响应。</td>
</tr>
<tr>
<td>&#x2F;log_dir_event_notification</td>
<td>持久化节点</td>
<td>主要用于保存当broker当中某些数据路径出现异常时候,例如磁盘损坏,文件读写失败等异常时候,向ZooKeeper当中增加一个通知序号，Controller节点监听到这个节点的变化之后，就会做出对应的处理操作</td>
</tr>
<tr>
<td>&#x2F;cluster&#x2F;id</td>
<td>持久化节点</td>
<td>主要用于保存kafka集群的唯一id信息，每个kafka集群都会给分配要给唯一id，以及对应的版本号</td>
</tr>
</tbody></table>
<h5 id="2-2-3-2-初始化服务"><a href="#2-2-3-2-初始化服务" class="headerlink" title="2.2.3.2 初始化服务"></a>2.2.3.2 初始化服务</h5><p>Kafka Broker中有很多的服务对象，用于实现内部管理和外部通信操作。</p>
<p><img src="/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240427171118763.png" alt="image-20240427171118763"></p>
<ul>
<li>创建任务调度器</li>
</ul>
<p>每一个Broker在启动时都会创建内部调度器（<code>KafkaScheduler</code>）并启动，用于完成节点内部的工作任务。底层就是Java中的定时任务线程池<code>ScheduledThreadPoolExecutor</code>。</p>
<ul>
<li>创建日志数据管理器</li>
</ul>
<p>每一个Broker在启动时都会创建日志数据管理器（<code>LogManager</code>），用于接收到消息后，完成后续的数据创建，查询，清理等处理。</p>
<ul>
<li>创建远程数据管理器</li>
</ul>
<p>每一个Broker在启动时都会创建远程数据管理器（<code>RemoteLogManager</code>），用于和其他Broker节点进行数据状态同步。</p>
<ul>
<li>创建副本管理器</li>
</ul>
<p>每一个Broker在启动时都会创建副本管理器（<code>ReplicaManager</code>），用于对主题分区的副本进行处理。</p>
<ul>
<li>创建ZK元数据缓存</li>
</ul>
<p>每一个Broker在启动时会将ZK的关于Kafka的元数据进行缓存，创建元数据对象（<code>ZkMetadataCache</code>）。</p>
<ul>
<li>创建Broker通信对象</li>
</ul>
<p>每一个Broker在启动时会创建Broker之间的通道管理器对象（<code>BrokerToControllerChannelManager</code>），用于管理Broker和Controller之间的通信。</p>
<ul>
<li>创建网络通信对象</li>
</ul>
<p>每一个Broker在启动时会创建自己的网络通信对象（<code>SocketServer</code>），用于和其他Broker之间的进行通信，其中包含了Java用于NIO通信的Channel、Selector对象。</p>
<img src="/imgs/Kafka技术探索/image-20240427171932255.png" alt="image-20240427171932255" style="zoom:150%;" />

<ul>
<li>注册Broker节点</li>
</ul>
<p>Broker启动时，会通过ZKClient对象向ZooKeeper注册当前的Broker节点ID，注册后创建的ZK节点为临时节点。如果当前Broker的ZKClient断开和ZooKeeper的连接，注册的节点会被删除。</p>
<h5 id="2-2-3-3-启动控制器"><a href="#2-2-3-3-启动控制器" class="headerlink" title="2.2.3.3 启动控制器"></a>2.2.3.3 启动控制器</h5><p>控制器（<code>KafkaController</code>）是每一个Broker启动时都会创建的核心对象，用于和ZooKeeper之间建立连接并申请自己为整个Kafka集群的Master管理者。如果申请成功，那么会完成管理者的初始化操作，并建立和其他Broker之间的数据通道接收各种事件，进行封装后交给事件管理器，并定义了<code>process</code>方法，用于真正处理各类事件。</p>
<p><img src="/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240427172253401.png" alt="image-20240427172253401"></p>
<ul>
<li>初始化通道管理器</li>
</ul>
<p>创建通道管理器（<code>ControllerChannelManager</code>），该管理器维护了Controller和集群所有Broker节点之间的网络连接，并向Broker发送控制类请求及接收响应。</p>
<ul>
<li>初始化事件管理器</li>
</ul>
<p>创建事件管理器（<code>ControllerEventManager</code>）维护了Controller和集群所有Broker节点之间的网络连接，并向Broker发送控制类请求及接收响应。</p>
<ul>
<li>初始化状态管理器</li>
</ul>
<p>创建状态管理器（<code>ControllerChangeHandler</code>）可以监听<code>/controller</code>节点的操作，一旦节点创建（<code>ControllerChange</code>），删除（<code>Reelect</code>），数据发生变化（<code>ControllerChange</code>），那么监听后执行相应的处理。</p>
<ul>
<li>启动控制器</li>
</ul>
<p>控制器对象启动后，会向事件管理器发送<code>Startup</code>事件，事件处理线程接收到事件后会通过ZKClient向ZooKeeper申请<code>/controller</code>节点，申请成功后，执行当前节点成为Controller的一系列操作。主要是注册各类ZooKeeper监听器、删除日志路径变更和ISR副本变更通知事件、启动Controller通道管理器，以及启动副本状态机和分区状态机。</p>
<h3 id="2-3-创建主题"><a href="#2-3-创建主题" class="headerlink" title="2.3 创建主题"></a>2.3 创建主题</h3><p>Topic主题是Kafka中消息的<code>逻辑分类</code>，但是这个分类不应该是固定的，而是应该由外部的业务场景进行定义（注意：Kafka中其实是有两个固定的内部主题，用于记录消费者偏移量和事务处理的Topic），所以Kafka提供了相应的指令和客户端进行主题操作。</p>
<ul>
<li><code>__consumer_offsets</code>:这个内部Topic用于存储Kafka消费者的偏移量信息。每个消费者组都会在这个Topic中维护其消费的进度，以确保消费者可以从上次离开的地方继续消费消息。</li>
<li><code>__transaction_state</code>:这个内部Topic用于支持Kafka事务。Kafka支持事务性生产和消费操作，__transaction_state用于存储事务的元数据信息。</li>
</ul>
<blockquote>
<p>通常，这些内部Topic不需要用户手动操作，Kafka会自动管理它们。它们对Kafka集群的正常运行非常重要，因此最好不要对它们进行修改或删除操作，以避免影响Kafka的正常功能。</p>
</blockquote>
<h4 id="2-3-1-相关概念"><a href="#2-3-1-相关概念" class="headerlink" title="2.3.1 相关概念"></a>2.3.1 相关概念</h4><h5 id="2-3-1-1-主题Topic"><a href="#2-3-1-1-主题Topic" class="headerlink" title="2.3.1.1 主题Topic"></a>2.3.1.1 主题Topic</h5><p>Kafka是分布式消息传输系统，采用的数据传输方式为发布订阅模式，也就是说由消息的生产者发布消息，消费者订阅消息后获取数据。为了对消费者订阅的消息进行区分，所以对消息在逻辑上进行了分类，这个分类我们称之为主题：Topic。为了防止主题的名称和监控指标的名称产生冲突，官方推荐主题的名称中不要同时包含下划线和点。</p>
<img src="/imgs/Kafka技术探索/image-20240427180933897.png" alt="image-20240427180933897" style="zoom:150%;" />

<h5 id="2-3-1-2-分区Partition"><a href="#2-3-1-2-分区Partition" class="headerlink" title="2.3.1.2 分区Partition"></a>2.3.1.2 分区Partition</h5><p>Kafka消息传输采用发布订阅模式，所以消息生产者必须将数据发送到一个主题，假如发送给这个主题的数据非常多，那么主题所在Broker节点的负载和吞吐量就会受到极大的考验，甚至有可能因为热点问题引起Broker节点故障，导致服务不可用。一个好的方案就是将一个主题从物理上分成几部分，然后将消息均匀地分配到不同的Broker节点分区上，这样就可以缓解单节点的负载问题。默认情况下，主题创建时分区数量为1，也就是一块分区，可以指定参数<code>--partitions</code>改变。Kafka的分区解决了单一主题线性扩展的问题，也解决了负载均衡的问题。</p>
<p>主题的每个分区都会用一个编号进行标记，一般是从0开始的连续整数数字。Partition分区是物理上的概念，也就意味着会以<code>数据文件</code>的方式真实存在。每个Topic包含一个或多个Partition，每个Partition都可以看作一个有序队列。Partition中每条消息都会分配一个有序的ID，称之为偏移量：<code>Offset</code>。</p>
<img src="/imgs/Kafka技术探索/image-20240427181416380.png" alt="image-20240427181416380" style="zoom:150%;" />

<h5 id="2-3-1-3-副本Replication"><a href="#2-3-1-3-副本Replication" class="headerlink" title="2.3.1.3 副本Replication"></a>2.3.1.3 副本Replication</h5><p>分布式系统出现错误是比较常见的，只要保证集群内部依然存在可用的服务节点即可，当然效率会有所降低，不过只要能保证系统可用就可以了。咱们Kafka的Topic也存在类似的问题，也就是说，如果一个Topic划分了多个分区，那么这些分区就会均匀地分布在不同的Broker节点上，一旦某一个Broker节点出现了问题，那么在这个节点上的分区就会出现问题，那么Topic的数据就不完整了。所以一般情况下，为了<code>防止出现数据丢失的情况</code>，我们会给分区数据设定多个备份，这里的备份，我们称之为副本：Replication。</p>
<p>Kafka支持多副本，使得主题可以做到更多容错性，牺牲性能与空间去换取更高的可靠性。</p>
<img src="/imgs/Kafka技术探索/image-20240427181647955.png" alt="image-20240427181647955" style="zoom:150%;" />

<blockquote>
<p>注意：这里不能将多个备份放置在同一个Broker中，因为一旦出现故障，多个副本就都不能用了，那么副本的意义就没有了。</p>
</blockquote>
<h5 id="2-3-1-4-副本类型Leader-x2F-Follower"><a href="#2-3-1-4-副本类型Leader-x2F-Follower" class="headerlink" title="2.3.1.4 副本类型Leader&#x2F;Follower"></a>2.3.1.4 副本类型Leader&#x2F;Follower</h5><p>假设我们有一份文件，一般情况下，我们对副本的理解应该是有一个正式的完整文件，然后这个文件的备份称之为副本。但是在Kafka中不是这样的，所有的文件都称之为副本，只不过会选择其中的一个文件作为主文件称之为Leader副本，其他的文件作为备份文件称之为Follower副本。<strong>在Kafka中，这里的文件就是分区，每一个分区都可以存在1个或多个副本，只有Leader副本才能进行数据的读写，Follower副本只做备份使用。</strong></p>
<img src="/imgs/Kafka技术探索/image-20240427182233007.png" alt="image-20240427182233007" style="zoom:150%;" />

<h5 id="2-3-1-5-日志Log"><a href="#2-3-1-5-日志Log" class="headerlink" title="2.3.1.5 日志Log"></a>2.3.1.5 日志Log</h5><p>Kafka最开始的应用场景就是日志场景或MQ场景，更多的扮演着一个日志传输和存储系统，这是Kafka立家之本。所以Kafka接收到的消息数据最终都是存储在log日志文件中的，底层存储数据的文件的扩展名就是<code>.log</code>。</p>
<p><img src="/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240427182803170.png" alt="image-20240427182803170"></p>
<h4 id="2-3-2-创建第一个主题"><a href="#2-3-2-创建第一个主题" class="headerlink" title="2.3.2 创建第一个主题"></a>2.3.2 创建第一个主题</h4><p>创建主题Topic的方式有很多种：命令行，工具，客户端API，自动创建。在<code>server.properties</code>文件中配置参数<code>auto.create.topics.enable=true</code>时，如果访问的主题不存在，那么Kafka就会自动创建主题，这个操作不在我们的讨论范围内。我们首先创建的主题，仅仅指明主题的名称即可，其他参数暂时无需设定。</p>
<p><img src="/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240427183549123.png" alt="image-20240427183549123"></p>
<h5 id="2-3-2-1-ZooKeeper节点变化"><a href="#2-3-2-1-ZooKeeper节点变化" class="headerlink" title="2.3.2.1 ZooKeeper节点变化"></a>2.3.2.1 ZooKeeper节点变化</h5><p>指令执行后，当前Kafka会增加一个主题，因为指令中没有配置分区和副本参数，所以当前主题默认分区数量为1，编号为0，副本数量为1。为了方便集群的管理，创建Topic时，会同时在ZooKeeper中增加子节点，记录主题相关配置信息：</p>
<ul>
<li><code>/config/topics</code>节点中会增加first-topic节点。</li>
</ul>
<p><img src="/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240427183631376.png" alt="image-20240427183631376"></p>
<ul>
<li><code>/brokers/topics</code>节点中会增加first-topic节点以及相应的子节点。</li>
</ul>
<p><img src="/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240427183815758.png" alt="image-20240427183815758"></p>
<h5 id="2-3-2-2-数据存储位置"><a href="#2-3-2-2-数据存储位置" class="headerlink" title="2.3.2.2 数据存储位置"></a>2.3.2.2 数据存储位置</h5><p>主题创建后，需要找到一个用于存储分区数据的位置，根据上面ZooKeeper存储的节点配置信息可以知道，当前主题的分区数量为1，副本数量为1，那么数据存储的位置就是副本所在的Broker节点，从当前数据来看，数据存储在我们的Broker3上。</p>
<p><img src="/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240427184341097.png" alt="image-20240427184341097"></p>
<p>路径中的<code>00000000000000000000.log</code>文件就是真正存储消息数据的文件，文件名称中的0表示当前文件中第一个消息的起始偏移量为0，index文件和timeindex文件都是数据索引文件，用于快速定位数据。只不过index文件采用<code>偏移量</code>的方式进行定位，而timeindex是采用<code>时间戳</code>的方式。</p>
<blockquote>
<p>查看的命令：kafka-run-class.sh kafka.tools.DumpLogSegments –files (000…..log|000……index) –print-data-log</p>
</blockquote>
<h4 id="2-3-3-创建第二个主题"><a href="#2-3-3-创建第二个主题" class="headerlink" title="2.3.3 创建第二个主题"></a>2.3.3 创建第二个主题</h4><p>接下来我们创建第二个主题，不过创建时，我们需要设定分区参数<code>--partitions</code>，参数值为3，表示创建3个分区</p>
<p><img src="/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240427185256204.png" alt="image-20240427185256204"></p>
<h5 id="2-3-3-1-ZooKeeper节点变化"><a href="#2-3-3-1-ZooKeeper节点变化" class="headerlink" title="2.3.3.1 ZooKeeper节点变化"></a>2.3.3.1 ZooKeeper节点变化</h5><p>指令执行后，当前Kafka会增加一个主题，因为指令中指定了分区数量（–partitions 3），所以当前主题分区数量为3，编号为[0、1、2]，副本数量为1，编号为所在Broker的ID值。为了方便集群的管理，创建Topic时，会同时在ZooKeeper中增加子节点，记录主题相关配置信息：</p>
<ul>
<li><code>/config/topics</code>节点中会增加second-topic节点。</li>
</ul>
<p><img src="/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240427185502734.png" alt="image-20240427185502734"></p>
<ul>
<li><code>/brokers/topics</code>节点中会增加second-topic节点以及相应的子节点。 <img src="/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240427185704383.png" alt="image-20240427185704383"></li>
</ul>
<p><img src="/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240427185646303.png" alt="image-20240427185646303"></p>
<h5 id="2-3-3-2-数据存储位置"><a href="#2-3-3-2-数据存储位置" class="headerlink" title="2.3.3.2 数据存储位置"></a>2.3.3.2 数据存储位置</h5><p>主题创建后，需要找到一个用于存储分区数据的位置，根据上面ZooKeeper存储的节点配置信息可以知道，当前主题的分区数量为3，副本数量为1，那么数据存储的位置就是每个分区Leader副本所在的Broker节点。</p>
<p><img src="/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240427190121016.png" alt="image-20240427190121016"></p>
<h4 id="2-3-4-创建第三个主题"><a href="#2-3-4-创建第三个主题" class="headerlink" title="2.3.4 创建第三个主题"></a>2.3.4 创建第三个主题</h4><p>接下来我们创建第三个主题，不过创建时，我们需要设定副本参数<code>--replication-factor</code>，参数值为3，表示每个分区创建3个副本。</p>
<p><img src="/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240427213253128.png" alt="image-20240427213253128"></p>
<h5 id="2-3-4-1-ZooKeeper节点变化"><a href="#2-3-4-1-ZooKeeper节点变化" class="headerlink" title="2.3.4.1 ZooKeeper节点变化"></a>2.3.4.1 ZooKeeper节点变化</h5><p>指令执行后，当前Kafka会增加一个主题，因为指令中指定了分区数量和副本数量（<code>--replication-factor 3</code>），所以当前主题分区数量为3，编号为[0、1、2]，副本为3，编号为[1、2、3]。为了方便集群的管理，创建Topic时，会同时在ZooKeeper中增加子节点，记录主题相关配置信息：</p>
<ul>
<li><code>/config/topics</code>节点中会增加third-topic节点。</li>
</ul>
<p><img src="/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240427213530618.png" alt="image-20240427213530618"></p>
<ul>
<li><code>/brokers/topics</code>节点中会增加third-topic节点以及相应的子节点。</li>
</ul>
<p><img src="/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240427213729353.png" alt="image-20240427213729353"></p>
<p><img src="/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240427213749881.png" alt="image-20240427213749881"></p>
<h5 id="2-3-4-2-数据存储位置"><a href="#2-3-4-2-数据存储位置" class="headerlink" title="2.3.4.2 数据存储位置"></a>2.3.4.2 数据存储位置</h5><p>主题创建后，需要找到一个用于存储分区数据的位置，根据上面ZooKeeper存储的节点配置信息可以知道，当前主题的分区数量为3，副本数量为3，那么数据存储的位置就是每个分区副本所在的Broker节点。</p>
<p><img src="/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240427214156546.png" alt="image-20240427214156546"></p>
<h4 id="2-3-5-创建主题流程"><a href="#2-3-5-创建主题流程" class="headerlink" title="2.3.5 创建主题流程"></a>2.3.5 创建主题流程</h4><p>Kafka中主题、分区以及副本的概念都和数据存储相关，所以是非常重要的。前面咱们演示了一下创建主题的具体操作和现象，那么接下来，我们就通过图解来了解一下Kafka是如何创建主题，并进行分区副本分配的。</p>
<h5 id="2-3-5-1-命令行提交创建指令"><a href="#2-3-5-1-命令行提交创建指令" class="headerlink" title="2.3.5.1 命令行提交创建指令"></a>2.3.5.1 命令行提交创建指令</h5><img src="/imgs/Kafka技术探索/image-20240427214315328.png" alt="image-20240427214315328" style="zoom:150%;" />

<ol>
<li>通过命令行提交指令，指令中会包含操作类型（<code>--create</code>）、Topic的名称（<code>--topic</code>）、主题分区数量（<code>--partitions</code>）、主题分区副本数量（<code>--replication-facotr</code>）、副本分配策略（<code>--replica-assignment</code>）等参数。</li>
<li>指令会提交到客户端进行处理，客户端获取指令后，会首先对指令参数进行校验。<ol>
<li>操作类型取值：create、list、alter、describe、delete，只能存在一个。</li>
<li>分区数量为大于0的整数。</li>
<li>主题是否已经存在。</li>
<li>分区副本数量处于[1,Short.MaxValue]，一般取值小于等于Broker数量。</li>
</ol>
</li>
<li>将参数封装主题对象（NewTopic）。</li>
<li>创建通信对象，设定请求标记（<code>CREATE_TOPICS</code>），查找Controller，通过通信对象向Controller发起创建主题的网络请求。</li>
</ol>
<h5 id="2-3-5-2-Controller接收创建主题请求"><a href="#2-3-5-2-Controller接收创建主题请求" class="headerlink" title="2.3.5.2 Controller接收创建主题请求"></a>2.3.5.2 Controller接收创建主题请求</h5><img src="/imgs/Kafka技术探索/image-20240427215442772.png" alt="image-20240427215442772" style="zoom:150%;" />

<ol>
<li>Controller节点接收到网络请求（<code>Acceptor</code>），并将请求数据封装成请求对象放置在队列（<code>requestQueue</code>）中。</li>
<li>请求控制器（<code>KafkaRequestHandler</code>）周期性从队列中获取请求对象（<code>BaseRequest</code>）。</li>
<li>将请求对象转发给请求应用处理器（<code>KafkaApis</code>），根据请求对象的类型调用创建主题的方法。</li>
</ol>
<h5 id="2-3-5-3-创建主题"><a href="#2-3-5-3-创建主题" class="headerlink" title="2.3.5.3 创建主题"></a>2.3.5.3 创建主题</h5><img src="/imgs/Kafka技术探索/image-20240427215733055.png" alt="image-20240427215733055" style="zoom:150%;" />

<ol>
<li><p>应用请求处理器（KafkaApis）校验主题参数。</p>
<ol>
<li>如果分区数量没有设置，那么会采用Kafka启动时加载的配置项：<code>num.partitions</code>（默认值为1）</li>
<li>如果副本数量没有设置，那么会采用Kafka启动时记载的配置项：<code>default.replication.factor</code>（默认值为1）</li>
</ol>
</li>
<li><p>在创建主题时，如果使用了<code>replica-assignment</code>参数，那么就按照指定的方案来进行分区副本的创建；如果没有指定replica-assignment参数，那么就按照Kafka内部逻辑来分配，内部逻辑按照机架信息分为两种策略：【未指定机架信息】和【指定机架信息】。当前课程中采用的是【未指定机架信息】副本分配策略：</p>
<ol>
<li><p>分区起始编号设置0;</p>
</li>
<li><p>轮询所有分区，计算每一个分区的所有副本位置：</p>
<ol>
<li>副本起始索引 &#x3D;（分区编号 + 随机值）% BrokerID列表长度</li>
<li>其他副本索引 &#x3D; 随机值（基本算法为使用随机值执行多次模运算）</li>
<li>通过索引位置获取副本BrokerID</li>
<li>保存分区以及对应的副本BrokerID列表</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">##################################################################</span><br><span class="line"># 假设 </span><br><span class="line">#     当前分区编号 : <span class="number">0</span></span><br><span class="line">#     BrokerID列表 :【<span class="number">1</span>，<span class="number">2</span>，<span class="number">3</span>，<span class="number">4</span>】</span><br><span class="line">#     副本数量 : <span class="number">4</span></span><br><span class="line">#     随机值（BrokerID列表长度）: <span class="number">2</span></span><br><span class="line">#     副本分配间隔随机值（BrokerID列表长度）: <span class="number">2</span></span><br><span class="line">##################################################################</span><br><span class="line"># 第一个副本索引：（分区编号 + 随机值）% BrokerID列表长度 =（<span class="number">0</span> + <span class="number">2</span>）% <span class="number">4</span> = <span class="number">2</span></span><br><span class="line"># 第一个副本所在BrokerID : <span class="number">3</span></span><br><span class="line"></span><br><span class="line"># 第二个副本索引（第一个副本索引 + （<span class="number">1</span> +（副本分配间隔 + <span class="number">0</span>）% （BrokerID列表长度 - <span class="number">1</span>））） % BrokerID列表长度 =（<span class="number">2</span> +（<span class="number">1</span> +（<span class="number">2</span> + <span class="number">0</span>）% <span class="number">3</span>））% <span class="number">4</span> = <span class="number">1</span></span><br><span class="line"># 第二个副本所在BrokerID：<span class="number">2</span></span><br><span class="line"></span><br><span class="line"># 第三个副本索引：（第一个副本索引 + （<span class="number">1</span> +（副本分配间隔 + <span class="number">1</span>）% （BrokerID列表长度 - <span class="number">1</span>））） % BrokerID列表长度 =（<span class="number">2</span> +（<span class="number">1</span> +（<span class="number">2</span> + <span class="number">1</span>）% <span class="number">3</span>））% <span class="number">4</span> = <span class="number">3</span></span><br><span class="line"># 第三个副本所在BrokerID：<span class="number">4</span></span><br><span class="line"></span><br><span class="line"># 第四个副本索引：（第一个副本索引 + （<span class="number">1</span> +（副本分配间隔 + <span class="number">2</span>）% （BrokerID列表长度 - <span class="number">1</span>））） % BrokerID列表长度 = （<span class="number">2</span> +（<span class="number">1</span> +（<span class="number">2</span> + <span class="number">2</span>）% <span class="number">3</span>））% <span class="number">4</span> = <span class="number">0</span></span><br><span class="line"># 第四个副本所在BrokerID：<span class="number">1</span></span><br><span class="line"></span><br><span class="line"># 最终分区<span class="number">0</span>的副本所在的Broker节点列表为【<span class="number">3</span>，<span class="number">2</span>，<span class="number">4</span>，<span class="number">1</span>】</span><br><span class="line"># 其他分区采用同样算法</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过ZK客户端在ZooKeeper端创建节点：</p>
<ol>
<li>在<code>/config/topics</code>节点下，增加当前主题节点，节点类型为持久类型。</li>
<li>在<code>/brokers/topics</code>节点下，增加当前主题及相关节点，节点类型为持久类型。</li>
</ol>
</li>
<li><p>Controller节点启动后，会在<code>/brokers/topics</code>节点增加<code>监听器</code>，一旦节点发生变化，会触发相应的功能：</p>
<ol>
<li>获取需要新增的主题信息</li>
<li>更新当前Controller节点保存的主题状态数据</li>
<li>更新分区状态机的状态为：<code>NewPartition</code></li>
<li>更新副本状态机的状态：<code>NewReplica</code></li>
<li>更新分区状态机的状态为：<code>OnlinePartition</code>，从正常的副本列表中的获取<code>第一个</code>作为分区的<code>Leader副本</code>，所有的副本作为分区的同步副本列表，我们称之为<code>ISR(In-Sync Replica)</code>。在ZK路径&#x2F;brokers&#x2F;topics&#x2F;主题名上增加分区节点<code>/partitions</code>及状态<code>/state</code>节点。</li>
<li>更新副本状态机的状态：<code>OnlineReplica</code></li>
</ol>
</li>
<li><p>Controller向主题的各个分区副本所属Broker节点发送<code>LeaderAndIsrRequest</code>请求，向所有的Broker节点发送<code>UPDATE_METADATA</code>请求，更新自身的缓存。</p>
<ol>
<li>Controller向分区所属的Broker发送请求</li>
<li>Broker节点接收到请求后，根据分区状态信息，设定当前的副本为Leader或Follower，并创建底层的数据存储文件目录和空的数据文件。</li>
</ol>
<p><strong>文件目录名：主题名 + 分区编号</strong></p>
<table>
<thead>
<tr>
<th>文件名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>0000000000000000.log</td>
<td>数据文件，用于存储传输的数据</td>
</tr>
<tr>
<td>0000000000000000.index</td>
<td>索引文件，用于定位数据</td>
</tr>
<tr>
<td>0000000000000000.timeindex</td>
<td>时间戳索引文件，用于定位数据</td>
</tr>
</tbody></table>
</li>
</ol>
</li>
</ol>
<h3 id="2-4-生产消息"><a href="#2-4-生产消息" class="headerlink" title="2.4 生产消息"></a>2.4 生产消息</h3><p>Topic主题已经创建好了，接下来我们就可以向该主题生产消息了，这里我们采用Java代码通过Kafka Producer API的方式生产数据。</p>
<h4 id="2-4-1-生产消息的基本步骤"><a href="#2-4-1-生产消息的基本步骤" class="headerlink" title="2.4.1 生产消息的基本步骤"></a>2.4.1 生产消息的基本步骤</h4><p>(一)创建Map类型的配置对象，根据场景增加相应的配置属性</p>
<ul>
<li>bootstrap.servers<ul>
<li>用于建立与Kafka集群的初始连接的主机&#x2F;端口对列表</li>
<li>格式：host1:port1,host2:port2,…</li>
</ul>
</li>
<li>key.serializer<ul>
<li>实现<code>org.apache.kafka.common.serialization.Serializer</code>接口的key的序列化器的<code>全限定类名</code></li>
</ul>
</li>
<li>value.serializer<ul>
<li>实现<code>org.apache.kafka.common.serialization.Serializer</code>接口的value的序列化器的<code>全限定类名</code></li>
</ul>
</li>
<li>interceptor.classes<ul>
<li>用作拦截器的类的列表，实现<code>org.apache.kafka.clients.Producer.ProducerInterceptor</code>接口允许您在将生产者收到的Record发布到Kafka集群之前拦截（并可能改变）它们</li>
<li>默认情况下，没有拦截器</li>
</ul>
</li>
<li>batch.size<ul>
<li>每当多个记录发送到同一分区时，生产者将尝试将记录一起批处理为更少的请求。这有助于提高客户端和服务器的性能。此配置控制默认批量大小（以字节为单位）</li>
<li>发送到Broker的请求将包含多个批次，每个批次对应一个可发送数据的分区</li>
<li>小批量大小将使批处理不太常见，并且可能会降低吞吐量（批量大小为零将完全禁用批处理）。非常大的批处理大小可能会更加浪费内存，因为我们总是会分配指定批处理大小的缓冲区以应对额外的记录</li>
<li>注意：此设置给出了要发送的批量大小的上限。如果该分区累积的字节数少于这么多，我们将徘徊<code>linger.ms</code>时间，等待更多记录到来。linger.ms设置默认为0，这意味着即使累积的批量大小低于该batch.size设置，我们也会立即发送一条记录</li>
</ul>
</li>
<li>linger.ms<ul>
<li>生产者将等待给定的延迟以允许发送其他记录，以便可以将发送分批在一起</li>
</ul>
</li>
<li>acks<ul>
<li><code>acks=0</code>:如果设置为零，那么生产者将根本不会等待来自服务器的任何确认。该记录将立即添加到Socket缓冲区并被视为已发送。 在这种情况下，<code>不能保证服务器已收到记录</code>，并且重试配置不会生效（因为客户端通常不会知道任何失败）</li>
<li><code>acks=1</code>:这意味着Leader会将记录写入其本地日志，但会在不等待所有Follower完全确认的情况下做出响应。在这种情况下，如果Leader在确认记录后但在Follower复制它之前立即失败，那么记录将丢失</li>
<li><code>acks=all</code>:这意味着Leader将等待完整的同步副本集确认记录。这保证了只要至少一个同步副本保持活动状态，记录就不会丢失。 这是<code>最强有力的保证</code>。这等同于acks&#x3D;-1</li>
<li><strong>启用幂等性要求此配置值为all</strong>。如果设置了冲突的配置并且未显式启用幂等性，则幂等性将被禁用</li>
</ul>
</li>
<li>retries<ul>
<li>设置大于零的值将导致客户端重新发送发送失败并可能出现暂时性错误的任何记录。请注意，此重试与客户端在收到错误后重新发送记录没有什么不同。如果在成功确认之前，<code>delivery.timeout.ms</code>配置的超时时间先到期，则生产请求将在重试次数用尽之前失败。用户通常应该更愿意不设置此配置，而是使用delivery.timeout.ms来控制重试行为</li>
<li>在将<code>enable.idempotence</code>设置为false并将<code>max.in.flight.requests.per.connection</code>设置为大于1时允许重试可能会更改记录的顺序，因为如果将两批发送到单个分区，并且第一批失败并重试 但是第二批成功了，那么第二批中的记录可能会先出现</li>
<li><strong>启用幂等性要求此配置值大于0</strong>。如果设置了冲突的配置并且未显式启用幂等性，则幂等性将被禁用</li>
</ul>
</li>
<li>max.in.flight.requests.per.connection<ul>
<li>客户端在阻塞之前在单个连接上发送的未确认请求的最大数量。注意，如果该配置设置大于1且enable.idempotence设置为false，则存在因重试而导致发送失败后消息重新排序的风险（即如果启用了重试）；如果禁用重试或将enable.idempotence设置为true，则将保留排序。</li>
<li><strong>启用幂等性要求此配置的值小于或等于5</strong>。如果设置了冲突的配置并且未显式启用幂等性，则幂等性将被禁用</li>
</ul>
</li>
<li>buffer.memory<ul>
<li>生产者可用于缓冲等待发送到服务器的记录的内存总字节数。如果记录发送速度快于传送到服务器的速度，生产者将阻塞<code>max.block.ms</code>之后将抛出异常。</li>
</ul>
</li>
<li>enable.idempotence<ul>
<li>当设置为true时，生产者将确保每条消息的一份副本准确写入流中。如果为false，则生产者由于Broker故障等原因重试，可能会在流中写入重试消息的重复项</li>
</ul>
</li>
<li>partitioner.ignore.keys<ul>
<li>当设置为true时，生产者将不会使用记录Key来选择分区。如果为false，则当存在Key时，生产者将根据<code>Key的哈希值</code>选择分区。 注意：如果使用自定义分区器，此设置无效。</li>
</ul>
</li>
</ul>
<p>(二)创建待发送数据</p>
<p>在Kafka中传递的数据我们称之为消息（message）或记录(record)，所以Kafka发送数据前，需要将待发送的数据封装为指定的数据模型：</p>
<img src="/imgs/Kafka技术探索/image-20240428155755449.png" alt="image-20240428155755449" style="zoom:150%;" />

<p><img src="/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240428155823107.png" alt="image-20240428155823107"></p>
<p>相关属性必须在构建数据模型时指定，其中Topic和Value的值是必须要传递的。如果配置中开启了自动创建主题，那么Topic主题可以不存在。Value就是我们需要真正传递的数据了，而Key可以用于数据的分区定位。</p>
<p>(三)创建生产者对象，发送生产的数据</p>
<p>根据前面提供的配置信息创建生产者对象，通过这个生产者对象向Kafka服务器节点发送数据，而具体的发送是由生产者对象创建时，内部构建的多个组件实现的，多个组件的关系有点类似于生产者-消费者模式。</p>
<img src="/imgs/Kafka技术探索/image-20240428160004995.png" alt="image-20240428160004995" style="zoom:150%;" />

<ul>
<li>数据生产者（<code>KafkaProducer</code>）：生产者对象，用于对我们的数据进行必要的转换和处理，将处理后的数据放入到数据收集器中，类似于生产者-消费者模式下的生产者。这里我们简单介绍一下内部的数据转换处理：<ul>
<li>如果配置拦截器（interceptor.classes），那么将数据进行拦截处理。某一个拦截器出现异常并不会影响后续的拦截器处理。</li>
<li>因为发送的数据为KV数据，所以需要根据配置信息中的序列化器对数据中Key和Value分别进行序列化处理。</li>
<li>计算数据所发送的分区位置。</li>
<li>将数据追加到数据收集器中。</li>
</ul>
</li>
<li>数据收集器（<code>RecordAccumulator</code>）：用于收集，转换我们产生的数据，类似于生产者-消费者模式下的缓冲区。为了优化数据的传输，Kafka并不是生产一条数据就向Broker发送一条数据，而是通过合并单条消息，进行批量（批次）发送，提高吞吐量，减少带宽消耗。<ul>
<li>默认情况下，一个发送批次的数据容量为16K，这个可以通过参数batch.size进行改善。</li>
<li>批次是和分区进行绑定的。也就是说发往同一个分区的数据会进行合并，形成一个批次。</li>
<li>如果当前批次能容纳数据，那么直接将数据追加到批次中即可，如果不能容纳数据，那么会产生新的批次放入到当前分区的批次队列中，这个队列使用的是Java的双端队列Deque。旧的批次关闭不再接收新的数据，等待发送。</li>
</ul>
</li>
<li>数据发送器（<code>Sender</code>）：线程对象，用于从收集器对象中获取数据，向服务节点发送。类似于生产者-消费者模式下的消费者。因为是线程对象，所以启动后会不断轮询获取数据收集器中已经关闭的批次数据。对批次进行整合后再发送到Broker节点中。<ul>
<li>因为数据真正发送的地方是Broker节点，不是分区。所以需要将从数据收集器中收集到的批次数据按照可用Broker节点重新组合成List集合。</li>
<li>将组合后的&lt;节点，List&lt;批次&gt;&gt;的数据封装成客户端请求（请求键为：<code>Produce</code>）发送到网络客户端对象的缓冲区，由网络客户端对象通过网络发送给Broker节点。</li>
<li>Broker节点获取客户端请求，并根据请求键进行后续的数据处理：向分区中增加数据。</li>
</ul>
</li>
</ul>
<img src="/imgs/Kafka技术探索/image-20240428160717743.png" alt="image-20240428160717743" style="zoom:150%;" />

<h4 id="2-4-2-生产消息的基本代码"><a href="#2-4-2-生产消息的基本代码" class="headerlink" title="2.4.2 生产消息的基本代码"></a>2.4.2 生产消息的基本代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">KafkaProducerTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 配置连接信息和序列化器</span></span><br><span class="line">        Map&lt;String, Object&gt; configs = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        configs.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, <span class="string">&quot;localhost:9092&quot;</span>);</span><br><span class="line">        configs.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, StringSerializer.class.getName());</span><br><span class="line">        configs.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, StringSerializer.class.getName());</span><br><span class="line">        <span class="comment">// 创建生产者对象</span></span><br><span class="line">        KafkaProducer&lt;String, String&gt; kafkaProducer = <span class="keyword">new</span> <span class="title class_">KafkaProducer</span>&lt;&gt;(configs);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 创建消息对象</span></span><br><span class="line">            ProducerRecord&lt;String, String&gt; record = <span class="keyword">new</span> <span class="title class_">ProducerRecord</span>&lt;&gt;(<span class="string">&quot;test&quot;</span>, <span class="string">&quot;key&quot;</span> + i, <span class="string">&quot;value&quot;</span> + i);</span><br><span class="line">            <span class="comment">// 发送消息</span></span><br><span class="line">            kafkaProducer.send(record);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 关闭生产者对象</span></span><br><span class="line">        kafkaProducer.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-4-3-发送消息"><a href="#2-4-3-发送消息" class="headerlink" title="2.4.3 发送消息"></a>2.4.3 发送消息</h4><h5 id="2-4-3-1-拦截器"><a href="#2-4-3-1-拦截器" class="headerlink" title="2.4.3.1 拦截器"></a>2.4.3.1 拦截器</h5><p>生产者API在数据准备好发送给Kafka服务器之前，允许我们对生产的数据进行<code>统一的处理</code>，比如校验，整合数据等等。这些处理我们是可以通过Kafka提供的拦截器完成。因为拦截器不是生产者必须配置的功能，所以大家可以根据实际的情况自行选择使用。</p>
<p>但是要注意，这里的拦截器是可以配置多个的。执行时，会<code>按照声明顺序</code>执行完一个后，再执行下一个。<strong>并且某一个拦截器如果出现异常，只会跳出当前拦截器逻辑，并不会影响后续拦截器的处理</strong>。所以开发时，需要将拦截器的这种处理方法考虑进去。</p>
<img src="/imgs/Kafka技术探索/image-20240428161203206.png" alt="image-20240428161203206" style="zoom:150%;" />

<p><img src="/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240428161301545.png" alt="image-20240428161301545"></p>
<p>下面演示拦截器的基本使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyProducerInterceptor</span> <span class="keyword">implements</span> <span class="title class_">ProducerInterceptor</span>&lt;String, String&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ProducerRecord&lt;String, String&gt; <span class="title function_">onSend</span><span class="params">(ProducerRecord&lt;String, String&gt; record)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ProducerRecord</span>&lt;&gt;(record.topic(), record.key(), record.value() + <span class="string">&quot; intercepted&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onAcknowledgement</span><span class="params">(RecordMetadata metadata, Exception exception)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(Map&lt;String, ?&gt; configs)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">KafkaProducerInterceptorTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 配置连接信息和序列化器</span></span><br><span class="line">        Map&lt;String, Object&gt; configs = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        configs.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, <span class="string">&quot;localhost:9092&quot;</span>);</span><br><span class="line">        configs.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, StringSerializer.class.getName());</span><br><span class="line">        configs.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, StringSerializer.class.getName());</span><br><span class="line">        <span class="comment">// 配置拦截器</span></span><br><span class="line">        configs.put(ProducerConfig.INTERCEPTOR_CLASSES_CONFIG, MyProducerInterceptor.class.getName());</span><br><span class="line">        <span class="comment">// 创建生产者对象</span></span><br><span class="line">        KafkaProducer&lt;String, String&gt; kafkaProducer = <span class="keyword">new</span> <span class="title class_">KafkaProducer</span>&lt;&gt;(configs);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 创建消息对象</span></span><br><span class="line">            ProducerRecord&lt;String, String&gt; record = <span class="keyword">new</span> <span class="title class_">ProducerRecord</span>&lt;&gt;(<span class="string">&quot;my-topic1&quot;</span>, <span class="string">&quot;key&quot;</span> + i, <span class="string">&quot;value&quot;</span> + i);</span><br><span class="line">            <span class="comment">// 发送消息</span></span><br><span class="line">            kafkaProducer.send(record);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 关闭生产者对象</span></span><br><span class="line">        kafkaProducer.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240428161558461.png" alt="image-20240428161558461"></p>
<h5 id="2-4-3-2-回调方法"><a href="#2-4-3-2-回调方法" class="headerlink" title="2.4.3.2 回调方法"></a>2.4.3.2 回调方法</h5><p>Kafka发送数据时，可以同时传递回调对象（Callback）用于对数据的发送结果进行对应处理，具体代码实现采用匿名类或Lambda表达式都可以。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">KafkaProducerCallbackTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 配置连接信息和序列化器</span></span><br><span class="line">        Map&lt;String, Object&gt; configs = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        configs.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, <span class="string">&quot;localhost:9092&quot;</span>);</span><br><span class="line">        configs.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, StringSerializer.class.getName());</span><br><span class="line">        configs.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, StringSerializer.class.getName());</span><br><span class="line">        <span class="comment">// 创建生产者对象</span></span><br><span class="line">        KafkaProducer&lt;String, String&gt; kafkaProducer = <span class="keyword">new</span> <span class="title class_">KafkaProducer</span>&lt;&gt;(configs);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 创建消息对象</span></span><br><span class="line">            ProducerRecord&lt;String, String&gt; record = <span class="keyword">new</span> <span class="title class_">ProducerRecord</span>&lt;&gt;(<span class="string">&quot;test&quot;</span>, <span class="string">&quot;key&quot;</span> + i, <span class="string">&quot;value&quot;</span> + i);</span><br><span class="line">            <span class="comment">// 异步发送消息</span></span><br><span class="line">            Future&lt;RecordMetadata&gt; result = kafkaProducer.send(record, <span class="keyword">new</span> <span class="title class_">Callback</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onCompletion</span><span class="params">(RecordMetadata metadata, Exception exception)</span> &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;数据发送成功：&quot;</span> + metadata);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;发送数据：&quot;</span> + record);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 关闭生产者对象</span></span><br><span class="line">        kafkaProducer.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240428162939197.png" alt="image-20240428162939197"></p>
<h5 id="2-4-3-3-异步发送"><a href="#2-4-3-3-异步发送" class="headerlink" title="2.4.3.3 异步发送"></a>2.4.3.3 异步发送</h5><p>Kafka发送数据时，底层的实现类似于生产者-消费者模式。对应的，底层会由主线程代码作为生产者向缓冲区中放数据，而数据发送线程会从缓冲区中获取数据进行发送。Broker接收到数据后进行后续处理。</p>
<p>如果Kafka通过主线程代码将一条数据放入到缓冲区后，无需等待数据的后续发送过程，就直接发送下一条数据，我们就称之为异步发送。</p>
<img src="/imgs/Kafka技术探索/image-20240428162252090.png" alt="image-20240428162252090" style="zoom:150%;" />

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">KafkaProducerCallbackTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 配置连接信息和序列化器</span></span><br><span class="line">        Map&lt;String, Object&gt; configs = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        configs.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, <span class="string">&quot;localhost:9092&quot;</span>);</span><br><span class="line">        configs.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, StringSerializer.class.getName());</span><br><span class="line">        configs.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, StringSerializer.class.getName());</span><br><span class="line">        <span class="comment">// 创建生产者对象</span></span><br><span class="line">        KafkaProducer&lt;String, String&gt; kafkaProducer = <span class="keyword">new</span> <span class="title class_">KafkaProducer</span>&lt;&gt;(configs);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 创建消息对象</span></span><br><span class="line">            ProducerRecord&lt;String, String&gt; record = <span class="keyword">new</span> <span class="title class_">ProducerRecord</span>&lt;&gt;(<span class="string">&quot;test&quot;</span>, <span class="string">&quot;key&quot;</span> + i, <span class="string">&quot;value&quot;</span> + i);</span><br><span class="line">            <span class="comment">// 异步发送消息</span></span><br><span class="line">            Future&lt;RecordMetadata&gt; result = kafkaProducer.send(record, <span class="keyword">new</span> <span class="title class_">Callback</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onCompletion</span><span class="params">(RecordMetadata metadata, Exception exception)</span> &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;数据发送成功：&quot;</span> + metadata);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;发送数据：&quot;</span> + record);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 关闭生产者对象</span></span><br><span class="line">        kafkaProducer.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240428163058286.png" alt="image-20240428163058286"></p>
<h5 id="2-4-3-4-同步发送"><a href="#2-4-3-4-同步发送" class="headerlink" title="2.4.3.4 同步发送"></a>2.4.3.4 同步发送</h5><p>如果Kafka通过主线程代码将一条数据放入到缓冲区后，需等待数据的后续发送操作的应答状态，才能发送下一条数据的场合，我们就称之为同步发送。所以这里的所谓同步，就是生产数据的线程需要等待发送线程的应答（响应）结果。代码实现上，采用的是JDK1.5增加的JUC并发编程的Future接口的get方法实现。</p>
<img src="/imgs/Kafka技术探索/image-20240428163206159.png" alt="image-20240428163206159" style="zoom:150%;" />

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">KafkaProducerCallbackTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 配置连接信息和序列化器</span></span><br><span class="line">        Map&lt;String, Object&gt; configs = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        configs.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, <span class="string">&quot;localhost:9092&quot;</span>);</span><br><span class="line">        configs.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, StringSerializer.class.getName());</span><br><span class="line">        configs.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, StringSerializer.class.getName());</span><br><span class="line">        <span class="comment">// 创建生产者对象</span></span><br><span class="line">        KafkaProducer&lt;String, String&gt; kafkaProducer = <span class="keyword">new</span> <span class="title class_">KafkaProducer</span>&lt;&gt;(configs);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 创建消息对象</span></span><br><span class="line">            ProducerRecord&lt;String, String&gt; record = <span class="keyword">new</span> <span class="title class_">ProducerRecord</span>&lt;&gt;(<span class="string">&quot;test&quot;</span>, <span class="string">&quot;key&quot;</span> + i, <span class="string">&quot;value&quot;</span> + i);</span><br><span class="line">            <span class="comment">// 异步发送消息</span></span><br><span class="line">            Future&lt;RecordMetadata&gt; result = kafkaProducer.send(record, <span class="keyword">new</span> <span class="title class_">Callback</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onCompletion</span><span class="params">(RecordMetadata metadata, Exception exception)</span> &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;数据发送成功：&quot;</span> + metadata);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="comment">// 同步发送消息</span></span><br><span class="line">            result.get();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;发送数据：&quot;</span> + record);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 关闭生产者对象</span></span><br><span class="line">        kafkaProducer.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240428163341069.png" alt="image-20240428163341069"></p>
<h4 id="2-4-4-消息分区"><a href="#2-4-4-消息分区" class="headerlink" title="2.4.4 消息分区"></a>2.4.4 消息分区</h4><h5 id="2-4-4-1-指定分区"><a href="#2-4-4-1-指定分区" class="headerlink" title="2.4.4.1 指定分区"></a>2.4.4.1 指定分区</h5><p>Kafka中Topic是对数据逻辑上的分类，而Partition才是数据真正存储的物理位置。所以在生产数据时，如果只是指定Topic的名称，其实Kafka是不知道将数据发送到哪一个Broker节点的。我们可以在构建数据传递Topic参数的同时，也可以指定数据存储的分区编号。</p>
<img src="/imgs/Kafka技术探索/image-20240428163458871.png" alt="image-20240428163458871" style="zoom:150%;" />

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 配置连接信息和序列化器</span></span><br><span class="line">Map&lt;String, Object&gt; configs = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">configs.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, <span class="string">&quot;localhost:9092&quot;</span>);</span><br><span class="line">configs.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, StringSerializer.class.getName());</span><br><span class="line">configs.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, StringSerializer.class.getName());</span><br><span class="line"><span class="comment">// 创建生产者对象</span></span><br><span class="line">KafkaProducer&lt;String, String&gt; kafkaProducer = <span class="keyword">new</span> <span class="title class_">KafkaProducer</span>&lt;&gt;(configs);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// 创建消息对象</span></span><br><span class="line">    ProducerRecord&lt;String, String&gt; record = <span class="keyword">new</span> <span class="title class_">ProducerRecord</span>&lt;&gt;(<span class="string">&quot;test&quot;</span>, <span class="number">0</span>, <span class="string">&quot;key&quot;</span> + i, <span class="string">&quot;value&quot;</span> + i);</span><br><span class="line">    <span class="comment">// 发送消息</span></span><br><span class="line">    kafkaProducer.send(record);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 关闭生产者对象</span></span><br><span class="line">kafkaProducer.close();</span><br></pre></td></tr></table></figure>

<h5 id="2-4-4-2-未指定分区"><a href="#2-4-4-2-未指定分区" class="headerlink" title="2.4.4.2 未指定分区"></a>2.4.4.2 未指定分区</h5><p>如果不指定分区，Kafka会根据<code>集群元数据</code>中的主题分区来通过算法来计算分区编号并设定：</p>
<p><img src="/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240428164256414.png" alt="image-20240428164256414"></p>
<ol>
<li>如果指定了分区，直接使用</li>
<li>如果指定了自己的分区器，通过分区器计算分区编号，如果有效，直接使用</li>
<li>如果指定了数据Key，且使用Key选择分区的场合，采用<code>murmur2</code>非加密散列算法（类似于hash）计算数据Key序列化后的值的散列值，然后对主题分区数量模运算取余，最后的结果就是分区编号<br><img src="/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240428164332126.png" alt="image-20240428164332126"></li>
<li>如果未指定数据Key，或不使用Key选择分区，那么Kafka会采用<code>优化后的粘性分区策略</code>进行分区选择：<ol>
<li>没有分区数据负载状态信息时，会从分区列表中随机选择一个分区<br><img src="/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240428164634056.png" alt="image-20240428164634056"></li>
<li>存在分区数据负载状态信息时，根据分区数据负载状态，通过随机数获取一个权重值<br><img src="/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240428164808894.png" alt="image-20240428164808894"></li>
<li>根据这个权重值在队列分区负载状态中进行二分查找法，查找权重值的索引值<br><img src="/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240428164905064.png" alt="image-20240428164905064"></li>
<li>将这个索引值加1就是当前设定的分区<br><img src="/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240428164925785.png" alt="image-20240428164925785"></li>
</ol>
</li>
<li>增加数据后，会根据当前粘性分区中生产的数据量进行判断，是不是需要切换其他的分区。判断标准就是大于等于批次大小（16K）的2倍，或大于一个批次大小（16K）且需要切换。如果满足条件，下一条数据就会放置到其他分区。</li>
</ol>
<h5 id="2-4-4-3-分区器"><a href="#2-4-4-3-分区器" class="headerlink" title="2.4.4.3 分区器"></a>2.4.4.3 分区器</h5><p>在某些场合中，指定的数据我们是需要根据自身的业务逻辑发往指定的分区的。所以需要自己定义分区编号规则，而不是采用Kafka自动设置就显得尤其必要了。Kafka早期版本中提供了两个分区器，不过在当前kafka版本中已经不推荐使用了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyProducerPartitioner</span> <span class="keyword">implements</span> <span class="title class_">Partitioner</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(String topic, Object key, <span class="type">byte</span>[] keyBytes, Object value, <span class="type">byte</span>[] valueBytes, Cluster cluster)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(Map&lt;String, ?&gt; configs)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">KafkaProducerPartitionerTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 配置连接信息和序列化器</span></span><br><span class="line">        Map&lt;String, Object&gt; configs = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        configs.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, <span class="string">&quot;localhost:9092&quot;</span>);</span><br><span class="line">        configs.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, StringSerializer.class.getName());</span><br><span class="line">        configs.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, StringSerializer.class.getName());</span><br><span class="line">        <span class="comment">// 配置分区器</span></span><br><span class="line">        configs.put(ProducerConfig.PARTITIONER_CLASS_CONFIG, MyProducerPartitioner.class.getName());</span><br><span class="line">        <span class="comment">// 创建生产者对象</span></span><br><span class="line">        KafkaProducer&lt;String, String&gt; kafkaProducer = <span class="keyword">new</span> <span class="title class_">KafkaProducer</span>&lt;&gt;(configs);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 创建消息对象</span></span><br><span class="line">            ProducerRecord&lt;String, String&gt; record = <span class="keyword">new</span> <span class="title class_">ProducerRecord</span>&lt;&gt;(<span class="string">&quot;my-topic2&quot;</span>, <span class="string">&quot;key&quot;</span> + i, <span class="string">&quot;value&quot;</span> + i);</span><br><span class="line">            <span class="comment">// 发送消息</span></span><br><span class="line">            kafkaProducer.send(record);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 关闭生产者对象</span></span><br><span class="line">        kafkaProducer.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-4-5-消息可靠性"><a href="#2-4-5-消息可靠性" class="headerlink" title="2.4.5 消息可靠性"></a>2.4.5 消息可靠性</h4><p>对于生产者发送的数据，我们有的时候是不关心数据是否已经发送成功的，我们只要发送就可以了。在这种场景中，消息可能会因为某些故障或问题导致丢失，我们将这种情况称之为消息不可靠。虽然消息数据可能会丢失，但是在某些需要高吞吐，低可靠的系统场景中，这种方式也是可以接受的，甚至是必须的。但是在更多的场景中，我们是需要确定数据是否已经发送成功了且Kafka正确接收到数据的，也就是要<code>保证数据不丢失</code>，这就是所谓的消息可靠性保证。</p>
<p>而这个确定的过程一般是通过Kafka给我们返回的响应确认结果（Acknowledgement）来决定的，这里的响应确认结果我们也可以简称为ACK应答。根据场景，Kafka提供了3种应答处理，可以通过配置对象进行配置。</p>
<h5 id="2-4-5-1-ACK-x3D-0"><a href="#2-4-5-1-ACK-x3D-0" class="headerlink" title="2.4.5.1 ACK&#x3D;0"></a>2.4.5.1 ACK&#x3D;0</h5><p>当生产数据时，生产者对象将数据<code>通过网络客户端NetworkClient将数据发送到网络数据流缓冲区中的时候</code>，Kafka就对当前的数据请求进行了响应（确认应答），如果是同步发送数据，此时就可以发送下一条数据了。如果是异步发送数据，回调方法就会被触发。</p>
<img src="/imgs/Kafka技术探索/image-20240428165810209.png" alt="image-20240428165810209" style="zoom:150%;" />

<p>通过图形，明显可以看出，这种应答方式，数据已经走网络给Kafka发送了，但这其实并不能保证Kafka能正确地接收到数据，在传输过程中如果网络出现了问题，那么数据就丢失了。也就是说这种应答确认的方式，<code>数据的可靠性是无法保证的</code>。不过相反，因为无需等待Kafka服务节点的确认，通信效率倒是比较高的，也就是<code>系统吞吐量会非常高</code>。</p>
<h5 id="2-4-5-2-ACK-x3D-1"><a href="#2-4-5-2-ACK-x3D-1" class="headerlink" title="2.4.5.2 ACK&#x3D;1"></a>2.4.5.2 ACK&#x3D;1</h5><p>当生产数据时，Kafka Leader副本将数据接收到并写入到了日志文件后，就会对当前的数据请求进行响应（确认应答），如果是同步发送数据，此时就可以发送下一条数据了。如果是异步发送数据，回调方法就会被触发。</p>
<img src="/imgs/Kafka技术探索/image-20240428170030658.png" alt="image-20240428170030658" style="zoom:150%;" />

<p>通过图形，可以看出，这种应答方式，数据已经存储到了分区Leader副本中，那么数据相对来讲就比较安全了，也就是<code>可靠性比较高</code>。之所以说相对来讲比较安全，就是因为现在只有一个节点存储了数据，而数据并没有来得及进行备份到Follower副本，那么一旦当前存储数据的Broker节点出现了故障，数据也依然会丢失。</p>
<h5 id="2-4-5-3-ACK-x3D-all"><a href="#2-4-5-3-ACK-x3D-all" class="headerlink" title="2.4.5.3 ACK&#x3D;all"></a>2.4.5.3 ACK&#x3D;all</h5><p>当生产数据时，Kafka Leader副本和Follower副本都已经将数据接收到并写入到了日志文件后，再对当前的数据请求进行响应（确认应答），如果是同步发送数据，此时就可以发送下一条数据了。如果是异步发送数据，回调方法就会被触发。</p>
<img src="/imgs/Kafka技术探索/image-20240428170146483.png" alt="image-20240428170146483" style="zoom:150%;" />

<p>通过图形，可以看出，这种应答方式，数据已经同时存储到了分区Leader副本和Follower副本中，那么<code>数据已经非常安全</code>了，可靠性也是最高的。此时，如果Leader副本出现了故障，那么Follower副本能够开始起作用，因为数据已经存储了，所以数据不会丢失。</p>
<p>不过这里需要注意，如果假设我们的分区有5个副本，编号为1，2，3，4，5:</p>
<img src="/imgs/Kafka技术探索/image-20240428170249018.png" alt="image-20240428170249018" style="zoom:150%;" />

<p>但是此时只有3个副本处于和Leader副本之间处于数据同步状态，那么此时分区就存在一个同步副本列表，我们称之为<code>In-Syn-Replica</code>，简称为ISR。此时，Kafka只要保证ISR中所有的4个副本接收到了数据，就可以对数据请求进行响应了，无需5个副本全部收到数据。</p>
<h4 id="2-4-6-消息去重-amp-有序"><a href="#2-4-6-消息去重-amp-有序" class="headerlink" title="2.4.6 消息去重&amp;有序"></a>2.4.6 消息去重&amp;有序</h4><h5 id="2-4-6-1-数据重试"><a href="#2-4-6-1-数据重试" class="headerlink" title="2.4.6.1 数据重试"></a>2.4.6.1 数据重试</h5><p>由于网络或服务节点的故障，Kafka在传输数据时，可能会导致数据丢失，所以我们才会设置ACK应答机制，尽可能提高数据的可靠性。但其实在某些场景中，数据的丢失并不是真正地丢失，而是“虚假丢失”，比如咱们将ACK应答设置为1，也就是说一旦Leader副本将数据写入文件后，Kafka就可以对请求进行响应了。</p>
<img src="/imgs/Kafka技术探索/image-20240428170712704.png" alt="image-20240428170712704" style="zoom:150%;" />

<p>此时，如果假设由于网络故障的原因，Kafka并没有成功将ACK应答信息发送给Producer，那么此时对于Producer来讲，以为Kafka没有收到数据，所以就会一直等待响应，一旦超过某个时间阈值，就会发生超时错误，也就是说在Kafka Producer眼里，数据已经丢了。</p>
<img src="/imgs/Kafka技术探索/image-20240428170754361.png" alt="image-20240428170754361" style="zoom:150%;" />

<p>所以在这种情况下，Kafka Producer会尝试对超时的请求数据进行重试(<code>retry</code>)操作。通过重试操作尝试将数据再次发送给Kafka。</p>
<img src="/imgs/Kafka技术探索/image-20240428170838266.png" alt="image-20240428170838266" style="zoom:150%;" />

<p>如果此时发送成功，那么Kafka就又收到了数据，而这两条数据是一样的，也就是说，导致了数据的重复。</p>
<img src="/imgs/Kafka技术探索/image-20240428170935538.png" alt="image-20240428170935538" style="zoom:150%;" />

<h5 id="2-4-6-2-数据乱序"><a href="#2-4-6-2-数据乱序" class="headerlink" title="2.4.6.2 数据乱序"></a>2.4.6.2 数据乱序</h5><p>数据重试(<code>retry</code>)功能除了可能会导致数据重复以外，还可能会导致数据乱序。假设我们需要将编号为1，2，3的三条连续数据发送给Kafka。每条数据会对应于一个连接请求:</p>
<img src="/imgs/Kafka技术探索/image-20240428171148879.png" alt="image-20240428171148879" style="zoom:150%;" />

<p>此时，如果第一个数据的请求出现了故障，而第二个数据和第三个数据的请求正常，那么Broker就收到了第二个数据和第三个数据，并进行了应答。</p>
<img src="/imgs/Kafka技术探索/image-20240428171221461.png" alt="image-20240428171221461" style="zoom:150%;" />

<p>为了保证数据的可靠性，此时，Kafka Producer会将第一条数据重新放回到缓冲区的第一个，进行重试操作:</p>
<img src="/imgs/Kafka技术探索/image-20240428171257414.png" alt="image-20240428171257414" style="zoom:150%;" />

<p>如果重试成功，Broker收到第一条数据，你会发现。数据的顺序已经被打乱了。</p>
<img src="/imgs/Kafka技术探索/image-20240428171319526.png" alt="image-20240428171319526" style="zoom:150%;" />

<h5 id="2-4-6-3-数据幂等性"><a href="#2-4-6-3-数据幂等性" class="headerlink" title="2.4.6.3 数据幂等性"></a>2.4.6.3 数据幂等性</h5><p>为了解决Kafka传输数据时，所产生的数据重复和乱序问题，Kafka引入了幂等性操作，所谓的幂等性，就是Producer同样的一条数据，无论向Kafka发送多少次，Kafka都只会存储一条。注意，这里的同样的一条数据，指的不是内容一致的数据，而是指的<code>不断重试的数据</code>。</p>
<p>默认幂等性是不起作用的，所以如果想要使用幂等性操作，只需要在生产者对象的配置中开启幂等性配置即可:</p>
<table>
<thead>
<tr>
<th>配置项</th>
<th>配置值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>enable.idempotence</td>
<td>true</td>
<td>开启幂等性</td>
</tr>
<tr>
<td>max.in.flight.requests.per.connection</td>
<td>小于等于5</td>
<td>每个连接的在途请求数，不能大于5，取值范围为[1,5]</td>
</tr>
<tr>
<td>acks</td>
<td>all(-1)</td>
<td>确认应答，固定值，不能修改</td>
</tr>
<tr>
<td>retries</td>
<td>&gt;0</td>
<td>重试次数，推荐使用Int最大值</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">KafkaProducerIdemTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 配置连接信息和序列化器</span></span><br><span class="line">        Map&lt;String, Object&gt; configs = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        configs.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, <span class="string">&quot;localhost:9092&quot;</span>);</span><br><span class="line">        configs.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, StringSerializer.class.getName());</span><br><span class="line">        configs.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, StringSerializer.class.getName());</span><br><span class="line">        configs.put(ProducerConfig.ACKS_CONFIG, <span class="string">&quot;-1&quot;</span>);</span><br><span class="line">        <span class="comment">// 开启幂等性需要满足以下条件：</span></span><br><span class="line">        <span class="comment">// 1. 生产者的acks配置为all(-1)</span></span><br><span class="line">        <span class="comment">// 2. 生产者的max.in.flight.requests.per.connections配置小于等于5</span></span><br><span class="line">        <span class="comment">// 3. 生产者的retries配置大于0</span></span><br><span class="line">        configs.put(ProducerConfig.ENABLE_IDEMPOTENCE_CONFIG, <span class="literal">true</span>);</span><br><span class="line">        configs.put(ProducerConfig.RETRIES_CONFIG, <span class="number">3</span>);</span><br><span class="line">        configs.put(ProducerConfig.REQUEST_TIMEOUT_MS_CONFIG, <span class="number">3000</span>);</span><br><span class="line">        <span class="comment">// 创建生产者对象</span></span><br><span class="line">        KafkaProducer&lt;String, String&gt; kafkaProducer = <span class="keyword">new</span> <span class="title class_">KafkaProducer</span>&lt;&gt;(configs);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 创建消息对象</span></span><br><span class="line">            ProducerRecord&lt;String, String&gt; record = <span class="keyword">new</span> <span class="title class_">ProducerRecord</span>&lt;&gt;(<span class="string">&quot;test&quot;</span>, <span class="string">&quot;key&quot;</span> + i, <span class="string">&quot;value&quot;</span> + i);</span><br><span class="line">            <span class="comment">// 发送消息</span></span><br><span class="line">            kafkaProducer.send(record);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 关闭生产者对象</span></span><br><span class="line">        kafkaProducer.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Kafka是如何实现数据的幂等性操作呢，我们这里简单说一下流程：</p>
<ol>
<li>开启幂等性后，为了保证数据不会重复，那么就需要给每一个请求批次的数据增加唯一性标识，Kafka中，这个标识采用的是连续的序列号数字<code>seqnum</code>，但是不同的生产者Producer可能序列号是一样的，所以仅仅靠seqnum还无法唯一标记数据，所以还需要同时对生产者进行区分，所以Kafka采用申请生产者ID（<code>producerid</code>）的方式对生产者进行区分。这样，在发送数据前，我们就需要提前申请producerid以及序列号seqnum</li>
<li>Broker中会给每一个分区记录生产者的生产状态：<code>采用队列的方式缓存最近的5个批次数据</code>。队列中的数据按照<code>seqnum</code>进行升序排列。这里的数字5是经过压力测试，均衡空间效率和时间效率所得到的值，所以为固定值，无法配置且不能修改。<br><img src="/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240428172017690.png" alt="image-20240428172017690"></li>
<li>如果Borker当前新的请求批次数据在缓存的5个旧的批次中存在相同的，那么说明有重复，当前批次数据不做任何处理。<br><img src="/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240428172052001.png" alt="image-20240428172052001"></li>
<li>如果Broker当前的请求批次数据在缓存中没有相同的，那么判断<code>当前新的请求批次的序列号是否为缓存的最后一个批次的序列号加1</code>，如果是，说明是连续的，顺序没乱。那么继续，如果不是，那么说明数据已经乱了，发生异常。<br><img src="/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240428172133131.png" alt="image-20240428172133131"></li>
<li>Broker根据异常返回响应，通知Producer进行重试。Producer重试前，需要在缓冲区中将数据重新排序，保证正确的顺序后，再进行重试即可。</li>
<li>如果请求批次不重复且有序，那么更新缓冲区中的批次数据。将当前的批次放置在队列的结尾，将队列的第一个移除，保证队列中缓冲的数据最多5个。<br><img src="/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240428172234387.png" alt="image-20240428172234387"></li>
</ol>
<p>从上面的流程可以看出，Kafka的幂等性是通过消耗时间和性能的方式保证了数据传输的有序和去重，在一些对数据敏感的业务中是十分重要的。但是通过原理，咱们也能明白，这种幂等性还是有缺陷的：</p>
<ul>
<li>幂等性的producer仅做到<code>单分区上的幂等性</code>，即单分区消息有序不重复，多分区无法保证幂等性。</li>
<li>只能保持生产者<code>单个会话的幂等性，无法实现跨会话的幂等性</code>，也就是说如果一个producer挂掉再重启，那么重启前和重启后的producer对象会被当成两个独立的生产者，从而获取两个不同的独立的producerid，导致Broker端无法获取之前的状态信息，所以无法实现跨会话的幂等。要想解决这个问题，可以采用后续的事务功能。</li>
</ul>
<h5 id="2-4-6-4-数据事务"><a href="#2-4-6-4-数据事务" class="headerlink" title="2.4.6.4 数据事务"></a>2.4.6.4 数据事务</h5><p>对于幂等性的缺陷，Kafka可以采用事务的方式解决跨会话的幂等性。基本的原理就是通过事务功能管理生产者ID，保证事务开启后，生产者对象总能获取一致的生产者ID。</p>
<p>为了实现事务，Kafka引入了事务协调器（<code>TransactionCoodinator</code>）负责事务的处理，所有的事务逻辑包括分派生产者ID等都是由TransactionCoodinator负责实施的。TransactionCoodinator会将事务状态持久化到该主题中。</p>
<p>事务基本的实现思路就是通过配置的事务ID，将生产者ID进行绑定，然后存储在Kafka专门管理事务的内部主题<code>__transaction_state</code>中，而内部主题的操作是由事务协调器（TransactionCoodinator）对象完成的，这个协调器对象有点类似于咱们数据发送时的那个副本Leader。其实这种设计是很巧妙的，因为Kafka将事务ID和生产者ID看成了消息数据，然后将数据发送到一个内部主题中。这样，使用事务处理的流程和咱们自己发送数据的流程是很像的。接下来，我们就把这两个流程简单做一个对比。</p>
<p><strong>普通数据发送流程</strong></p>
<img src="/imgs/Kafka技术探索/image-20240428195526286.png" alt="image-20240428195526286" style="zoom:150%;" />

<p><strong>事务数据发送流程</strong></p>
<img src="/imgs/Kafka技术探索/image-20240428195615914.png" alt="image-20240428195615914" style="zoom:150%;" />

<p>通过两张图大家可以看到，基本的事务操作和数据操作是很像的，不过要注意，我们这里只是简单对比了数据发送的过程，其实它们的区别还在于数据发送后的提交过程。普通的数据操作，只要数据写入了日志，那么对于消费者来讲。数据就可以读取到了，但是事务操作中，如果数据写入了日志，但是没有提交的话，其实数据默认情况下也是不能被消费者看到的。只有提交后才能看见数据。</p>
<p><strong>事务提交流程</strong></p>
<p>Kafka中的事务是分布式事务，所以采用的也是<code>二阶段提交</code>:</p>
<p>第一个阶段提交事务协调器会告诉生产者事务已经提交了，所以也称之<code>预提交</code>操作，事务协调器会修改事务为<code>预提交状态</code>:</p>
<img src="/imgs/Kafka技术探索/image-20240428195924781.png" alt="image-20240428195924781" style="zoom:150%;" />

<p>第二个阶段提交事务协调器会向分区Leader节点中发送数据标记，通知Broker事务已经提交，然后事务协调器会修改事务为<code>完成提交状态</code>:</p>
<img src="/imgs/Kafka技术探索/image-20240428200052256.png" alt="image-20240428200052256" style="zoom:150%;" />

<p>特殊情况下，事务已经提交成功，但还是读取不到数据，那是因为当前提交成功只是一阶段提交成功，事务协调器会继续向各个Partition发送marker信息，此操作会无限重试，直至成功。但是不同的Broker可能无法全部同时接收到marker信息，此时有的Broker上的数据还是无法访问，这也是正常的，因为kafka的事务不能保证强一致性，只能保证最终数据的一致性，无法保证中间的数据是一致的。不过对于常规的场景这里已经够用了，事务协调器会不遗余力的重试，直至成功。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">KafkaProducerTransactionTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 配置连接信息和序列化器</span></span><br><span class="line">        Map&lt;String, Object&gt; configs = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        configs.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, <span class="string">&quot;localhost:9092&quot;</span>);</span><br><span class="line">        configs.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, StringSerializer.class.getName());</span><br><span class="line">        configs.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, StringSerializer.class.getName());</span><br><span class="line">        configs.put(ProducerConfig.ACKS_CONFIG, <span class="string">&quot;-1&quot;</span>);</span><br><span class="line">        <span class="comment">// 开启幂等性需要满足以下条件：</span></span><br><span class="line">        <span class="comment">// 1. 生产者的acks配置为all(-1)</span></span><br><span class="line">        <span class="comment">// 2. 生产者的max.in.flight.requests.per.connections配置小于等于5</span></span><br><span class="line">        <span class="comment">// 3. 生产者的retries配置大于0</span></span><br><span class="line">        configs.put(ProducerConfig.ENABLE_IDEMPOTENCE_CONFIG, <span class="literal">true</span>);</span><br><span class="line">        configs.put(ProducerConfig.RETRIES_CONFIG, <span class="number">3</span>);</span><br><span class="line">        configs.put(ProducerConfig.REQUEST_TIMEOUT_MS_CONFIG, <span class="number">3000</span>);</span><br><span class="line">        <span class="comment">// 配置事务，注意事务只能保证单个分区的幂等性和跨会话的幂等性</span></span><br><span class="line">        configs.put(ProducerConfig.TRANSACTIONAL_ID_CONFIG, <span class="string">&quot;transactional-id&quot;</span>);</span><br><span class="line">        <span class="comment">// 创建生产者对象</span></span><br><span class="line">        KafkaProducer&lt;String, String&gt; kafkaProducer = <span class="keyword">new</span> <span class="title class_">KafkaProducer</span>&lt;&gt;(configs);</span><br><span class="line">        <span class="comment">// 初始化事务</span></span><br><span class="line">        kafkaProducer.initTransactions();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 开启事务</span></span><br><span class="line">            kafkaProducer.beginTransaction();</span><br><span class="line">            <span class="comment">// 发送消息 这里只是发送10条消息，实际业务场景可能会有更多的消息</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="comment">// 创建消息对象</span></span><br><span class="line">                ProducerRecord&lt;String, String&gt; record = <span class="keyword">new</span> <span class="title class_">ProducerRecord</span>&lt;&gt;(<span class="string">&quot;test&quot;</span>, <span class="string">&quot;key&quot;</span> + i, <span class="string">&quot;value&quot;</span> + i);</span><br><span class="line">                <span class="comment">// 发送消息</span></span><br><span class="line">                kafkaProducer.send(record);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 提交事务</span></span><br><span class="line">            kafkaProducer.commitTransaction();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// 回滚事务</span></span><br><span class="line">            kafkaProducer.abortTransaction();</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 关闭生产者对象</span></span><br><span class="line">            kafkaProducer.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-4-6-5-数据传输语义"><a href="#2-4-6-5-数据传输语义" class="headerlink" title="2.4.6.5 数据传输语义"></a>2.4.6.5 数据传输语义</h5><table>
<thead>
<tr>
<th>传输语义</th>
<th>说明</th>
<th>例子</th>
</tr>
</thead>
<tbody><tr>
<td>at most once</td>
<td>最多一次：不管是否能接收到，数据最多只传一次。这样数据可能会丢失，</td>
<td>ACK&#x3D;0</td>
</tr>
<tr>
<td>at least once</td>
<td>最少一次：消息不会丢失，如果接收不到，那么就继续发，所以会发送多次，直到收到为止，有可能出现数据重复</td>
<td>ACK&#x3D;1</td>
</tr>
<tr>
<td>Exactly once</td>
<td>精准一次：消息只会一次，不会丢，也不会重复。</td>
<td>幂等+事务+ACK&#x3D;-1</td>
</tr>
</tbody></table>
<h3 id="2-5-存储消息"><a href="#2-5-存储消息" class="headerlink" title="2.5 存储消息"></a>2.5 存储消息</h3><p>数据已经由生产者Producer发送给Kafka集群，当Kafka接收到数据后，会将数据写入本地文件中。</p>
<img src="/imgs/Kafka技术探索/image-20240428200808205.png" alt="image-20240428200808205" style="zoom:150%;" />

<h4 id="2-5-1-存储组件"><a href="#2-5-1-存储组件" class="headerlink" title="2.5.1 存储组件"></a>2.5.1 存储组件</h4><ul>
<li><p><code>KafkaApis</code> : Kafka应用接口组件，当Kafka Producer向Kafka Broker发送数据请求后，Kafka Broker接收请求，会使用Apis组件进行请求类型的判断，然后选择相应的方法进行处理。</p>
</li>
<li><p><code>ReplicaManager</code> : 副本管理器组件，用于提供主题副本的相关功能，在数据的存储前进行ACK校验和事务检查，并提供数据请求的响应处理。</p>
</li>
<li><p><code>Partition</code> : 分区对象，主要包含分区状态变换的监控，分区上下线的处理等功能，在数据存储是主要用于对分区副本数量的相关校验，并提供追加数据的功能。</p>
</li>
<li><p>UnifiedLog : 同一日志管理组件，用于管理数据日志文件的新增，删除等功能，并提供数据日志文件偏移量的相关处理。</p>
</li>
<li><p>LocalLog : 本地日志组件，管理整个分区副本的数据日志文件。假设当前主题分区中有3个日志文件，那么3个文件都会在组件中进行管理和操作。</p>
</li>
<li><p>LogSegment : 文件段组件，对应具体的某一个数据日志文件，假设当前主题分区中有3个日志文件，那么3个文件每一个都会对应一个LogSegment组件，并打开文件的数据管道FileChannel。数据存储时，就是采用组件中的FileChannel实现日志数据的追加。</p>
</li>
<li><p>LogConfig: 日志配置对象，常用的数据存储配置。</p>
</li>
</ul>
<h4 id="2-5-2-数据存储"><a href="#2-5-2-数据存储" class="headerlink" title="2.5.2 数据存储"></a>2.5.2 数据存储</h4><p>Kafka Broker节点从获取到生产者的数据请求到数据存储到文件的过程相对比较简单，只是中间会进行一些基本的数据检查和校验。所以接下来我们就将数据存储的基本流程介绍一下：</p>
<h5 id="2-5-2-1-ACKS校验"><a href="#2-5-2-1-ACKS校验" class="headerlink" title="2.5.2.1 ACKS校验"></a>2.5.2.1 ACKS校验</h5><p>Producer将数据发送给Kafka Broker时，会告知Broker当前生产者的数据生产场景，从而要求Kafka对数据请求进行应答响应确认数据的接收情况，Producer获取应答后可以进行后续的处理。</p>
<ul>
<li><code>ACKS=0</code>: Producer端将数据发送到网络输出流缓冲区中，此时Kafka就会进行响应。在这个场景中，数据的应答是非常快的，但是因为仅仅将数据发送到网络输出流缓冲区中，所以是无法保证Kafka Broker节点能够接收到消息，假设此时网络出现抖动不稳定导致数据丢失，而由于Kafka已经做出了确认收到的应答，所以此时Producer端就不会再次发送数据，而导致数据真正地丢失了。所以此种场景，数据的发送是不可靠的。</li>
<li><code>ACKS=1</code>：Producer端将数据发送到Broker中，并保存到当前节点的数据日志文件中，Kafka就会进行确认收到数据的响应。因为数据已经保存到了文件中，也就是进行了持久化，那么相对于ACKS&#x3D;0，数据就更加可靠。但是也要注意，因为Kafka是分布式的，所以集群的运行和管理是非常复杂的，难免当前Broker节点出现问题而宕掉，那么此时，消费者就消费不到我们存储的数据了，此时，数据我们还是会认为丢失了。</li>
<li><code>ACKS=-1</code>：Kafka在管理分区时，会了数据的可靠性和更高的吞吐量，提供了多个副本，而多个副本之间，会选出一个副本作为数据的读写副本，称之为Leader副本，而其他副本称之Follower副本。普通场景中，所有的这些节点都是需要保存数据的。而Kafka会优先将Leader副本的数据进行保存，保存成功后，再由Follower副本向Leader副本拉取数据，进行数据同步。一旦所有的这些副本数据同步完毕后，Kafka再对Producer进行收到数据的确认。此时ACKS应答就是-1（all）。明显此种场景，多个副本本地文件都保存了数据，那么数据就更加可靠，但是相对，应答时间更长，导致Kafka吞吐量降低。</li>
</ul>
<p>基于上面的三种生产数据的场景，在存储数据前，需要校验生产者需要的应答场景是否合法有效。</p>
<h5 id="2-5-2-2-内部主题校验"><a href="#2-5-2-2-内部主题校验" class="headerlink" title="2.5.2.2 内部主题校验"></a>2.5.2.2 内部主题校验</h5><p>Producer向Kafka Broker发送数据时，是必须指定主题Topic的，但是这个主题的名称不能是Kafka的内部主题名称。Kafka为了管理的需要，创建了2个内部主题，一个是用于事务处理的<code>transaction_state</code>内部主题，还有一个是用于处理消费者偏移量的<code>consumer_offsets</code>内部主题。<strong>生产者是无法对这两个主题生产数据的，所以在存储数据之前，需要对主题名称进行校验有效性校验。</strong></p>
<h5 id="2-5-2-3-ACKS应答及副本数量关系校验"><a href="#2-5-2-3-ACKS应答及副本数量关系校验" class="headerlink" title="2.5.2.3 ACKS应答及副本数量关系校验"></a>2.5.2.3 ACKS应答及副本数量关系校验</h5><p>Kafka为了数据可靠性更高一些，需要分区的所有副本都能够存储数据，但是分布式环境中难免会出现某个副本节点出现故障，暂时不能同步数据。在Kafka中，能够进行数据同步的所有副本，我们称之为<code>In-Sync-Replicas</code>，简称ISR列表。</p>
<p>当生产者Producer要求的数据ACKS应答为-1的时候，那么就必须保证能够同步数据的所有副本能够将数据保存成功后，再进行数据的确认应答。<strong>但是一种特殊情况就是，如果当前ISR列表中只有一个Broker存在，那么此时只要这一个Broker数据保存成功了，那么就产生确认应答了，数据依然是不可靠的，那么就失去了设置ACK&#x3D;all的意义了，所以此时还需要对ISR列表中的副本数量进行约束，至少不能少于2个</strong>。这个数量是可以通过配置文件配置的。参数名为：<code>min.insync.replicas</code>。默认值为1（不推荐），所以存储数据前，也需要对ACK应答和最小分区副本数量的关系进行校验。</p>
<h5 id="2-5-2-4-日志文件滚动判断"><a href="#2-5-2-4-日志文件滚动判断" class="headerlink" title="2.5.2.4 日志文件滚动判断"></a>2.5.2.4 日志文件滚动判断</h5><p>数据存储到文件中，如果数据文件太大，对于查询性能是会有很大影响的，所以副本数据文件并不是一个完整的大的数据文件，而是根据某些条件分成很多的小文件，每个小文件我们称之为<code>文件段</code>。其中的一个条件就是文件大小，参数名为：<code>log.segment.bytes</code>。默认值为1G。如果当前日志段剩余容量可能无法容纳新消息集合，因此有必要创建一个新的日志段来保存待写入的所有消息。此时日志文件就需要滚动生产新的。</p>
<p>除了文件大小外，还有时间间隔，如果文件段第一批数据有时间戳，那么当前批次数据的时间戳和第一批数据的时间戳间隔大于滚动阈值，那么日志文件也会滚动生产新的。如果文件段第一批数据没有时间戳，那么就用当前时间戳和文件创建时间戳进行比对，如果大于滚动阈值，那么日志文件也会滚动生产新的。这个阈值参数名为：<code>log.roll.hours</code>，默认为7天。如果时间到达，但是文件不满1G，依然会滚动生产新的数据文件。</p>
<p>如果<code>索引文件或时间索引文件满了</code>，或者索引文件无法存放当前索引数据了，那么日志文件也会滚动生产新的。</p>
<p>基于以上的原则，需要在保存数据前进行判断。</p>
<h5 id="2-5-2-5-请求数据重复性校验"><a href="#2-5-2-5-请求数据重复性校验" class="headerlink" title="2.5.2.5 请求数据重复性校验"></a>2.5.2.5 请求数据重复性校验</h5><p>因为Kafka允许生产者进行数据重试操作，所以因为一些特殊的情况，就会导致数据请求被Kafka重复获取导致<code>数据重复</code>，所以为了数据的幂等性操作，需要在Broker端对数据进行重复性校验。这里的重复性校验只能对<code>同一个主题分区的5个在途请求</code>中数据进行校验，所以需要在生产者端进行相关配置。</p>
<h5 id="2-5-2-6-请求数据序列号校验"><a href="#2-5-2-6-请求数据序列号校验" class="headerlink" title="2.5.2.6 请求数据序列号校验"></a>2.5.2.6 请求数据序列号校验</h5><p>因为Kafka允许生产者进行数据重试操作，所以因为一些特殊的情况，就会导致数据请求被Kafka重复获取导致数据顺序发生改变从而引起<code>数据乱序</code>。为了防止数据乱序，需要在Broker端对数据的序列号进行连续性（<code>插入数据序列号和Broker分区缓冲的最后一个数据的序列号差值为1</code>）校验。</p>
<h5 id="2-5-2-7-数据存储"><a href="#2-5-2-7-数据存储" class="headerlink" title="2.5.2.7 数据存储"></a>2.5.2.7 数据存储</h5><p>将数据通过<code>LogSegment</code>中<code>FileChannel</code>对象。将数据写入日志文件，写入完成后，更新当前日志文件的数据偏移量。</p>
<h4 id="2-5-3-存储文件格式"><a href="#2-5-3-存储文件格式" class="headerlink" title="2.5.3 存储文件格式"></a>2.5.3 存储文件格式</h4><p>我们已经将数据存储到了日志文件中，当然除了日志文件还有其他的一些文件，所以接下来我们就了解一下这些文件：</p>
<h5 id="2-5-3-1-数据日志文件"><a href="#2-5-3-1-数据日志文件" class="headerlink" title="2.5.3.1 数据日志文件"></a>2.5.3.1 数据日志文件</h5><p>Kafka系统早期设计的目的就是日志数据的采集和传输，所以数据是使用log文件进行保存的。我们所说的数据文件就是以<code>.log</code>作为扩展名的日志文件。文件名长度为<code>20位长度</code>的数字字符串，数字含义为当前日志文件的第一批数据的基础偏移量，也就是文件中保存的<code>第一条数据偏移量</code>。字符串数字位数不够的，前面补0。</p>
<p><img src="/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240428204630492.png" alt="image-20240428204630492"></p>
<p>我们的常规数据主要分为两部分：批次头 + 数据体</p>
<p><img src="/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240428205810058.png" alt="image-20240428205810058"></p>
<p><img src="/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240428205846182.png" alt="image-20240428205846182"></p>
<p>如果我们发送的数据是一条为（key1，value1）的数据，那么Kafka当前会向日志文件增加的数据大小为：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">追加数据字节计算</span></span><br><span class="line">批次头 = 61</span><br><span class="line">数据体 = 1 + 1 + 1 + 4 + 1 + 6 + 1 + 1 + 1 = 17</span><br><span class="line">总的字节大小为61 + 17 = 78</span><br></pre></td></tr></table></figure>

<p><img src="/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240428205139613.png" alt="image-20240428205139613"></p>
<p>如果我们发送的数据是两条为（key1，value1），（key2，value2）的数据，那么Kafka当前会向日志文件增加的数据大小为：</p>
<p><img src="/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240428210529334.png" alt="image-20240428210529334"></p>
<p><img src="/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240428210615311.png" alt="image-20240428210615311"></p>
<h5 id="2-5-3-2-数据索引文件"><a href="#2-5-3-2-数据索引文件" class="headerlink" title="2.5.3.2 数据索引文件"></a>2.5.3.2 数据索引文件</h5><p>Kafka的基础设置中，数据日志文件到达1G才会滚动生产新的文件。那么从1G文件中想要快速获取我们想要的数据，效率还是比较低的。通过前面的介绍，如果我们能知道数据在文件中的位置（<code>position</code>），那么定位数据就会快很多，问题在于我们如何才能在知道这个位置呢。</p>
<p>Kafka在存储数据时，都会保存数据的偏移量信息，而偏移量是从0开始计算的。简单理解就是数据的保存顺序。比如第一条保存的数据，那么偏移量就是0，第二条保存的数据偏移量就是1，但是这个偏移量只是告诉我们数据的保存顺序，却无法定位数据，不过需要注意的是，每条数据的大小是可以确定的（参考上一个小节的内容）。既然可以确定，那么数据存放在文件的位置起始也就是确定了，所以Kafka在保存数据时，其实是可以同时保存位置的，那么我们在访问数据时，只要通过偏移量其实就可以快速定位日志文件的数据了。</p>
<p><img src="/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240428211248196.png" alt="image-20240428211248196"></p>
<p>不过这依然有问题，就是数据量太多了，对应的偏移量也太多了，并且主题分区的数据文件会有很多，那我们是如何知道数据在哪一个文件中呢？为了定位方便Kafka在提供日志文件保存数据的同时，还提供了用于数据定位的索引文件，<code>索引文件中保存的就是逻辑偏移量和数据物理存储位置（偏移量）的对应关系</code>。并且还记得吗，<code>每个数据日志文件的名称就是当前文件中数据起始偏移量</code>，所以通过偏移量就可以快速选取文件以及定位数据的位置从而快速找到数据。这种感觉就有点像Java的HashMap通过Key可以快速找到Value的感觉一样，如果不知道Key，那么从HashMap中获取Value是不是就特别慢。道理是一样的。</p>
<p>Kafka的数据索引文件都保存了什么呢？咱们来看一下：</p>
<p><img src="/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240428211602096.png" alt="image-20240428211602096"></p>
<p>通过图片可以看到，索引文件中保存的就是<code>逻辑偏移量和物理偏移量位置</code>的关系。有了这个索引文件，那么我们根据数据的顺序获取数据就非常的方便和高效了，Kafka在查询定位时其实采用的就是<code>二分查找法</code>。</p>
<p>不过，为什么Kafka的索引文件是不连续的呢，那是因为如果每条数据如果把偏移量定位都保存下来，数据量也不小，还有就是如果索引数据丢了几条，其实并不会太影响查询效率，因为Kafka底层实现时，采用的是<code>虚拟内存映射技术mmap</code>，将内存和index文件进行双向映射，操作内存数据就等同于操作文件，所以效率是非常高的，而且为了效率，Kafka默认情况下，4KB的日志数据才会记录一次索引，但是这个是可以进行配置修改的，参数为<code>log.index.interval.bytes</code>，默认值为<code>4096</code>。所以我们有的时候会将Kafka的不连续索引数据称之为<code>稀疏索引</code>。</p>
<h5 id="2-5-3-3-数据时间戳索引文件"><a href="#2-5-3-3-数据时间戳索引文件" class="headerlink" title="2.5.3.3 数据时间戳索引文件"></a>2.5.3.3 数据时间戳索引文件</h5><p>某些场景中，我们不想根据顺序（偏移量）获取Kafka的数据，而是想根据时间戳来获取的数据。这个时候，可没有对应的偏移量来定位数据，那么查找的效率就非常低了，因此Kafka还提供了时间索引文件，咱们来看看它的内容是什么:</p>
<p><img src="/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240428212545858.png" alt="image-20240428212545858"></p>
<p>通过图片，大家可以看到，这个时间索引文件起始就是将<code>时间戳和偏移量</code>对应起来了，那么此时通过时间戳就可以找到偏移量，再通过偏移量找到文件位置信息，再通过文件位置信息找到数据不就非常方便了吗。</p>
<h4 id="2-5-4-数据刷写"><a href="#2-5-4-数据刷写" class="headerlink" title="2.5.4 数据刷写"></a>2.5.4 数据刷写</h4><p>在Linux系统中，当我们把数据写入文件系统之后，其实数据在操作系统的PageCache（页缓冲）里面，并没有刷到磁盘上。如果操作系统挂了，数据就丢失了。一方面，应用程序可以调用fsync这个系统调用来强制刷盘，另一方面，操作系统有后台线程定时刷盘。频繁调用fsync会影响性能，需要在性能和可靠性之间进行权衡。实际上，Kafka提供了参数进行数据的刷写：</p>
<ul>
<li><code>log.flush.interval.messages</code> ：达到消息数量时，会将数据flush到日志文件中。</li>
<li><code>log.flush.interval.ms</code> ：间隔多少时间(ms)，执行一次强制的flush操作。</li>
<li><code>flush.scheduler.interval.ms</code>：所有日志刷新到磁盘的频率</li>
</ul>
<p>log.flush.interval.messages和log.flush.interval.ms无论哪个达到，都会flush。官方不建议通过上述的三个参数来强制写盘，<code>数据的可靠性应该通过replica来保证，而强制flush数据到磁盘会对整体性能产生影响</code>。</p>
<h4 id="2-5-5-副本同步"><a href="#2-5-5-副本同步" class="headerlink" title="2.5.5 副本同步"></a>2.5.5 副本同步</h4><p>Kafka中，分区的某个副本会被指定为Leader，负责响应客户端的读写请求。分区中的其他副本自动成为Follower，主动拉取（同步）Leader副本中的数据，写入自己本地日志，确保所有副本上的数据是一致的。</p>
<img src="/imgs/Kafka技术探索/image-20240428213137350.png" alt="image-20240428213137350" style="zoom:150%;" />

<h5 id="2-5-5-1-启动数据同步线程"><a href="#2-5-5-1-启动数据同步线程" class="headerlink" title="2.5.5.1 启动数据同步线程"></a>2.5.5.1 启动数据同步线程</h5><p>Kafka创建主题时，会根据副本分配策略向指定的Broker节点发出请求，将不同的副本节点设定为Leader或Follower。一旦某一个Broker节点设定为Follower节点，那么Follower节点会启动数据同步线程<code>ReplicaFetcherThread</code>，从Leader副本节点同步数据。线程运行后，会不断重复两个操作：截断（truncate）和抓取（fetch）。</p>
<ul>
<li><code>截断</code>：为了保证分区副本的数据一致性，当分区存在Leader Epoch值时，会将副本的本地日志截断到Leader Epoch对应的最新位移处。如果分区不存在对应的Leader Epoch记录，那么依然使用原来的高水位机制，将日志调整到<code>高水位</code>值处。</li>
<li><code>抓取</code>：向Leader同步最新的数据。</li>
</ul>
<h5 id="2-5-5-2-生成数据同步请求"><a href="#2-5-5-2-生成数据同步请求" class="headerlink" title="2.5.5.2 生成数据同步请求"></a>2.5.5.2 生成数据同步请求</h5><p>启动线程后，需要周期地向Leader节点发送<code>FETCH请求</code>，用于从Leader获取数据。等待Leader节点的响应的过程中，会阻塞当前同步数据线程。</p>
<h5 id="2-5-5-3-处理数据响应"><a href="#2-5-5-3-处理数据响应" class="headerlink" title="2.5.5.3 处理数据响应"></a>2.5.5.3 处理数据响应</h5><p>当Leader副本返回响应数据时，其中会包含多个分区数据，当前副本会遍历每一个分区，将分区数据写入数据文件中。</p>
<p><img src="/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240428214051211.png" alt="image-20240428214051211"></p>
<h5 id="2-5-5-4-更新数据偏移量"><a href="#2-5-5-4-更新数据偏移量" class="headerlink" title="2.5.5.4 更新数据偏移量"></a>2.5.5.4 更新数据偏移量</h5><p>当Leader副本返回响应数据时，除了包含多个分区数据外，还包含了和偏移量相关的数据HW和LSO，副本需要根据场景对Leader返回的不同偏移量进行更新。</p>
<ul>
<li><code>Offset</code>:Kafka的每个分区的数据都是有序的，所谓的数据偏移量，指的就是Kafka在保存数据时，用于快速定位数据的标识，类似于Java中数组的索引，从0开始。Kafka的数据文件以及数据访问中包含了大量和偏移量的相关的操作。</li>
<li><code>LSO</code>:起始偏移量（Log Start Offset），每个分区副本都有起始偏移量，用于表示<code>副本数据的起始偏移位置</code>，初始值为0。LSO一般情况下是无需更新的，但是如果数据过期，或用户手动删除数据时，Leader的Log Start Offset可能发生变化，Follower副本的日志需要和Leader保持严格的一致，因此，如果Leader的该值发生变化，Follower自然也要发生变化保持一致。</li>
<li><code>LEO</code>:日志末端位移（Log End Offset），表示<code>下一条待写入消息的offset</code>，每个分区副本都会记录自己的LEO。对于Follower副本而言，它能读取到Leader副本LEO值以下的所有消息。</li>
<li><code>HW</code>:高水位值（High Watermark），定义了<code>消息可见性</code>，标识了一个特定的消息偏移量（offset），消费者只能拉取到这个水位offset之前的消息，同时这个偏移量还可以帮助Kafka完成副本数据同步操作。</li>
</ul>
<h4 id="2-5-6-数据一致性"><a href="#2-5-6-数据一致性" class="headerlink" title="2.5.6 数据一致性"></a>2.5.6 数据一致性</h4><h5 id="2-5-6-1-数据一致性表现"><a href="#2-5-6-1-数据一致性表现" class="headerlink" title="2.5.6.1 数据一致性表现"></a>2.5.6.1 数据一致性表现</h5><p>Kafka的设计目标是：高吞吐、高并发、高性能。为了做到以上三点，它必须设计成分布式的，多台机器可以同时提供读写，并且需要为数据的存储做冗余备份。</p>
<img src="/imgs/Kafka技术探索/image-20240428214612711.png" alt="image-20240428214612711" style="zoom:150%;" />

<p>图中的主题有3个分区，每个分区有3个副本，这样<code>数据可以冗余存储，提高了数据的可用性</code>。并且3个副本有两种角色，Leader和Follower，Follower副本会同步Leader副本的数据。一旦Leader副本挂了，Follower副本可以选举成为新的Leader副本，这样就提升了分区可用性，但是相对的，在提升了分区可用性的同时，也就牺牲了数据的一致性。</p>
<p>我们来看这样的一个场景：一个分区有3个副本，一个Leader和两个Follower。Leader副本作为数据的读写副本，所以生产者的数据都会发送给Leader副本，而两个Follower副本会周期性地同步Leader副本的数据，但是因为网络，资源等因素的制约，同步数据的过程是有一定延迟的，所以3个副本之间的数据可能是不同的。具体如下图所示：</p>
<img src="/imgs/Kafka技术探索/image-20240428214755561.png" alt="image-20240428214755561" style="zoom:150%;" />

<p>此时，假设Leader副本因为意外原因宕掉了，那么Kafka为了提高分区可用性，此时会选择2个Follower副本中的一个作为Leader对外提供数据服务。此时我们就会发现，对于消费者而言，之前Leader副本能访问的数据是D，但是重新选择Leader副本后，能访问的数据就变成了C，这样消费者就会认为数据丢失了，也就是所谓的数据不一致了。</p>
<img src="/imgs/Kafka技术探索/image-20240428214843094.png" alt="image-20240428214843094" style="zoom:150%;" />

<p>为了提升数据的一致性，Kafka引入了<code>高水位（HW ：High Watermark）机制</code>，Kafka在不同的副本之间维护了一个水位线的机制（其实也是一个偏移量的概念），<code>消费者只能读取到水位线以下的的数据</code>。这就是所谓的木桶理论：木桶中容纳水的高度，只能是水桶中最短的那块木板的高度。这里将整个分区看成一个木桶，其中的数据看成水，而每一个副本就是木桶上的一块木板，那么这个分区（木桶）可以被消费者消费的数据（容纳的水）其实就是数据最少的那个副本的最后数据位置（木板高度）。</p>
<p>也就是说，消费者一开始在消费Leader的时候，虽然Leader副本中已经有a、b、c、d 4条数据，但是由于高水位线的限制，所以也只能消费到a、b这两条数据。</p>
<img src="/imgs/Kafka技术探索/image-20240428214957062.png" alt="image-20240428214957062" style="zoom:150%;" />

<p>这样即使Leader挂掉了，但是对于消费者来讲，消费到的数据其实还是一样的，因为它能看到的数据是一样的，也就是说，消费者不会认为数据不一致。</p>
<img src="/imgs/Kafka技术探索/image-20240428215023891.png" alt="image-20240428215023891" style="zoom:150%;" />

<h5 id="2-5-6-2-HW在副本之间的传递"><a href="#2-5-6-2-HW在副本之间的传递" class="headerlink" title="2.5.6.2 HW在副本之间的传递"></a>2.5.6.2 HW在副本之间的传递</h5><p>HW高水位线会随着Follower的数据同步操作，而不断上涨，也就是说，Follower同步的数据越多，那么水位线也就越高，那么消费者能访问的数据也就越多。接下来，我们就看一看，Follower在同步数据时HW的变化。</p>
<p>首先，初始状态下，Leader和Follower都没有数据，所以和偏移量相关的值都是初始值0，而由于Leader需要管理Follower，所以也包含着Follower的相关偏移量（LEO）数据。</p>
<img src="/imgs/Kafka技术探索/image-20240428215219716.png" alt="image-20240428215219716" style="zoom:150%;" />

<p>生产者向Leader发送两条数据，Leader收到数据后，会更新自身的偏移量信息。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Leader副本偏移量更新：</span><br><span class="line">LEO=LEO+2=2</span><br></pre></td></tr></table></figure>

<img src="/imgs/Kafka技术探索/image-20240428215306657.png" alt="image-20240428215306657" style="zoom:150%;" />

<p>接下来，Follower开始同步Leader的数据，同步数据时，会将自身的LEO值作为参数传递给Leader。此时，Leader会将数据传递给Follower，且同时Leader会根据所有副本的LEO值更新HW。</p>
<p><img src="/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240428215349451.png" alt="image-20240428215349451"></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Leader副本偏移量更新：</span><br><span class="line">HW = Math.max[HW, min(LeaderLEO，F1-LEO，F2-LEO)]=0</span><br></pre></td></tr></table></figure>

<img src="/imgs/Kafka技术探索/image-20240428215433214.png" alt="image-20240428215433214" style="zoom:150%;" />

<p>由于两个Follower的数据拉取速率不一致，所以Follower-1抓取了2条数据，而Follower-2抓取了1条数据。Follower再收到数据后，会将数据写入文件，并更新自身的偏移量信息。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Follower-1副本偏移量更新：</span><br><span class="line">LEO=LEO+2=2</span><br><span class="line">HW = Math.min[LeaderHW, LEO]=0</span><br><span class="line">Follower-2副本偏移量更新：</span><br><span class="line">LEO=LEO+1=1</span><br><span class="line">HW = Math.min[LeaderHW, LEO]=0</span><br></pre></td></tr></table></figure>

<img src="/imgs/Kafka技术探索/image-20240428215607287.png" alt="image-20240428215607287" style="zoom:150%;" />

<p>接下来Leader收到了生产者的数据C，那么此时会根据相同的方式更新自身的偏移量信息:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Leader副本偏移量更新：</span><br><span class="line">LEO=LEO+1=3</span><br></pre></td></tr></table></figure>

<img src="/imgs/Kafka技术探索/image-20240428215644699.png" alt="image-20240428215644699" style="zoom:150%;" />

<p>Follower接着向Leader发送Fetch请求，同样会将最新的LEO作为参数传递给Leader。Leader收到请求后，会更新自身的偏移量信息。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Leader副本偏移量更新：</span><br><span class="line">HW = Math.max[HW, min(LeaderLEO，F1-LEO，F2-LEO)]=1</span><br></pre></td></tr></table></figure>

<img src="/imgs/Kafka技术探索/image-20240428215743927.png" alt="image-20240428215743927" style="zoom:150%;" />

<p>此时，Leader会将数据发送给Follower，同时也会将HW一起发送。</p>
<img src="/imgs/Kafka技术探索/image-20240428215809592.png" alt="image-20240428215809592" style="zoom:150%;" />

<p>Follower收到数据后，会将数据写入文件，并更新自身偏移量信息:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Follower-1副本偏移量更新：</span><br><span class="line">LEO=LEO+1=3</span><br><span class="line">HW = Math.min[LeaderHW, LEO]=1</span><br><span class="line">Follower-2副本偏移量更新：</span><br><span class="line">LEO=LEO+1=2</span><br><span class="line">HW = Math.min[LeaderHW, LEO]=1</span><br></pre></td></tr></table></figure>

<img src="/imgs/Kafka技术探索/image-20240428215902766.png" alt="image-20240428215902766" style="zoom:150%;" />

<p>因为Follower会不断重复Fetch数据的过程，所以前面的操作会不断地重复。最终，Follower副本和Leader副本的数据和偏移量是保持一致的。</p>
<img src="/imgs/Kafka技术探索/image-20240428215925337.png" alt="image-20240428215925337" style="zoom:150%;" />

<p>上面演示了副本列表ISR中Follower副本和Leader副本之间HW偏移量的变化过程，但特殊情况是例外的。<strong>比如当前副本列表ISR中，只剩下了Leader一个副本的场合下，是不需要等待其他副本的，直接推高HW即可。</strong></p>
<h5 id="2-5-6-3-ISR（In-Sync-Replicas）伸缩"><a href="#2-5-6-3-ISR（In-Sync-Replicas）伸缩" class="headerlink" title="2.5.6.3 ISR（In-Sync-Replicas）伸缩"></a>2.5.6.3 ISR（In-Sync-Replicas）伸缩</h5><p>Kafka的分区副本中只有Leader副本具有数据写入的功能，而Follower副本需要不断向Leader发出申请，进行数据的同步。这里所有同步的副本会形成一个列表，我们称之为同步副本列表也可以简称ISR，除了ISR以外，还有已分配的副本列表（Assigned Replicas），简称AR。这里的AR其实不仅仅包含ISR，还包含了没有同步的副本列表（Out-of-Sync Replicas），简称OSR。</p>
<p>生产者Producer生产数据时，ACKS应答机制如果设置为all（-1），那此时就需要保证同步副本列表ISR中的所有副本全部接收完毕后，Kafka才会进行确认应答。数据存储时，只有ISR中的所有副本LEO数据都更新了，才有可能推高HW偏移量的值。这就可以看出，ISR在Kafka集群的管理中是非常重要的。</p>
<p>在Broker节点中，有一个副本管理器组件（ReplicaManager），除了读写副本、管理分区和副本的功能之外，还有一个重要的功能，那就是管理ISR。这里的管理主要体现在两个方面：</p>
<ul>
<li><p>周期性地查看ISR中的副本集合是否需要收缩。这里的收缩是指把ISR副本集合中那些与Leader差距过大的副本移除的过程。<br><img src="/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240428220252472.png" alt="image-20240428220252472"></p>
<p>相对的，有收缩就会有扩大，在Follower抓取数据时，判断副本状态，满足扩大ISR条件后，就可以提交分区变更请求。完成ISR列表的变更。</p>
</li>
<li><p>向集群Broker传播ISR的变更。ISR发生变化（包含Shrink和Expand）都会执行传播逻辑。ReplicaManager每间隔2500毫秒就会根据条件，将ISR变化的结果传递给集群的其他Broker。<br><img src="/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240428220408804.png" alt="image-20240428220408804"></p>
</li>
</ul>
<h3 id="2-6-消费消息"><a href="#2-6-消费消息" class="headerlink" title="2.6 消费消息"></a>2.6 消费消息</h3><h4 id="2-6-1-消费消息的基本步骤"><a href="#2-6-1-消费消息的基本步骤" class="headerlink" title="2.6.1 消费消息的基本步骤"></a>2.6.1 消费消息的基本步骤</h4><p>(一)创建Map类型的配置对象，根据场景增加相应的配置属性</p>
<ul>
<li>bootstrap.servers<ul>
<li>用于建立与Kafka集群的初始连接的主机&#x2F;端口对列表</li>
<li>格式：host1:port1,host2:port2,…</li>
</ul>
</li>
<li>key.serializer<ul>
<li>实现<code>org.apache.kafka.common.serialization.Deserializer</code>接口的key的反序列化器的<code>全限定类名</code></li>
</ul>
</li>
<li>value.serializer<ul>
<li>实现<code>org.apache.kafka.common.serialization.Deserializer</code>接口的value的反序列化器的<code>全限定类名</code></li>
</ul>
</li>
<li>group.id<ul>
<li>标识该消费者所属的消费者组的唯一字符串</li>
</ul>
</li>
<li>auto.offset.reset<ul>
<li>当Kafka中没有初始消费者偏移量或者当前消费者偏移量在Broker上不再存在时，该怎么办：<ul>
<li><code>earliest</code>：自动将消费者偏移量重置为最早偏移量</li>
<li><code>latest</code>：自动将消费者偏移量重置为最新偏移量</li>
<li><code>none</code>：如果没有找到消费者组的先前偏移量，则向消费者抛出异常</li>
</ul>
</li>
</ul>
</li>
<li>group.instance.id<ul>
<li>消费者实例ID，如果指定，那么在消费者组中使用此ID作为memberId前缀</li>
</ul>
</li>
<li>partition.assignment.strategy<ul>
<li>默认分配器是[RangeAssignor, CooperativeStickyAssignor]，默认情况下将使用<code>RangeAssignor</code>，但允许升级到 <code>CooperativeStickyAssignor</code>，只需一次ReBlance即可从列表中删除RangeAssignor</li>
</ul>
</li>
<li>enable.auto.commit<ul>
<li>如果为true，消费者的偏移量将在后台定期提交</li>
</ul>
</li>
<li>auto.commit.interval.ms<ul>
<li>如果enable.auto.commit设置为true，则消费者偏移量自动提交到Kafka的频率（以毫秒为单位），默认5000ms</li>
</ul>
</li>
</ul>
<p>(二)创建消费者对象</p>
<p>根据配置创建消费者对象<code>KafkaConsumer</code>，向Kafka订阅（subscribe）主题消息，并向Kafka发送请求（poll）获取数据。</p>
<p>(三)获取数据</p>
<p>Kafka会根据消费者发送的参数，返回数据对象<code>ConsumerRecord</code>。返回的数据对象中包括指定的数据。</p>
<p><img src="/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240428222140144.png" alt="image-20240428222140144"></p>
<h4 id="2-6-2-消费消息的基本代码"><a href="#2-6-2-消费消息的基本代码" class="headerlink" title="2.6.2 消费消息的基本代码"></a>2.6.2 消费消息的基本代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">KafkaConsumerTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 配置连接信息和反序列化器</span></span><br><span class="line">        Map&lt;String, Object&gt; configs = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        configs.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, <span class="string">&quot;localhost:9092&quot;</span>);</span><br><span class="line">        configs.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class.getName());</span><br><span class="line">        configs.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class.getName());</span><br><span class="line">        configs.put(ConsumerConfig.GROUP_ID_CONFIG, <span class="string">&quot;groupId&quot;</span>);</span><br><span class="line">        configs.put(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG, <span class="string">&quot;earliest&quot;</span>);</span><br><span class="line">        <span class="comment">// 创建消费者对象</span></span><br><span class="line">        KafkaConsumer&lt;String, String&gt; kafkaConsumer = <span class="keyword">new</span> <span class="title class_">KafkaConsumer</span>&lt;&gt;(configs);</span><br><span class="line">        <span class="comment">// 订阅主题</span></span><br><span class="line">        kafkaConsumer.subscribe(Collections.singletonList(<span class="string">&quot;test&quot;</span>));</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 拉取消息</span></span><br><span class="line">            ConsumerRecords&lt;String, String&gt; records = kafkaConsumer.poll(Duration.ofSeconds(<span class="number">100</span>));</span><br><span class="line">            <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records) &#123;</span><br><span class="line">                System.out.println(record);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-6-3-消费消息的基本原理"><a href="#2-6-3-消费消息的基本原理" class="headerlink" title="2.6.3 消费消息的基本原理"></a>2.6.3 消费消息的基本原理</h4><h5 id="2-6-3-1-消费者组"><a href="#2-6-3-1-消费者组" class="headerlink" title="2.6.3.1 消费者组"></a>2.6.3.1 消费者组</h5><p>Kafka的主题如果就一个分区的话，那么在硬件配置相同的情况下，消费者Consumer消费主题数据的方式没有什么太大的差别。</p>
<p><img src="/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240428222516419.png" alt="image-20240428222516419"></p>
<p>不过，Kafka为了能够构建高吞吐，高可靠性，高并发的分布式消息传输系统，它的主题是允许多个分区的，那么就会发现不同的消费数据的方式区别还是很大的。</p>
<ul>
<li><p>如果数据由Kafka进行<code>推送（push）</code>，那么多个分区的数据同时推送给消费者进行处理，明显一个消费者的消费能力是有限的，那么消费者无法快速处理数据，就会导致数据的积压，从而导致网络，存储等资源造成极大的压力，影响吞吐量和数据传输效率。<br> <img src="/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240428222620257.png" alt="image-20240428222620257"></p>
</li>
<li><p>如果Kafka的分区数据在内部可以存储的时间更长一些，再由消费者根据自己的消费能力向Kafka<code>拉取（poll）</code>数据，那么整个数据处理的通道就会更顺畅一些。Kafka的Consumer就采用的这种拉取数据的方式。</p>
<p><img src="/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240428222716360.png" alt="image-20240428222716360"></p>
</li>
</ul>
<p>消费者可以根据自身的消费能力主动拉取Kafka的数据，但是毕竟自身的消费能力有限，如果主题分区的数据过多，那么消费的时间就会很长。对于Kafka来讲，数据就需要长时间的进行存储，那么对Kafka集群资源的压力就非常大。如果希望提高消费者的消费能力，并且减少Kafka集群的存储资源压力。所以有必要对消费者进行<code>横向伸缩</code>，从而提高消息消费速率。</p>
<img src="/imgs/Kafka技术探索/image-20240428222807751.png" alt="image-20240428222807751" style="zoom:150%;" />

<p>不过这么做有一个问题，就是每一个消费者是独立，那么一个消费者就不能消费主题中的全部数据，简单来讲，就是对于某一个消费者个体来讲，主题中的部分数据是没有消费到的，也就会认为数据丢了，这个该如何解决呢？那如果我们将这多个消费者当成一个整体，是不是就可以了呢？这就是所谓的<code>消费者组Consumer Group</code>。在Kafka中，每个消费者都对应一个消费组，消费者可以是一个线程，一个进程，一个服务实例，如果Kafka想要消费消息，那么需要指定消费哪个Topic的消息以及自己的消费组id(groupId)。</p>
<img src="/imgs/Kafka技术探索/image-20240428223038793.png" alt="image-20240428223038793" style="zoom:150%;" />

<h5 id="2-6-3-2-组调度器GroupCoordinator"><a href="#2-6-3-2-组调度器GroupCoordinator" class="headerlink" title="2.6.3.2 组调度器GroupCoordinator"></a>2.6.3.2 组调度器GroupCoordinator</h5><p>消费者想要拉取数据，首先必须要加入到一个组中，成为消费组中的一员，同样道理，如果消费者出现了问题，也应该从消费者组中剥离。而这种加入组和退出组的处理，都应该由专门的管理组件进行处理，这个组件在Kafka中，我们称之为消费者组调度器（Group Coordinator）</p>
<p>Group Coordinator是Broker上的一个组件，用于管理和调度消费者组的成员、状态、分区分配、偏移量等信息。每个Broker都有一个Group Coordinator对象，负责管理多个消费者组，但每个消费者组只有一个Group Coordinator。</p>
<img src="/imgs/Kafka技术探索/image-20240428223648494.png" alt="image-20240428223648494" style="zoom:150%;" />

<h5 id="2-6-3-3-消费者分配策略Assignor"><a href="#2-6-3-3-消费者分配策略Assignor" class="headerlink" title="2.6.3.3 消费者分配策略Assignor"></a>2.6.3.3 消费者分配策略Assignor</h5><p>消费者想要拉取主题分区的数据，首先必须要加入到一个组中。</p>
<p><img src="/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240428223731697.png" alt="image-20240428223731697"></p>
<p>但是一个组中有多个消费者的话，那么每一个消费者该如何消费呢，是不是像图中一样的消费策略呢？如果是的话，那假设消费者组中只有2个消费者或有4个消费者，和分区的数量不匹配，怎么办？所以这里，我们需要给大家介绍一下，Kafka中基本的消费者组中的消费者和分区之间的分配规则：</p>
<ul>
<li><code>同一个消费者组的消费者都订阅同一个主题</code>，所以消费者组中的多个消费者可以共同消费一个主题中的所有数据。</li>
<li>为了避免数据被重复消费，所以主题<code>一个分区的数据只能被组中的一个消费者消费</code>，也就是说不能两个消费者同时消费一个分区的数据。但是反过来，一个消费者是可以消费多个分区数据的。<br><img src="/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240428223907358.png" alt="image-20240428223907358"></li>
<li>消费者组中的消费者数量最好不要超出主题分区的数据，就会导致多出的消费者是无法消费数据的，造成了资源的浪费。<br><img src="/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240428223929390.png" alt="image-20240428223929390"></li>
</ul>
<p>消费者中的每个消费者到底消费哪一个主题分区，这个分配策略其实是由消费者的Leader决定的，这个Leader我们称之为群主。群主是多个消费者中，第一个加入组中的消费者，其他消费者我们称之为Follower，称呼上有点类似与分区的Leader和Follower。</p>
<p>当消费者加入群组的时候，会发送一个<code>JoinGroup</code>请求。群主负责给每一个消费者分配分区。每个消费者只知道自己的分配信息，只有群主知道群组内所有消费者的分配信息。</p>
<p><strong>指定分配策略的基本流程</strong>：</p>
<ol>
<li><p>第一个消费者设定group.id为test，向当前负载最小的节点发送<code>FIND_COORDINATOR</code>请求查找消费组调度器<br><img src="/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240428224116726.png" alt="image-20240428224116726"></p>
</li>
<li><p>找到消费调度器后，消费者向调度器节点发出<code>JOIN_GROUP</code>请求，加入消费者组</p>
<p><img src="/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240428224220155.png" alt="image-20240428224220155"> </p>
</li>
<li><p>当前消费者当选为群主后，根据消费者配置中分配策略设计分区分配方案，并将分配好的方案告知调度器<br><img src="/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240428224313324.png" alt="image-20240428224313324"></p>
</li>
<li><p>此时第二个消费者设定group.id为test，申请加入消费者组<br><img src="/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240428224336839.png" alt="image-20240428224336839"></p>
</li>
<li><p>加入成功后，Kafka将消费者组状态切换到<code>准备rebalance</code>，<strong>关闭和消费者的所有连接，等待它们重新加入</strong>。客户端重新申请加入，Kafka从消费者组中挑选第一个作为Leader，其它的作为Follower。（<em>步骤和之前相同，我们假设还是之前的消费者为Leader</em>）<br><img src="/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240428224519668.png" alt="image-20240428224519668"></p>
</li>
<li><p>Leader会按照分配策略对分区进行重分配，并将方案发送给调度器，由调度器通知所有的成员新的分配方案。消费者组成员会按照新的方案重新消费数据<br><img src="/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240428224600552.png" alt="image-20240428224600552"></p>
</li>
</ol>
<p>Kafka提供的分区分配策略常用的有4个：</p>
<ul>
<li><code>RoundRobinAssignor（轮询分配策略）</code></li>
</ul>
<p>每个消费者组中的消费者都会含有一个自动生产的UUID作为memberid。</p>
<img src="/imgs/Kafka技术探索/image-20240428224701418.png" alt="image-20240428224701418" style="zoom:150%;" />

<p>轮询策略中会将每个消费者按照memberid进行排序，所有member消费的主题分区根据主题名称进行排序。</p>
<img src="/imgs/Kafka技术探索/image-20240428224804396.png" alt="image-20240428224804396" style="zoom:150%;" />

<p>将主题分区轮询分配给对应的订阅用户，注意未订阅当前轮询主题的消费者会跳过。</p>
<p><img src="/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240428224834085.png" alt="image-20240428224834085"></p>
<p><img src="/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240428224840167.png" alt="image-20240428224840167"></p>
<p>从图中可以看出，轮询分配策略是存在缺点的，并不是那么的均衡，如果test1-2分区能够分配给消费者ccc是不是就完美了。</p>
<ul>
<li><code>RangeAssignor（范围分配策略）</code></li>
</ul>
<p>按照每个Topic的Partition数计算出每个消费者应该分配的分区数量，然后分配，分配的原则就是一个主题的分区尽可能的平均分，如果不能平均分，那就按顺序向前补齐即可。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">所谓按顺序向前补齐就是：</span></span><br><span class="line">假设【1,2,3,4,5】5个分区分给2个消费者：</span><br><span class="line">5 / 2 = 2, 5 % 2 = 1 =&gt; 剩余的一个补在第一个中[2+1][2] =&gt; 结果为[1,2,3][4,5]</span><br><span class="line"></span><br><span class="line">假设【1,2,3,4,5】5个分区分到3个消费者:</span><br><span class="line">5 / 3 = 1, 5 % 3 = 2 =&gt; 剩余的两个补在第一个和第二个中[1+1][1+1][1] =&gt; 结果为[1,2][3,4][5]</span><br></pre></td></tr></table></figure>

<img src="/imgs/Kafka技术探索/image-20240428225126226.png" alt="image-20240428225126226" style="zoom:150%;" />

<p>缺点：Range分配策略针对单个Topic的情况下显得比较均衡，但是假如Topic多的话, <code>member排序靠前的可能会比member排序靠后的负载多很多</code>。</p>
<img src="/imgs/Kafka技术探索/image-20240428225225932.png" alt="image-20240428225225932" style="zoom:150%;" />

<p>还有就是如果新增或移除消费者成员，那么会导致每个消费者都需要去建立新的分区节点的连接，更新本地的分区缓存，效率比较低。</p>
<img src="/imgs/Kafka技术探索/image-20240428225430546.png" alt="image-20240428225430546" style="zoom:150%;" />

<ul>
<li><code>StickyAssignor（粘性分区）</code></li>
</ul>
<p>在第一次分配后，每个消费者组成员都保留分配给自己的分区信息。如果有消费者加入或退出，那么在进行分区再分配时（一般情况下，消费者退出45s后，才会进行再分配，因为需要考虑可能又恢复的情况），<code>尽可能保证消费者原有的分区不变</code>，重新对加入或退出消费者的分区进行分配。</p>
<img src="/imgs/Kafka技术探索/image-20240428225550064.png" alt="image-20240428225550064" style="zoom:150%;" />

<img src="/imgs/Kafka技术探索/image-20240428225609098.png" alt="image-20240428225609098" style="zoom:150%;" />

<p>从图中可以看出，粘性分区分配策略分配的会更加均匀和高效一些。</p>
<ul>
<li><code>CooperativeStickyAssignor</code></li>
</ul>
<p>前面的三种分配策略再进行重分配时使用的是EAGER协议，会让当前的所有消费者放弃当前分区，关闭连接，资源清理，重新加入组和等待分配策略。明显效率是比较低的，所以从Kafka2.4版本开始，在粘性分配策略的基础上，优化了重分配的过程，使用的是COOPERATIVE协议，特点就是在整个再分配的过程中从图中可以看出，粘性分区分配策略分配的会更加均匀和高效一些，COOPERATIVE协议将一次全局重平衡，改成每次小规模重平衡，直至最终收敛平衡的过程。</p>
<p>Kafka消费者默认的分区分配就是[RangeAssignor，CooperativeStickyAssignor]。</p>
<h5 id="2-6-3-4-消费者偏移量"><a href="#2-6-3-4-消费者偏移量" class="headerlink" title="2.6.3.4 消费者偏移量"></a>2.6.3.4 消费者偏移量</h5><p>消费者偏移量是消费者消费数据的一个非常重要的属性。默认情况下，消费者如果不指定消费主题数据的偏移量，那么消费者启动消费时，无论当前主题之前存储了多少历史数据，消费者只能从连接成功后当前主题最新的数据偏移位置读取，而无法读取之前的任何数据，如果想要获取之前的数据，就需要设定配置参数或指定数据偏移量。</p>
<p>在消费者的配置中，我们可以增加偏移量相关参数<code>auto.offset.reset</code>，用于从最开始获取主题数据:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">KafkaConsumerOffsetTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 配置连接信息和反序列化器</span></span><br><span class="line">        Map&lt;String, Object&gt; configs = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        configs.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, <span class="string">&quot;localhost:9092&quot;</span>);</span><br><span class="line">        configs.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class.getName());</span><br><span class="line">        configs.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class.getName());</span><br><span class="line">        configs.put(ConsumerConfig.GROUP_ID_CONFIG, <span class="string">&quot;groupId&quot;</span>);</span><br><span class="line">        <span class="comment">// 设置重启后消费者偏移量，earliest表示从最早的位置开始消费，如果开启了自动提交偏移量则以上次自动提交的偏移量为准</span></span><br><span class="line">        configs.put(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG, <span class="string">&quot;earliest&quot;</span>);</span><br><span class="line">        <span class="comment">// 创建消费者对象</span></span><br><span class="line">        KafkaConsumer&lt;String, String&gt; kafkaConsumer = <span class="keyword">new</span> <span class="title class_">KafkaConsumer</span>&lt;&gt;(configs);</span><br><span class="line">        <span class="comment">// 订阅主题</span></span><br><span class="line">        kafkaConsumer.subscribe(Collections.singletonList(<span class="string">&quot;test&quot;</span>));</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 拉取消息</span></span><br><span class="line">            ConsumerRecords&lt;String, String&gt; records = kafkaConsumer.poll(Duration.ofSeconds(<span class="number">100</span>));</span><br><span class="line">            <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records) &#123;</span><br><span class="line">                System.out.println(record);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240429142907777.png" alt="image-20240429142907777"></p>
<p>除了从最开始的偏移量或最后的偏移量读取数据以外，Kafka还支持从指定的偏移量的位置开始消费数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">KafkaConsumerSpecificOffsetTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 配置连接信息和反序列化器</span></span><br><span class="line">        Map&lt;String, Object&gt; configs = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        configs.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, <span class="string">&quot;localhost:9092&quot;</span>);</span><br><span class="line">        configs.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class.getName());</span><br><span class="line">        configs.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class.getName());</span><br><span class="line">        configs.put(ConsumerConfig.GROUP_ID_CONFIG, <span class="string">&quot;groupId&quot;</span>);</span><br><span class="line">        <span class="comment">// 创建消费者对象</span></span><br><span class="line">        KafkaConsumer&lt;String, String&gt; kafkaConsumer = <span class="keyword">new</span> <span class="title class_">KafkaConsumer</span>&lt;&gt;(configs);</span><br><span class="line">        <span class="comment">// 订阅主题</span></span><br><span class="line">        kafkaConsumer.subscribe(Collections.singletonList(<span class="string">&quot;test&quot;</span>));</span><br><span class="line">        <span class="comment">// 获取集群元数据信息</span></span><br><span class="line">        kafkaConsumer.poll(Duration.ofSeconds(<span class="number">3</span>));</span><br><span class="line">        Set&lt;TopicPartition&gt; assignment = kafkaConsumer.assignment();</span><br><span class="line">        <span class="comment">// 配置需要消费的主题及偏移量</span></span><br><span class="line">        <span class="keyword">for</span> (TopicPartition partition : assignment) &#123;</span><br><span class="line">            <span class="comment">// 设置偏移量为0，从头开始消费</span></span><br><span class="line">            kafkaConsumer.seek(partition, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 拉取消息</span></span><br><span class="line">            ConsumerRecords&lt;String, String&gt; records = kafkaConsumer.poll(Duration.ofSeconds(<span class="number">100</span>));</span><br><span class="line">            <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records) &#123;</span><br><span class="line">                System.out.println(record);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>生产环境中，消费者可能因为某些原因或故障重新启动消费，那么如果不知道之前消费数据的位置，重启后再消费，就可能<code>重复消费（earliest）</code>或<code>漏消费（latest）</code>。所以Kafka提供了<code>保存消费者偏移量</code>的功能，而这个功能需要由消费者进行<code>提交操作</code>。这样消费者重启后就可以根据之前提交的偏移量进行消费了。</p>
<blockquote>
<p>注意，一旦消费者提交了偏移量，那么Kafka会<code>优先使用提交的偏移量</code>进行消费。此时，<code>auto.offset.reset</code>参数是不起作用的。</p>
</blockquote>
<ul>
<li>自动提交</li>
</ul>
<p>所谓的自动提交就是消费者消费完数据后，无需告知Kafka当前消费数据的偏移量，而是由<strong>消费者客户端API周期性</strong>地将消费的偏移量提交到Kafka中。这个周期默认为<code>5000ms</code>，可以通过配置进行修改。</p>
<p><img src="/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240429193535365.png" alt="image-20240429193535365"></p>
<ul>
<li>手动提交<br>基于时间周期的消费者偏移量提交是我们无法控制的，一旦参数设置的不合理，或单位时间内数据量消费的很多，却没有来及的自动提交，那么数据就会重复消费。所以Kafka也<code>支持消费偏移量的手动提交</code>，也就是说当消费者消费完数据后，自行通过API进行提交。不过为了考虑效率和安全，Kafka同时提供了异步提交和同步提交两种方式供我们选择。注意：需要禁用自动提交<code>auto.offset.reset=false</code>，才能开启手动提交。<ul>
<li>异步提交<br>向Kafka发送偏移量提交请求后，就可以直接消费下一批数据，因为<code>无需等待Kafka的提交确认</code>，所以无法知道当前的偏移量一定提交成功，所以安全性比较低，但相对消费性能会提高。<br><img src="/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240429194300516.png" alt="image-20240429194300516"></li>
<li>同步提交<br>必须等待Kafka完成偏移量提交请求的响应后，才可以消费下一批数据，一旦提交失败，会进行重试处理，尽可能保证偏移量提交成功，但是依然可能因为一些情况导致提交请求失败。此种方式消费效率比较低，但是安全性高。<br><img src="/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240429194447160.png" alt="image-20240429194447160"></li>
</ul>
</li>
</ul>
<h5 id="2-6-3-5-消费者事务"><a href="#2-6-3-5-消费者事务" class="headerlink" title="2.6.3.5 消费者事务"></a>2.6.3.5 消费者事务</h5><p>无论偏移量使用自动提交还是，手动提交，特殊场景中数据都有可能会出现重复消费。</p>
<img src="/imgs/Kafka技术探索/image-20240429200434078.png" alt="image-20240429200434078" style="zoom:150%;" />

<p>如果提前提交偏移量，再处理业务，又可能出现数据丢失的情况。</p>
<img src="/imgs/Kafka技术探索/image-20240429200543721.png" alt="image-20240429200543721" style="zoom:150%;" />

<p>对于单独的Consumer来讲，事务保证会比较弱，尤其是无法保证提交的信息被精确消费，主要原因就是消费者可以通过偏移量访问信息，而不同的数据文件生命周期不同，同一事务的信息可能会因为重启导致被删除的情况。一般情况下，想要完成Kafka消费者端的事务处理，需要将<code>数据消费过程和偏移量提交过程进行原子性绑定</code>，也就是说数据处理完了，必须要保证偏移量正确提交，才可以做下一步的操作，如果偏移量提交失败，那么数据就恢复成处理之前的效果。</p>
<p>对于生产者事务而言，消费者消费的数据也会受到限制。默认情况下，消费者只能消费到生产者提交的数据，也就是未提交完成的数据，消费者是看不到的。如果想要消费到未提交的数据，需要更高消费事务隔离级别。</p>
<p><img src="/imgs/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/image-20240429202953305.png" alt="image-20240429202953305"></p>
<h5 id="2-6-3-6-偏移量保存"><a href="#2-6-3-6-偏移量保存" class="headerlink" title="2.6.3.6 偏移量保存"></a>2.6.3.6 偏移量保存</h5><p>由于消费者在消费消息的时候可能会由于各种原因而断开消费，当重新启动消费者时我们需要让它接着上次消费的位置offset继续消费，因此消费者需要实时的记录自己消费的位置。</p>
<p>0.90版本之前，这个信息是记录在ZooKeeper内的，在0.90之后的版本，offset保存在<code>__consumer_offsets</code>这个Topic内。每个consumer会定期将自己消费分区的offset提交给kafka内部Topic：<code>__consumer_offsets</code>，提交过去的时候，key是<code>consumerGroupId+Topic+分区号</code>，value就是当前offset的值，Kafka会定期清理Topic里的消息，最后就保留最新的那条数据。</p>
<blockquote>
<p>因为__consumer_offsets可能会接收高并发的请求，Kafka默认给其分配<code>50</code>个分区(可以通过<code>offsets.topic.num.partitions</code>设置)，均匀分配到Kafka集群的多个Broker中。Kafka采用<code>hash(consumerGroupId) % __consumer_offsets主题的分区数</code>来计算我们的偏移量提交到哪一个分区。因为偏移量也是保存到主题中的，所以保存的过程和生产者生产数据的过程基本相同。</p>
</blockquote>
<h5 id="2-6-3-7-消费数据"><a href="#2-6-3-7-消费数据" class="headerlink" title="2.6.3.7 消费数据"></a>2.6.3.7 消费数据</h5><p>消费者消费数据时，一般情况下，只是设定了订阅的主题名称，那是如何消费到数据的呢。我们这里说一下服务端拉取数据的基本流程。</p>
<img src="/imgs/Kafka技术探索/image-20240429203635918.png" alt="image-20240429203635918" style="zoom:150%;" />

<ol>
<li>服务端获取到用户拉取数据的请求：Kafka消费客户端会向Broker发送拉取数据的请求<code>FetchRequest</code>，服务端Broker获取到请求后根据请求标记FETCH交给应用处理接口<code>KafkaApis</code>进行处理。</li>
<li>通过副本管理器拉取数据：副本管理器需要确定当前拉取数据的分区，然后进行数据的读取操作。</li>
<li>判定首选副本：2.4版本前，数据读写的分区都是Leader分区，从2.4版本后，Kafka支持Follower副本进行读取。主要原因就是跨机房或者说跨数据中心的场景，为了节约流量资源，可以从当前机房或数据中心的副本中获取数据。这个副本称之首选副本。</li>
<li>拉取分区数据：Kafka的底层读取数据是采用日志段<code>LogSegment</code>对象进行操作的。</li>
<li>零拷贝：为了提高数据读取效率，Kafka的底层采用<code>NIO</code>提供的<code>FileChannel</code>零拷贝技术，直接从操作系统内核中进行数据传输，提高数据拉取的效率。</li>
</ol>

  </div>
</article>

    <div class="blog-post-comments">
        <div id="disqus_thread">
            <noscript>Please enable JavaScript to view the comments.</noscript>
        </div>
    </div>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
        
          <li><a href="/">Home</a></li>
        
          <li><a href="/about/">About</a></li>
        
          <li><a href="/archives/">Writing</a></li>
        
          <li><a href="/tags/">Tag</a></li>
        
          <li><a target="_blank" rel="noopener" href="http://github.com/hulingF">Projects</a></li>
        
      </ul>
    </div>

    
    
      <div id="toc-footer" style="display: none">
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2"><span class="toc-number">1.</span> <span class="toc-text">Kafka技术探索</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC1%E7%AB%A0-Kafka%E5%85%A5%E9%97%A8"><span class="toc-number">1.1.</span> <span class="toc-text">第1章 Kafka入门</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E6%A6%82%E8%BF%B0"><span class="toc-number">1.1.1.</span> <span class="toc-text">1.1 概述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-1-%E5%88%9D%E8%AF%86Kafka"><span class="toc-number">1.1.1.1.</span> <span class="toc-text">1.1.1 初识Kafka</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-2-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="toc-number">1.1.1.2.</span> <span class="toc-text">1.1.2 消息队列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-3-%E7%94%9F%E4%BA%A7%E8%80%85-x2F-%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.1.1.3.</span> <span class="toc-text">1.1.3 生产者&#x2F;消费者模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-4-%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%AF%B9%E6%AF%94"><span class="toc-number">1.1.1.4.</span> <span class="toc-text">1.1.4 消息中间件对比</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-5-ZooKeeper"><span class="toc-number">1.1.1.5.</span> <span class="toc-text">1.1.5 ZooKeeper</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B"><span class="toc-number">1.1.2.</span> <span class="toc-text">1.2 快速上手</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-1-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85"><span class="toc-number">1.1.2.1.</span> <span class="toc-text">1.2.1 环境安装</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-2-%E6%B6%88%E6%81%AF%E4%B8%BB%E9%A2%98"><span class="toc-number">1.1.2.2.</span> <span class="toc-text">1.2.2 消息主题</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-2-2-1-%E5%88%9B%E5%BB%BA%E4%B8%BB%E9%A2%98"><span class="toc-number">1.1.2.2.1.</span> <span class="toc-text">1.2.2.1 创建主题</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-2-2-2-%E6%9F%A5%E8%AF%A2%E4%B8%BB%E9%A2%98"><span class="toc-number">1.1.2.2.2.</span> <span class="toc-text">1.2.2.2 查询主题</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-2-2-3-%E4%BF%AE%E6%94%B9%E4%B8%BB%E9%A2%98"><span class="toc-number">1.1.2.2.3.</span> <span class="toc-text">1.2.2.3 修改主题</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-2-2-4-%E5%88%A0%E9%99%A4%E4%B8%BB%E9%A2%98"><span class="toc-number">1.1.2.2.4.</span> <span class="toc-text">1.2.2.4 删除主题</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-3-%E7%94%9F%E4%BA%A7%E6%95%B0%E6%8D%AE"><span class="toc-number">1.1.2.3.</span> <span class="toc-text">1.2.3 生产数据</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-2-3-1-%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%93%8D%E4%BD%9C"><span class="toc-number">1.1.2.3.1.</span> <span class="toc-text">1.2.3.1 命令行操作</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-2-3-2-%E5%B7%A5%E5%85%B7%E6%93%8D%E4%BD%9C"><span class="toc-number">1.1.2.3.2.</span> <span class="toc-text">1.2.3.2 工具操作</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-2-3-3-Java-API%E6%93%8D%E4%BD%9C"><span class="toc-number">1.1.2.3.3.</span> <span class="toc-text">1.2.3.3 Java API操作</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-4-%E6%B6%88%E8%B4%B9%E6%95%B0%E6%8D%AE"><span class="toc-number">1.1.2.4.</span> <span class="toc-text">1.2.4 消费数据</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-2-4-1-%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%93%8D%E4%BD%9C"><span class="toc-number">1.1.2.4.1.</span> <span class="toc-text">1.2.4.1 命令行操作</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-2-4-2-Java-API%E6%93%8D%E4%BD%9C"><span class="toc-number">1.1.2.4.2.</span> <span class="toc-text">1.2.4.2 Java API操作</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC2%E7%AB%A0-Kafka%E5%9F%BA%E7%A1%80"><span class="toc-number">1.2.</span> <span class="toc-text">第2章 Kafka基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2"><span class="toc-number">1.2.1.</span> <span class="toc-text">2.1 集群部署</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E9%9B%86%E7%BE%A4%E5%90%AF%E5%8A%A8"><span class="toc-number">1.2.2.</span> <span class="toc-text">2.2 集群启动</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-1-%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">2.2.1 相关概念</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-2-1-1-%E4%BB%A3%E7%90%86Broker"><span class="toc-number">1.2.2.1.1.</span> <span class="toc-text">2.2.1.1 代理Broker</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-2-1-2-%E6%8E%A7%E5%88%B6%E5%99%A8Controller"><span class="toc-number">1.2.2.1.2.</span> <span class="toc-text">2.2.1.2 控制器Controller</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-2-%E5%90%AF%E5%8A%A8ZooKeeper"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">2.2.2 启动ZooKeeper</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-3-%E5%90%AF%E5%8A%A8Kafka"><span class="toc-number">1.2.2.3.</span> <span class="toc-text">2.2.3 启动Kafka</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-2-3-1-%E5%88%9D%E5%A7%8B%E5%8C%96ZooKeeper"><span class="toc-number">1.2.2.3.1.</span> <span class="toc-text">2.2.3.1 初始化ZooKeeper</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-2-3-2-%E5%88%9D%E5%A7%8B%E5%8C%96%E6%9C%8D%E5%8A%A1"><span class="toc-number">1.2.2.3.2.</span> <span class="toc-text">2.2.3.2 初始化服务</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-2-3-3-%E5%90%AF%E5%8A%A8%E6%8E%A7%E5%88%B6%E5%99%A8"><span class="toc-number">1.2.2.3.3.</span> <span class="toc-text">2.2.3.3 启动控制器</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E5%88%9B%E5%BB%BA%E4%B8%BB%E9%A2%98"><span class="toc-number">1.2.3.</span> <span class="toc-text">2.3 创建主题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-1-%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5"><span class="toc-number">1.2.3.1.</span> <span class="toc-text">2.3.1 相关概念</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-3-1-1-%E4%B8%BB%E9%A2%98Topic"><span class="toc-number">1.2.3.1.1.</span> <span class="toc-text">2.3.1.1 主题Topic</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-3-1-2-%E5%88%86%E5%8C%BAPartition"><span class="toc-number">1.2.3.1.2.</span> <span class="toc-text">2.3.1.2 分区Partition</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-3-1-3-%E5%89%AF%E6%9C%ACReplication"><span class="toc-number">1.2.3.1.3.</span> <span class="toc-text">2.3.1.3 副本Replication</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-3-1-4-%E5%89%AF%E6%9C%AC%E7%B1%BB%E5%9E%8BLeader-x2F-Follower"><span class="toc-number">1.2.3.1.4.</span> <span class="toc-text">2.3.1.4 副本类型Leader&#x2F;Follower</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-3-1-5-%E6%97%A5%E5%BF%97Log"><span class="toc-number">1.2.3.1.5.</span> <span class="toc-text">2.3.1.5 日志Log</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-2-%E5%88%9B%E5%BB%BA%E7%AC%AC%E4%B8%80%E4%B8%AA%E4%B8%BB%E9%A2%98"><span class="toc-number">1.2.3.2.</span> <span class="toc-text">2.3.2 创建第一个主题</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-3-2-1-ZooKeeper%E8%8A%82%E7%82%B9%E5%8F%98%E5%8C%96"><span class="toc-number">1.2.3.2.1.</span> <span class="toc-text">2.3.2.1 ZooKeeper节点变化</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-3-2-2-%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E4%BD%8D%E7%BD%AE"><span class="toc-number">1.2.3.2.2.</span> <span class="toc-text">2.3.2.2 数据存储位置</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-3-%E5%88%9B%E5%BB%BA%E7%AC%AC%E4%BA%8C%E4%B8%AA%E4%B8%BB%E9%A2%98"><span class="toc-number">1.2.3.3.</span> <span class="toc-text">2.3.3 创建第二个主题</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-3-3-1-ZooKeeper%E8%8A%82%E7%82%B9%E5%8F%98%E5%8C%96"><span class="toc-number">1.2.3.3.1.</span> <span class="toc-text">2.3.3.1 ZooKeeper节点变化</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-3-3-2-%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E4%BD%8D%E7%BD%AE"><span class="toc-number">1.2.3.3.2.</span> <span class="toc-text">2.3.3.2 数据存储位置</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-4-%E5%88%9B%E5%BB%BA%E7%AC%AC%E4%B8%89%E4%B8%AA%E4%B8%BB%E9%A2%98"><span class="toc-number">1.2.3.4.</span> <span class="toc-text">2.3.4 创建第三个主题</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-3-4-1-ZooKeeper%E8%8A%82%E7%82%B9%E5%8F%98%E5%8C%96"><span class="toc-number">1.2.3.4.1.</span> <span class="toc-text">2.3.4.1 ZooKeeper节点变化</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-3-4-2-%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E4%BD%8D%E7%BD%AE"><span class="toc-number">1.2.3.4.2.</span> <span class="toc-text">2.3.4.2 数据存储位置</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-5-%E5%88%9B%E5%BB%BA%E4%B8%BB%E9%A2%98%E6%B5%81%E7%A8%8B"><span class="toc-number">1.2.3.5.</span> <span class="toc-text">2.3.5 创建主题流程</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-3-5-1-%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%8F%90%E4%BA%A4%E5%88%9B%E5%BB%BA%E6%8C%87%E4%BB%A4"><span class="toc-number">1.2.3.5.1.</span> <span class="toc-text">2.3.5.1 命令行提交创建指令</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-3-5-2-Controller%E6%8E%A5%E6%94%B6%E5%88%9B%E5%BB%BA%E4%B8%BB%E9%A2%98%E8%AF%B7%E6%B1%82"><span class="toc-number">1.2.3.5.2.</span> <span class="toc-text">2.3.5.2 Controller接收创建主题请求</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-3-5-3-%E5%88%9B%E5%BB%BA%E4%B8%BB%E9%A2%98"><span class="toc-number">1.2.3.5.3.</span> <span class="toc-text">2.3.5.3 创建主题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-%E7%94%9F%E4%BA%A7%E6%B6%88%E6%81%AF"><span class="toc-number">1.2.4.</span> <span class="toc-text">2.4 生产消息</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-1-%E7%94%9F%E4%BA%A7%E6%B6%88%E6%81%AF%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%AD%A5%E9%AA%A4"><span class="toc-number">1.2.4.1.</span> <span class="toc-text">2.4.1 生产消息的基本步骤</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-2-%E7%94%9F%E4%BA%A7%E6%B6%88%E6%81%AF%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BB%A3%E7%A0%81"><span class="toc-number">1.2.4.2.</span> <span class="toc-text">2.4.2 生产消息的基本代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-3-%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF"><span class="toc-number">1.2.4.3.</span> <span class="toc-text">2.4.3 发送消息</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-4-3-1-%E6%8B%A6%E6%88%AA%E5%99%A8"><span class="toc-number">1.2.4.3.1.</span> <span class="toc-text">2.4.3.1 拦截器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-4-3-2-%E5%9B%9E%E8%B0%83%E6%96%B9%E6%B3%95"><span class="toc-number">1.2.4.3.2.</span> <span class="toc-text">2.4.3.2 回调方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-4-3-3-%E5%BC%82%E6%AD%A5%E5%8F%91%E9%80%81"><span class="toc-number">1.2.4.3.3.</span> <span class="toc-text">2.4.3.3 异步发送</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-4-3-4-%E5%90%8C%E6%AD%A5%E5%8F%91%E9%80%81"><span class="toc-number">1.2.4.3.4.</span> <span class="toc-text">2.4.3.4 同步发送</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-4-%E6%B6%88%E6%81%AF%E5%88%86%E5%8C%BA"><span class="toc-number">1.2.4.4.</span> <span class="toc-text">2.4.4 消息分区</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-4-4-1-%E6%8C%87%E5%AE%9A%E5%88%86%E5%8C%BA"><span class="toc-number">1.2.4.4.1.</span> <span class="toc-text">2.4.4.1 指定分区</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-4-4-2-%E6%9C%AA%E6%8C%87%E5%AE%9A%E5%88%86%E5%8C%BA"><span class="toc-number">1.2.4.4.2.</span> <span class="toc-text">2.4.4.2 未指定分区</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-4-4-3-%E5%88%86%E5%8C%BA%E5%99%A8"><span class="toc-number">1.2.4.4.3.</span> <span class="toc-text">2.4.4.3 分区器</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-5-%E6%B6%88%E6%81%AF%E5%8F%AF%E9%9D%A0%E6%80%A7"><span class="toc-number">1.2.4.5.</span> <span class="toc-text">2.4.5 消息可靠性</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-4-5-1-ACK-x3D-0"><span class="toc-number">1.2.4.5.1.</span> <span class="toc-text">2.4.5.1 ACK&#x3D;0</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-4-5-2-ACK-x3D-1"><span class="toc-number">1.2.4.5.2.</span> <span class="toc-text">2.4.5.2 ACK&#x3D;1</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-4-5-3-ACK-x3D-all"><span class="toc-number">1.2.4.5.3.</span> <span class="toc-text">2.4.5.3 ACK&#x3D;all</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-6-%E6%B6%88%E6%81%AF%E5%8E%BB%E9%87%8D-amp-%E6%9C%89%E5%BA%8F"><span class="toc-number">1.2.4.6.</span> <span class="toc-text">2.4.6 消息去重&amp;有序</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-4-6-1-%E6%95%B0%E6%8D%AE%E9%87%8D%E8%AF%95"><span class="toc-number">1.2.4.6.1.</span> <span class="toc-text">2.4.6.1 数据重试</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-4-6-2-%E6%95%B0%E6%8D%AE%E4%B9%B1%E5%BA%8F"><span class="toc-number">1.2.4.6.2.</span> <span class="toc-text">2.4.6.2 数据乱序</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-4-6-3-%E6%95%B0%E6%8D%AE%E5%B9%82%E7%AD%89%E6%80%A7"><span class="toc-number">1.2.4.6.3.</span> <span class="toc-text">2.4.6.3 数据幂等性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-4-6-4-%E6%95%B0%E6%8D%AE%E4%BA%8B%E5%8A%A1"><span class="toc-number">1.2.4.6.4.</span> <span class="toc-text">2.4.6.4 数据事务</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-4-6-5-%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E8%AF%AD%E4%B9%89"><span class="toc-number">1.2.4.6.5.</span> <span class="toc-text">2.4.6.5 数据传输语义</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-%E5%AD%98%E5%82%A8%E6%B6%88%E6%81%AF"><span class="toc-number">1.2.5.</span> <span class="toc-text">2.5 存储消息</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5-1-%E5%AD%98%E5%82%A8%E7%BB%84%E4%BB%B6"><span class="toc-number">1.2.5.1.</span> <span class="toc-text">2.5.1 存储组件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5-2-%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8"><span class="toc-number">1.2.5.2.</span> <span class="toc-text">2.5.2 数据存储</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-5-2-1-ACKS%E6%A0%A1%E9%AA%8C"><span class="toc-number">1.2.5.2.1.</span> <span class="toc-text">2.5.2.1 ACKS校验</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-5-2-2-%E5%86%85%E9%83%A8%E4%B8%BB%E9%A2%98%E6%A0%A1%E9%AA%8C"><span class="toc-number">1.2.5.2.2.</span> <span class="toc-text">2.5.2.2 内部主题校验</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-5-2-3-ACKS%E5%BA%94%E7%AD%94%E5%8F%8A%E5%89%AF%E6%9C%AC%E6%95%B0%E9%87%8F%E5%85%B3%E7%B3%BB%E6%A0%A1%E9%AA%8C"><span class="toc-number">1.2.5.2.3.</span> <span class="toc-text">2.5.2.3 ACKS应答及副本数量关系校验</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-5-2-4-%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6%E6%BB%9A%E5%8A%A8%E5%88%A4%E6%96%AD"><span class="toc-number">1.2.5.2.4.</span> <span class="toc-text">2.5.2.4 日志文件滚动判断</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-5-2-5-%E8%AF%B7%E6%B1%82%E6%95%B0%E6%8D%AE%E9%87%8D%E5%A4%8D%E6%80%A7%E6%A0%A1%E9%AA%8C"><span class="toc-number">1.2.5.2.5.</span> <span class="toc-text">2.5.2.5 请求数据重复性校验</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-5-2-6-%E8%AF%B7%E6%B1%82%E6%95%B0%E6%8D%AE%E5%BA%8F%E5%88%97%E5%8F%B7%E6%A0%A1%E9%AA%8C"><span class="toc-number">1.2.5.2.6.</span> <span class="toc-text">2.5.2.6 请求数据序列号校验</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-5-2-7-%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8"><span class="toc-number">1.2.5.2.7.</span> <span class="toc-text">2.5.2.7 数据存储</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5-3-%E5%AD%98%E5%82%A8%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F"><span class="toc-number">1.2.5.3.</span> <span class="toc-text">2.5.3 存储文件格式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-5-3-1-%E6%95%B0%E6%8D%AE%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6"><span class="toc-number">1.2.5.3.1.</span> <span class="toc-text">2.5.3.1 数据日志文件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-5-3-2-%E6%95%B0%E6%8D%AE%E7%B4%A2%E5%BC%95%E6%96%87%E4%BB%B6"><span class="toc-number">1.2.5.3.2.</span> <span class="toc-text">2.5.3.2 数据索引文件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-5-3-3-%E6%95%B0%E6%8D%AE%E6%97%B6%E9%97%B4%E6%88%B3%E7%B4%A2%E5%BC%95%E6%96%87%E4%BB%B6"><span class="toc-number">1.2.5.3.3.</span> <span class="toc-text">2.5.3.3 数据时间戳索引文件</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5-4-%E6%95%B0%E6%8D%AE%E5%88%B7%E5%86%99"><span class="toc-number">1.2.5.4.</span> <span class="toc-text">2.5.4 数据刷写</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5-5-%E5%89%AF%E6%9C%AC%E5%90%8C%E6%AD%A5"><span class="toc-number">1.2.5.5.</span> <span class="toc-text">2.5.5 副本同步</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-5-5-1-%E5%90%AF%E5%8A%A8%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.2.5.5.1.</span> <span class="toc-text">2.5.5.1 启动数据同步线程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-5-5-2-%E7%94%9F%E6%88%90%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5%E8%AF%B7%E6%B1%82"><span class="toc-number">1.2.5.5.2.</span> <span class="toc-text">2.5.5.2 生成数据同步请求</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-5-5-3-%E5%A4%84%E7%90%86%E6%95%B0%E6%8D%AE%E5%93%8D%E5%BA%94"><span class="toc-number">1.2.5.5.3.</span> <span class="toc-text">2.5.5.3 处理数据响应</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-5-5-4-%E6%9B%B4%E6%96%B0%E6%95%B0%E6%8D%AE%E5%81%8F%E7%A7%BB%E9%87%8F"><span class="toc-number">1.2.5.5.4.</span> <span class="toc-text">2.5.5.4 更新数据偏移量</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5-6-%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7"><span class="toc-number">1.2.5.6.</span> <span class="toc-text">2.5.6 数据一致性</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-5-6-1-%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7%E8%A1%A8%E7%8E%B0"><span class="toc-number">1.2.5.6.1.</span> <span class="toc-text">2.5.6.1 数据一致性表现</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-5-6-2-HW%E5%9C%A8%E5%89%AF%E6%9C%AC%E4%B9%8B%E9%97%B4%E7%9A%84%E4%BC%A0%E9%80%92"><span class="toc-number">1.2.5.6.2.</span> <span class="toc-text">2.5.6.2 HW在副本之间的传递</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-5-6-3-ISR%EF%BC%88In-Sync-Replicas%EF%BC%89%E4%BC%B8%E7%BC%A9"><span class="toc-number">1.2.5.6.3.</span> <span class="toc-text">2.5.6.3 ISR（In-Sync-Replicas）伸缩</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6-%E6%B6%88%E8%B4%B9%E6%B6%88%E6%81%AF"><span class="toc-number">1.2.6.</span> <span class="toc-text">2.6 消费消息</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-6-1-%E6%B6%88%E8%B4%B9%E6%B6%88%E6%81%AF%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%AD%A5%E9%AA%A4"><span class="toc-number">1.2.6.1.</span> <span class="toc-text">2.6.1 消费消息的基本步骤</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-6-2-%E6%B6%88%E8%B4%B9%E6%B6%88%E6%81%AF%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BB%A3%E7%A0%81"><span class="toc-number">1.2.6.2.</span> <span class="toc-text">2.6.2 消费消息的基本代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-6-3-%E6%B6%88%E8%B4%B9%E6%B6%88%E6%81%AF%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86"><span class="toc-number">1.2.6.3.</span> <span class="toc-text">2.6.3 消费消息的基本原理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-6-3-1-%E6%B6%88%E8%B4%B9%E8%80%85%E7%BB%84"><span class="toc-number">1.2.6.3.1.</span> <span class="toc-text">2.6.3.1 消费者组</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-6-3-2-%E7%BB%84%E8%B0%83%E5%BA%A6%E5%99%A8GroupCoordinator"><span class="toc-number">1.2.6.3.2.</span> <span class="toc-text">2.6.3.2 组调度器GroupCoordinator</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-6-3-3-%E6%B6%88%E8%B4%B9%E8%80%85%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5Assignor"><span class="toc-number">1.2.6.3.3.</span> <span class="toc-text">2.6.3.3 消费者分配策略Assignor</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-6-3-4-%E6%B6%88%E8%B4%B9%E8%80%85%E5%81%8F%E7%A7%BB%E9%87%8F"><span class="toc-number">1.2.6.3.4.</span> <span class="toc-text">2.6.3.4 消费者偏移量</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-6-3-5-%E6%B6%88%E8%B4%B9%E8%80%85%E4%BA%8B%E5%8A%A1"><span class="toc-number">1.2.6.3.5.</span> <span class="toc-text">2.6.3.5 消费者事务</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-6-3-6-%E5%81%8F%E7%A7%BB%E9%87%8F%E4%BF%9D%E5%AD%98"><span class="toc-number">1.2.6.3.6.</span> <span class="toc-text">2.6.3.6 偏移量保存</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-6-3-7-%E6%B6%88%E8%B4%B9%E6%95%B0%E6%8D%AE"><span class="toc-number">1.2.6.3.7.</span> <span class="toc-text">2.6.3.7 消费数据</span></a></li></ol></li></ol></li></ol></li></ol></li></ol>
      </div>
    

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://hulingf.github.io/2024/04/27/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://hulingf.github.io/2024/04/27/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/&text=Kafka技术探索"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://hulingf.github.io/2024/04/27/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/&title=Kafka技术探索"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://hulingf.github.io/2024/04/27/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/&is_video=false&description=Kafka技术探索"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=Kafka技术探索&body=Check out this article: https://hulingf.github.io/2024/04/27/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/"><i class="fa-solid fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://hulingf.github.io/2024/04/27/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/&title=Kafka技术探索"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://hulingf.github.io/2024/04/27/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/&title=Kafka技术探索"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://hulingf.github.io/2024/04/27/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/&title=Kafka技术探索"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://hulingf.github.io/2024/04/27/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/&title=Kafka技术探索"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://hulingf.github.io/2024/04/27/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/&name=Kafka技术探索&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://hulingf.github.io/2024/04/27/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/&t=Kafka技术探索"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fa-solid fa-bars fa-lg" aria-hidden="true"></i> Menu</a>
        
          <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fa-solid fa-list fa-lg" aria-hidden="true"></i> TOC</a>
        
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fa-solid fa-share-alt fa-lg" aria-hidden="true"></i> Share</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2024
    hulingF
  </div>
  <div class="footer-right">
    <nav>
      <ul>
        <!--
       --><li><a href="/">Home</a></li><!--
     --><!--
       --><li><a href="/about/">About</a></li><!--
     --><!--
       --><li><a href="/archives/">Writing</a></li><!--
     --><!--
       --><li><a href="/tags/">Tag</a></li><!--
     --><!--
       --><li><a target="_blank" rel="noopener" href="http://github.com/hulingF">Projects</a></li><!--
     -->
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->



  <link rel="preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" crossorigin="anonymous" onload="this.onload=null;this.rel='stylesheet'"/>


    <!-- jquery -->

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" crossorigin="anonymous"></script>




<!-- clipboard -->

  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.7/clipboard.min.js" crossorigin="anonymous"></script>
  
  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"Copy to clipboard!\">";
    btn += '<i class="fa-regular fa-clone"></i>';
    btn += '</span>';
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "Copied!");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Disqus Comments -->

    <script type="text/javascript">
        var disqus_shortname = 'hulingF';

        (function(){
            var dsq = document.createElement('script');
            dsq.type = 'text/javascript';
            dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        }());
    </script>

<!-- utterances Comments -->

</body>
</html>
