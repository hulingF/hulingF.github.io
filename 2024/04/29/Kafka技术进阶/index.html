<!DOCTYPE html>
<html lang=en>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5" />
    <meta name="description" content="Kafka技术进阶1 Kafka技术精讲1.1 Controller选举Controller，是Apache Kafka的核心组件。它的主要作用是在Apache ZooKeeper的帮助下管理和协调控制整个Kafka集群。 集群中的任意一台Broker都能充当Controller的角色，但是，在整个集群运行过程中，只能有一个Broker成为Controller。也就是说，每个正常运行的Kafka集">
<meta property="og:type" content="article">
<meta property="og:title" content="Kafka技术进阶">
<meta property="og:url" content="https://hulingf.github.io/2024/04/29/Kafka%E6%8A%80%E6%9C%AF%E8%BF%9B%E9%98%B6/index.html">
<meta property="og:site_name" content="大军的秘密花园">
<meta property="og:description" content="Kafka技术进阶1 Kafka技术精讲1.1 Controller选举Controller，是Apache Kafka的核心组件。它的主要作用是在Apache ZooKeeper的帮助下管理和协调控制整个Kafka集群。 集群中的任意一台Broker都能充当Controller的角色，但是，在整个集群运行过程中，只能有一个Broker成为Controller。也就是说，每个正常运行的Kafka集">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://hulingf.github.io/imgs/Kafka%E6%8A%80%E6%9C%AF%E8%BF%9B%E9%98%B6/image-20240429205054630.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/Kafka%E6%8A%80%E6%9C%AF%E8%BF%9B%E9%98%B6/image-20240429205453716.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/Kafka%E6%8A%80%E6%9C%AF%E8%BF%9B%E9%98%B6/image-20240429210902760.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/Kafka%E6%8A%80%E6%9C%AF%E8%BF%9B%E9%98%B6/image-20240429212000889.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/Kafka%E6%8A%80%E6%9C%AF%E8%BF%9B%E9%98%B6/image-20240429212529784.png">
<meta property="og:image" content="https://hulingf.github.io/imgs/Kafka%E6%8A%80%E6%9C%AF%E8%BF%9B%E9%98%B6/image-20240429212653126.png">
<meta property="article:published_time" content="2024-04-29T12:42:34.939Z">
<meta property="article:modified_time" content="2024-05-04T06:56:48.651Z">
<meta property="article:author" content="hulingF">
<meta property="article:tag" content="Kafka">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://hulingf.github.io/imgs/Kafka%E6%8A%80%E6%9C%AF%E8%BF%9B%E9%98%B6/image-20240429205054630.png">
    
    
      
        
          <link rel="shortcut icon" href="/images/favicon.ico">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
        
      
    
    <!-- title -->
    <title>Kafka技术进阶</title>
    <!-- async scripts -->
    <!-- Google Analytics -->


    <!-- Umami Analytics -->


    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
    <!-- rss -->
    
    
	<!-- mathjax -->
	
<meta name="generator" content="Hexo 6.3.0"></head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#" aria-label="Menu"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#" aria-label="Menu"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" aria-label="Top" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa-solid fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
        <!--
       --><li><a href="/">Home</a></li><!--
     --><!--
       --><li><a href="/about/">About</a></li><!--
     --><!--
       --><li><a href="/archives/">Writing</a></li><!--
     --><!--
       --><li><a href="/tags/">Tag</a></li><!--
     --><!--
       --><li><a target="_blank" rel="noopener" href="http://github.com/hulingF">Projects</a></li><!--
     -->
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" aria-label="Previous post" href="/2024/06/22/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1DDD/"><i class="fa-solid fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" aria-label="Next post" href="/2024/04/27/Kafka%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%B4%A2/"><i class="fa-solid fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" aria-label="Back to top" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" aria-label="Share post" href="#"><i class="fa-solid fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://hulingf.github.io/2024/04/29/Kafka%E6%8A%80%E6%9C%AF%E8%BF%9B%E9%98%B6/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://hulingf.github.io/2024/04/29/Kafka%E6%8A%80%E6%9C%AF%E8%BF%9B%E9%98%B6/&text=Kafka技术进阶"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://hulingf.github.io/2024/04/29/Kafka%E6%8A%80%E6%9C%AF%E8%BF%9B%E9%98%B6/&title=Kafka技术进阶"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://hulingf.github.io/2024/04/29/Kafka%E6%8A%80%E6%9C%AF%E8%BF%9B%E9%98%B6/&is_video=false&description=Kafka技术进阶"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=Kafka技术进阶&body=Check out this article: https://hulingf.github.io/2024/04/29/Kafka%E6%8A%80%E6%9C%AF%E8%BF%9B%E9%98%B6/"><i class="fa-solid fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://hulingf.github.io/2024/04/29/Kafka%E6%8A%80%E6%9C%AF%E8%BF%9B%E9%98%B6/&title=Kafka技术进阶"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://hulingf.github.io/2024/04/29/Kafka%E6%8A%80%E6%9C%AF%E8%BF%9B%E9%98%B6/&title=Kafka技术进阶"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://hulingf.github.io/2024/04/29/Kafka%E6%8A%80%E6%9C%AF%E8%BF%9B%E9%98%B6/&title=Kafka技术进阶"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://hulingf.github.io/2024/04/29/Kafka%E6%8A%80%E6%9C%AF%E8%BF%9B%E9%98%B6/&title=Kafka技术进阶"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://hulingf.github.io/2024/04/29/Kafka%E6%8A%80%E6%9C%AF%E8%BF%9B%E9%98%B6/&name=Kafka技术进阶&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://hulingf.github.io/2024/04/29/Kafka%E6%8A%80%E6%9C%AF%E8%BF%9B%E9%98%B6/&t=Kafka技术进阶"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    
    
      <div id="toc">
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Kafka%E6%8A%80%E6%9C%AF%E8%BF%9B%E9%98%B6"><span class="toc-number">1.</span> <span class="toc-text">Kafka技术进阶</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-Kafka%E6%8A%80%E6%9C%AF%E7%B2%BE%E8%AE%B2"><span class="toc-number">1.1.</span> <span class="toc-text">1 Kafka技术精讲</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-Controller%E9%80%89%E4%B8%BE"><span class="toc-number">1.1.1.</span> <span class="toc-text">1.1 Controller选举</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-Broker%E4%B8%8A%E4%B8%8B%E7%BA%BF"><span class="toc-number">1.1.2.</span> <span class="toc-text">1.2 Broker上下线</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-%E6%95%B0%E6%8D%AE%E5%81%8F%E7%A7%BB%E9%87%8F%E5%AE%9A%E4%BD%8D"><span class="toc-number">1.1.3.</span> <span class="toc-text">1.3 数据偏移量定位</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-%E6%97%A5%E5%BF%97%E6%B8%85%E7%90%86%E5%92%8C%E5%8E%8B%E7%BC%A9"><span class="toc-number">1.1.4.</span> <span class="toc-text">1.4 日志清理和压缩</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5-%E9%A1%B5%E7%BC%93%E5%AD%98"><span class="toc-number">1.1.5.</span> <span class="toc-text">1.5 页缓存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-6-%E9%A1%BA%E5%86%99%E6%97%A5%E5%BF%97"><span class="toc-number">1.1.6.</span> <span class="toc-text">1.6 顺写日志</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-Kafka%E9%9B%86%E7%BE%A4%E4%BC%98%E5%8C%96"><span class="toc-number">1.2.</span> <span class="toc-text">2.Kafka集群优化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2%E6%96%B9%E6%A1%88"><span class="toc-number">1.2.1.</span> <span class="toc-text">2.1 集群部署方案</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">2.1.1 操作系统</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-2-%E7%A3%81%E7%9B%98%E9%80%89%E5%9E%8B"><span class="toc-number">1.2.1.2.</span> <span class="toc-text">2.1.2 磁盘选型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-3-%E7%A3%81%E7%9B%98%E5%AE%B9%E9%87%8F"><span class="toc-number">1.2.1.3.</span> <span class="toc-text">2.1.3 磁盘容量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-4-%E5%B8%A6%E5%AE%BD"><span class="toc-number">1.2.1.4.</span> <span class="toc-text">2.1.4 带宽</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E9%9B%86%E7%BE%A4%E5%8F%82%E6%95%B0%E9%85%8D%E7%BD%AE"><span class="toc-number">1.2.2.</span> <span class="toc-text">2.2 集群参数配置</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-1-Broker%E7%AB%AF%E5%8F%82%E6%95%B0"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">2.2.1 Broker端参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-2-Topic%E7%BA%A7%E5%88%AB%E5%8F%82%E6%95%B0"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">2.2.2 Topic级别参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-3-JVM%E5%8F%82%E6%95%B0"><span class="toc-number">1.2.2.3.</span> <span class="toc-text">2.2.3 JVM参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-4-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8F%82%E6%95%B0"><span class="toc-number">1.2.2.4.</span> <span class="toc-text">2.2.4 操作系统参数</span></a></li></ol></li></ol></li></ol></li></ol>
      </div>
    
  </span>
</div>

    
    <div class="content index py4 ">
        
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle p-name" itemprop="name headline">
        Kafka技术进阶
    </h1>



    <div class="meta">
      <span class="author p-author h-card" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span class="p-name" itemprop="name">hulingF</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2024-04-29T12:42:34.939Z" class="dt-published" itemprop="datePublished">2024-04-29</time>
        
      
    </div>


      

      
    <div class="article-tag">
        <i class="fa-solid fa-tag"></i>
        <a class="p-category" href="/tags/Kafka/" rel="tag">Kafka</a>
    </div>


    </div>
  </header>
  

  <div class="content e-content" itemprop="articleBody">
    <h1 id="Kafka技术进阶"><a href="#Kafka技术进阶" class="headerlink" title="Kafka技术进阶"></a>Kafka技术进阶</h1><h2 id="1-Kafka技术精讲"><a href="#1-Kafka技术精讲" class="headerlink" title="1 Kafka技术精讲"></a>1 Kafka技术精讲</h2><h3 id="1-1-Controller选举"><a href="#1-1-Controller选举" class="headerlink" title="1.1 Controller选举"></a>1.1 Controller选举</h3><p>Controller，是Apache Kafka的核心组件。它的主要作用是在Apache ZooKeeper的帮助下管理和协调控制整个Kafka集群。</p>
<p>集群中的任意一台Broker都能充当Controller的角色，但是，在整个集群运行过程中，只能有一个Broker成为Controller。也就是说，每个正常运行的Kafka集群，在任何时刻都有且只有一个Controller。</p>
<p><img src="/imgs/Kafka%E6%8A%80%E6%9C%AF%E8%BF%9B%E9%98%B6/image-20240429205054630.png" alt="image-20240429205054630"></p>
<p>最先在ZooKeeper上创建<code>临时节点/controller</code>成功的Broker就是Controller。Controller重度依赖Zookeeper，依赖ZooKeeper保存元数据，依赖Zookeeper进行服务发现。Controller大量使用<code>Watcher功能</code>实现对集群的协调管理。如果此时，作为Controller的Broker节点宕掉了。那么ZooKeeper的临时节点&#x2F;controller就会因为会话超时而自动删除。而监控这个节点的Broker就会收到通知而向ZooKeeper发出创建&#x2F;controller节点的申请，一旦创建成功，那么创建成功的Broker节点就成为了新的Controller。</p>
<p><img src="/imgs/Kafka%E6%8A%80%E6%9C%AF%E8%BF%9B%E9%98%B6/image-20240429205453716.png" alt="image-20240429205453716"></p>
<p>有一种特殊的情况，就是Controller节点并没有宕掉，而是因为<code>网络抖动不稳定</code>，导致和ZooKeeper之间的会话超时，那么此时，整个Kafka集群就会认为之前的Controller已经下线从而选举出新的Controller，而之前的Controller的网络又恢复了，以为自己还是Controller了，继续管理整个集群，那么此时，整个Kafka集群就有两个Controller进行管理，那么其他的Broker就懵了，不知道听谁的了，这种情况，我们称之为<code>脑裂现象</code>，为了解决这个问题，Kafka通过一个<code>任期（epoch:纪元）</code>的概念来解决，也就是说，每一个Broker当选Controller时，会告诉当前Broker是第几任Controller，一旦重新选举时，这个任期会自动增1，那么不同任期的Controller的epoch值是不同的，那么旧的Controller一旦发现集群中有新任Controller的时候，那么它就会完成退出操作（清空缓存，中断和Broker的连接，并重新加载最新的缓存），让自己重新变成一个普通的Broker。</p>
<h3 id="1-2-Broker上下线"><a href="#1-2-Broker上下线" class="headerlink" title="1.2 Broker上下线"></a>1.2 Broker上下线</h3><p>Controller在初始化时，会利用ZooKeeper的Watcher机制注册很多不同类型的<code>监听器</code>，当监听的事件被触发时，Controller就会触发相应的操作。Controller在初始化时，会注册多种类型的监听器，主要有以下几种：</p>
<ul>
<li>监听<code>/admin/reassign_partitions</code>节点，用于分区副本迁移的监听</li>
<li>监听<code>/isr_change_notification</code>节点，用于Partition ISR变动的监听</li>
<li>监听<code>/admin/preferred_replica_election</code>节点，用于需要进行Partition最优Leader选举的监听</li>
<li>监听<code>/brokers/topics</code>节点，用于Topic新建的监听</li>
<li>监听<code>/brokers/topics/TOPIC_NAME</code>节点，用于Topic Partition扩容的监听</li>
<li>监听<code>/admin/delete_topics</code>节点，用于Topic删除的监听</li>
<li>监听<code>/brokers/ids</code>节点，用于Broker上下线的监听</li>
</ul>
<p>每台Broker在上线时，都会与ZooKeeper建立一个建立一个session，并在<code>/brokers/ids</code>下注册一个节点，节点名字就是<code>brokerid</code>，这个节点是<code>临时节点</code>，该节点内部会有这个Broker的详细节点信息。Controller会监听&#x2F;brokers&#x2F;ids这个路径下的所有子节点，如果有新的节点出现，那么就代表有新的Broker上线，如果有节点消失，就代表有旧的Broker下线，Controller会进行相应的处理，Kafka就是利用ZooKeeper的这种<code>Watcher机制及临时节点的特性</code>来完成集群Broker的上下线。无论Controller监听到的哪一种节点的变化，都会进行相应的处理，同步整个集群元数据。</p>
<h3 id="1-3-数据偏移量定位"><a href="#1-3-数据偏移量定位" class="headerlink" title="1.3 数据偏移量定位"></a>1.3 数据偏移量定位</h3><p>分区是一个逻辑工作单元，其中记录被<code>顺序附加</code>分区上（<strong>Kafka只能保证分区消息的有序性，而不能保证消息的全局有序性</strong>）。但是分区不是存储单元，<code>分区进一步划分为Segment</code>（段），这些段是文件系统上的<code>实际文件</code>。为了获得更好的性能和可维护性，可以创建多个段，而不是从一个巨大的分区中读取，消费者现在可以更快地从较小的段文件中读取。创建具有分区名称的目录，并将该分区的所有段作为各种文件进行维护。在理想情况下，数据流量分摊到各个Parition中，实现了负载均衡的效果。</p>
<p>每个数据日志文件会对应一个LogSegment对象，并且都有一个基准偏移量，表示当前LogSegment中第一条消息的偏移量offset。</p>
<p><img src="/imgs/Kafka%E6%8A%80%E6%9C%AF%E8%BF%9B%E9%98%B6/image-20240429210902760.png" alt="image-20240429210902760"></p>
<p>偏移量是一个64位的长整形数，固定是20位数字，长度未达到用0进行填补，索引文件和日志文件都由该作为文件名命名规则：</p>
<p>00000000000000000000.index：索引文件，记录偏移量映射到.log文件位置，此映射用于从任何特定偏移量读取记录</p>
<p>0000000000000000000.timeindex：时间戳索引文件，此文件包含时间戳到记录偏移量的映射</p>
<p>00000000000000000000.log：此文件包含实际记录，并将记录保持到特定偏移量，文件名描述了添加到此文件的起始偏移量，如果日志文件名为 00000000000000000004.log，则当前日志文件的第一条数据偏移量就是4（偏移量从0开始）</p>
<p>多个数据日志文件在操作时，<code>只有最新的日志文件处于活动状态，拥有文件写入和读取权限</code>，其他的日志文件只有只读的权限。</p>
<p>偏移量索引文件用于记录消息偏移量与物理地址之间的映射关系。时间戳索引文件则根据时间戳查找对应的偏移量。Kafka中的索引文件是以<code>稀疏索引</code>的方式构造消息的索引，<code>并不保证每一个消息在索引文件中都有对应的索引项</code>。每当写入一定量的消息时，偏移量索引文件和时间戳索引文件分别增加一个偏移量索引项和时间戳索引项。通过修改<code>log.index.interval.bytes</code>的值，改变索引项的密度。</p>
<p>数据位置索引保存在index文件中，log日志默认每写入4K（log.index.interval.bytes设定的），会写入一条索引信息到index文件中，因此索引文件是稀疏索引，它不会为每条日志都建立索引信息，索引文件的数据结构则是由相对offset（4byte）+position（4byte）组成，由于保存的是相对第一个消息的相对offset，只需要4byte就可以，节省空间，实际查找后还需要计算回实际的offset，这对用户是不可见的。</p>
<p>如果消费者想要消费某一个偏移量的数据，那么Kafka会通过Kafka中存在一个<code>ConcurrentSkipListMap（跳跃表）</code>定位到00000000000000000000.index索引文件，通过<code>二分法</code>在偏移量索引文件中找到不大于指定偏移量的最大索引项，然后从日志分段文件中的物理位置开始顺序查找偏移量为指定值的消息。</p>
<h3 id="1-4-日志清理和压缩"><a href="#1-4-日志清理和压缩" class="headerlink" title="1.4 日志清理和压缩"></a>1.4 日志清理和压缩</h3><p>Kafka软件的目的本质是用于传输数据，而不是存储数据，但是为了均衡生产数据速率和消费者的消费速率，所以可以将数据保存到日志文件中进行存储。默认的数据日志保存时间为7天，可以通过调整如下参数修改保存时间：</p>
<ul>
<li><code>log.retention.hours</code>：小时（默认：7天，最低优先级）</li>
<li><code>log.retention.minutes</code>：分钟</li>
<li><code>log.retention.ms</code>：毫秒（最高优先级）</li>
<li><code>log.retention.check.interval.ms</code>：负责设置检查周期，默认5分钟</li>
</ul>
<p>日志一旦超过了设置的时间，Kafka中提供了两种日志清理策略：delete和compact。</p>
<ul>
<li><p>delete：将过期数据删除</p>
<ul>
<li><code>log.cleanup.policy = delete</code>（所有数据启用删除策略）</li>
<li>基于时间：默认打开。以Segment中所有记录中的最大时间戳作为该文件时间戳。</li>
<li>基于大小：默认关闭。超过设置的所有日志总大小，删除最早的Segment。<code>log.retention.bytes</code>，默认等于-1，表示无穷大。</li>
</ul>
</li>
<li><p>compact：日志压缩</p>
<ul>
<li><p>基本思路就是将相同key的数据，只保留最后一个</p>
</li>
<li><p><code>log.cleanup.policy = compact</code>（所有数据启用压缩策略）</p>
<p><img src="/imgs/Kafka%E6%8A%80%E6%9C%AF%E8%BF%9B%E9%98%B6/image-20240429212000889.png" alt="image-20240429212000889"></p>
</li>
<li><p><strong>注意：因为数据会丢失，所以这种策略只适用保存数据最新状态的特殊场景。</strong></p>
</li>
</ul>
</li>
</ul>
<h3 id="1-5-页缓存"><a href="#1-5-页缓存" class="headerlink" title="1.5 页缓存"></a>1.5 页缓存</h3><p>页缓存是操作系统实现的一种主要的磁盘缓存，以此用来减少对磁盘I&#x2F;O的操作。具体来说，就是把磁盘中的数据缓存到内存中，把对磁盘的访问变为对内存的访问。为了弥补性能上的差异，现代操作系统越来越多地将内存作为磁盘缓存，甚至会将所有可用的内存用于磁盘缓存，这样当内存回收时也几乎没有性能损失，所有对于磁盘的读写也将经由统一的缓存。</p>
<p>当一个进程准备读取磁盘上的文件内容时，操作系统会先查看待读取的数据所在的页是否在页缓存（page cache）中，如果存在（命中）则直接返回数据，从而避免了对物理磁盘的I&#x2F;O操作；如果没有命中，则操作系统会向磁盘发起读取请示并将读取的数据页写入页缓存，之后再将数据返回进程。同样，如果一个进程需要将数据写入磁盘，那么操作系统也会检测数据对应的页是否在页缓存中，如果不存在，则会先在页缓存中添加相应的页，最后将数据写入对应的页。<strong>被修改过后的页也就变成了脏页，操作系统会在合适的时间把脏页中的数据写入磁盘，以操作数据的一致性。</strong></p>
<p>Kafka中大量使用了页缓存，这是Kafka实现高吞吐的重要因此之一。虽然消息都是先被写入页缓存，然后由操作系统负责具体的刷盘任务，但在Kafka中同样提供了<code>同步刷盘及间断性强制刷盘（fsync）</code>的功能，这些功能可以通过<code>log.flush.interval.message</code>、<code>log.flush.interval.ms</code>等参数来控制。同步刷盘可以提高消息的可靠性，防止由于机器掉电等异常造成处于页缓存而没有及时写入磁盘的消息丢失。不过一般不建议这么做，刷盘任务就应交由操作系统去调配，消息的可靠性应该由多副本机制来保障，而不是由同步刷盘这种严重影响性能的行为来保障。</p>
<h3 id="1-6-顺写日志"><a href="#1-6-顺写日志" class="headerlink" title="1.6 顺写日志"></a>1.6 顺写日志</h3><p>Kafka中消息是以Topic进行分类的，生产者生产消息，消费者消费消息，都是面向Topic的。在Kafka中，一个Topic可以分为多个Partition，一个Partition分为多个Segment，每个Segment对应三个文件：<code>.index</code>文件、<code>.log</code>文件、<code>.timeindex</code>文件。</p>
<img src="/imgs/Kafka技术进阶/image-20240429212529784.png" alt="image-20240429212529784" style="zoom:150%;" />

<p>Kafka底层采用的是<code>FileChannel.wrtieTo</code>进行数据的写入，写的时候并不是直接写入文件，而是<code>写入ByteBuffer</code>，然后当缓冲区满了，再将数据顺序写入文件，无需定位文件中的某一个位置进行写入，那么就减少了磁盘查询，数据定位的过程。所以性能要比随机写入效率高得多。</p>
<p>官网有数据表明，同样的磁盘，顺序写能到600M&#x2F;s，而随机写只有100K&#x2F;s。这与磁盘的机械结构有关，顺序写之所以快，是因为其<code>省去了大量磁头寻址的时间</code>。</p>
<p><img src="/imgs/Kafka%E6%8A%80%E6%9C%AF%E8%BF%9B%E9%98%B6/image-20240429212653126.png" alt="image-20240429212653126"></p>
<h2 id="2-Kafka集群优化"><a href="#2-Kafka集群优化" class="headerlink" title="2.Kafka集群优化"></a>2.Kafka集群优化</h2><h3 id="2-1-集群部署方案"><a href="#2-1-集群部署方案" class="headerlink" title="2.1 集群部署方案"></a>2.1 集群部署方案</h3><h4 id="2-1-1-操作系统"><a href="#2-1-1-操作系统" class="headerlink" title="2.1.1 操作系统"></a>2.1.1 操作系统</h4><p>如果考虑操作系统与Kafka的适配性，Linux系统显然要比其他特别是Windows系统更加适合部署Kafka。虽然这个结论可能你不感到意外，但其中具体的原因你也一定要了解。主要是在下面这三个方面上，Linux 的表现更胜一筹。</p>
<ul>
<li>I&#x2F;O模型的使用：实际上Kafka客户端底层使用了<code>Java的selector</code>，selector在Linux上的实现机制是<code>epoll</code>，而在Windows平台上的实现机制是<code>select</code>。因此在这一点上将Kafka部署在Linux上是有优势的，因为能够获得更高效的I&#x2F;O性能。</li>
<li>数据网络传输效率：你知道的，Kafka生产和消费的消息都是通过网络传输的，而消息保存在哪里呢？肯定是磁盘。故Kafka需要在磁盘和网络间进行大量数据传输。如果你熟悉Linux，你肯定听过零拷贝技术，就是当<code>数据在磁盘和网络进行传输时避免昂贵的内核态数据拷贝从而实现快速的数据传输</code>。Linux平台实现了这样的零拷贝机制，但有些令人遗憾的是在Windows平台上必须要等到Java 8的60更新版本才能“享受”到这个福利。一句话总结一下，在Linux部署Kafka能够享受到零拷贝技术所带来的快速数据传输特性。</li>
<li>社区支持度：这一点虽然不是什么明显的差别，但如果不了解的话可能比前两个因素对你的影响更大。简单来说就是，社区目前对Windows平台上发现的Kafka Bug不做任何承诺。虽然口头上依然保证尽力去解决(<code>但实际上Windows上的Bug一般是不会修复的</code>)。因此，Windows平台上部署Kafka只适合于个人测试或用于功能验证，千万不要应用于生产环境。</li>
</ul>
<h4 id="2-1-2-磁盘选型"><a href="#2-1-2-磁盘选型" class="headerlink" title="2.1.2 磁盘选型"></a>2.1.2 磁盘选型</h4><p>如果问哪种资源对Kafka性能最重要，磁盘无疑是要排名靠前的。在对Kafka集群进行磁盘规划时经常面对的问题是，我应该选择普通的机械磁盘还是固态硬盘？前者成本低且容量大，但易损坏；后者性能优势大，不过单价高。<strong>我给出的建议是使用普通机械硬盘即可。</strong></p>
<p>Kafka大量使用磁盘不假，可它使用的方式<code>多是顺序读写操作，一定程度上规避了机械磁盘最大的劣势，即随机读写操作慢</code>。从这一点上来说，使用SSD似乎并没有太大的性能优势，毕竟从性价比上来说，机械磁盘物美价廉，而它因易损坏而造成的可靠性差等缺陷，又由Kafka在软件层面提供机制来保证，故使用普通机械磁盘是很划算的。</p>
<p>关于磁盘选择另一个经常讨论的话题就是到底是否应该使用磁盘阵列（RAID）。使用RAID的两个主要优势在于：提供冗余的磁盘存储空间和提供负载均衡。以上两个优势对于任何一个分布式系统都很有吸引力。不过就Kafka而言，一方面Kafka自己<code>实现了冗余机制来提供高可靠性</code>；另一方面<code>通过分区的概念，Kafka也能在软件层面自行实现负载均衡</code>。如此说来RAID的优势就没有那么明显了。当然，我并不是说RAID不好，实际上依然有很多大厂确实是把Kafka底层的存储交由RAID的，只是目前Kafka在存储这方面提供了越来越便捷的高可靠性方案，因此在线上环境使用RAID似乎变得不是那么重要了。</p>
<p>综合以上的考量，我给出的建议是：</p>
<ul>
<li>追求性价比的公司可以不搭建RAID，使用普通磁盘组成存储空间即可。</li>
<li>使用机械磁盘完全能够胜任Kafka线上环境。</li>
</ul>
<h4 id="2-1-3-磁盘容量"><a href="#2-1-3-磁盘容量" class="headerlink" title="2.1.3 磁盘容量"></a>2.1.3 磁盘容量</h4><p>Kafka集群到底需要多大的存储空间？这是一个非常经典的规划问题。Kafka需要将消息保存在底层的磁盘上，这些消息默认会被保存一段时间然后自动被删除。虽然这段时间是可以配置的，但你应该如何结合自身业务场景和存储需求来规划Kafka集群的存储容量呢？</p>
<p>我举一个简单的例子来说明该如何思考这个问题。假设你所在公司有个业务每天需要向Kafka集群发送1亿条消息，每条消息保存两份以防止数据丢失，另外消息默认保存两周时间。现在假设消息的平均大小是1KB，那么你能说出你的Kafka集群需要为这个业务预留多少磁盘空间吗？</p>
<p>我们来计算一下：每天1亿条1KB大小的消息，保存两份且留存两周的时间，那么总的空间大小就等于1亿 * 1KB * 2 &#x2F; 1000 &#x2F; 1000 &#x3D; 200GB。一般情况下Kafka集群除了消息数据还有其他类型的数据，比如索引数据等，故我们再为这些数据预留出10%的磁盘空间，因此总的存储容量就是220GB。既然要保存两周，那么整体容量即为220GB * 14，大约3TB左右。Kafka支持数据的压缩，假设压缩比是0.75，那么最后你需要规划的存储空间就是0.75 * 3 &#x3D; 2.25TB。</p>
<p>总之在规划磁盘容量时你需要考虑下面这几个元素：</p>
<ul>
<li><code>新增消息数</code></li>
<li><code>消息留存时间</code></li>
<li><code>平均消息大小</code></li>
<li><code>备份数</code></li>
<li><code>是否启用压缩</code></li>
</ul>
<h4 id="2-1-4-带宽"><a href="#2-1-4-带宽" class="headerlink" title="2.1.4 带宽"></a>2.1.4 带宽</h4><p>与其说是带宽资源的规划，其实<code>真正要规划的是所需的Kafka服务器的数量</code>。假设你公司的机房环境是千兆网络，即1Gbps，现在你有个业务，其业务目标或SLA是在1小时内处理1TB的业务数据。那么问题来了，你到底需要多少台Kafka服务器来完成这个业务呢？</p>
<p>让我们来计算一下，由于带宽是1Gbps，即每秒处理1Gb的数据，假设每台Kafka服务器都是安装在专属的机器上，也就是说<code>每台Kafka机器上没有混部其他服务，毕竟真实环境中不建议这么做</code>。通常情况下你只能假设Kafka会用到70%的带宽资源，因为总要为其他应用或进程留一些资源。</p>
<blockquote>
<p>根据实际使用经验，超过70%的阈值就有网络丢包的可能性了，故70%的设定是一个比较合理的值，也就是说单台Kafka服务器最多也就能使用大约700Mb的带宽资源。</p>
</blockquote>
<p>稍等，这只是它能使用的最大带宽资源，你不能让Kafka服务器常规性使用这么多资源，故通常要再额外预留出2&#x2F;3的资源，即单台服务器使用带宽700Mb &#x2F; 3 ≈ 240Mbps。需要提示的是，这里的2&#x2F;3其实是相当保守的，你可以结合你自己机器的使用情况酌情减少此值。</p>
<p>好了，有了240Mbps，我们就可以计算1小时内处理1TB数据所需的服务器数量了。根据这个目标，我们每秒需要处理2336Mb的数据，除以240，约等于10台服务器。如果消息还需要额外复制两份，那么总的服务器台数还要乘以3，即30台。</p>
<h3 id="2-2-集群参数配置"><a href="#2-2-集群参数配置" class="headerlink" title="2.2 集群参数配置"></a>2.2 集群参数配置</h3><h4 id="2-2-1-Broker端参数"><a href="#2-2-1-Broker端参数" class="headerlink" title="2.2.1 Broker端参数"></a>2.2.1 Broker端参数</h4><ul>
<li><p>针对存储信息:</p>
<ul>
<li><p><code>log.dirs</code>:指定了Broker需要使用的若干个文件目录路径，<code>在线上生产环境中一定要为log.dirs配置多个路径</code>，具体格式是一个CSV格式，也就是用逗号分隔的多个路径，比如&#x2F;home&#x2F;kafka1,&#x2F;home&#x2F;kafka2,&#x2F;home&#x2F;kafka3这样。</p>
<blockquote>
<p>如果有条件的话你最好保证这些目录挂载到不同的物理磁盘上。这样做有两个好处：</p>
<ul>
<li><code>提升读写性能</code>：比起单块磁盘，多块物理磁盘同时读写数据有更高的吞吐量。</li>
<li><code>能够实现故障转移</code>：即 Failover。这是Kafka 1.1版本新引入的强大功能。要知道在以前，只要Kafka Broker使用的任何一块磁盘挂掉了，整个Broker进程都会关闭。但是自1.1开始，这种情况被修正了，坏掉的磁盘上的数据会自动地转移到其他正常的磁盘上，而且Broker还能正常工作。</li>
</ul>
</blockquote>
</li>
</ul>
</li>
<li><p>针对ZooKeeper相关配置:</p>
<ul>
<li><p><code>zookeeper.connect</code>:这也是一个CSV格式的参数，比如我可以指定它的值为zk1:2181,zk2:2181,zk3:2181。</p>
<blockquote>
<p>如果你有两套Kafka集群，假设分别叫它们kafka1和kafka2，那么两套集群的zookeeper.connect参数可以这样指定：zk1:2181,zk2:2181,zk3:2181&#x2F;kafka1和zk1:2181,zk2:2181,zk3:2181&#x2F;kafka2。<code>切记chroot只需要写一次，而且是加到最后的</code>。</p>
</blockquote>
</li>
</ul>
</li>
<li><p>针对Topic管理相关配置:</p>
<ul>
<li><p><code>auto.create.topics.enable</code>:建议最好设置成<code>false</code>，即不允许自动创建Topic。在我们的线上环境里面有很多名字稀奇古怪的Topic，我想大概都是因为该参数被设置成了true的缘故。</p>
</li>
<li><p><code>unclean.leader.election.enable</code>:关闭Unclean Leader选举，何谓Unclean？还记得Kafka有多个副本这件事吗？每个分区都有多个副本来提供高可用。在这些副本中只能有一个副本对外提供服务，即所谓的Leader副本。那么问题来了，这些副本都有资格竞争Leader吗？显然不是，<strong>只有保存数据比较多的那些副本才有资格竞选，那些落后进度太多的副本没资格做这件事</strong>。</p>
<blockquote>
<p>好了，现在出现这种情况了：假设那些保存数据比较多的副本都挂了怎么办？我们还要不要进行Leader选举了？此时这个参数就派上用场了。</p>
<p>如果设置成false，那么就坚持之前的原则，坚决不能让那些落后太多的副本竞选Leader。<code>这样做的后果是这个分区就不可用了</code>，因为没有Leader了。反之如果是true，那么Kafka允许你从那些“跑得慢”的副本中选一个出来当Leader。<code>这样做的后果是数据有可能就丢失了</code>，因为这些副本保存的数据本来就不全，当了Leader之后它本人就变得膨胀了，认为自己的数据才是权威的。</p>
</blockquote>
</li>
<li><p><code>auto.leader.reblance.enable</code>:是否开启分区Leader的自平衡，后台线程会定期检查分区Leader的分布情况(可以通过<code>leader.imbalance.check.interval.seconds</code>参数配置检查时间间隔)，如果分区Leader的不平衡程度超过了设定的参数<code>leader.imbalance.per.broker.percentage</code>则会触发Leader重平衡到分区的Prederred Leader。换一次Leader代价很高的，原本向A发送请求的所有客户端都要切换成向B发送请求，而且这种换Leader本质上没有任何性能收益，因此我建议你在生产环境中把这个参数设置成false。</p>
</li>
</ul>
</li>
<li><p>针对数据留存相关配置:</p>
<ul>
<li><p><code>log.retention.&#123;hours|minutes|ms&#125;</code>：这是个”三兄弟”，都是控制一条消息数据被保存多长时间。从优先级上来说ms设置最高、minutes次之、hours最低。</p>
<blockquote>
<p>虽然ms设置有最高的优先级，但是通常情况下我们还是设置hours级别的多一些，比如<code>log.retention.hours=168</code>表示默认保存7天的数据，自动删除7天前的数据。很多公司把Kafka当作存储来使用，那么这个值就要相应地调大。</p>
</blockquote>
</li>
<li><p><code>log.retention.bytes</code>:指定Broker为消息保存的总磁盘容量大小，这个值默认是-1，表明你想在这台Broker上保存多少数据都可以，至少在容量方面Broker绝对为你开绿灯，不会做任何阻拦。</p>
<blockquote>
<p>这个参数真正发挥作用的场景其实是在云上构建多租户的Kafka集群：设想你要做一个云上的Kafka服务，每个租户只能使用100GB的磁盘空间，为了避免有个”恶意”租户使用过多的磁盘空间，设置这个参数就显得至关重要了。</p>
</blockquote>
</li>
<li><p><code>message.max.bytes</code>:控制Broker能够接收的最大消息大小，默认的1000012太少了，还不到1MB。实际场景中突破1MB的消息都是屡见不鲜的，因此<code>在线上环境中设置一个比较大的值还是比较保险的做法</code>。毕竟它只是一个标尺而已，仅仅衡量Broker能够处理的最大消息大小，即使设置大一点也不会耗费什么磁盘空间的。</p>
</li>
</ul>
</li>
</ul>
<h4 id="2-2-2-Topic级别参数"><a href="#2-2-2-Topic级别参数" class="headerlink" title="2.2.2 Topic级别参数"></a>2.2.2 Topic级别参数</h4><p>说起Topic级别的参数，你可能会有这样的疑问：如果同时设置了Topic级别参数和全局Broker参数，到底听谁的呢？哪个说了算呢？答案就是Topic级别参数会覆盖全局Broker参数的值，而每个Topic都能设置自己的参数值，这就是所谓的Topic级别参数。</p>
<p>举个例子说明一下，上一期我提到了消息数据的留存时间参数，在实际生产环境中，如果为所有Topic的数据都保存相当长的时间，这样做既不高效也无必要。<code>更适当的做法是允许不同部门的Topic根据自身业务需要，设置自己的留存时间。</code>如果只能设置全局Broker参数，那么势必要提取所有业务留存时间的最大值作为全局参数值，此时设置Topic级别参数把它覆盖，就是一个不错的选择。</p>
<p>下面我们依然按照用途分组的方式引出重要的Topic级别参数。从保存消息方面来考量的话，下面这组参数是非常重要的：</p>
<ul>
<li><code>retention.ms</code>：规定了该Topic消息被保存的时长。默认是7天，即该Topic只保存最近7天的消息。一旦设置了这个值，它会覆盖掉Broker端的全局参数值。</li>
<li><code>retention.bytes</code>：规定了要为该Topic预留多大的磁盘空间。和全局参数作用相似，这个值通常在多租户的Kafka集群中会有用武之地。当前默认值是-1，表示可以无限使用磁盘空间。</li>
</ul>
<p>上面这些是从保存消息的维度来说的。如果从能处理的消息大小这个角度来看的话，有一个参数是必须要设置的，即<code>max.message.bytes</code>。它决定了Kafka Broker能够正常接收该Topic的最大消息大小。我知道目前在很多公司都把Kafka作为一个基础架构组件来运行，上面跑了很多的业务数据。<code>如果在全局层面上，我们不好给出一个合适的最大消息值，那么不同业务部门能够自行设定这个Topic级别参数就显得非常必要了</code>。在实际场景中，这种用法也确实是非常常见的。</p>
<p>我们先来看看如何在创建Topic时设置这些参数。我用上面提到的retention.ms和max.message.bytes举例。设想你的部门需要将交易数据发送到Kafka进行处理，需要保存最近半年的交易数据，同时这些数据很大，通常都有几MB，但一般不会超过5MB。现在让我们用以下命令来创建Topic：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/kafka-topics.sh --bootstrap-server localhost:9092 --create --topic transaction --partitions 1 --replication-factor 1 --config retention.ms=15552000000 --config max.message.bytes=5242880</span><br></pre></td></tr></table></figure>

<p>我们只需要知道Kafka开放了kafka-topics命令供我们来创建Topic即可。对于上面这样一条命令，请注意结尾处的<code>--config</code>设置，我们就是在config后面指定了想要设置的Topic级别参数。</p>
<p>下面看看使用另一个自带的命令<code>kafka-configs</code>来修改Topic级别参数。假设我们现在要发送最大值是10MB 的消息，该如何修改呢？命令如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/kafka-configs.sh --zookeeper localhost:2181 --entity-type topics --entity-name transaction --alter --add-config max.message.bytes=10485760</span><br></pre></td></tr></table></figure>

<h4 id="2-2-3-JVM参数"><a href="#2-2-3-JVM参数" class="headerlink" title="2.2.3 JVM参数"></a>2.2.3 JVM参数</h4><p>先无脑给出一个通用的建议：<code>将你的JVM堆大小设置成6GB吧，这是目前业界比较公认的一个合理值</code>(当然最好还是监控一下实时的堆大小，特别是GC之后的live data大小，通常将HeapSize设置成其1.5~2倍就足以了)。我见过很多人就是使用默认的Heap Size来跑Kafka，说实话默认的1GB有点小，毕竟Kafka Broker在与客户端进行交互时会在JVM堆上创建大量的ByteBuffer实例，Heap Size不能太小。</p>
<p>JVM端配置的另一个重要参数就是垃圾回收器的设置，也就是平时常说的GC设置。如果你依然在使用Java 7，那么可以根据以下法则选择合适的垃圾回收器：</p>
<ul>
<li>如果Broker所在机器的CPU资源非常充裕，建议使用CMS收集器。启用方法是指定<code>-XX:+UseCurrentMarkSweepGC</code>。</li>
<li>否则，使用吞吐量收集器。开启方法是指定<code>-XX:+UseParallelGC</code>。</li>
</ul>
<p>当然了，如果你在使用Java 8，那么可以手动设置使用G1收集器。在没有任何调优的情况下，G1表现得要比CMS出色，主要体现在更少的Full GC，需要调整的参数更少等，所以使用G1就好了。</p>
<p>现在我们确定好了要设置的JVM参数，我们该如何为Kafka进行设置呢？其实设置的方法也很简单，你只需要设置下面这两个环境变量即可：</p>
<ul>
<li><code>KAFKA_HEAP_OPTS</code>：指定堆大小。</li>
<li><code>KAFKA_JVM_PERFORMANCE_OPTS</code>：指定GC参数。</li>
</ul>
<p>比如你可以这样启动Kafka Broker，即在启动Kafka Broker之前，先设置上这两个环境变量：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">&gt; <span class="built_in">export</span> KAFKA_HEAP_OPTS=--Xms6g  --Xmx6g</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">&gt; <span class="built_in">export</span> KAFKA_JVM_PERFORMANCE_OPTS= -server -XX:+UseG1GC -XX:MaxGCPauseMillis=20 -XX:InitiatingHeapOccupancyPercent=35 -XX:+ExplicitGCInvokesConcurrent -Djava.awt.headless=<span class="literal">true</span></span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">&gt; bin/kafka-server-start.sh config/server.properties</span></span><br></pre></td></tr></table></figure>

<h4 id="2-2-4-操作系统参数"><a href="#2-2-4-操作系统参数" class="headerlink" title="2.2.4 操作系统参数"></a>2.2.4 操作系统参数</h4><ul>
<li>文件描述符限制:首先是<code>ulimit -n</code>。我觉得任何一个Java项目最好都调整下这个值。实际上，文件描述符系统资源并不像我们想象的那样昂贵，你不用太担心调大此值会有什么不利的影响。通常情况下将它设置成一个超大的值是合理的做法。</li>
<li>文件系统类型:其次是文件系统类型的选择。这里所说的文件系统指的是如ext3、ext4或XFS这样的日志型文件系统。根据官网的测试报告，XFS的性能要强于ext4，所以生产环境最好还是使用XFS。</li>
<li>Swappiness:网上很多文章都提到设置其为0，将swap完全禁掉以防止Kafka进程使用swap空间。我个人反倒觉得还是不要设置成0比较好，我们可以设置成一个较小的值。为什么呢？因为一旦设置成0，当物理内存耗尽时，操作系统会触发<code>OOM killer</code>这个组件，它会随机挑选一个进程然后kill掉，即<code>根本不给用户任何的预警</code>。但如果设置成一个比较小的值，当开始使用swap空间时，你至少能够观测到<code>Broker性能开始出现急剧下降，从而给你进一步调优和诊断问题的时间</code>。基于这个考虑，我个人建议将swappniess配置成一个接近0但不为0的值，比如1。</li>
<li>提交时间:向Kafka发送数据并不是真要等数据被写入磁盘才会认为成功，而是只要数据被写入到操作系统的页缓存（Page Cache）上就可以了，随后操作系统根据LRU算法会定期将页缓存上的“脏”数据落盘到物理磁盘上。这个定期就是由提交时间来确定的，默认是5秒。一般情况下我们会认为这个时间太频繁了，<code>可以适当地增加提交间隔来降低物理磁盘的写操作</code>。当然你可能会有这样的疑问：如果在页缓存中的数据在写入到磁盘前机器宕机了，那岂不是数据就丢失了。的确，这种情况数据确实就丢失了，但<code>鉴于Kafka在软件层面已经提供了多副本的冗余机制，因此这里稍微拉大提交间隔去换取性能还是一个合理的做法</code>。</li>
</ul>

  </div>
</article>

    <div class="blog-post-comments">
        <div id="disqus_thread">
            <noscript>Please enable JavaScript to view the comments.</noscript>
        </div>
    </div>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
        
          <li><a href="/">Home</a></li>
        
          <li><a href="/about/">About</a></li>
        
          <li><a href="/archives/">Writing</a></li>
        
          <li><a href="/tags/">Tag</a></li>
        
          <li><a target="_blank" rel="noopener" href="http://github.com/hulingF">Projects</a></li>
        
      </ul>
    </div>

    
    
      <div id="toc-footer" style="display: none">
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Kafka%E6%8A%80%E6%9C%AF%E8%BF%9B%E9%98%B6"><span class="toc-number">1.</span> <span class="toc-text">Kafka技术进阶</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-Kafka%E6%8A%80%E6%9C%AF%E7%B2%BE%E8%AE%B2"><span class="toc-number">1.1.</span> <span class="toc-text">1 Kafka技术精讲</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-Controller%E9%80%89%E4%B8%BE"><span class="toc-number">1.1.1.</span> <span class="toc-text">1.1 Controller选举</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-Broker%E4%B8%8A%E4%B8%8B%E7%BA%BF"><span class="toc-number">1.1.2.</span> <span class="toc-text">1.2 Broker上下线</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-%E6%95%B0%E6%8D%AE%E5%81%8F%E7%A7%BB%E9%87%8F%E5%AE%9A%E4%BD%8D"><span class="toc-number">1.1.3.</span> <span class="toc-text">1.3 数据偏移量定位</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-%E6%97%A5%E5%BF%97%E6%B8%85%E7%90%86%E5%92%8C%E5%8E%8B%E7%BC%A9"><span class="toc-number">1.1.4.</span> <span class="toc-text">1.4 日志清理和压缩</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5-%E9%A1%B5%E7%BC%93%E5%AD%98"><span class="toc-number">1.1.5.</span> <span class="toc-text">1.5 页缓存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-6-%E9%A1%BA%E5%86%99%E6%97%A5%E5%BF%97"><span class="toc-number">1.1.6.</span> <span class="toc-text">1.6 顺写日志</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-Kafka%E9%9B%86%E7%BE%A4%E4%BC%98%E5%8C%96"><span class="toc-number">1.2.</span> <span class="toc-text">2.Kafka集群优化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2%E6%96%B9%E6%A1%88"><span class="toc-number">1.2.1.</span> <span class="toc-text">2.1 集群部署方案</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">2.1.1 操作系统</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-2-%E7%A3%81%E7%9B%98%E9%80%89%E5%9E%8B"><span class="toc-number">1.2.1.2.</span> <span class="toc-text">2.1.2 磁盘选型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-3-%E7%A3%81%E7%9B%98%E5%AE%B9%E9%87%8F"><span class="toc-number">1.2.1.3.</span> <span class="toc-text">2.1.3 磁盘容量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-4-%E5%B8%A6%E5%AE%BD"><span class="toc-number">1.2.1.4.</span> <span class="toc-text">2.1.4 带宽</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E9%9B%86%E7%BE%A4%E5%8F%82%E6%95%B0%E9%85%8D%E7%BD%AE"><span class="toc-number">1.2.2.</span> <span class="toc-text">2.2 集群参数配置</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-1-Broker%E7%AB%AF%E5%8F%82%E6%95%B0"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">2.2.1 Broker端参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-2-Topic%E7%BA%A7%E5%88%AB%E5%8F%82%E6%95%B0"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">2.2.2 Topic级别参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-3-JVM%E5%8F%82%E6%95%B0"><span class="toc-number">1.2.2.3.</span> <span class="toc-text">2.2.3 JVM参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-4-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8F%82%E6%95%B0"><span class="toc-number">1.2.2.4.</span> <span class="toc-text">2.2.4 操作系统参数</span></a></li></ol></li></ol></li></ol></li></ol>
      </div>
    

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://hulingf.github.io/2024/04/29/Kafka%E6%8A%80%E6%9C%AF%E8%BF%9B%E9%98%B6/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://hulingf.github.io/2024/04/29/Kafka%E6%8A%80%E6%9C%AF%E8%BF%9B%E9%98%B6/&text=Kafka技术进阶"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://hulingf.github.io/2024/04/29/Kafka%E6%8A%80%E6%9C%AF%E8%BF%9B%E9%98%B6/&title=Kafka技术进阶"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://hulingf.github.io/2024/04/29/Kafka%E6%8A%80%E6%9C%AF%E8%BF%9B%E9%98%B6/&is_video=false&description=Kafka技术进阶"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=Kafka技术进阶&body=Check out this article: https://hulingf.github.io/2024/04/29/Kafka%E6%8A%80%E6%9C%AF%E8%BF%9B%E9%98%B6/"><i class="fa-solid fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://hulingf.github.io/2024/04/29/Kafka%E6%8A%80%E6%9C%AF%E8%BF%9B%E9%98%B6/&title=Kafka技术进阶"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://hulingf.github.io/2024/04/29/Kafka%E6%8A%80%E6%9C%AF%E8%BF%9B%E9%98%B6/&title=Kafka技术进阶"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://hulingf.github.io/2024/04/29/Kafka%E6%8A%80%E6%9C%AF%E8%BF%9B%E9%98%B6/&title=Kafka技术进阶"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://hulingf.github.io/2024/04/29/Kafka%E6%8A%80%E6%9C%AF%E8%BF%9B%E9%98%B6/&title=Kafka技术进阶"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://hulingf.github.io/2024/04/29/Kafka%E6%8A%80%E6%9C%AF%E8%BF%9B%E9%98%B6/&name=Kafka技术进阶&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://hulingf.github.io/2024/04/29/Kafka%E6%8A%80%E6%9C%AF%E8%BF%9B%E9%98%B6/&t=Kafka技术进阶"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fa-solid fa-bars fa-lg" aria-hidden="true"></i> Menu</a>
        
          <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fa-solid fa-list fa-lg" aria-hidden="true"></i> TOC</a>
        
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fa-solid fa-share-alt fa-lg" aria-hidden="true"></i> Share</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2024
    hulingF
  </div>
  <div class="footer-right">
    <nav>
      <ul>
        <!--
       --><li><a href="/">Home</a></li><!--
     --><!--
       --><li><a href="/about/">About</a></li><!--
     --><!--
       --><li><a href="/archives/">Writing</a></li><!--
     --><!--
       --><li><a href="/tags/">Tag</a></li><!--
     --><!--
       --><li><a target="_blank" rel="noopener" href="http://github.com/hulingF">Projects</a></li><!--
     -->
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->



  <link rel="preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" crossorigin="anonymous" onload="this.onload=null;this.rel='stylesheet'"/>


    <!-- jquery -->

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" crossorigin="anonymous"></script>




<!-- clipboard -->

  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.7/clipboard.min.js" crossorigin="anonymous"></script>
  
  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"Copy to clipboard!\">";
    btn += '<i class="fa-regular fa-clone"></i>';
    btn += '</span>';
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "Copied!");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Disqus Comments -->

    <script type="text/javascript">
        var disqus_shortname = 'hulingF';

        (function(){
            var dsq = document.createElement('script');
            dsq.type = 'text/javascript';
            dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        }());
    </script>

<!-- utterances Comments -->

</body>
</html>
